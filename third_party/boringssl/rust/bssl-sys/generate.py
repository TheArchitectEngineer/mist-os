#!/usr/bin/env fuchsia-vendored-python
#
# Copyright 2025 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import datetime
import platform
import re
import subprocess
import sys
from pathlib import Path

# Add //build/rust to Python path so the bindgen import works.
FUCHSIA_DIR = Path(__file__).parent.parent.parent.parent.parent
sys.path.append(str(FUCHSIA_DIR / "build" / "rust"))

from bindgen import Bindgen

LICENSE_HEADER = f"""# Copyright {datetime.datetime.now().year} The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""

HOST_OS = {"Linux": "linux", "Darwin": "mac"}[platform.system()]
HOST_CPU = {"x86_64": "x64", "arm64": "arm64"}[platform.machine()]
HOST_PLATFORM = f"{HOST_OS}-{HOST_CPU}"

# The directory in fuchsia.git providing build support to the nested checkout
# of the boringssl.git mirror.
BORINGSSL_PLATFORM_DIR = FUCHSIA_DIR / "third_party" / "boringssl"
BORINGSSL_MIRROR_DIR = BORINGSSL_PLATFORM_DIR / "src"

BSSL_SYS_INPUT_FILE = BORINGSSL_MIRROR_DIR / "rust" / "bssl-sys" / "wrapper.h"
BSSL_SYS_OUTPUT_FILE = BORINGSSL_PLATFORM_DIR / "rust" / "bssl-sys" / "bindgen.rs"
BORINGSSL_INCLUDE_DIR = BORINGSSL_MIRROR_DIR / "include"

OPENSSLCONF_INPUT_FILE = BORINGSSL_INCLUDE_DIR / "openssl" / "opensslconf.h"
OPENSSLCONF_OUTPUT_FILE = BORINGSSL_PLATFORM_DIR / "rust" / "bssl-sys" / "opensslconf.gni"

RELATIVE_SCRIPT_PATH = Path(__file__).relative_to(FUCHSIA_DIR)
RELATIVE_OPENSSLCONF_INPUT_FILE = Path(OPENSSLCONF_INPUT_FILE).relative_to(FUCHSIA_DIR)

GENERATION_HEADER = "{} This file is automatically generated by //{}."
GENERATION_HEADER_RUST = GENERATION_HEADER.format("//", RELATIVE_SCRIPT_PATH)
GENERATION_HEADER_GNI = GENERATION_HEADER.format("#", RELATIVE_SCRIPT_PATH)

CLANG = FUCHSIA_DIR / "prebuilt" / "third_party" / "clang" / HOST_PLATFORM / "bin" / "clang"
GN = FUCHSIA_DIR / "prebuilt" / "third_party" / "gn" / HOST_PLATFORM / "gn"
OPENSSLCONF_DEFINE_REGEXP = r"^#define (?P<define>OPENSSL_\w+)\b"

def main() -> None:
    generate_rust_bindings()
    generate_opensslconf_gni_bindings()

def generate_rust_bindings() -> None:
    bindgen = Bindgen()
    bindgen.raw_lines = GENERATION_HEADER_RUST

    # The output gets `include!`d in the bssl-sys crate root, so we are unable to
    # generate `#![allow(...)]` directives.
    bindgen.generate_allows = False

    # There are third-party dependents of bssl-sys that don't expect padding
    # fields.
    bindgen.explicit_padding = False

    # The remaining options mirror what's specified in
    # //third_party/boringssl/src/rust/bssl-sys/CMakeLists.txt
    bindgen.include_dirs = [ BORINGSSL_INCLUDE_DIR ]
    bindgen.use_core = True
    bindgen.additional_bindgen_flags = [
        "--no-derive-default",
        "--enable-function-attribute-detection",
        "--default-macro-constant-type=signed",
        "--rustified-enum=point_conversion_form_t",
    ]

    bindgen.run(str(BSSL_SYS_INPUT_FILE), str(BSSL_SYS_OUTPUT_FILE))

def generate_opensslconf_gni_bindings() -> None:
    defines = subprocess.run(
        [
            CLANG,
            "-E", # Only run the preprocessor
            "-dM", # Print macro definitions in -E mode instead of normal output
            OPENSSLCONF_INPUT_FILE,
        ],
        stdout=subprocess.PIPE,
        check=True,
    ).stdout.splitlines()
    openssl_defines = []
    for line in defines:
        match = re.search(OPENSSLCONF_DEFINE_REGEXP, line.decode("utf-8").strip())
        if not match:
            continue
        openssl_defines.append('"{}"'.format(match.group("define")))

    # The first entry should correspond to a header guard, which we don't want
    # to count.
    assert openssl_defines[0].endswith('_H"')
    openssl_defines.pop(0)

    opensslconf_gni_contents = f"""
    {LICENSE_HEADER}
    {GENERATION_HEADER_GNI}

    # The #defines in //{RELATIVE_OPENSSLCONF_INPUT_FILE}
    opensslconf_defines = [{", ".join(openssl_defines)}]
    """

    with Path.open(OPENSSLCONF_OUTPUT_FILE, "w") as f:
        subprocess.run(
            [GN, "format", "--stdin"],
            input=opensslconf_gni_contents,
            stdout=f,
            text=True,
            check=True,
        )



if __name__ == "__main__":
    main()
