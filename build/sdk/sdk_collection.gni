# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/json/validate_json.gni")
import("//build/python/python_action.gni")
import("//build/sdk/idk_prebuild_manifest.gni")
import("config.gni")
import("meta/version.gni")
import("sdk_molecule.gni")

# Prepare a collection of elements to be published in an IDK.
#
# This creates the $BUILD_DIR/sdk/exported/{collection_name}/ directory, which
# will follow the standard IDK layout, including a top-level meta/manifest.json
# file describing all atoms in the collection using the standard IDK schema.
#
# It may write the $BUILD_DIR/sdk/manifest/{collection_name} file, as an
# internal IDK manifest describing all atoms. Note that this format is internal
# to the build system, and should not be used outside of it (though it is
# ok for `ffx` to use that from a Fuchsia checkout).
#
# Parameters
#
#   id (optional)
#     An opaque identifier for the SDK.
#     Defaults to the empty string.
#
#   category (required)
#     Describes the minimum category that atoms in this SDK must have.
#     See //build/sdk/sdk_atom.gni for possible values.
#
#   deps
#     A list of sdk_atom() and sdk_molecule() targets that will be walked to
#     collect all SDK atom dependencies for this collection.
#
#   name (optional)
#     The name used for this collection's output directory and manifest.
#     Defaults to `target_name`.
#
#   testonly
#     Usual GN meaning.
#
template("sdk_collection") {
  assert(defined(invoker.category), "Must define an SDK category")

  visibility = [ ":*" ]

  # Compute target and host triples, which will be written to the
  # top-level meta/manifest.json file for this collection.
  target_triple = target_cpu
  if (host_cpu == "x64") {
    host_triple_cpu = "x86_64"
  } else if (host_cpu == "arm64") {
    host_triple_cpu = "aarch64"
  } else {
    assert(false, "Unrecognized host CPU: $host_cpu")
  }
  if (host_os == "linux") {
    host_triple_os = "linux-gnu"
  } else if (host_os == "mac") {
    host_triple_os = "apple-darwin"
  } else if (host_os == "fuchsia") {
    host_triple_os = "fuchsia"
  } else {
    assert(false, "Unrecognized host OS: $host_os")
  }
  host_triple = "${host_triple_cpu}-${host_triple_os}"

  if (defined(invoker.name)) {
    collection_name = invoker.name
  } else {
    collection_name = target_name
  }

  all_collection_deps = invoker.deps + [ "//build/sdk/meta" ]

  # Labels and file paths for all targets generated by this template.
  targets = {
    export = "${target_name}_export"
    main = target_name
    collection_prebuild_info = "${target_name}_prebuild_info"
    prebuild_manifest = "${target_name}_prebuild_manifest"
    generate_meta_files = "${target_name}_generate_meta_files"
  }

  files = {
    # Location of the final collection.
    exported_collection_dir = "${root_out_dir}/sdk/exported/${collection_name}"

    # The main manifest in the IDK that references all atoms.
    collection_manifest_relative_path = "meta/manifest.json"
    idk_meta_manifest_json =
        "${exported_collection_dir}/${collection_manifest_relative_path}"

    # Metadata about the collection that is generated at GN gen time.
    prebuild_manifest = "${root_out_dir}/sdk/prebuild/${collection_name}.json"
  }

  # Adds prebuild metadata that is used to generate the collection manifest. The
  # main target cannot do this because it depends on the
  # `idk_prebuild_manifest()` instance, which must depend on the target with
  # this metadata.
  group(targets.collection_prebuild_info) {
    metadata = {
      idk_atom_prebuild_info = [
        {
          if (defined(invoker.id) && invoker.id != "") {
            atom_id = invoker.id
          }
          atom_label = get_label_info(":${target_name}", "label_no_toolchain")
          atom_type = "collection"
          atom_meta = {
            dest = files.collection_manifest_relative_path
          }
          prebuild_info = {
            arch = {
              host = host_triple
              target = [ target_triple ]
            }
            schema_version = sdk_metadata_schema_version
            root = ".."  # Hard-coded in build/sdk/create_molecule_manifest.py.
          }
          category = invoker.category
        },
      ]
    }
  }

  idk_prebuild_manifest(targets.prebuild_manifest) {
    forward_variables_from(invoker, [ "testonly" ])

    output = files.prebuild_manifest
    deps = all_collection_deps + [ ":${targets.collection_prebuild_info}" ]
  }

  python_action(targets.generate_meta_files) {
    forward_variables_from(invoker, [ "testonly" ])

    binary_label = "//build/sdk/generate_prebuild_idk"

    inputs = [
      files.prebuild_manifest,

      # Used in validation.
      "//docs/contribute/governance/areas/_areas.yaml",
    ]

    _stamp_file = "${target_gen_dir}/${target_name}.exported"

    depfile = "${target_gen_dir}/${target_name}.d"

    outputs = [
      _stamp_file,
      files.idk_meta_manifest_json,
    ]

    args = [
      "--output-dir",
      rebase_path(files.exported_collection_dir, root_build_dir),
      "--build-dir",
      rebase_path(root_build_dir, root_build_dir),
      "--prebuild-manifest",
      rebase_path(files.prebuild_manifest, root_build_dir),
      "--fuchsia-source-dir",
      rebase_path("//", root_build_dir),
      "--stamp-file",
      rebase_path(_stamp_file, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]

    # TODO(https://fxbug.dev/333907192): Remove along with internal only IDK.
    if (defined(invoker.include_internal_atoms) &&
        invoker.include_internal_atoms) {
      args += [ "--include-internal-atoms" ]
    }

    deps = [ ":${targets.prebuild_manifest}" ]
  }

  group(targets.main) {
    forward_variables_from(invoker, [ "testonly" ])

    if (defined(invoker.visibility)) {
      visibility = []
      visibility = invoker.visibility
    }

    deps = [ ":${targets.generate_meta_files}" ]

    # TODO(https://fxbug.dev/42174965): Block all metadata traversals such as the following:
    # metadata = {
    #   expect_includes_barrier = []
    # }
  }
}
