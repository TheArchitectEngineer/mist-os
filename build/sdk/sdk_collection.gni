# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/json/validate_json.gni")
import("//build/python/python_action.gni")
import("//build/sdk/idk_prebuild_manifest.gni")
import("config.gni")
import("meta/version.gni")
import("sdk_molecule.gni")

# Prepare a collection of elements to be published in an IDK.
#
# This creates the $BUILD_DIR/sdk/exported/{collection_name}/ directory, which
# will follow the standard IDK layout, including a top-level meta/manifest.json
# file describing all atoms in the collection using the standard IDK schema.
#
# It also writes the $BUILD_DIR/sdk/manifest/{collection_name} file, as an
# internal SDK manifest describing all atoms. Note that this format is internal
# to the build system, and should not be used outside of it (though it is
# ok for `ffx` to use that from a Fuchsia checkout).
#
# Parameters
#
#   id (optional)
#     An opaque identifier for the SDK.
#     Defaults to the empty string.
#
#   category (required)
#     Describes the minimum category that atoms in this SDK must have.
#     See //build/sdk/sdk_atom.gni for possible values.
#
#   deps
#     A list of sdk_atom() and sdk_molecule() targets that will be walked to
#     collect all SDK atom dependencies for this collection.
#
#   name (optional)
#     The name used for this collection's output directory and manifest.
#     Defaults to `target_name`.
#
#   testonly
#     Usual GN meaning.
#
template("sdk_collection") {
  assert(defined(invoker.category), "Must define an SDK category")

  # Compute target and host triples, which will be written to the
  # top-level meta/manifest.json file for this collection.
  target_triple = target_cpu
  if (host_cpu == "x64") {
    host_triple_cpu = "x86_64"
  } else if (host_cpu == "arm64") {
    host_triple_cpu = "aarch64"
  } else {
    assert(false, "Unrecognized host CPU: $host_cpu")
  }
  if (host_os == "linux") {
    host_triple_os = "linux-gnu"
  } else if (host_os == "mac") {
    host_triple_os = "apple-darwin"
  } else if (host_os == "fuchsia") {
    host_triple_os = "fuchsia"
  } else {
    assert(false, "Unrecognized host OS: $host_os")
  }
  host_triple = "${host_triple_cpu}-${host_triple_os}"

  if (defined(invoker.name)) {
    collection_name = invoker.name
  } else {
    collection_name = target_name
  }

  all_collection_deps = invoker.deps + [ "//build/sdk/meta" ]

  # Labels and file paths for all targets generated by this template.
  targets = {
    export = "${target_name}_export"
    final_manifest = "${target_name}_final_manifest"
    local_manifest = "${target_name}_molecule"
    main = target_name
    collection_prebuild_info = "${target_name}_prebuild_info"
    prebuild_manifest = "${target_name}_prebuild_manifest"
    idk_meta_manifest_json = "${target_name}_idk_meta_manifest_json"
    tarmaker_manifest = "${target_name}_tarmaker_manifest"
    verify_manifest = "${target_name}_verify_manifest"
    verify_idk_meta_manifest_json =
        "${target_name}_verify_idk_meta_manifest_json"
  }

  files = {
    # Location of the final collection.
    exported_collection_dir = "${root_out_dir}/sdk/exported/${collection_name}"

    # Internal manifests.
    # TODO(https://fxbug.dev/317385989): Eliminate `final_manifest` once ffx
    # no longer depends on a manifest at that location.
    final_manifest = "${root_out_dir}/sdk/manifest/${collection_name}"
    local_manifest = "${target_gen_dir}/${targets.main}.sdk"

    # IDK-like manifests.
    idk_meta_manifest_json =
        "${target_gen_dir}/${collection_name}.idk_meta_manifest_json.json"
    collection_manifest_relative_path = "meta/manifest.json"

    # Archive manifest.
    tarmaker_manifest = "${target_gen_dir}/${collection_name}.tarmaker_manifest"

    # Metadata about the collection that is generated at GN gen time.
    prebuild_manifest = "${root_out_dir}/sdk/prebuild/${collection_name}.json"
  }

  # Generates an internal molecule target, which creates an internal SDK
  # manifest file describing all atoms in it.
  sdk_molecule(targets.local_manifest) {
    # Do not expose this molecule to other targets. Depending directly on the
    # contents of an SDK foregoes API verification, which is not desirable.
    visibility = [ ":*" ]

    # Ensure the internal manifest is named foo.sdk instead of foo_molecule.sdk
    output_name = targets.main

    forward_variables_from(invoker,
                           [
                             "assert_no_deps",
                             "category",
                             "testonly",
                           ])

    deps = all_collection_deps
  }

  # Copies the manifest to a central location + verify the collection API if
  # needed.
  copy(targets.final_manifest) {
    forward_variables_from(invoker, [ "testonly" ])

    sources = [ files.local_manifest ]

    outputs = [ files.final_manifest ]

    deps = [ ":${targets.local_manifest}" ]

    metadata = {
      # Used by distribution_manifest() template. Ensure that dependencies are not
      # installed into Fuchsia packages that depend on the current target.
      distribution_entries_barrier = []
    }
  }

  # Verifies that the manifest is valid.
  validate_json(targets.verify_manifest) {
    forward_variables_from(invoker, [ "testonly" ])

    data = files.final_manifest

    schema = "//build/sdk/manifest_schema.json"

    deps = [ ":${targets.final_manifest}" ]
  }

  # Generates the top-level metadata file (which will later be symlinked at
  # meta/manifest.json) describing the various parts of the SDK collection.
  python_action(targets.idk_meta_manifest_json) {
    forward_variables_from(invoker, [ "testonly" ])

    binary_label = "//build/sdk:generate_idk_meta_manifest_json"

    inputs = [ files.local_manifest ]

    outputs = [ files.idk_meta_manifest_json ]

    args = [
      "--manifest",
      rebase_path(files.local_manifest, root_build_dir),
      "--meta",
      rebase_path(files.idk_meta_manifest_json, root_build_dir),
      "--target-arch",
      target_triple,
      "--host-arch",
      host_triple,
      "--schema-version",
      sdk_metadata_schema_version,
    ]

    if (defined(invoker.id) && invoker.id != "") {
      args += [
        "--id",
        invoker.id,
      ]
    }

    public_deps = [ ":${targets.local_manifest}" ]
  }

  # Verifies that the collection manifest (which will later be symlinked at
  # meta/manifest.json) file is valid.
  validate_json(targets.verify_idk_meta_manifest_json) {
    forward_variables_from(invoker, [ "testonly" ])

    data = files.idk_meta_manifest_json

    schema = "//build/sdk/meta/manifest.json"
    sources = [
      # This file is imported by all schemas.
      "//build/sdk/meta/common.json",
    ]

    public_deps = [ ":${targets.idk_meta_manifest_json}" ]
  }

  additional_archive_files = [
    {
      source = files.idk_meta_manifest_json
      dest = files.collection_manifest_relative_path
      deps = [ ":${targets.idk_meta_manifest_json}" ]
    },
  ]

  # Generate an input tarmaker manifest that will be used to create
  # a tarball archive from the content listed in final_manifest.
  python_action(targets.tarmaker_manifest) {
    forward_variables_from(invoker, [ "testonly" ])

    binary_label = "//build/sdk:generate_archive_manifest_from_sdk_manifest"

    inputs = [ files.final_manifest ]

    outputs = [ files.tarmaker_manifest ]

    args = [
      "--manifest",
      rebase_path(inputs[0], root_build_dir),
      "--output",
      rebase_path(outputs[0], root_build_dir),
    ]

    deps = [ ":${targets.final_manifest}" ]

    foreach(file, additional_archive_files) {
      inputs += [ file.source ]
      args += [
        "--mapping",
        file.dest,
        rebase_path(file.source, root_build_dir),
      ]
      deps += file.deps
    }
  }

  # Populate the content of the $BUILD_DIR/sdk/exported/{collection_name}/
  # directory from the content of the archive (tarmaker) manifest.
  action(targets.export) {
    forward_variables_from(invoker, [ "testonly" ])

    script = "//build/sdk/export_sdk.py"

    inputs = [ files.tarmaker_manifest ]

    _out_dir = files.exported_collection_dir
    _stamp_file = "${target_gen_dir}/${target_name}.exported"

    outputs = [
      _stamp_file,

      # One of many symlinks the script creates based on the archive manifest.
      "${_out_dir}/${files.collection_manifest_relative_path}",
    ]

    depfile = "${_stamp_file}.d"

    args = [
      "--out-dir",
      rebase_path(_out_dir, root_build_dir),
      "--stamp-file",
      rebase_path(_stamp_file, root_build_dir),
      "--manifest",
      rebase_path(files.tarmaker_manifest, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]

    deps = [ ":${targets.tarmaker_manifest}" ]
  }

  # Adds prebuild metadata that is used to generate the collection manifest. The
  # main target cannot do this because it depends on the
  # `idk_prebuild_manifest()` instance, which must depend on the target with
  # this metadata..
  group(targets.collection_prebuild_info) {
    metadata = {
      idk_atom_prebuild_info = [
        {
          if (defined(invoker.id) && invoker.id != "") {
            atom_id = invoker.id
          }
          atom_label = get_label_info(":${target_name}", "label_no_toolchain")
          atom_type = "collection"
          atom_meta = {
            dest = files.collection_manifest_relative_path
          }
          atom_meta_json_file =
              rebase_path(files.idk_meta_manifest_json, root_build_dir)
          prebuild_info = {
            arch = {
              host = host_triple
              target = [ target_triple ]
            }
            schema_version = sdk_metadata_schema_version
            root = ".."  # Hard-coded in build/sdk/create_molecule_manifest.py.
          }
        },
      ]
    }
  }

  idk_prebuild_manifest(targets.prebuild_manifest) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":${targets.main}" ]
    output = files.prebuild_manifest
    deps = all_collection_deps + [ ":${targets.collection_prebuild_info}" ]
  }

  group(targets.main) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    deps = [
      ":${targets.prebuild_manifest}",
      ":${targets.verify_idk_meta_manifest_json}",
      ":${targets.verify_manifest}",
    ]

    public_deps = [
      ":${targets.export}",
      ":${targets.final_manifest}",
    ]

    # TODO(https://fxbug.dev/42174965): Block all metadata traversals such as the following:
    # metadata = {
    #   expect_includes_barrier = []
    # }
  }
}
