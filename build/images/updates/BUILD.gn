# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/product.gni")
import("//src/sys/pkg/bin/system-updater/epoch/generate_epoch.gni")
import("//src/sys/pkg/repositories/devhost/devhost.gni")

# Package publishing
#
# While this is called "updates", it's not about OTA as much as it is about
# package publishing.
#
# This file contains targets that gather data from two different places, and
# then combines that to create a list of "all unique packages in the build",
# which is then published.
#
# The general flow is:
#
#  +----------------+    +----------------+
#  |   The "main"   |    | The "universe" |
#  | Product Bundle |    |  Package Set   |
#  +----------------+    +----------------+
#           |                     |
#           +----------+----------+
#                      |
#                      V
#               +-------------+
#               | The devhost |
#               | Repository  |
#               +-------------+
#
# Note that `fx publish` and `fx build` use different data to produce the set
# of packages to publish to the repository, and both are in this file.  The
# flow for `fx build` will be covered first, then `fx publish`. (This matches
# their order within the file).
#
# Also: In "bringup" product configs, this is all a giant no-op, as there are no
# packages to be published.
#
# Entry-Point Targets
#
#  //build/updates:updates  -> Create package lists and publish everything
#
#  //build/updates:packages -> Used to do metadata walks over "all software
#                              built for the product", but not usable to gather
#                              all the packages, as it doesn't have enough info
#                              to do so via GN metadata.  See the target for
#                              details.
#
#  //build/updates:publish -> publish everything
#
#
# The "universe" package set is constructed in the same manner:  A GN metadata
# walk is done over the the following:
#   - //:developer_universe_packages (created from the 'universe_package_labels'
#                                     GN build argument, in 'args.gn')
#
#   - //:discoverable_packages (created from the 'discoverable_package_lables'
#                               GN build arg, and all "discoverable" tests)
#
# The `package_manifests_from_metadata.list` target creates a file of the same
# name which is a metadata walk for all packages in the above.
#
#
# The packages from assembly need to be gathered.  Depending on if the assembly
# operation is performed by a Bazel or a GN target, this is done differently.
# That is done in two separate BUILD.gn files, to simplify things here:
#  - //build/images/updates/bazel_assemblies/BUILD.gn
#  - //build/images/updates/gn_assemblies/BUILD.gn
#
# These expose the following files (with same-named targets):
#  - base_package_manifests.list
#  - cache_package_manifests.list
#  - ondemand_package_manifests.list
#  - bundle_package_manifests.list
#
#  These are json lists of paths to package manifests, via the jq path of
#  'contents.manifests[]'
#
#  all_package_manifests.list is then created by merging the following files
#  from above:
#    - bundle_package_manifests.list
#    - universe_package_manifests.list
#
# Publishing in fx build
#
#    //build/images/updates:publish
#      After 'all_package_manifests.list' is created, all packages listed in it
#      are published to the devhost repo.
#
# fx publish cache
#
#   When just publishing cache, all of the above is skipped.  Instead the
#   following file is used:
#
#    assembly_cache_packages.list
#      This file is a copy of the cache_package_manifests.list that's exposed
#      by the GN- or Bazel-based assembly logic.
#

assert(current_toolchain == default_toolchain,
       "//build/images/* are only valid in the Fuchsia toolchain")

has_product_bundle =
    !(use_bazel_images_only && bazel_product_bundle_target == "")

if (use_bringup_assembly) {
  not_needed([ "has_product_bundle" ])

  # These don't have any meaning in these assemblies, so leave them as empty
  # placeholder targets.
  group("updates") {
  }
  group("packages") {
  }
  group("prepare_publish") {
  }
  group("all_package_manifests.list") {
  }
  group("publish") {
  }
} else {
  group("updates") {
    testonly = true
    deps = [
      ":package_lists",
      ":publish",
    ]
  }

  # Use the common `labels` and `files` vars, and define where our bundle package lists
  # are coming from.
  import("//build/images/paths.gni")
  if (has_product_bundle) {
    if (use_bazel_images_only) {
      package_lists_label_dir = "//build/images/updates/bazel_assemblies"
      package_lists_out_dir = "${target_out_dir}/bazel_assemblies"
    } else {
      package_lists_label_dir = "//build/images/updates/gn_assemblies"
      package_lists_out_dir = "${target_out_dir}/gn_assemblies"
    }
  }

  group("universe_packages") {
    testonly = true
    visibility = [ ":*" ]
    public_deps = [
      # The runtime "universe" of packages that's set by the developer.
      "//:developer_universe_packages",
      "//:discoverable_packages",

      # The tests that are added by a developer, and are not verified for their
      # type.
      "//:developer_specified_tests",
    ]
  }

  generate_package_metadata("universe_packages.list") {
    testonly = true
    visibility = [ ":*" ]
    data_keys = [ "package_names" ]
    outputs = [ "${root_build_dir}/universe_packages.list" ]
    deps = [ ":universe_packages" ]
  }

  group("package_lists") {
    testonly = true
    visibility = [ ":*" ]

    deps = [
      # This is still necessary for fx list-packages.
      ":universe_packages.list",
    ]

    if (has_product_bundle) {
      deps += [
        ":all_package_manifests.list",
        ":assembly_cache_packages.list",
        ":base_packages.list",

        # This is still necessary for fx list-packages.
        ":cache_packages.list",
      ]
    }
  }

  if (has_product_bundle) {
    # Create a list of the names of (nearly) all base packages.  This is used by
    # 'fx test' and 'update-if-in-base' to determine if an OTA is necessary.
    action("base_packages.list") {
      testonly = true
      script = "package_names_list.py"

      deps = [ "${package_lists_label_dir}:base_package_manifests.list" ]
      inputs = [ "${package_lists_out_dir}/base_package_manifests.list" ]
      outputs = [ "${root_out_dir}/base_packages.list" ]
      depfile = "${target_out_dir}/${target_name}.d"
      args = [
        "--output",
        rebase_path(outputs[0], root_build_dir),
        "--path",
        rebase_path(inputs[0], root_build_dir),
        "--depfile",
        rebase_path(depfile, root_build_dir),
      ]
    }

    # Create a list of the names of all cache packages.  This is used by fx list-packages
    action("cache_packages.list") {
      testonly = true
      script = "package_names_list.py"

      deps = [ "${package_lists_label_dir}:cache_package_manifests.list" ]
      inputs = [ "${package_lists_out_dir}/cache_package_manifests.list" ]
      outputs = [ "${root_out_dir}/cache_packages.list" ]
      depfile = "${target_out_dir}/${target_name}.d"
      args = [
        "--output",
        rebase_path(outputs[0], root_build_dir),
        "--path",
        rebase_path(inputs[0], root_build_dir),
        "--depfile",
        rebase_path(depfile, root_build_dir),
      ]
    }
  }

  #####
  # This label is used by //BUILD.gn's 'build_api_module()s' to perform metadata
  # walks over "all the software built for the target", both the universe and
  # that which is part of the assembled images (bootfs, base pkgs, cache pkgs,
  # etc.)
  #
  # To get a list of all packages built, use the following file:
  #   `$root_build_dir/all_package_manifests.list`
  # which is generated by:
  #   `//build/images/updates:all_package_manifests.list`
  #
  # This label defined here (`:packages`) IS NOT usable to perform a GN metadata
  # walk for a list of "all the packages built".  That list cannot be gathered by
  # GN metadata alone.
  #
  # Because the list would be incomplete, this label ACTIVELY BLOCKS the ability
  # to use it to gather ANY package manifest metadata.
  #
  group("packages") {
    testonly = true
    deps = [
      # The universe package set
      ":universe_packages",
    ]

    if (has_product_bundle) {
      deps += [
        # Everything else in the main image
        labels.images,

        # The recovery image
        labels.recovery_images,
      ]
    }

    # Restrict usages to //BUILD.gn targets only (build_api_module()s, for the
    # most part)
    visibility = [ "//:*" ]

    metadata = {
      # Block the package_manifest_output gathering, because this target cannot
      # provide a correct list via that mechanism.
      package_barrier = []
    }
  }

  # This is an intermediate output file used to construct the universe
  # package manifests list.
  #
  # fx test currently uses this to synthesize a new set of package lists to
  # publish after building a test package.
  universe_manifests_from_metadata =
      "$root_build_dir/package_manifests_from_metadata.list"
  generate_package_metadata("universe_manifests_from_metadata.list") {
    testonly = true
    outputs = [ universe_manifests_from_metadata ]
    data_keys = [ "package_output_manifests" ]
    rebase = root_build_dir
    deps = [
      # Universe
      ":universe_packages",
    ]

    if (has_product_bundle) {
      deps += [
        # The update packages for the main image
        labels.images,
      ]
    }
  }

  if (has_product_bundle) {
    ###
    ### Amber updates.
    ###

    if (!use_bazel_images_only) {
      recovery_images_list = root_build_dir + "/recovery_images_list"
      generated_file("recovery_images_list") {
        testonly = true
        outputs = [ recovery_images_list ]
        output_conversion = "list lines"
        data_keys = [ "update_target" ]
        deps = [ recovery_label ]
      }
    }

    generate_epoch("epoch.json") {
      output_file = "${target_out_dir}/${target_name}"
    }
  }

  all_package_manifests_list = root_build_dir + "/all_package_manifests.list"
  action("all_package_manifests.list") {
    testonly = true
    script = "merge_package_manifests_list.py"

    deps = []
    inputs = []
    args = []

    outputs = [ all_package_manifests_list ]
    args += [
      "--output",
      rebase_path(all_package_manifests_list, root_build_dir),
    ]

    # GN legacy-defined universe packages
    deps += [ ":universe_manifests_from_metadata.list" ]
    inputs += [ universe_manifests_from_metadata ]
    args += [
      "--paths",
      rebase_path(universe_manifests_from_metadata, root_build_dir),
    ]

    if (has_product_bundle) {
      deps += [
        "${package_lists_label_dir}:bundle_package_manifests.list",
        "${package_lists_label_dir}:ondemand_package_manifests.list",
      ]
      inputs += [
        "${package_lists_out_dir}/bundle_package_manifests.list",
        "${package_lists_out_dir}/ondemand_package_manifests.list",
      ]
      args += [
        "--paths",
        rebase_path("${package_lists_out_dir}/bundle_package_manifests.list",
                    root_build_dir),
        "--paths",
        rebase_path("${package_lists_out_dir}/ondemand_package_manifests.list",
                    root_build_dir),
      ]
    }
  }

  # Publish all packages to the package repository.
  devhost_repository_publish("publish") {
    testonly = true

    output_repository_dir = "${root_build_dir}/amber-files"

    deps = [ ":all_package_manifests.list" ]
    package_list_manifests = [ all_package_manifests_list ]

    output_blob_manifest_path = root_build_dir + "/all_blobs.json"

    metadata = {
      package_repository = [
        {
          path =
              rebase_path("${output_repository_dir}/repository", root_build_dir)
          targets =
              rebase_path("${output_repository_dir}/repository/targets.json",
                          root_build_dir)
          blobs = rebase_path("${output_repository_dir}/repository/blobs",
                              root_build_dir)
        },
      ]
    }
  }

  if (has_product_bundle) {
    # Generate a list of packages for the `fx publish` tool to use, these are
    # different from those used above to create the `all_package_manifests.list`
    # files.
    #
    # These are defined by assembly, and not by legacy GN arguments.

    # The cache package set from assembly
    copy("assembly_cache_packages.list") {
      deps = [ "${package_lists_label_dir}:cache_package_manifests.list" ]
      sources = [ "${package_lists_out_dir}/cache_package_manifests.list" ]
      outputs = [ "$root_build_dir/assembly_cache_packages.list" ]
      testonly = true
    }
  }

  # Allow the incremental publisher to stage the repository keys and root metadata so it can publish
  # without needing to do a full build.
  group("prepare_publish") {
    testonly = true
    deps = [ ":publish_repo_deps" ]
  }
}
