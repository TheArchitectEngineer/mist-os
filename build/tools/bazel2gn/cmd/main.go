// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package main

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"strings"

	"github.com/google/go-cmp/cmp"
	"go.fuchsia.dev/fuchsia/build/tools/bazel2gn"
	"go.starlark.net/starlark"
	"go.starlark.net/syntax"
)

var (
	gnBin          = flag.String("gn_bin", "", "Path to the GN binary.")
	bazelInputPath = flag.String("bazel_input_path", "", "Path to read the BUILD.bazel file from.")
	gnOutputPath   = flag.String("gn_output_path", "", "Path to output the converted GN targest to.")
	checkOnly      = flag.Bool("check_only", false, "When true, compare generated GN content with the input GN file without writing to it")
	diffOutputPath = flag.String("diff_output_path", "", "Path to write the diff to, only useful when checkOnly is true")
)

// bazelBuiltins contains all known Bazel builtin functions. The starlark parser
// fail when it encounters any names not found in this dictionary, or not loaded
// in through a explicit load call.
var bazelBuiltins = starlark.StringDict{
	"select":  nil,
	"package": nil,
}

// commonFileHeader is the header to add to the top of every BUILD.gn file
// converted from a BUILD.bazel file.
const (
	bazel2gnComment = `#
#  ________  _________  ________  ________
# |\   ____\|\___   ___\\   __  \|\   __  \
# \ \  \___|\|___ \  \_\ \  \|\  \ \  \|\  \
#  \ \_____  \   \ \  \ \ \  \\\  \ \   ____\
#   \|____|\  \   \ \  \ \ \  \\\  \ \  \___|
#     ____\_\  \   \ \__\ \ \_______\ \__\
#    |\_________\   \|__|  \|_______|\|__|
#    \|_________|
#
#
# AUTO-GENERATED - DO NOT EDIT
#
# The targets below are auto-generated based on the targets defined in the
# BUILD.bazel file from the same directory. If you made changes to targets in
# Bazel, instead of editing this file manually, run:
#
#   > fx bazel2gn
#
# Please do NOT edit this file directly. Instead, edit the BUILD.bazel file and
# rerun bazel2gn.

import("//build/tools/bazel2gn/bazel_migration.gni")

# A self-verification target for generated content in this file.
if (is_host) {
  verify_bazel2gn("verify_bazel2gn") {
  }
}
`

	sentinelComment = "## BAZEL2GN SENTINEL - DO NOT EDIT BELOW THIS LINE ##"
)

func main() {
	flag.Parse()

	if *bazelInputPath == "" {
		log.Fatal("--bazel_input_path is required, see --help")
	}

	if *gnOutputPath == "" {
		log.Fatal("--gn_output_path is required, see --help")
	}

	if *gnBin == "" {
		log.Fatal("--gn_bin is required, see --help")
	}

	if *diffOutputPath != "" && !*checkOnly {
		log.Fatalf("--diff_output_path is set to %s, but --check_only is not set", *diffOutputPath)
	}

	opts := new(syntax.FileOptions)
	bazelIn, _, err := starlark.SourceProgramOptions(opts, *bazelInputPath, nil, bazelBuiltins.Has)
	if err != nil {
		log.Fatalf("Parsing input Bazel file %s: %v", *bazelInputPath, err)
	}

	var finalLines []string

	for _, stmt := range bazelIn.Stmts {
		lines, err := bazel2gn.StmtToGN(stmt)
		if err != nil {
			log.Fatalf("Failed to convert top-level statement in Bazel to GN: %v", err)
		}
		finalLines = append(finalLines, lines...)
	}

	// Open the GN build file with readonly first, to read the GN targets that
	// need to be preserved.
	gnOut, err := os.Open(*gnOutputPath)
	if err != nil {
		log.Fatalf("Failed to open %s for reading: %v", *gnOutputPath, err)
	}
	toPreserve, err := gnTargetsToPreserve(gnOut)
	if err != nil {
		log.Fatalf("Failed to read GN targets to preserve: %v", err)
	}
	finalContent, err := gnFormated(
		context.Background(),
		*gnBin,
		toPreserve+"\n"+sentinelComment+"\n"+bazel2gnComment+"\n"+strings.Join(finalLines, "\n"),
	)
	if err != nil {
		log.Fatalf("Formatting final GN targets: %v", err)
	}

	if *checkOnly {
		gnOut, err := os.Open(*gnOutputPath)
		if err != nil {
			log.Fatalf("Failed to open %s for reading: %v", *gnOutputPath, err)
		}
		actual, err := io.ReadAll(gnOut)
		if err != nil {
			log.Fatalf("Failed to read full content of %s", *gnOutputPath)
		}
		diffPrintout := ""
		if diff := cmp.Diff(string(actual), finalContent); diff != "" {
			diffPrintout = fmt.Sprintf(`
The following BUILD files are not in sync:

  - %s
  - %s

Make sure you update the BUILD.bazel file, then run this command to sync BUILD.gn:

  fx bazel2gn

Diff of GN targets (-actual, +expected):

%s`,
				*bazelInputPath, *gnOutputPath, diff)
		}
		if *diffOutputPath != "" {
			if err := writeDiffOutput(*diffOutputPath, diffPrintout); err != nil {
				log.Fatalf("Failed to write diff output: %v", err)
			}
		}
		if diffPrintout != "" {
			log.Fatal(diffPrintout)
		}
	} else {
		// Open the GN file again for write.
		gnOut, err = os.OpenFile(*gnOutputPath, os.O_WRONLY|os.O_TRUNC, 0)
		if err != nil {
			log.Fatalf("Failed to open %s for writing: %v", *gnOutputPath, err)
		}
		if _, err := io.WriteString(gnOut, finalContent); err != nil {
			log.Fatalf("Failed to write final GN build file: %v", err)
		}
	}
}

func writeDiffOutput(path string, content string) error {
	diffOut, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)
	if err != nil {
		return fmt.Errorf("opening %s for writing: %v", path, err)
	}
	if _, err := io.WriteString(diffOut, content); err != nil {
		return fmt.Errorf("writing diff to %s: %v", *diffOutputPath, err)
	}
	return nil
}

func gnTargetsToPreserve(r io.Reader) (string, error) {
	s := bufio.NewScanner(r)
	ret := strings.Builder{}
	for s.Scan() {
		line := s.Text()
		if strings.TrimSpace(line) == sentinelComment {
			break
		}
		if _, err := ret.WriteString(line + "\n"); err != nil {
			return "", fmt.Errorf("writing existing line to string buffer: %v", err)
		}
	}
	return ret.String(), nil
}

func gnFormated(ctx context.Context, gnBin string, original string) (string, error) {
	cmd := exec.CommandContext(ctx, gnBin, "format", "--stdin")
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return "", fmt.Errorf("cmd.StdinPipe of `gn format`: %v", err)
	}
	if _, err := io.WriteString(stdin, original); err != nil {
		return "", fmt.Errorf("writing stdin for `gn format`: %v", err)
	}
	if err := stdin.Close(); err != nil {
		return "", fmt.Errorf("closing stdin of `gn format`: %v", err)
	}
	out, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("`gn format` error: %v\nCombinedOutput:\n%s", err, string(out))
	}
	return string(out), nil
}
