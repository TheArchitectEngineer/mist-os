// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef LIB_LD_TESTING_TEST_ELF_OBJECT_H_
#define LIB_LD_TESTING_TEST_ELF_OBJECT_H_

#include <lib/elfldltl/layout.h>
#include <lib/elfldltl/soname.h>

#include <array>
#include <cstdint>
#include <span>
#include <string_view>
#include <unordered_map>

namespace ld {
namespace [[gnu::visibility("hidden")]] testing {

// This represents data culled from a linked ELF (test data) file at build
// time, using //sdk/lib/ld/testing/test_elf_object.gni's test_elf_object().
//
// Each test_elf_object() target produces one initialized const TestElfObject
// named `ld::testing::kTestElfObject_k<build ID hex>`, with the hex build ID
// of the ELF file encoded in the symbol name.  Due to build system issues, the
// same ELF file may be compiled separately multiple times to be linked into
// the same test; so the generated definitions are `inline const` variables.
struct TestElfObject {
  std::string_view build_path;
  std::string_view build_id_hex;
  elfldltl::Soname<> soname;
  std::span<const elfldltl::Elf<>::Phdr> load_segments;
  std::optional<std::string_view> libprefix;
};

// References to those appear in fixed-size arrays referenced as spans.
using TestElfObjectList = std::span<const TestElfObject* const>;

// This is an easy way to populate TestElfObject::load_segments in an
// initializer.  The code fragments generated by test_elf_object() use this.
template <const elfldltl::Elf<>::Phdr&... Segments>
inline constexpr std::array<elfldltl::Elf<>::Phdr, sizeof...(Segments)> kTestElfLoadSegments = {
    Segments...};

// This is an easy way to generate those populated arrays implicitly right in
// the kTestElfLoadSegments instantiation.  The code fragments generated by
// test_elf_object() use this.
template <uintptr_t Vaddr, uintptr_t Memsz, uint32_t Flags>
inline constexpr elfldltl::Elf<>::Phdr kTestElfLoadSegment = {
    .flags = Flags, .vaddr = Vaddr, .memsz = Memsz};

// This represents a named list of ld::testing::TestElfObject records, as
// generated by an test_elf_load_set() target in GN.
//
// Each test_elf_load_set() target produces one corresponding initialized const
// TestElfLoadSet C++ object with internal linkage, so linking it into a test
// just runs its constructor.  The only TestElfLoadSet objects ever constructed
// are these static constructors, so every one is registered in a table that
// TestElfLoadSet::Get looks up by name.
//
// If the build graph was arranged properly, then the last object in the list
// is the test executable or other kind of root module and the others are its
// DT_NEEDED dependencies or other kinds of dependencies (post-order traversal
// of the build graph).  Those other modules will be used at runtime via their
// DT_SONAME strings, and their build-time metadata order is not necessarily
// their runtime load order.  So they are always looked up via the SonameMap.
class TestElfLoadSet {
 public:
  using SonameMap = std::unordered_map<elfldltl::Soname<>, const TestElfObject&>;

  TestElfLoadSet() = delete;
  TestElfLoadSet(const TestElfLoadSet&) = delete;

  TestElfLoadSet(elfldltl::Soname<> name, TestElfObjectList objects);

  // Returns the set by the given name, usually the build-time name of the main
  // module (which may well have no SONAME or other runtime name).  Precisely,
  // the name is the `output_name` parameter to test_elf_load_set() in GN.
  static const TestElfLoadSet* Get(elfldltl::Soname<> name);

  // Return the main module.  This winds up last in the list because the
  // initializer order flows from the post-order GN metadata walk in
  // test_elf_load_set() from the main module to reach its dependencies.  The
  // order is not otherwise meaningful, and might not correspond to load order.
  // Everything but the main module is found by SONAME via MakeSonameMap().
  constexpr const TestElfObject& main_module() const { return *objects_.back(); }

  // Construct a map from SONAME to TestElfObject from the data.
  SonameMap MakeSonameMap() const;

 private:
  TestElfObjectList objects_;
};

// This is an easy way to generate the TestElfObjectList right in the
// TestElfLoadSet constructor argument.  The code fragments generated by
// test_elf_load_set() use this.  The first template parameter is ignored; it's
// just there so generated code can prepend `void` and not count the commas
// (which allows more generation at `gn gen` and fewer recurring build steps).
template <typename, const TestElfObject&... Objects>
inline constexpr std::array<const TestElfObject*, sizeof...(Objects)> kTestElfObjectList = {
    &Objects...};

}  // namespace testing
}  // namespace ld

#endif  // LIB_LD_TESTING_TEST_ELF_OBJECT_H_
