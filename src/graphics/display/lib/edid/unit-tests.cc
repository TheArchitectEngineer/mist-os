// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <lib/driver/testing/cpp/scoped_global_logger.h>
#include <lib/stdcompat/span.h>

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <iterator>
#include <numeric>

#include <gtest/gtest.h>

#include "src/graphics/display/lib/edid-values/edid-values.h"
#include "src/graphics/display/lib/edid/edid.h"

namespace {

class EdidTest : public ::testing::Test {
 private:
  fdf_testing::ScopedGlobalLogger logger_;
};

TEST_F(EdidTest, CaeValidationDtdOverflow) {
  edid::CeaEdidTimingExtension cea = {};
  cea.tag = edid::CeaEdidTimingExtension::kTag;
  cea.dtd_start_idx = 2;

  ASSERT_FALSE(cea.validate());
}

TEST_F(EdidTest, EisaVidLookup) {
  EXPECT_TRUE(!strcmp(edid::GetEisaVendorName(0x1e6d), "GOLDSTAR COMPANY LTD"));
  EXPECT_TRUE(!strcmp(edid::GetEisaVendorName(0x5a63), "VIEWSONIC CORPORATION"));
}

TEST_F(EdidTest, GetManufacturerIdAndName) {
  static constexpr uint8_t kHpZr30wEdidArray[] = {
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x22, 0xf0, 0x6c, 0x28, 0x01, 0x01, 0x01,
      0x01, 0x1e, 0x15, 0x01, 0x04, 0xb5, 0x40, 0x28, 0x78, 0xe2, 0x8d, 0x85, 0xad, 0x4f, 0x35,
      0xb1, 0x25, 0x0e, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xe2, 0x68, 0x00, 0xa0, 0xa0, 0x40,
      0x2e, 0x60, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a, 0xbc, 0x1b, 0x00,
      0xa0, 0x50, 0x20, 0x17, 0x30, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a,
      0x00, 0x00, 0x00, 0xfc, 0x00, 0x48, 0x50, 0x20, 0x5a, 0x52, 0x33, 0x30, 0x77, 0x0a, 0x20,
      0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xff, 0x00, 0x43, 0x4e, 0x34, 0x31, 0x33, 0x30, 0x31,
      0x30, 0x59, 0x48, 0x0a, 0x20, 0x20, 0x00, 0x40};
  static constexpr cpp20::span<const uint8_t> kHpZr30wEdid(kHpZr30wEdidArray);

  fit::result<const char*, edid::Edid> result = edid::Edid::Create(kHpZr30wEdid);
  ASSERT_FALSE(result.is_error()) << "Error while reading EDID: " << result.error_value();
  edid::Edid edid = std::move(result).value();

  // The byte 0x08 and byte 0x09 of the EDID are 0x22 and 0xf0.
  //
  // 0 0 1 0 0 0 1 0 1 1 1 1 0 0 0 0
  //   --------- --------- ---------
  //    Char #1   Char #2   Char #3
  //        = 8       = 23      = 16
  //          H         W          P
  // Thus, the manufacturer ID should be "HWP".
  EXPECT_EQ(edid.GetManufacturerId(), std::string("HWP"));

  // The manufacturer ID "HWP" stands for "HEWLETT PACKARD" in the PNP ID
  // registry.
  const char* manufacturer_name = edid.GetManufacturerName();
  EXPECT_STREQ(manufacturer_name, "HEWLETT PACKARD");
}

TEST_F(EdidTest, GetDisplayProductNameWithNameDescriptor) {
  static constexpr uint8_t kHpZr30wEdidArray[] = {
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x22, 0xf0, 0x6c, 0x28, 0x01, 0x01, 0x01,
      0x01, 0x1e, 0x15, 0x01, 0x04, 0xb5, 0x40, 0x28, 0x78, 0xe2, 0x8d, 0x85, 0xad, 0x4f, 0x35,
      0xb1, 0x25, 0x0e, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xe2, 0x68, 0x00, 0xa0, 0xa0, 0x40,
      0x2e, 0x60, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a, 0xbc, 0x1b, 0x00,
      0xa0, 0x50, 0x20, 0x17, 0x30, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a,
      0x00, 0x00, 0x00, 0xfc, 0x00, 0x48, 0x50, 0x20, 0x5a, 0x52, 0x33, 0x30, 0x77, 0x0a, 0x20,
      0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xff, 0x00, 0x43, 0x4e, 0x34, 0x31, 0x33, 0x30, 0x31,
      0x30, 0x59, 0x48, 0x0a, 0x20, 0x20, 0x00, 0x40};
  static constexpr cpp20::span<const uint8_t> kHpZr30wEdid(kHpZr30wEdidArray);

  fit::result<const char*, edid::Edid> result = edid::Edid::Create(kHpZr30wEdid);
  ASSERT_FALSE(result.is_error()) << "Error while reading EDID: " << result.error_value();
  edid::Edid edid = std::move(result).value();

  // The third 18-byte descriptor:
  // 0x00, 0x00, 0x00, 0xfc, 0x00, 0x48, 0x50, 0x20, 0x5a, 0x52,
  // 0x33, 0x30, 0x77, 0x0a, 0x20, 0x20, 0x20, 0x20
  // is a display descriptor with Display Product Name (0xfc) tag.
  //
  // The ASCII data string (without the terminator and paddings) is
  // {0x48, 0x50, 0x20, 0x5a, 0x52, 0x33, 0x30, 0x77}
  // which stands for "HP ZR30w".

  EXPECT_EQ(edid.GetDisplayProductName(), std::string("HP ZR30w"));
}

TEST_F(EdidTest, GetDisplayProductNameWithoutNameDescriptor) {
  // This removes the name descriptor HP ZR30w EDID array and replaces it with
  // a placeholder display descriptor instead.
  static constexpr uint8_t kHpZr30wWithoutNameDescriptorEdidArray[] = {
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x22, 0xf0, 0x6c, 0x28, 0x01, 0x01, 0x01,
      0x01, 0x1e, 0x15, 0x01, 0x04, 0xb5, 0x40, 0x28, 0x78, 0xe2, 0x8d, 0x85, 0xad, 0x4f, 0x35,
      0xb1, 0x25, 0x0e, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xe2, 0x68, 0x00, 0xa0, 0xa0, 0x40,
      0x2e, 0x60, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a, 0xbc, 0x1b, 0x00,
      0xa0, 0x50, 0x20, 0x17, 0x30, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a,
      0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x43, 0x4e, 0x34, 0x31, 0x33, 0x30, 0x31,
      0x30, 0x59, 0x48, 0x0a, 0x20, 0x20, 0x00, 0xf4};
  static constexpr cpp20::span<const uint8_t> kHpZr30wWithoutNameDescriptorEdid(
      kHpZr30wWithoutNameDescriptorEdidArray);

  fit::result<const char*, edid::Edid> result =
      edid::Edid::Create(kHpZr30wWithoutNameDescriptorEdid);
  ASSERT_FALSE(result.is_error()) << "Error while reading EDID: " << result.error_value();
  edid::Edid edid = std::move(result).value();

  // There is no display product name descriptor. GetDisplayProductName() should
  // return an empty string instead.
  EXPECT_TRUE(edid.GetDisplayProductName().empty());
}

TEST_F(EdidTest, GetDisplayProductSerialWithSerialDescriptor) {
  static constexpr uint8_t kHpZr30wEdidArray[] = {
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x22, 0xf0, 0x6c, 0x28, 0x01, 0x01, 0x01,
      0x01, 0x1e, 0x15, 0x01, 0x04, 0xb5, 0x40, 0x28, 0x78, 0xe2, 0x8d, 0x85, 0xad, 0x4f, 0x35,
      0xb1, 0x25, 0x0e, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xe2, 0x68, 0x00, 0xa0, 0xa0, 0x40,
      0x2e, 0x60, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a, 0xbc, 0x1b, 0x00,
      0xa0, 0x50, 0x20, 0x17, 0x30, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a,
      0x00, 0x00, 0x00, 0xfc, 0x00, 0x48, 0x50, 0x20, 0x5a, 0x52, 0x33, 0x30, 0x77, 0x0a, 0x20,
      0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xff, 0x00, 0x43, 0x4e, 0x34, 0x31, 0x33, 0x30, 0x31,
      0x30, 0x59, 0x48, 0x0a, 0x20, 0x20, 0x00, 0x40};
  static constexpr cpp20::span<const uint8_t> kHpZr30wEdid(kHpZr30wEdidArray);

  fit::result<const char*, edid::Edid> result = edid::Edid::Create(kHpZr30wEdid);
  ASSERT_FALSE(result.is_error()) << "Error while reading EDID: " << result.error_value();
  edid::Edid edid = std::move(result).value();

  // The fourth 18-byte descriptor:
  // 0x00, 0x00, 0x00, 0xff, 0x00, 0x43, 0x4e, 0x34, 0x31, 0x33,
  // 0x30, 0x31, 0x30, 0x59, 0x48, 0x0a, 0x20, 0x20
  // is a display descriptor with Display Product Serial Number (0xff) tag.
  //
  // The ASCII data string (without the terminator and paddings) is
  // {0x43, 0x4e, 0x34, 0x31, 0x33,  0x30, 0x31, 0x30, 0x59, 0x48}
  // which stands for "CN413010YH".
  EXPECT_EQ(edid.GetDisplayProductSerialNumber(), std::string("CN413010YH"));
}

TEST_F(EdidTest, GetDisplayProductSerialWithoutSerialDescriptor) {
  // This removes the serial descriptor HP ZR30w EDID array and replaces it with
  // a placeholder display descriptor instead.
  static constexpr uint8_t kHpZr30wWithoutSerialDescriptorEdidArray[] = {
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x22, 0xf0, 0x6c, 0x28, 0x01, 0x02, 0x03,
      0x04, 0x1e, 0x15, 0x01, 0x04, 0xb5, 0x40, 0x28, 0x78, 0xe2, 0x8d, 0x85, 0xad, 0x4f, 0x35,
      0xb1, 0x25, 0x0e, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xe2, 0x68, 0x00, 0xa0, 0xa0, 0x40,
      0x2e, 0x60, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a, 0xbc, 0x1b, 0x00,
      0xa0, 0x50, 0x20, 0x17, 0x30, 0x30, 0x20, 0x36, 0x00, 0x81, 0x90, 0x21, 0x00, 0x00, 0x1a,
      0x00, 0x00, 0x00, 0xfc, 0x00, 0x48, 0x50, 0x20, 0x5a, 0x52, 0x33, 0x30, 0x77, 0x0a, 0x20,
      0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce};
  static constexpr cpp20::span<const uint8_t> kHpZr30wWithoutSerialDescriptorEdid(
      kHpZr30wWithoutSerialDescriptorEdidArray);

  fit::result<const char*, edid::Edid> result =
      edid::Edid::Create(kHpZr30wWithoutSerialDescriptorEdid);
  ASSERT_FALSE(result.is_error()) << "Error while reading EDID: " << result.error_value();
  edid::Edid edid = std::move(result).value();

  // There is no display product serial number descriptor.
  // GetDisplayProductSerialNumber() should fall back to the decimal expression
  // of the serial number stored in the base EDID "ID serial number" field.
  //
  // The base EDID ID serial number bytes (bytes 0x0c-0x0f) are:
  // (least-significant byte) 0x01, 0x02, 0x03, 0x04 (most-significant byte)
  // So the serial number is 0x04030201 = 67305985.
  EXPECT_EQ(edid.GetDisplayProductSerialNumber(), std::string("67305985"));
}

TEST_F(EdidTest, QemuVirtioGpuEdidParsesCorrectly) {
  fit::result<const char*, edid::Edid> edid_result = edid::Edid::Create(edid::kQemuVirtioGpuEdid);
  EXPECT_TRUE(edid_result.is_ok()) << "EDID parsing failed: " << edid_result.error_value();
  edid::Edid edid = std::move(edid_result).value();

  for (auto timing_it = edid::timing_iterator(&edid); timing_it.is_valid(); ++timing_it) {
    const display::DisplayTiming& display_timing = *timing_it;
    EXPECT_TRUE(display_timing.IsValid());
  }

  EXPECT_EQ(false, edid.is_hdmi());
  EXPECT_EQ(false, edid.supports_basic_audio());
}

TEST_F(EdidTest, QemuVirtioGpuEdidWithPaddingParsesCorrectly) {
  std::array<uint8_t, 1024> padded_edid_bytes;
  std::copy(edid::kQemuVirtioGpuEdid.begin(), edid::kQemuVirtioGpuEdid.end(),
            padded_edid_bytes.begin());

  fit::result<const char*, edid::Edid> edid_result = edid::Edid::Create(padded_edid_bytes);
  EXPECT_TRUE(edid_result.is_ok()) << "EDID parsing failed: " << edid_result.error_value();
  edid::Edid edid = std::move(edid_result).value();

  for (auto timing_it = edid::timing_iterator(&edid); timing_it.is_valid(); ++timing_it) {
    const display::DisplayTiming& display_timing = *timing_it;
    EXPECT_TRUE(display_timing.IsValid());
  }

  EXPECT_EQ(false, edid.is_hdmi());
  EXPECT_EQ(false, edid.supports_basic_audio());
}

}  // namespace
