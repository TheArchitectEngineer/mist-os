/* automatically generated by rust-bindgen 0.71.1 */

// Copyright 2025 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(clippy::missing_safety_doc)]

//! WARNING - This file was auto generated by //src/developer/ffx/lib/symbolize/sys/generate.py.
//! Do not modify this file. To re-generate, run the following command from the root of
//! your Fuchsia checkout:
//!
//!    ./src/developer/ffx/lib/symbolize/sys/generate.py

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symbolizer_SymbolizerImpl {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn symbolizer_global_init();
}
unsafe extern "C" {
    pub fn symbolizer_global_cleanup();
}
unsafe extern "C" {
    pub fn symbolizer_new() -> *mut symbolizer_SymbolizerImpl;
}
unsafe extern "C" {
    pub fn symbolizer_free(symbolizer: *mut symbolizer_SymbolizerImpl);
}
unsafe extern "C" {
    pub fn symbolizer_add_module(
        symbolizer: *mut symbolizer_SymbolizerImpl,
        id: u64,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
        build_id: *const ::std::os::raw::c_char,
        build_id_len: usize,
    );
}
pub const MappingStatus_Ok: MappingStatus = 0;
pub const MappingStatus_InconsistentBaseAddress: MappingStatus = 1;
pub const MappingStatus_InvalidModuleId: MappingStatus = 2;
pub type MappingStatus = u8;
unsafe extern "C" {
    pub fn symbolizer_add_mapping(
        symbolizer: *mut symbolizer_SymbolizerImpl,
        module_id: u64,
        start_addr: u64,
        size: u64,
        module_offset: u64,
        flags: *const ::std::os::raw::c_char,
        flags_len: usize,
    ) -> MappingStatus;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symbolizer_location_t {
    pub function: *const ::std::os::raw::c_char,
    pub function_len: usize,
    pub file: *const ::std::os::raw::c_char,
    pub file_len: usize,
    pub line: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub library: *const ::std::os::raw::c_char,
    pub library_len: usize,
    pub library_offset: u64,
}
pub type location_callback = ::std::option::Option<
    unsafe extern "C" fn(
        location: *const symbolizer_location_t,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub const ResolveAddressStatus_Ok: ResolveAddressStatus = 0;
pub const ResolveAddressStatus_SymbolFileUnavailable: ResolveAddressStatus = 1;
pub const ResolveAddressStatus_NoOverlappingModule: ResolveAddressStatus = 2;
pub type ResolveAddressStatus = u8;
unsafe extern "C" {
    pub fn symbolizer_resolve_address(
        symbolizer: *mut symbolizer_SymbolizerImpl,
        address: u64,
        output: location_callback,
        output_context: *mut ::std::os::raw::c_void,
    ) -> ResolveAddressStatus;
}
