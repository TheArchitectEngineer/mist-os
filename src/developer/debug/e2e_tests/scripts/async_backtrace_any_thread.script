## require is_lto=false
## require optimize=none

[zxdb] run-component fuchsia-pkg://fuchsia.com/zxdb_e2e_inferiors#meta/async_rust_multithreaded.cm
Launched Process 1 state=Running koid=?? name=async_rust_multithreaded.cm component=async_rust_multithreaded.cm
ðŸ›‘

# Only the thread that executes the panic! will be stopped when we catch the exception, so
# explicitly pause to make sure all threads are suspended.
[zxdb] pause
ðŸ›‘

# TODO(jruthe): undo this once we can download symbols.
[zxdb] thread * frame --force-remote-unwind
0

# There are three threads. The "initial-thread" on all processes, plus the two specified to the
# fasync::run annotation to main.
[zxdb] t 1 abt
Task(id = 0)
â””â”€ async_rust_multithreaded::main::func â€¢ async_rust_multithreaded.rs:??
   â””â”€ fuchsia_async::runtime::fuchsia::timer::Timer
Scope("scope")
â””â”€ Task(id = 3)
   â””â”€ async_rust_multithreaded::foo (Unresumed) â€¢ async_rust_multithreaded.rs:??
â””â”€ Scope("child")
   â””â”€ Task(id = 4)
      â””â”€ async_rust_multithreaded::foo (Unresumed) â€¢ async_rust_multithreaded.rs:??

[zxdb] t 2 abt
Task(id = 0)
â””â”€ async_rust_multithreaded::main::func â€¢ async_rust_multithreaded.rs:??
   â””â”€ fuchsia_async::runtime::fuchsia::timer::Timer
Scope("scope")
â””â”€ Task(id = 3)
   â””â”€ async_rust_multithreaded::foo (Unresumed) â€¢ async_rust_multithreaded.rs:??
â””â”€ Scope("child")
   â””â”€ Task(id = 4)
      â””â”€ async_rust_multithreaded::foo (Unresumed) â€¢ async_rust_multithreaded.rs:??

[zxdb] t 3 abt
Task(id = 0)
â””â”€ async_rust_multithreaded::main::func â€¢ async_rust_multithreaded.rs:??
   â””â”€ fuchsia_async::runtime::fuchsia::timer::Timer
Scope("scope")
â””â”€ Task(id = 3)
   â””â”€ async_rust_multithreaded::foo (Unresumed) â€¢ async_rust_multithreaded.rs:??
â””â”€ Scope("child")
   â””â”€ Task(id = 4)
      â””â”€ async_rust_multithreaded::foo (Unresumed) â€¢ async_rust_multithreaded.rs:??

[zxdb] kill
Process 1 killed.
