// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_STARNIX_LIB_LINUX_UAPI_STUB_MISSING_INCLUDES_H_
#define SRC_STARNIX_LIB_LINUX_UAPI_STUB_MISSING_INCLUDES_H_

// Adding includes that are not detected by rust-bindings because they are
// defined using functions

#include <asm/ioctls.h>
#include <linux/if_tun.h>
#include <linux/seccomp.h>

// generate.py will remove __bindgen_missing_ from the start of constant names.
#define C(x) const __u32 __bindgen_missing_##x = x

C(SECCOMP_IOCTL_NOTIF_RECV);
C(SECCOMP_IOCTL_NOTIF_SEND);
C(SECCOMP_IOCTL_NOTIF_ID_VALID);
C(SECCOMP_IOCTL_NOTIF_ADDFD);

C(TIOCSPTLCK);
C(TIOCGPTLCK);
C(TIOCGPKT);
C(TIOCSIG);
C(TIOCGPTN);

C(BLKGETSIZE);
C(BLKFLSBUF);
C(BLKGETSIZE64);

C(EVIOCGVERSION);
C(EVIOCGID);

C(RWF_HIPRI);
C(RWF_DSYNC);
C(RWF_SYNC);
C(RWF_NOWAIT);
C(RWF_APPEND);
C(RWF_SUPPORTED);

// `EVIOCGBIT`, `EVIOCGPROP`, and `EVIOCGABS` are invoked with various paraemters to query
// metadata about an input device. Create Rust symbols for the commonly used invocations.
//
// The `EVIOCGBIT` invocations specify a `size` _just_ large enough to report all off the
// feature bits for that attribute.
//
// TODO(quiche): Eventually, it will probably be better to provide a way to parse the fields
// within an `ioctl()`'s `request` parameter. That would allow, e.g., the input code to
// respond to any request for `EV_KEY` feature bits, even if the caller provided a buffer
// larger than that needed for the available bits.
#define N_BYTES(BITS) (((BITS) + CHAR_BIT - 1) / CHAR_BIT)
const __u32 EVIOCGBIT_EV_KEY = EVIOCGBIT(EV_KEY, N_BYTES(KEY_MAX));
const __u32 EVIOCGBIT_EV_ABS = EVIOCGBIT(EV_ABS, N_BYTES(ABS_MAX));
const __u32 EVIOCGBIT_EV_REL = EVIOCGBIT(EV_REL, N_BYTES(REL_MAX));
const __u32 EVIOCGBIT_EV_SW = EVIOCGBIT(EV_SW, N_BYTES(SW_MAX));
const __u32 EVIOCGBIT_EV_LED = EVIOCGBIT(EV_LED, N_BYTES(LED_MAX));
const __u32 EVIOCGBIT_EV_FF = EVIOCGBIT(EV_FF, N_BYTES(FF_MAX));
const __u32 EVIOCGBIT_EV_MSC = EVIOCGBIT(EV_MSC, N_BYTES(MSC_MAX));
const __u32 EVIOCGPROP = EVIOCGPROP(N_BYTES(INPUT_PROP_MAX));
const __u32 EVIOCGABS_X = EVIOCGABS(ABS_X);
const __u32 EVIOCGABS_Y = EVIOCGABS(ABS_Y);
const __u32 EVIOCGABS_MT_SLOT = EVIOCGABS(ABS_MT_SLOT);
const __u32 EVIOCGABS_MT_TRACKING_ID = EVIOCGABS(ABS_MT_TRACKING_ID);
const __u32 EVIOCGABS_MT_POSITION_X = EVIOCGABS(ABS_MT_POSITION_X);
const __u32 EVIOCGABS_MT_POSITION_Y = EVIOCGABS(ABS_MT_POSITION_Y);
// Zero-size device name.
const __u32 EVIOCGNAME_0 = EVIOCGNAME(0);
#undef N_BYTES

// Symbols for remote binder device driver

struct remote_binder_start_command {
  const char* incoming_service;
};

struct remote_binder_wait_command {
  char spawn_thread;
};

const __u32 REMOTE_BINDER_START = _IOR('R', 1, struct remote_binder_start_command);
const __u32 REMOTE_BINDER_WAIT = _IOW('R', 2, struct remote_binder_wait_command);

C(FIBMAP);
C(FIGETBSZ);

C(FS_IOC_GETVERSION);
C(FS_IOC_SETVERSION);

C(FS_IOC_FSGETXATTR);
C(FS_IOC_FSSETXATTR);

C(FS_IOC_GETFLAGS);
C(FS_IOC_SETFLAGS);

// Symbols for fsverity

C(FS_IOC_ENABLE_VERITY);
C(FS_IOC_MEASURE_VERITY);
C(FS_IOC_READ_VERITY_METADATA);

// Symbols for the device-mapper

C(DM_DEV_STATUS);
C(DM_DEV_CREATE);
C(DM_DEV_REMOVE);
C(DM_DEV_SUSPEND);
C(DM_TABLE_LOAD);
C(DM_TABLE_STATUS);
C(DM_LIST_VERSIONS);
C(DM_LIST_DEVICES);
C(DM_VERSION);
C(DM_REMOVE_ALL);
C(DM_DEV_RENAME);
C(DM_DEV_WAIT);
C(DM_TABLE_CLEAR);
C(DM_TABLE_DEPS);
C(DM_TARGET_MSG);
C(DM_DEV_SET_GEOMETRY);
C(DM_DEV_ARM_POLL);
C(DM_GET_TARGET_VERSION);

// Symbols for fscrypt
C(FS_IOC_ADD_ENCRYPTION_KEY);
C(FS_IOC_SET_ENCRYPTION_POLICY);
C(FS_IOC_GET_ENCRYPTION_POLICY);
C(FS_IOC_REMOVE_ENCRYPTION_KEY);

// Symbols for kgsl

C(KGSL_MEMFLAGS_USERMEM_PMEM);
C(KGSL_MEMFLAGS_USERMEM_ASHMEM);
C(KGSL_MEMFLAGS_USERMEM_ADDR);
C(KGSL_MEMFLAGS_USERMEM_ION);

C(IOCTL_KGSL_DEVICE_GETPROPERTY);
C(IOCTL_KGSL_DEVICE_WAITTIMESTAMP);
C(IOCTL_KGSL_DEVICE_WAITTIMESTAMP_CTXTID);
C(IOCTL_KGSL_RINGBUFFER_ISSUEIBCMDS);
C(IOCTL_KGSL_CMDSTREAM_READTIMESTAMP_OLD);
C(IOCTL_KGSL_CMDSTREAM_READTIMESTAMP);
C(IOCTL_KGSL_CMDSTREAM_FREEMEMONTIMESTAMP);
C(IOCTL_KGSL_CMDSTREAM_FREEMEMONTIMESTAMP_OLD);
C(IOCTL_KGSL_DRAWCTXT_CREATE);
C(IOCTL_KGSL_DRAWCTXT_DESTROY);
C(IOCTL_KGSL_MAP_USER_MEM);
C(IOCTL_KGSL_CMDSTREAM_READTIMESTAMP_CTXTID);
C(IOCTL_KGSL_CMDSTREAM_FREEMEMONTIMESTAMP_CTXTID);
C(IOCTL_KGSL_SHAREDMEM_FROM_PMEM);
C(IOCTL_KGSL_SHAREDMEM_FREE);
C(IOCTL_KGSL_CFF_USER_EVENT);
C(IOCTL_KGSL_DRAWCTXT_BIND_GMEM_SHADOW);
C(IOCTL_KGSL_SHAREDMEM_FROM_VMALLOC);
C(IOCTL_KGSL_SHAREDMEM_FLUSH_CACHE);
C(IOCTL_KGSL_DRAWCTXT_SET_BIN_BASE_OFFSET);
C(IOCTL_KGSL_CMDWINDOW_WRITE);
C(IOCTL_KGSL_GPUMEM_ALLOC);
C(IOCTL_KGSL_CFF_SYNCMEM);
C(IOCTL_KGSL_TIMESTAMP_EVENT_OLD);
C(IOCTL_KGSL_SETPROPERTY);
C(IOCTL_KGSL_TIMESTAMP_EVENT);
C(IOCTL_KGSL_GPUMEM_ALLOC_ID);
C(IOCTL_KGSL_GPUMEM_FREE_ID);
C(IOCTL_KGSL_GPUMEM_GET_INFO);
C(IOCTL_KGSL_GPUMEM_SYNC_CACHE);
C(IOCTL_KGSL_PERFCOUNTER_GET);
C(IOCTL_KGSL_PERFCOUNTER_PUT);
C(IOCTL_KGSL_PERFCOUNTER_QUERY);
C(IOCTL_KGSL_PERFCOUNTER_READ);
C(IOCTL_KGSL_GPUMEM_SYNC_CACHE_BULK);
C(IOCTL_KGSL_SUBMIT_COMMANDS);
C(IOCTL_KGSL_SYNCSOURCE_CREATE);
C(IOCTL_KGSL_SYNCSOURCE_DESTROY);
C(IOCTL_KGSL_SYNCSOURCE_CREATE_FENCE);
C(IOCTL_KGSL_SYNCSOURCE_SIGNAL_FENCE);
C(IOCTL_KGSL_CFF_SYNC_GPUOBJ);
C(IOCTL_KGSL_GPUOBJ_ALLOC);
C(IOCTL_KGSL_GPUOBJ_FREE);
C(IOCTL_KGSL_GPUOBJ_INFO);
C(IOCTL_KGSL_GPUOBJ_IMPORT);
C(IOCTL_KGSL_GPUOBJ_SYNC);
C(IOCTL_KGSL_GPU_COMMAND);
C(IOCTL_KGSL_PREEMPTIONCOUNTER_QUERY);
C(IOCTL_KGSL_GPUOBJ_SET_INFO);
C(IOCTL_KGSL_SPARSE_PHYS_ALLOC);
C(IOCTL_KGSL_SPARSE_PHYS_FREE);
C(IOCTL_KGSL_SPARSE_VIRT_ALLOC);
C(IOCTL_KGSL_SPARSE_VIRT_FREE);
C(IOCTL_KGSL_SPARSE_BIND);
C(IOCTL_KGSL_GPU_SPARSE_COMMAND);
C(IOCTL_KGSL_GPUMEM_BIND_RANGES);
C(IOCTL_KGSL_GPU_AUX_COMMAND);
C(IOCTL_KGSL_TIMELINE_CREATE);
C(IOCTL_KGSL_TIMELINE_WAIT);
C(IOCTL_KGSL_TIMELINE_QUERY);
C(IOCTL_KGSL_TIMELINE_SIGNAL);
C(IOCTL_KGSL_TIMELINE_FENCE_GET);
C(IOCTL_KGSL_TIMELINE_DESTROY);
C(IOCTL_KGSL_GET_FAULT_REPORT);
C(IOCTL_KGSL_RECURRING_COMMAND);
C(IOCTL_KGSL_READ_CALIBRATED_TIMESTAMPS);

// Symbols for uinput

C(UI_DEV_CREATE);
C(UI_DEV_DESTROY);
C(UI_DEV_SETUP);
C(UI_ABS_SETUP);
C(UI_SET_EVBIT);
C(UI_SET_KEYBIT);
C(UI_SET_RELBIT);
C(UI_SET_ABSBIT);
C(UI_SET_MSCBIT);
C(UI_SET_LEDBIT);
C(UI_SET_SNDBIT);
C(UI_SET_FFBIT);
C(UI_SET_PHYS);
C(UI_SET_SWBIT);
C(UI_SET_PROPBIT);
C(UI_BEGIN_FF_UPLOAD);
C(UI_END_FF_UPLOAD);
C(UI_BEGIN_FF_ERASE);
C(UI_END_FF_ERASE);
C(UI_GET_VERSION);

C(ASHMEM_SET_NAME);
C(ASHMEM_GET_NAME);
C(ASHMEM_SET_SIZE);
C(ASHMEM_GET_SIZE);
C(ASHMEM_SET_PROT_MASK);
C(ASHMEM_GET_PROT_MASK);
C(ASHMEM_PIN);
C(ASHMEM_UNPIN);
C(ASHMEM_GET_PIN_STATUS);
C(ASHMEM_PURGE_ALL_CACHES);
C(ASHMEM_GET_FILE_ID);

C(RNDGETENTCNT);
C(RNDADDTOENTCNT);
C(RNDGETPOOL);
C(RNDADDENTROPY);
C(RNDZAPENTCNT);
C(RNDCLEARPOOL);
C(RNDRESEEDCRNG);

// Symbols for userfaultfd
C(UFFDIO_REGISTER);
C(UFFDIO_UNREGISTER);
C(UFFDIO_WAKE);
C(UFFDIO_COPY);
C(UFFDIO_ZEROPAGE);
C(UFFDIO_WRITEPROTECT);
C(UFFDIO_CONTINUE);
C(UFFDIO_POISON);
C(UFFDIO_MOVE);
C(UFFDIO_API);
C(UFFDIO_REGISTER_MODE_MISSING);
C(UFFDIO_REGISTER_MODE_WP);
C(UFFDIO_REGISTER_MODE_MINOR);
C(UFFDIO_COPY_MODE_DONTWAKE);
C(UFFDIO_COPY_MODE_WP);
C(UFFDIO_ZEROPAGE_MODE_DONTWAKE);
C(UFFDIO_CONTINUE_MODE_DONTWAKE);

// Ioctls that can be done on a perf event fd:
// Should match //third_party/android/platform/bionic/libc/kernel/uapi/linux/perf_event.h
// and https://man7.org/linux/man-pages/man2/perf_event_open.2.html
C(PERF_EVENT_IOC_ENABLE);
C(PERF_EVENT_IOC_DISABLE);
C(PERF_EVENT_IOC_REFRESH);
C(PERF_EVENT_IOC_RESET);
C(PERF_EVENT_IOC_PERIOD);
C(PERF_EVENT_IOC_SET_OUTPUT);
C(PERF_EVENT_IOC_SET_FILTER);
C(PERF_EVENT_IOC_ID);
C(PERF_EVENT_IOC_SET_BPF);
C(PERF_EVENT_IOC_PAUSE_OUTPUT);
C(PERF_EVENT_IOC_QUERY_BPF);
C(PERF_EVENT_IOC_MODIFY_ATTRIBUTES);

typedef struct new_utsname utsname;
typedef __kernel_gid_t gid_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_off_t off_t;

C(TUNSETIFF);

// Struct only defined in libc and not in the uapi part of bionic
struct sched_param {
  int sched_priority;
};

#ifndef __arm__

C(FUSE_DEV_IOC_PASSTHROUGH_OPEN_V0);
C(FUSE_DEV_IOC_PASSTHROUGH_OPEN_V1);
C(FUSE_DEV_IOC_PASSTHROUGH_OPEN_V2);

#endif  // #ifndef __arm__

#endif  // SRC_STARNIX_LIB_LINUX_UAPI_STUB_MISSING_INCLUDES_H_
