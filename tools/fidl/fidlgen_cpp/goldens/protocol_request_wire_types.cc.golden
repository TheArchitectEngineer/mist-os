// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.protocolrequest/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

#ifdef __Fuchsia__

void ::test_protocolrequest::wire::ParentGetChildResponse::_CloseHandles() {
  c.reset();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolrequest::wire::ParentGetChildResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolrequest::wire::ParentGetChildResponse));
  } else {
    internal::WireCodingTraits<::fidl::ClientEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->c, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::ClientEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolrequest::wire::ParentGetChildResponse>);
static_assert(offsetof(::test_protocolrequest::wire::ParentGetChildResponse, c) == 0);
static_assert(sizeof(::test_protocolrequest::wire::ParentGetChildResponse) == ::fidl::TypeTraits<::test_protocolrequest::wire::ParentGetChildResponse>::kPrimarySize);

void ::test_protocolrequest::wire::ParentGetChildRequestResponse::_CloseHandles() {
  r.reset();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolrequest::wire::ParentGetChildRequestResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolrequest::wire::ParentGetChildRequestResponse));
  } else {
    internal::WireCodingTraits<::fidl::ServerEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->r, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::ServerEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentGetChildRequestResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolrequest::wire::ParentGetChildRequestResponse>);
static_assert(offsetof(::test_protocolrequest::wire::ParentGetChildRequestResponse, r) == 0);
static_assert(sizeof(::test_protocolrequest::wire::ParentGetChildRequestResponse) == ::fidl::TypeTraits<::test_protocolrequest::wire::ParentGetChildRequestResponse>::kPrimarySize);

void ::test_protocolrequest::wire::ParentTakeChildRequest::_CloseHandles() {
  c.reset();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolrequest::wire::ParentTakeChildRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolrequest::wire::ParentTakeChildRequest));
  } else {
    internal::WireCodingTraits<::fidl::ClientEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->c, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::ClientEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolrequest::wire::ParentTakeChildRequest>);
static_assert(offsetof(::test_protocolrequest::wire::ParentTakeChildRequest, c) == 0);
static_assert(sizeof(::test_protocolrequest::wire::ParentTakeChildRequest) == ::fidl::TypeTraits<::test_protocolrequest::wire::ParentTakeChildRequest>::kPrimarySize);

void ::test_protocolrequest::wire::ParentTakeChildRequestRequest::_CloseHandles() {
  r.reset();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolrequest::wire::ParentTakeChildRequestRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolrequest::wire::ParentTakeChildRequestRequest));
  } else {
    internal::WireCodingTraits<::fidl::ServerEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->r, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::ServerEnd<::test_protocolrequest::Child>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolrequest::wire::ParentTakeChildRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolrequest::wire::ParentTakeChildRequestRequest>);
static_assert(offsetof(::test_protocolrequest::wire::ParentTakeChildRequestRequest, r) == 0);
static_assert(sizeof(::test_protocolrequest::wire::ParentTakeChildRequestRequest) == ::fidl::TypeTraits<::test_protocolrequest::wire::ParentTakeChildRequestRequest>::kPrimarySize);

#endif  // __Fuchsia__

#pragma clang diagnostic pop
