// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.error/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

::test_error::ExampleFooRequest::ExampleFooRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_error::ExampleFooRequest::ExampleFooRequest(::std::string s) noexcept
    : storage_({.s = std::move(s)}) {}

::test_error::ExampleFooRequest::ExampleFooRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ExampleFooRequest(Storage_{
                                                                                                                     .s = {},
                                                                                                                 }) {}
::test_error::ExampleFooRequest::ExampleFooRequest(const ::test_error::ExampleFooRequest& other) noexcept : ::test_error::ExampleFooRequest(other.CloneStorage_()) {}

::test_error::ExampleFooRequest& test_error::ExampleFooRequest::operator=(const ::test_error::ExampleFooRequest& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_error::ExampleFooRequest::operator==(const ExampleFooRequest& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_error::ExampleFooRequest, 16>::Equal(this, &other);
}

bool test_error::ExampleFooRequest::operator!=(const ExampleFooRequest& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_error::ExampleFooRequest, 16>::Equal(this, &other);
}

::test_error::ExampleFooRequest::Storage_ test_error::ExampleFooRequest::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.s)};
}
const ::std::string&
test_error::ExampleFooRequest::s() const {
  return storage_.s;
}

::std::string& ::test_error::ExampleFooRequest::s() {
  return storage_.s;
}

::test_error::ExampleFooRequest& ::test_error::ExampleFooRequest::s(::std::string value) {
  storage_.s = std::move(value);
  return *this;
}

::test_error::ExampleFooResponse::ExampleFooResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_error::ExampleFooResponse::ExampleFooResponse(int64_t y) noexcept
    : storage_({.y = std::move(y)}) {}

::test_error::ExampleFooResponse::ExampleFooResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ExampleFooResponse(Storage_{
                                                                                                                       .y = {},
                                                                                                                   }) {}
::test_error::ExampleFooResponse::ExampleFooResponse(const ::test_error::ExampleFooResponse& other) noexcept : ::test_error::ExampleFooResponse(other.CloneStorage_()) {}

::test_error::ExampleFooResponse& test_error::ExampleFooResponse::operator=(const ::test_error::ExampleFooResponse& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_error::ExampleFooResponse::operator==(const ExampleFooResponse& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_error::ExampleFooResponse, 8>::Equal(this, &other);
}

bool test_error::ExampleFooResponse::operator!=(const ExampleFooResponse& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_error::ExampleFooResponse, 8>::Equal(this, &other);
}

::test_error::ExampleFooResponse::Storage_ test_error::ExampleFooResponse::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.y)};
}
int64_t
test_error::ExampleFooResponse::y() const {
  return storage_.y;
}

int64_t& ::test_error::ExampleFooResponse::y() {
  return storage_.y;
}

::test_error::ExampleFooResponse& ::test_error::ExampleFooResponse::y(int64_t value) {
  storage_.y = std::move(value);
  return *this;
}

::test_error::ExampleFooResult::ExampleFooResult(ExampleFooResult&& other) noexcept : ExampleFooResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_error::ExampleFooResult& ::test_error::ExampleFooResult::operator=(ExampleFooResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_error::ExampleFooResult::ExampleFooResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_error::ExampleFooResult::ExampleFooResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_error::ExampleFooResult::Tag test_error::ExampleFooResult::Which() const {
  return ExampleFooResult::IndexToTag(storage_->index()).value();
}

size_t test_error::ExampleFooResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_error::ExampleFooResult::Tag tag) {
  switch (tag) {
    case ::test_error::ExampleFooResult::Tag::kResponse:
      return 1;
    case ::test_error::ExampleFooResult::Tag::kErr:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_error::ExampleFooResult::Tag> test_error::ExampleFooResult::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_error::ExampleFooResult::Tag::kResponse;
    case 2:
      return ::test_error::ExampleFooResult::Tag::kErr;
    default:
      return std::nullopt;
  }
}

::test_error::ExampleFooResult::ExampleFooResult(const ExampleFooResult& other) noexcept : ExampleFooResult(other.CloneStorage_()) {}

::test_error::ExampleFooResult& test_error::ExampleFooResult::operator=(const ExampleFooResult& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_error::ExampleFooResult::operator==(const ExampleFooResult& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_error::ExampleFooResult::operator!=(const ExampleFooResult& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_error::ExampleFooResult::Storage_> test_error::ExampleFooResult::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_error::ExampleFooResult test_error::ExampleFooResult::WithResponse(::test_error::ExampleFooResponse val) {
  return ExampleFooResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_error::ExampleFooResult::Storage_> test_error::ExampleFooResult::response() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_error::ExampleFooResult::Storage_> test_error::ExampleFooResult::response() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_error::ExampleFooResult& test_error::ExampleFooResult::response(::test_error::ExampleFooResponse value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_error::ExampleFooResult test_error::ExampleFooResult::WithErr(uint32_t val) {
  return ExampleFooResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_error::ExampleFooResult::Storage_> test_error::ExampleFooResult::err() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_error::ExampleFooResult::Storage_> test_error::ExampleFooResult::err() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_error::ExampleFooResult& test_error::ExampleFooResult::err(uint32_t value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

#pragma clang diagnostic pop
