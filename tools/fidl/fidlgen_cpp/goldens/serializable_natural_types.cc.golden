// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.serializable/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

::test_serializable::SerializableStruct::SerializableStruct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_serializable::SerializableStruct::SerializableStruct(uint8_t __reserved) noexcept
    : storage_({.__reserved = std::move(__reserved)}) {}

::test_serializable::SerializableStruct::SerializableStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : SerializableStruct(Storage_{
                                                                                                                              .__reserved = 0u,
                                                                                                                          }) {}
::test_serializable::SerializableStruct::SerializableStruct(const ::test_serializable::SerializableStruct& other) noexcept : ::test_serializable::SerializableStruct(other.CloneStorage_()) {}

::test_serializable::SerializableStruct& test_serializable::SerializableStruct::operator=(const ::test_serializable::SerializableStruct& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_serializable::SerializableStruct::operator==(const SerializableStruct& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_serializable::SerializableStruct, 1>::Equal(this, &other);
}

bool test_serializable::SerializableStruct::operator!=(const SerializableStruct& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_serializable::SerializableStruct, 1>::Equal(this, &other);
}

::test_serializable::SerializableStruct::Storage_ test_serializable::SerializableStruct::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.__reserved)};
}
uint8_t
test_serializable::SerializableStruct::__reserved() const {
  return storage_.__reserved;
}

uint8_t& ::test_serializable::SerializableStruct::__reserved() {
  return storage_.__reserved;
}

::test_serializable::SerializableStruct& ::test_serializable::SerializableStruct::__reserved(uint8_t value) {
  storage_.__reserved = std::move(value);
  return *this;
}

::test_serializable::SerializableTable::SerializableTable(::test_serializable::SerializableTable::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_serializable::SerializableTable::SerializableTable(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : SerializableTable(Storage_{}) {}

::test_serializable::SerializableTable::SerializableTable(const ::test_serializable::SerializableTable& other) noexcept : SerializableTable(other.CloneStorage_()) {}

::test_serializable::SerializableTable& ::test_serializable::SerializableTable::operator=(const ::test_serializable::SerializableTable& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_serializable::SerializableTable::operator==(const SerializableTable& other) const noexcept {
  return ::fidl::internal::NaturalTableCodingTraits<::test_serializable::SerializableTable>::Equal(this, &other);
}
bool test_serializable::SerializableTable::operator!=(const SerializableTable& other) const noexcept {
  return !::fidl::internal::NaturalTableCodingTraits<::test_serializable::SerializableTable>::Equal(this, &other);
}

::test_serializable::SerializableTable::Storage_ test_serializable::SerializableTable::CloneStorage_() const {
  return Storage_{};
}

bool test_serializable::SerializableTable::IsEmpty() const {
  return true;
}

::test_serializable::SerializableUnion::SerializableUnion(SerializableUnion&& other) noexcept : SerializableUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_serializable::SerializableUnion& ::test_serializable::SerializableUnion::operator=(SerializableUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_serializable::SerializableUnion::SerializableUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_serializable::SerializableUnion::SerializableUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_serializable::SerializableUnion::Tag test_serializable::SerializableUnion::Which() const {
  return SerializableUnion::IndexToTag(storage_->index()).value();
}

size_t test_serializable::SerializableUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_serializable::SerializableUnion::Tag tag) {
  switch (tag) {
    case ::test_serializable::SerializableUnion::Tag::kUnused:
      return 1;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_serializable::SerializableUnion::Tag> test_serializable::SerializableUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_serializable::SerializableUnion::Tag::kUnused;
    default:
      return std::nullopt;
  }
}

::test_serializable::SerializableUnion::SerializableUnion(const SerializableUnion& other) noexcept : SerializableUnion(other.CloneStorage_()) {}

::test_serializable::SerializableUnion& test_serializable::SerializableUnion::operator=(const SerializableUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_serializable::SerializableUnion::operator==(const SerializableUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_serializable::SerializableUnion::operator!=(const SerializableUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_serializable::SerializableUnion::Storage_> test_serializable::SerializableUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_serializable::SerializableUnion test_serializable::SerializableUnion::WithUnused(bool val) {
  return SerializableUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_serializable::SerializableUnion::Storage_> test_serializable::SerializableUnion::unused() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_serializable::SerializableUnion::Storage_> test_serializable::SerializableUnion::unused() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_serializable::SerializableUnion& test_serializable::SerializableUnion::unused(bool value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

#pragma clang diagnostic pop
