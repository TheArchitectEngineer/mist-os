// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.handlesintypes/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::ObjType, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_handlesintypes::wire::ObjType* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  switch (*value) {
    case ::test_handlesintypes::wire::ObjType::kNone:
    case ::test_handlesintypes::wire::ObjType::kVmo:
      break;
    default:
      encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
      return;
  }
  *position.As<::test_handlesintypes::wire::ObjType>() = *value;
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::ObjType, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  [[maybe_unused]] ::test_handlesintypes::wire::ObjType value = *position.As<::test_handlesintypes::wire::ObjType>();
  switch (value) {
    case ::test_handlesintypes::wire::ObjType::kNone:
    case ::test_handlesintypes::wire::ObjType::kVmo:
      break;
    default:
      decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
      return;
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::ObjType, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::ObjType, ::fidl::internal::WireCodingConstraintEmpty, false>;

#ifdef __Fuchsia__

void ::test_handlesintypes::wire::HandlesInTypes::_CloseHandles() {
  normal_handle.reset();
  for (auto& e_1 : handle_in_vec) {
    e_1.reset();
  }

  for (auto& e_1 : handle_in_array) {
    e_1.reset();
  }

  for (auto& e_1 : handle_in_mixed_vec_array) {
    for (auto& e_2 : e_1) {
      e_2.reset();
    }
  }

  table_with_handle._CloseHandles();
  union_with_handle._CloseHandles();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::HandlesInTypes, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_handlesintypes::wire::HandlesInTypes* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_handlesintypes::wire::HandlesInTypes));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 40);
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->normal_handle, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Encode(encoder, &value->handle_in_vec, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->handle_in_array, position + 24, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::Array<::zx::vmo, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Encode(encoder, &value->handle_in_mixed_vec_array, position + 48, recursion_depth);
    internal::WireCodingTraits<::test_handlesintypes::wire::TableWithHandle, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->table_with_handle, position + 64, recursion_depth);
    internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_with_handle, position + 80, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::HandlesInTypes, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::Array<::zx::vmo, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Decode(
        decoder, position + 48, recursion_depth);
    internal::WireCodingTraits<::test_handlesintypes::wire::TableWithHandle, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 64, recursion_depth);
    internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 80, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 40, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::HandlesInTypes, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::HandlesInTypes, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_handlesintypes::wire::HandlesInTypes>);
static_assert(offsetof(::test_handlesintypes::wire::HandlesInTypes, normal_handle) == 0);
static_assert(offsetof(::test_handlesintypes::wire::HandlesInTypes, handle_in_vec) == 8);
static_assert(offsetof(::test_handlesintypes::wire::HandlesInTypes, handle_in_array) == 24);
static_assert(offsetof(::test_handlesintypes::wire::HandlesInTypes, handle_in_mixed_vec_array) == 48);
static_assert(offsetof(::test_handlesintypes::wire::HandlesInTypes, table_with_handle) == 64);
static_assert(offsetof(::test_handlesintypes::wire::HandlesInTypes, union_with_handle) == 80);
static_assert(sizeof(::test_handlesintypes::wire::HandlesInTypes) == ::fidl::TypeTraits<::test_handlesintypes::wire::HandlesInTypes>::kPrimarySize);

void ::test_handlesintypes::wire::EmptyResourceStruct::_CloseHandles() {
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_handlesintypes::wire::EmptyResourceStruct* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_handlesintypes::wire::EmptyResourceStruct));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_handlesintypes::wire::EmptyResourceStruct>);
static_assert(offsetof(::test_handlesintypes::wire::EmptyResourceStruct, __reserved) == 0);
static_assert(sizeof(::test_handlesintypes::wire::EmptyResourceStruct) == ::fidl::TypeTraits<::test_handlesintypes::wire::EmptyResourceStruct>::kPrimarySize);

::test_handlesintypes::wire::UnionWithHandle::UnionWithHandle() : ordinal_(::test_handlesintypes::wire::UnionWithHandle::Ordinal::Invalid), envelope_{} {}
auto ::test_handlesintypes::wire::UnionWithHandle::Which() const -> ::test_handlesintypes::wire::UnionWithHandle::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
    case ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH:
      return static_cast<::test_handlesintypes::wire::UnionWithHandle::Tag>(ordinal_);
    default:
      return ::test_handlesintypes::wire::UnionWithHandle::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_handlesintypes::wire::UnionWithHandle::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionWithHandle) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionWithHandle, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionWithHandle, envelope_) == offsetof(fidl_union_t, envelope));
}
::test_handlesintypes::wire::UnionWithHandle::~UnionWithHandle() {
  switch (ordinal_) {
    case ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH:
      envelope_.As<::zx::vmo>().clear_data();
      break;
    default:
      break;
  }
}

::test_handlesintypes::wire::UnionWithHandle::UnionWithHandle(UnionWithHandle&& other) {
  _Move(std::move(other));
}
::test_handlesintypes::wire::UnionWithHandle& test_handlesintypes::wire::UnionWithHandle::operator=(::test_handlesintypes::wire::UnionWithHandle&& other) {
  if (this != &other) {
    _Move(std::move(other));
  }
  return *this;
}

void ::test_handlesintypes::wire::UnionWithHandle::_Move(UnionWithHandle&& other) {
  ordinal_ = other.ordinal_;
  switch (ordinal_) {
    case ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH:
      envelope_.As<::zx::vmo>() = std::move(other.envelope_.As<::zx::vmo>());
      break;
    default:
      break;
  }
}

void ::test_handlesintypes::wire::UnionWithHandle::_CloseHandles() {
  switch (ordinal_) {
    case ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH: {
      h().reset();
      break;
    }
    default:
      break;
  }
}

bool test_handlesintypes::wire::UnionWithHandle::has_invalid_tag() const { return ordinal_ == ::test_handlesintypes::wire::UnionWithHandle::Ordinal::Invalid; }

bool test_handlesintypes::wire::UnionWithHandle::is_h() const { return ordinal_ == ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH; }
::test_handlesintypes::wire::UnionWithHandle test_handlesintypes::wire::UnionWithHandle::WithH(::zx::vmo val) {
  UnionWithHandle result;
  result.ordinal_ = ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH;
  result.envelope_.As<::zx::vmo>().set_data(std::move(val));
  return result;
}

::zx::vmo& test_handlesintypes::wire::UnionWithHandle::h() {
  ZX_ASSERT(ordinal_ == ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH);
  return envelope_.As<::zx::vmo>().get_data();
}
const ::zx::vmo& test_handlesintypes::wire::UnionWithHandle::h() const {
  ZX_ASSERT(ordinal_ == ::test_handlesintypes::wire::UnionWithHandle::Ordinal::kH);
  return envelope_.As<::zx::vmo>().get_data();
}

static_assert(std::is_standard_layout_v<::test_handlesintypes::wire::UnionWithHandle>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_handlesintypes::wire::UnionWithHandle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_handlesintypes::wire::UnionWithHandle::Tag::kH
      encode_inline_size = ::fidl::internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_handlesintypes::wire::UnionWithHandle::Tag::kH
      encode_fn = ::fidl::internal::MakeEncodeFn<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_handlesintypes::wire::UnionWithHandle::Tag tag = *position.As<::test_handlesintypes::wire::UnionWithHandle::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_handlesintypes::wire::UnionWithHandle::Tag::kH:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_handlesintypes::wire::UnionWithHandle::Tag::kH:
      decode_fn = ::fidl::internal::MakeDecodeFn<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::UnionWithHandle, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_handlesintypes::wire::EmptyResourceUnion::EmptyResourceUnion() : ordinal_(::test_handlesintypes::wire::EmptyResourceUnion::Ordinal::Invalid), envelope_{} {}
auto ::test_handlesintypes::wire::EmptyResourceUnion::Which() const -> ::test_handlesintypes::wire::EmptyResourceUnion::Tag {
  ZX_ASSERT(!has_invalid_tag());
  return ::test_handlesintypes::wire::EmptyResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}

void ::test_handlesintypes::wire::EmptyResourceUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(EmptyResourceUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(EmptyResourceUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(EmptyResourceUnion, envelope_) == offsetof(fidl_union_t, envelope));
}
::test_handlesintypes::wire::EmptyResourceUnion::~EmptyResourceUnion() {
  switch (ordinal_) {
    default:
      break;
  }
}

::test_handlesintypes::wire::EmptyResourceUnion::EmptyResourceUnion(EmptyResourceUnion&& other) {
  _Move(std::move(other));
}
::test_handlesintypes::wire::EmptyResourceUnion& test_handlesintypes::wire::EmptyResourceUnion::operator=(::test_handlesintypes::wire::EmptyResourceUnion&& other) {
  if (this != &other) {
    _Move(std::move(other));
  }
  return *this;
}

void ::test_handlesintypes::wire::EmptyResourceUnion::_Move(EmptyResourceUnion&& other) {
  ordinal_ = other.ordinal_;
  switch (ordinal_) {
    default:
      break;
  }
}

void ::test_handlesintypes::wire::EmptyResourceUnion::_CloseHandles() {
  switch (ordinal_) {
    default:
      break;
  }
}

bool test_handlesintypes::wire::EmptyResourceUnion::has_invalid_tag() const { return ordinal_ == ::test_handlesintypes::wire::EmptyResourceUnion::Ordinal::Invalid; }

static_assert(std::is_standard_layout_v<::test_handlesintypes::wire::EmptyResourceUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_handlesintypes::wire::EmptyResourceUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_handlesintypes::wire::EmptyResourceUnion::Tag tag = *position.As<::test_handlesintypes::wire::EmptyResourceUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

bool ::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
  if (!h_.has_data()) {
    max_ordinal = 1;
  }
  return max_ordinal;
}

::test_handlesintypes::wire::TableWithHandle::TableWithHandle(::fidl::AnyArena& allocator)
    : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>>(allocator)) {}

::test_handlesintypes::wire::TableWithHandle::TableWithHandle(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>>&& frame)
    : frame_ptr_(std::move(frame)) {}

void test_handlesintypes::wire::TableWithHandle::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>>(allocator);
}
void test_handlesintypes::wire::TableWithHandle::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_handlesintypes::wire::TableWithHandle::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_handlesintypes::wire::TableWithHandle::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

void ::test_handlesintypes::wire::TableWithHandle::_CloseHandles() {
  if (has_h()) {
    h().reset();
  }
}

::zx::vmo& test_handlesintypes::wire::TableWithHandle::h() const {
  ZX_ASSERT(has_h());
  return frame_ptr_->h_.get_data();
}

bool test_handlesintypes::wire::TableWithHandle::has_h() const {
  return max_ordinal_ >= 1 && frame_ptr_->h_.has_data();
}

::test_handlesintypes::wire::TableWithHandle& test_handlesintypes::wire::TableWithHandle::clear_h() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->h_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_handlesintypes::wire::TableWithHandle& test_handlesintypes::wire::TableWithHandle::set_h(::zx::vmo elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->h_.set_data(std::move(elem));
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
  return *this;
}

::fidl::WireTableBuilder<::test_handlesintypes::wire::TableWithHandle> test_handlesintypes::wire::TableWithHandle::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_handlesintypes::wire::TableWithHandle>(arena);
}
::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::TableWithHandle> test_handlesintypes::wire::TableWithHandle::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::TableWithHandle>(std::move(frame));
}

template <typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>>&& frame)
    : table_(std::move(frame)) {}

template <typename BuilderImpl>
::test_handlesintypes::wire::TableWithHandle fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_handlesintypes::wire::TableWithHandle t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, BuilderImpl>::has_h() const {
  return table_.has_h();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, BuilderImpl>::clear_h() {
  table_.clear_h();
}

template <typename BuilderImpl>
::zx::vmo& fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, BuilderImpl>::h() const {
  return table_.h();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, BuilderImpl>::h(::zx::vmo elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  table_.frame_ptr_->h_.set_data(std::move(elem));
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
  return *static_cast<BuilderImpl*>(this);
}

template class fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, ::fidl::WireTableBuilder<::test_handlesintypes::wire::TableWithHandle>>;
template class fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::TableWithHandle, ::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::TableWithHandle>>;

::fidl::WireTableBuilder<::test_handlesintypes::wire::TableWithHandle>::WireTableBuilder(::fidl::AnyArena& arena)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>>(arena)),
      arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::TableWithHandle>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>* frame)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::TableWithHandle>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::TableWithHandle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_handlesintypes::wire::TableWithHandle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {
    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::TableWithHandle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {
    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch (i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::TableWithHandle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::TableWithHandle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_handlesintypes::wire::TableWithHandle>);

bool ::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
  return max_ordinal;
}

::test_handlesintypes::wire::EmptyResourceTable::EmptyResourceTable(::fidl::AnyArena& allocator)
    : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>>(allocator)) {}

::test_handlesintypes::wire::EmptyResourceTable::EmptyResourceTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>>&& frame)
    : frame_ptr_(std::move(frame)) {}

void test_handlesintypes::wire::EmptyResourceTable::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>>(allocator);
}
void test_handlesintypes::wire::EmptyResourceTable::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_handlesintypes::wire::EmptyResourceTable::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_handlesintypes::wire::EmptyResourceTable::HasUnknownData() const {
  if (max_ordinal_ > 0) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

void ::test_handlesintypes::wire::EmptyResourceTable::_CloseHandles() {
}

::fidl::WireTableBuilder<::test_handlesintypes::wire::EmptyResourceTable> test_handlesintypes::wire::EmptyResourceTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_handlesintypes::wire::EmptyResourceTable>(arena);
}
::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::EmptyResourceTable> test_handlesintypes::wire::EmptyResourceTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::EmptyResourceTable>(std::move(frame));
}

template <typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::EmptyResourceTable, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>>&& frame)
    : table_(std::move(frame)) {}

template <typename BuilderImpl>
::test_handlesintypes::wire::EmptyResourceTable fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::EmptyResourceTable, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_handlesintypes::wire::EmptyResourceTable t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}

template class fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::EmptyResourceTable, ::fidl::WireTableBuilder<::test_handlesintypes::wire::EmptyResourceTable>>;
template class fidl::internal::WireTableBaseBuilder<::test_handlesintypes::wire::EmptyResourceTable, ::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::EmptyResourceTable>>;

::fidl::WireTableBuilder<::test_handlesintypes::wire::EmptyResourceTable>::WireTableBuilder(::fidl::AnyArena& arena)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>>(arena)),
      arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_handlesintypes::wire::EmptyResourceTable>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>* frame)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_handlesintypes::wire::EmptyResourceTable>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_handlesintypes::wire::EmptyResourceTable* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {
    size_t encode_inline_size = 0;
    switch (i) {
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {
    size_t decode_inline_size = 0;
    switch (i) {
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch (i) {
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceTable, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_handlesintypes::wire::EmptyResourceTable, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_handlesintypes::wire::EmptyResourceTable>);

#endif  // __Fuchsia__

#pragma clang diagnostic pop
