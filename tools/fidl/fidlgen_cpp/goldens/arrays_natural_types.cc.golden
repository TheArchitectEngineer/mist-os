// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.arrays/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

::test_arrays::StructSmallArray::StructSmallArray(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_arrays::StructSmallArray::StructSmallArray(::std::array<uint32_t, 2> a) noexcept
    : storage_({.a = std::move(a)}) {}

::test_arrays::StructSmallArray::StructSmallArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : StructSmallArray(Storage_{
                                                                                                                    .a = ::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint32_t, 2>>::Make(),
                                                                                                                }) {}
::test_arrays::StructSmallArray::StructSmallArray(const ::test_arrays::StructSmallArray& other) noexcept : ::test_arrays::StructSmallArray(other.CloneStorage_()) {}

::test_arrays::StructSmallArray& test_arrays::StructSmallArray::operator=(const ::test_arrays::StructSmallArray& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_arrays::StructSmallArray::operator==(const StructSmallArray& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_arrays::StructSmallArray, 8>::Equal(this, &other);
}

bool test_arrays::StructSmallArray::operator!=(const StructSmallArray& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_arrays::StructSmallArray, 8>::Equal(this, &other);
}

::test_arrays::StructSmallArray::Storage_ test_arrays::StructSmallArray::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a)};
}
const ::std::array<uint32_t, 2>&
test_arrays::StructSmallArray::a() const {
  return storage_.a;
}

::std::array<uint32_t, 2>& ::test_arrays::StructSmallArray::a() {
  return storage_.a;
}

::test_arrays::StructSmallArray& ::test_arrays::StructSmallArray::a(::std::array<uint32_t, 2> value) {
  storage_.a = std::move(value);
  return *this;
}

::test_arrays::StructLargeArray::StructLargeArray(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_arrays::StructLargeArray::StructLargeArray(::std::array<uint32_t, 100> a) noexcept
    : storage_({.a = std::move(a)}) {}

::test_arrays::StructLargeArray::StructLargeArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : StructLargeArray(Storage_{
                                                                                                                    .a = ::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint32_t, 100>>::Make(),
                                                                                                                }) {}
::test_arrays::StructLargeArray::StructLargeArray(const ::test_arrays::StructLargeArray& other) noexcept : ::test_arrays::StructLargeArray(other.CloneStorage_()) {}

::test_arrays::StructLargeArray& test_arrays::StructLargeArray::operator=(const ::test_arrays::StructLargeArray& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_arrays::StructLargeArray::operator==(const StructLargeArray& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_arrays::StructLargeArray, 400>::Equal(this, &other);
}

bool test_arrays::StructLargeArray::operator!=(const StructLargeArray& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_arrays::StructLargeArray, 400>::Equal(this, &other);
}

::test_arrays::StructLargeArray::Storage_ test_arrays::StructLargeArray::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a)};
}
const ::std::array<uint32_t, 100>&
test_arrays::StructLargeArray::a() const {
  return storage_.a;
}

::std::array<uint32_t, 100>& ::test_arrays::StructLargeArray::a() {
  return storage_.a;
}

::test_arrays::StructLargeArray& ::test_arrays::StructLargeArray::a(::std::array<uint32_t, 100> value) {
  storage_.a = std::move(value);
  return *this;
}

::test_arrays::TableSmallArray::TableSmallArray(::test_arrays::TableSmallArray::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_arrays::TableSmallArray::TableSmallArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TableSmallArray(Storage_{}) {}

::test_arrays::TableSmallArray::TableSmallArray(const ::test_arrays::TableSmallArray& other) noexcept : TableSmallArray(other.CloneStorage_()) {}

::test_arrays::TableSmallArray& ::test_arrays::TableSmallArray::operator=(const ::test_arrays::TableSmallArray& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_arrays::TableSmallArray::operator==(const TableSmallArray& other) const noexcept {
  return ::fidl::internal::NaturalTableCodingTraits<::test_arrays::TableSmallArray>::Equal(this, &other);
}
bool test_arrays::TableSmallArray::operator!=(const TableSmallArray& other) const noexcept {
  return !::fidl::internal::NaturalTableCodingTraits<::test_arrays::TableSmallArray>::Equal(this, &other);
}

::test_arrays::TableSmallArray::Storage_ test_arrays::TableSmallArray::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a)};
}

bool test_arrays::TableSmallArray::IsEmpty() const {
  return !(storage_.a.has_value());
}
const std::optional<::std::array<uint32_t, 2>>& test_arrays::TableSmallArray::a() const {
  return storage_.a;
}

::std::optional<::std::array<uint32_t, 2>>& test_arrays::TableSmallArray::a() {
  return storage_.a;
}

::test_arrays::TableSmallArray& test_arrays::TableSmallArray::a(std::optional<::std::array<uint32_t, 2>> value) {
  storage_.a = std::move(value);
  return *this;
}

::test_arrays::TableLargeArray::TableLargeArray(::test_arrays::TableLargeArray::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_arrays::TableLargeArray::TableLargeArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TableLargeArray(Storage_{}) {}

::test_arrays::TableLargeArray::TableLargeArray(const ::test_arrays::TableLargeArray& other) noexcept : TableLargeArray(other.CloneStorage_()) {}

::test_arrays::TableLargeArray& ::test_arrays::TableLargeArray::operator=(const ::test_arrays::TableLargeArray& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_arrays::TableLargeArray::operator==(const TableLargeArray& other) const noexcept {
  return ::fidl::internal::NaturalTableCodingTraits<::test_arrays::TableLargeArray>::Equal(this, &other);
}
bool test_arrays::TableLargeArray::operator!=(const TableLargeArray& other) const noexcept {
  return !::fidl::internal::NaturalTableCodingTraits<::test_arrays::TableLargeArray>::Equal(this, &other);
}

::test_arrays::TableLargeArray::Storage_ test_arrays::TableLargeArray::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a)};
}

bool test_arrays::TableLargeArray::IsEmpty() const {
  return !(storage_.a.has_value());
}
const std::optional<::std::array<uint32_t, 100>>& test_arrays::TableLargeArray::a() const {
  return storage_.a;
}

::std::optional<::std::array<uint32_t, 100>>& test_arrays::TableLargeArray::a() {
  return storage_.a;
}

::test_arrays::TableLargeArray& test_arrays::TableLargeArray::a(std::optional<::std::array<uint32_t, 100>> value) {
  storage_.a = std::move(value);
  return *this;
}

::test_arrays::UnionSmallArray::UnionSmallArray(UnionSmallArray&& other) noexcept : UnionSmallArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_arrays::UnionSmallArray& ::test_arrays::UnionSmallArray::operator=(UnionSmallArray&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_arrays::UnionSmallArray::UnionSmallArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_arrays::UnionSmallArray::UnionSmallArray(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_arrays::UnionSmallArray::Tag test_arrays::UnionSmallArray::Which() const {
  return UnionSmallArray::IndexToTag(storage_->index()).value();
}

size_t test_arrays::UnionSmallArray::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_arrays::UnionSmallArray::Tag tag) {
  switch (tag) {
    case ::test_arrays::UnionSmallArray::Tag::kA:
      return 1;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_arrays::UnionSmallArray::Tag> test_arrays::UnionSmallArray::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_arrays::UnionSmallArray::Tag::kA;
    default:
      return std::nullopt;
  }
}

::test_arrays::UnionSmallArray::UnionSmallArray(const UnionSmallArray& other) noexcept : UnionSmallArray(other.CloneStorage_()) {}

::test_arrays::UnionSmallArray& test_arrays::UnionSmallArray::operator=(const UnionSmallArray& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_arrays::UnionSmallArray::operator==(const UnionSmallArray& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_arrays::UnionSmallArray::operator!=(const UnionSmallArray& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_arrays::UnionSmallArray::Storage_> test_arrays::UnionSmallArray::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_arrays::UnionSmallArray test_arrays::UnionSmallArray::WithA(::std::array<uint32_t, 2> val) {
  return UnionSmallArray(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_arrays::UnionSmallArray::Storage_> test_arrays::UnionSmallArray::a() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_arrays::UnionSmallArray::Storage_> test_arrays::UnionSmallArray::a() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_arrays::UnionSmallArray& test_arrays::UnionSmallArray::a(::std::array<uint32_t, 2> value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_arrays::UnionLargeArray::UnionLargeArray(UnionLargeArray&& other) noexcept : UnionLargeArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_arrays::UnionLargeArray& ::test_arrays::UnionLargeArray::operator=(UnionLargeArray&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_arrays::UnionLargeArray::UnionLargeArray(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_arrays::UnionLargeArray::UnionLargeArray(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_arrays::UnionLargeArray::Tag test_arrays::UnionLargeArray::Which() const {
  return UnionLargeArray::IndexToTag(storage_->index()).value();
}

size_t test_arrays::UnionLargeArray::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_arrays::UnionLargeArray::Tag tag) {
  switch (tag) {
    case ::test_arrays::UnionLargeArray::Tag::kA:
      return 1;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_arrays::UnionLargeArray::Tag> test_arrays::UnionLargeArray::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_arrays::UnionLargeArray::Tag::kA;
    default:
      return std::nullopt;
  }
}

::test_arrays::UnionLargeArray::UnionLargeArray(const UnionLargeArray& other) noexcept : UnionLargeArray(other.CloneStorage_()) {}

::test_arrays::UnionLargeArray& test_arrays::UnionLargeArray::operator=(const UnionLargeArray& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_arrays::UnionLargeArray::operator==(const UnionLargeArray& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_arrays::UnionLargeArray::operator!=(const UnionLargeArray& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_arrays::UnionLargeArray::Storage_> test_arrays::UnionLargeArray::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_arrays::UnionLargeArray test_arrays::UnionLargeArray::WithA(::std::array<uint32_t, 100> val) {
  return UnionLargeArray(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_arrays::UnionLargeArray::Storage_> test_arrays::UnionLargeArray::a() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_arrays::UnionLargeArray::Storage_> test_arrays::UnionLargeArray::a() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_arrays::UnionLargeArray& test_arrays::UnionLargeArray::a(::std::array<uint32_t, 100> value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

#pragma clang diagnostic pop
