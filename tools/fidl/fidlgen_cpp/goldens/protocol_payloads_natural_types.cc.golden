// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.protocolpayloads/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

::test_protocolpayloads::LocalStructPayload::LocalStructPayload(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_protocolpayloads::LocalStructPayload::LocalStructPayload(uint32_t a, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .b = std::move(b)}) {}

::test_protocolpayloads::LocalStructPayload::LocalStructPayload(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : LocalStructPayload(Storage_{
                                                                                                                                  .a = {},
                                                                                                                                  .b = {},
                                                                                                                              }) {}
::test_protocolpayloads::LocalStructPayload::LocalStructPayload(const ::test_protocolpayloads::LocalStructPayload& other) noexcept : ::test_protocolpayloads::LocalStructPayload(other.CloneStorage_()) {}

::test_protocolpayloads::LocalStructPayload& test_protocolpayloads::LocalStructPayload::operator=(const ::test_protocolpayloads::LocalStructPayload& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_protocolpayloads::LocalStructPayload::operator==(const LocalStructPayload& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::LocalStructPayload, 8>::Equal(this, &other);
}

bool test_protocolpayloads::LocalStructPayload::operator!=(const LocalStructPayload& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::LocalStructPayload, 8>::Equal(this, &other);
}

::test_protocolpayloads::LocalStructPayload::Storage_ test_protocolpayloads::LocalStructPayload::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_protocolpayloads::LocalStructPayload::a() const {
  return storage_.a;
}

uint32_t& ::test_protocolpayloads::LocalStructPayload::a() {
  return storage_.a;
}

::test_protocolpayloads::LocalStructPayload& ::test_protocolpayloads::LocalStructPayload::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
uint32_t
test_protocolpayloads::LocalStructPayload::b() const {
  return storage_.b;
}

uint32_t& ::test_protocolpayloads::LocalStructPayload::b() {
  return storage_.b;
}

::test_protocolpayloads::LocalStructPayload& ::test_protocolpayloads::LocalStructPayload::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_protocolpayloads::MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_protocolpayloads::MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(uint32_t a, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .b = std::move(b)}) {}

::test_protocolpayloads::MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolOneWayAnonRequest(Storage_{
                                                                                                                                                        .a = {},
                                                                                                                                                        .b = {},
                                                                                                                                                    }) {}
::test_protocolpayloads::MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(const ::test_protocolpayloads::MainProtocolOneWayAnonRequest& other) noexcept : ::test_protocolpayloads::MainProtocolOneWayAnonRequest(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolOneWayAnonRequest& test_protocolpayloads::MainProtocolOneWayAnonRequest::operator=(const ::test_protocolpayloads::MainProtocolOneWayAnonRequest& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_protocolpayloads::MainProtocolOneWayAnonRequest::operator==(const MainProtocolOneWayAnonRequest& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolOneWayAnonRequest, 8>::Equal(this, &other);
}

bool test_protocolpayloads::MainProtocolOneWayAnonRequest::operator!=(const MainProtocolOneWayAnonRequest& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolOneWayAnonRequest, 8>::Equal(this, &other);
}

::test_protocolpayloads::MainProtocolOneWayAnonRequest::Storage_ test_protocolpayloads::MainProtocolOneWayAnonRequest::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_protocolpayloads::MainProtocolOneWayAnonRequest::a() const {
  return storage_.a;
}

uint32_t& ::test_protocolpayloads::MainProtocolOneWayAnonRequest::a() {
  return storage_.a;
}

::test_protocolpayloads::MainProtocolOneWayAnonRequest& ::test_protocolpayloads::MainProtocolOneWayAnonRequest::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
uint32_t
test_protocolpayloads::MainProtocolOneWayAnonRequest::b() const {
  return storage_.b;
}

uint32_t& ::test_protocolpayloads::MainProtocolOneWayAnonRequest::b() {
  return storage_.b;
}

::test_protocolpayloads::MainProtocolOneWayAnonRequest& ::test_protocolpayloads::MainProtocolOneWayAnonRequest::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayAnonRequest::MainProtocolTwoWayAnonRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_protocolpayloads::MainProtocolTwoWayAnonRequest::MainProtocolTwoWayAnonRequest(uint32_t a, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .b = std::move(b)}) {}

::test_protocolpayloads::MainProtocolTwoWayAnonRequest::MainProtocolTwoWayAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayAnonRequest(Storage_{
                                                                                                                                                        .a = {},
                                                                                                                                                        .b = {},
                                                                                                                                                    }) {}
::test_protocolpayloads::MainProtocolTwoWayAnonRequest::MainProtocolTwoWayAnonRequest(const ::test_protocolpayloads::MainProtocolTwoWayAnonRequest& other) noexcept : ::test_protocolpayloads::MainProtocolTwoWayAnonRequest(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolTwoWayAnonRequest& test_protocolpayloads::MainProtocolTwoWayAnonRequest::operator=(const ::test_protocolpayloads::MainProtocolTwoWayAnonRequest& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_protocolpayloads::MainProtocolTwoWayAnonRequest::operator==(const MainProtocolTwoWayAnonRequest& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonRequest, 8>::Equal(this, &other);
}

bool test_protocolpayloads::MainProtocolTwoWayAnonRequest::operator!=(const MainProtocolTwoWayAnonRequest& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonRequest, 8>::Equal(this, &other);
}

::test_protocolpayloads::MainProtocolTwoWayAnonRequest::Storage_ test_protocolpayloads::MainProtocolTwoWayAnonRequest::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonRequest::a() const {
  return storage_.a;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonRequest::a() {
  return storage_.a;
}

::test_protocolpayloads::MainProtocolTwoWayAnonRequest& ::test_protocolpayloads::MainProtocolTwoWayAnonRequest::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonRequest::b() const {
  return storage_.b;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonRequest::b() {
  return storage_.b;
}

::test_protocolpayloads::MainProtocolTwoWayAnonRequest& ::test_protocolpayloads::MainProtocolTwoWayAnonRequest::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_protocolpayloads::MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(uint32_t a, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .b = std::move(b)}) {}

::test_protocolpayloads::MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayAnonResponse(Storage_{
                                                                                                                                                          .a = {},
                                                                                                                                                          .b = {},
                                                                                                                                                      }) {}
::test_protocolpayloads::MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(const ::test_protocolpayloads::MainProtocolTwoWayAnonResponse& other) noexcept : ::test_protocolpayloads::MainProtocolTwoWayAnonResponse(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolTwoWayAnonResponse& test_protocolpayloads::MainProtocolTwoWayAnonResponse::operator=(const ::test_protocolpayloads::MainProtocolTwoWayAnonResponse& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_protocolpayloads::MainProtocolTwoWayAnonResponse::operator==(const MainProtocolTwoWayAnonResponse& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonResponse, 8>::Equal(this, &other);
}

bool test_protocolpayloads::MainProtocolTwoWayAnonResponse::operator!=(const MainProtocolTwoWayAnonResponse& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonResponse, 8>::Equal(this, &other);
}

::test_protocolpayloads::MainProtocolTwoWayAnonResponse::Storage_ test_protocolpayloads::MainProtocolTwoWayAnonResponse::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonResponse::a() const {
  return storage_.a;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonResponse::a() {
  return storage_.a;
}

::test_protocolpayloads::MainProtocolTwoWayAnonResponse& ::test_protocolpayloads::MainProtocolTwoWayAnonResponse::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonResponse::b() const {
  return storage_.b;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonResponse::b() {
  return storage_.b;
}

::test_protocolpayloads::MainProtocolTwoWayAnonResponse& ::test_protocolpayloads::MainProtocolTwoWayAnonResponse::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(uint32_t a, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .b = std::move(b)}) {}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayAnonWithErrorRequest(Storage_{
                                                                                                                                                                          .a = {},
                                                                                                                                                                          .b = {},
                                                                                                                                                                      }) {}
::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest& other) noexcept : ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest& test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::operator=(const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::operator==(const MainProtocolTwoWayAnonWithErrorRequest& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest, 8>::Equal(this, &other);
}

bool test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::operator!=(const MainProtocolTwoWayAnonWithErrorRequest& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest, 8>::Equal(this, &other);
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::Storage_ test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::a() const {
  return storage_.a;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::a() {
  return storage_.a;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::b() const {
  return storage_.b;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::b() {
  return storage_.b;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::MainProtocolTwoWayAnonWithErrorResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::MainProtocolTwoWayAnonWithErrorResponse(uint32_t a, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .b = std::move(b)}) {}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::MainProtocolTwoWayAnonWithErrorResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolTwoWayAnonWithErrorResponse(Storage_{
                                                                                                                                                                            .a = {},
                                                                                                                                                                            .b = {},
                                                                                                                                                                        }) {}
::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::MainProtocolTwoWayAnonWithErrorResponse(const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse& other) noexcept : ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse& test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::operator=(const ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::operator==(const MainProtocolTwoWayAnonWithErrorResponse& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse, 8>::Equal(this, &other);
}

bool test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::operator!=(const MainProtocolTwoWayAnonWithErrorResponse& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse, 8>::Equal(this, &other);
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::Storage_ test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::a() const {
  return storage_.a;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::a() {
  return storage_.a;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
uint32_t
test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::b() const {
  return storage_.b;
}

uint32_t& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::b() {
  return storage_.b;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_protocolpayloads::MainProtocolOnAnonRequest::MainProtocolOnAnonRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_protocolpayloads::MainProtocolOnAnonRequest::MainProtocolOnAnonRequest(uint32_t a, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .b = std::move(b)}) {}

::test_protocolpayloads::MainProtocolOnAnonRequest::MainProtocolOnAnonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : MainProtocolOnAnonRequest(Storage_{
                                                                                                                                                .a = {},
                                                                                                                                                .b = {},
                                                                                                                                            }) {}
::test_protocolpayloads::MainProtocolOnAnonRequest::MainProtocolOnAnonRequest(const ::test_protocolpayloads::MainProtocolOnAnonRequest& other) noexcept : ::test_protocolpayloads::MainProtocolOnAnonRequest(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolOnAnonRequest& test_protocolpayloads::MainProtocolOnAnonRequest::operator=(const ::test_protocolpayloads::MainProtocolOnAnonRequest& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_protocolpayloads::MainProtocolOnAnonRequest::operator==(const MainProtocolOnAnonRequest& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolOnAnonRequest, 8>::Equal(this, &other);
}

bool test_protocolpayloads::MainProtocolOnAnonRequest::operator!=(const MainProtocolOnAnonRequest& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_protocolpayloads::MainProtocolOnAnonRequest, 8>::Equal(this, &other);
}

::test_protocolpayloads::MainProtocolOnAnonRequest::Storage_ test_protocolpayloads::MainProtocolOnAnonRequest::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_protocolpayloads::MainProtocolOnAnonRequest::a() const {
  return storage_.a;
}

uint32_t& ::test_protocolpayloads::MainProtocolOnAnonRequest::a() {
  return storage_.a;
}

::test_protocolpayloads::MainProtocolOnAnonRequest& ::test_protocolpayloads::MainProtocolOnAnonRequest::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
uint32_t
test_protocolpayloads::MainProtocolOnAnonRequest::b() const {
  return storage_.b;
}

uint32_t& ::test_protocolpayloads::MainProtocolOnAnonRequest::b() {
  return storage_.b;
}

::test_protocolpayloads::MainProtocolOnAnonRequest& ::test_protocolpayloads::MainProtocolOnAnonRequest::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::MainProtocolTwoWayLocalWithErrorResult(MainProtocolTwoWayLocalWithErrorResult&& other) noexcept : MainProtocolTwoWayLocalWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult& ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::operator=(MainProtocolTwoWayLocalWithErrorResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::MainProtocolTwoWayLocalWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::MainProtocolTwoWayLocalWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Tag test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Which() const {
  return MainProtocolTwoWayLocalWithErrorResult::IndexToTag(storage_->index()).value();
}

size_t test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Tag tag) {
  switch (tag) {
    case ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse:
      return 1;
    case ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Tag> test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse;
    case 2:
      return ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr;
    default:
      return std::nullopt;
  }
}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::MainProtocolTwoWayLocalWithErrorResult(const MainProtocolTwoWayLocalWithErrorResult& other) noexcept : MainProtocolTwoWayLocalWithErrorResult(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult& test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::operator=(const MainProtocolTwoWayLocalWithErrorResult& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::operator==(const MainProtocolTwoWayLocalWithErrorResult& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::operator!=(const MainProtocolTwoWayLocalWithErrorResult& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::WithResponse(::test_protocolpayloads::LocalStructPayload val) {
  return MainProtocolTwoWayLocalWithErrorResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::response() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::response() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult& test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::response(::test_protocolpayloads::LocalStructPayload value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::WithErr(uint32_t val) {
  return MainProtocolTwoWayLocalWithErrorResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::err() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::err() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult& test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::err(uint32_t value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::MainProtocolTwoWayAnonWithErrorResult(MainProtocolTwoWayAnonWithErrorResult&& other) noexcept : MainProtocolTwoWayAnonWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult& ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::operator=(MainProtocolTwoWayAnonWithErrorResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::MainProtocolTwoWayAnonWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::MainProtocolTwoWayAnonWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Tag test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Which() const {
  return MainProtocolTwoWayAnonWithErrorResult::IndexToTag(storage_->index()).value();
}

size_t test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Tag tag) {
  switch (tag) {
    case ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse:
      return 1;
    case ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Tag> test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse;
    case 2:
      return ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr;
    default:
      return std::nullopt;
  }
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::MainProtocolTwoWayAnonWithErrorResult(const MainProtocolTwoWayAnonWithErrorResult& other) noexcept : MainProtocolTwoWayAnonWithErrorResult(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult& test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::operator=(const MainProtocolTwoWayAnonWithErrorResult& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::operator==(const MainProtocolTwoWayAnonWithErrorResult& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::operator!=(const MainProtocolTwoWayAnonWithErrorResult& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::WithResponse(::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse val) {
  return MainProtocolTwoWayAnonWithErrorResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::response() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::response() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult& test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::response(::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::WithErr(uint32_t val) {
  return MainProtocolTwoWayAnonWithErrorResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::err() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::err() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult& test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::err(uint32_t value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::MainProtocolTwoWayImportWithErrorResult(MainProtocolTwoWayImportWithErrorResult&& other) noexcept : MainProtocolTwoWayImportWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult& ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::operator=(MainProtocolTwoWayImportWithErrorResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::MainProtocolTwoWayImportWithErrorResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::MainProtocolTwoWayImportWithErrorResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Tag test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Which() const {
  return MainProtocolTwoWayImportWithErrorResult::IndexToTag(storage_->index()).value();
}

size_t test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Tag tag) {
  switch (tag) {
    case ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Tag::kResponse:
      return 1;
    case ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Tag::kErr:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Tag> test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Tag::kResponse;
    case 2:
      return ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Tag::kErr;
    default:
      return std::nullopt;
  }
}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::MainProtocolTwoWayImportWithErrorResult(const MainProtocolTwoWayImportWithErrorResult& other) noexcept : MainProtocolTwoWayImportWithErrorResult(other.CloneStorage_()) {}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult& test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::operator=(const MainProtocolTwoWayImportWithErrorResult& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::operator==(const MainProtocolTwoWayImportWithErrorResult& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::operator!=(const MainProtocolTwoWayImportWithErrorResult& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::WithResponse(::test_protocolpayloads_imported::ImportStructPayload val) {
  return MainProtocolTwoWayImportWithErrorResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::response() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::response() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult& test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::response(::test_protocolpayloads_imported::ImportStructPayload value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::WithErr(uint32_t val) {
  return MainProtocolTwoWayImportWithErrorResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::err() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::Storage_> test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::err() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult& test_protocolpayloads::MainProtocolTwoWayImportWithErrorResult::err(uint32_t value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

#pragma clang diagnostic pop
