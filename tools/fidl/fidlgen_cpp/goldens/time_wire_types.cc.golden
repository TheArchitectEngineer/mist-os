// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.time/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_time::wire::AllInstants, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_time::wire::AllInstants* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_time::wire::AllInstants));
  } else {
    internal::WireCodingTraits<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->monotonic, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::basic_time<ZX_CLOCK_BOOT>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->boot, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->monotonic_ticks, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::basic_ticks<ZX_CLOCK_BOOT>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->boot_ticks, position + 24, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_time::wire::AllInstants, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::basic_time<ZX_CLOCK_BOOT>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::basic_ticks<ZX_CLOCK_BOOT>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_time::wire::AllInstants, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_time::wire::AllInstants, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_time::wire::AllInstants>);
static_assert(offsetof(::test_time::wire::AllInstants, monotonic) == 0);
static_assert(offsetof(::test_time::wire::AllInstants, boot) == 8);
static_assert(offsetof(::test_time::wire::AllInstants, monotonic_ticks) == 16);
static_assert(offsetof(::test_time::wire::AllInstants, boot_ticks) == 24);
static_assert(sizeof(::test_time::wire::AllInstants) == ::fidl::TypeTraits<::test_time::wire::AllInstants>::kPrimarySize);

bool ::fidl::WireTableFrame<::test_time::wire::ComplexInstants>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_time::wire::ComplexInstants>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
  if (!monotonic_.has_data()) {
    max_ordinal = 1;
  }
  if (!boot_.has_data()) {
    max_ordinal = 2;
  }
  if (!monotonic_ticks_.has_data()) {
    max_ordinal = 3;
  }
  if (!boot_ticks_.has_data()) {
    max_ordinal = 4;
  }
  return max_ordinal;
}

::test_time::wire::ComplexInstants::ComplexInstants(::fidl::AnyArena& allocator)
    : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>>(allocator)) {}

::test_time::wire::ComplexInstants::ComplexInstants(::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>>&& frame)
    : frame_ptr_(std::move(frame)) {}

void test_time::wire::ComplexInstants::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>>(allocator);
}
void test_time::wire::ComplexInstants::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_time::wire::ComplexInstants::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_time::wire::ComplexInstants::HasUnknownData() const {
  if (max_ordinal_ > 4) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>& test_time::wire::ComplexInstants::monotonic() const {
  ZX_ASSERT(has_monotonic());
  return frame_ptr_->monotonic_.get_data();
}

bool test_time::wire::ComplexInstants::has_monotonic() const {
  return max_ordinal_ >= 1 && frame_ptr_->monotonic_.has_data();
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::clear_monotonic() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->monotonic_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_monotonic(::fidl::ObjectView<::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>> elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->monotonic_.set_data(elem);
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_monotonic(std::nullptr_t) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->monotonic_.set_data(nullptr);
  return *this;
}

::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>& test_time::wire::ComplexInstants::boot() const {
  ZX_ASSERT(has_boot());
  return frame_ptr_->boot_.get_data();
}

bool test_time::wire::ComplexInstants::has_boot() const {
  return max_ordinal_ >= 2 && frame_ptr_->boot_.has_data();
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::clear_boot() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->boot_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_boot(::fidl::ObjectView<::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>> elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->boot_.set_data(elem);
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_boot(std::nullptr_t) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->boot_.set_data(nullptr);
  return *this;
}

::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>& test_time::wire::ComplexInstants::monotonic_ticks() const {
  ZX_ASSERT(has_monotonic_ticks());
  return frame_ptr_->monotonic_ticks_.get_data();
}

bool test_time::wire::ComplexInstants::has_monotonic_ticks() const {
  return max_ordinal_ >= 3 && frame_ptr_->monotonic_ticks_.has_data();
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::clear_monotonic_ticks() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->monotonic_ticks_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_monotonic_ticks(::fidl::ObjectView<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>> elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->monotonic_ticks_.set_data(elem);
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_monotonic_ticks(std::nullptr_t) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->monotonic_ticks_.set_data(nullptr);
  return *this;
}

::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>& test_time::wire::ComplexInstants::boot_ticks() const {
  ZX_ASSERT(has_boot_ticks());
  return frame_ptr_->boot_ticks_.get_data();
}

bool test_time::wire::ComplexInstants::has_boot_ticks() const {
  return max_ordinal_ >= 4 && frame_ptr_->boot_ticks_.has_data();
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::clear_boot_ticks() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->boot_ticks_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_boot_ticks(::fidl::ObjectView<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>> elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->boot_ticks_.set_data(elem);
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(4));
  return *this;
}

::test_time::wire::ComplexInstants& test_time::wire::ComplexInstants::set_boot_ticks(std::nullptr_t) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->boot_ticks_.set_data(nullptr);
  return *this;
}

::fidl::WireTableBuilder<::test_time::wire::ComplexInstants> test_time::wire::ComplexInstants::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_time::wire::ComplexInstants>(arena);
}
::fidl::WireTableExternalBuilder<::test_time::wire::ComplexInstants> test_time::wire::ComplexInstants::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_time::wire::ComplexInstants>(std::move(frame));
}

template <typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>>&& frame)
    : table_(std::move(frame)) {}

template <typename BuilderImpl>
::test_time::wire::ComplexInstants fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_time::wire::ComplexInstants t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::has_monotonic() const {
  return table_.has_monotonic();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::clear_monotonic() {
  table_.clear_monotonic();
}

template <typename BuilderImpl>
::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::monotonic() const {
  return table_.monotonic();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::monotonic(Wrapper_Ignore_Me_<::fidl::ObjectView<::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>>> elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
  table_.frame_ptr_->monotonic_.set_data(elem.value);
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
  return *static_cast<BuilderImpl*>(this);
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::has_boot() const {
  return table_.has_boot();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::clear_boot() {
  table_.clear_boot();
}

template <typename BuilderImpl>
::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::boot() const {
  return table_.boot();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::boot(Wrapper_Ignore_Me_<::fidl::ObjectView<::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>>> elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
  table_.frame_ptr_->boot_.set_data(elem.value);
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(2));
  return *static_cast<BuilderImpl*>(this);
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::has_monotonic_ticks() const {
  return table_.has_monotonic_ticks();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::clear_monotonic_ticks() {
  table_.clear_monotonic_ticks();
}

template <typename BuilderImpl>
::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::monotonic_ticks() const {
  return table_.monotonic_ticks();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::monotonic_ticks(Wrapper_Ignore_Me_<::fidl::ObjectView<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>>> elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
  table_.frame_ptr_->monotonic_ticks_.set_data(elem.value);
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(3));
  return *static_cast<BuilderImpl*>(this);
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::has_boot_ticks() const {
  return table_.has_boot_ticks();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::clear_boot_ticks() {
  table_.clear_boot_ticks();
}

template <typename BuilderImpl>
::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::boot_ticks() const {
  return table_.boot_ticks();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, BuilderImpl>::boot_ticks(Wrapper_Ignore_Me_<::fidl::ObjectView<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>>> elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
  table_.frame_ptr_->boot_ticks_.set_data(elem.value);
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(4));
  return *static_cast<BuilderImpl*>(this);
}

template class fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, ::fidl::WireTableBuilder<::test_time::wire::ComplexInstants>>;
template class fidl::internal::WireTableBaseBuilder<::test_time::wire::ComplexInstants, ::fidl::WireTableExternalBuilder<::test_time::wire::ComplexInstants>>;

::fidl::WireTableBuilder<::test_time::wire::ComplexInstants>::WireTableBuilder(::fidl::AnyArena& arena)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>>(arena)),
      arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_time::wire::ComplexInstants>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_time::wire::ComplexInstants>* frame)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_time::wire::ComplexInstants>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_time::wire::ComplexInstants, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_time::wire::ComplexInstants* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {
    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
      case 1:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::kInlineSize;
        break;
      case 2:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
      case 3:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 1:
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>();
        break;
      case 2:
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3:
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_time::wire::ComplexInstants, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {
    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
      case 1:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::kInlineSize;
        break;
      case 2:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
      case 3:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch (i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::Array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 1:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::basic_time<ZX_CLOCK_BOOT>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>();
        break;
      case 2:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::Array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_time::wire::ComplexInstants, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_time::wire::ComplexInstants, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_time::wire::ComplexInstants>);

#pragma clang diagnostic pop
