// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <fidl/test.enum/cpp/common_types.h>

#if defined(__cpp_lib_format) && __cplusplus >= 202002L && defined(__Fuchsia__)
#include <format>

template <>
struct std::formatter<::test_enum::MyStrictEnum> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_enum::MyStrictEnum& value, std::format_context& ctx) const {
    std::string_view output;
    switch (value) {
      case ::test_enum::MyStrictEnum::kFoo:
        output = "kFoo";
        break;
      case ::test_enum::MyStrictEnum::kBar:
        output = "kBar";
        break;
      default:
        output = "UNKNOWN";
    }
    return std::format_to(ctx.out(), "test_enum::MyStrictEnum::{}", output);
  }
};
template <>
struct std::formatter<::test_enum::MyFlexibleEnum> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_enum::MyFlexibleEnum& value, std::format_context& ctx) const {
    std::string_view output;
    switch (value) {
      case ::test_enum::MyFlexibleEnum::kFoo:
        output = "kFoo";
        break;
      case ::test_enum::MyFlexibleEnum::kBar:
        output = "kBar";
        break;
      default:
        output = "UNKNOWN";
    }
    return std::format_to(ctx.out(), "test_enum::MyFlexibleEnum::{}", output);
  }
};
template <>
struct std::formatter<::test_enum::MyFlexibleEnumWithCustomUnknown> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_enum::MyFlexibleEnumWithCustomUnknown& value, std::format_context& ctx) const {
    std::string_view output;
    switch (value) {
      case ::test_enum::MyFlexibleEnumWithCustomUnknown::kFoo:
        output = "kFoo";
        break;
      case ::test_enum::MyFlexibleEnumWithCustomUnknown::kBar:
        output = "kBar";
        break;
      case ::test_enum::MyFlexibleEnumWithCustomUnknown::kCustomUnknown:
        output = "kCustomUnknown";
        break;
      default:
        output = "UNKNOWN";
    }
    return std::format_to(ctx.out(), "test_enum::MyFlexibleEnumWithCustomUnknown::{}", output);
  }
};
template <>
struct std::formatter<::test_enum::MyEmptyFlexibleEnum> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_enum::MyEmptyFlexibleEnum& value, std::format_context& ctx) const {
    std::string_view output;
    switch (value) {
      default:
        output = "UNKNOWN";
    }
    return std::format_to(ctx.out(), "test_enum::MyEmptyFlexibleEnum::{}", output);
  }
};

#endif
