// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <lib/fidl/cpp/wire/array.h>
#include <lib/fidl/cpp/wire/envelope.h>
#include <lib/fidl/cpp/wire/internal/framework_err.h>
#include <lib/fidl/cpp/wire/message.h>
#include <lib/fidl/cpp/wire/message_storage.h>
#include <lib/fidl/cpp/wire/object_view.h>
#include <lib/fidl/cpp/wire/string_view.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/fidl/cpp/wire/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.union/cpp/common_types.h>
#include <fidl/test.union/cpp/markers.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_union {

namespace wire {

struct Pizza;

struct Pasta;

struct NullableUnionStruct;

struct Empty;

struct TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse;

struct TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse;

struct StructWithNullableUnion;

struct UnionSandwich;

class PizzaOrPasta;

class ExplicitPizzaOrPasta;

class FlexiblePizzaOrPasta;

class StrictPizzaOrPasta;

class Union;

class FlexibleUnion;

class StrictUnion;

class FieldCollision;

class ExplicitUnion;

class ReverseOrdinalUnion;

class FlexibleFoo;

class StrictFoo;

class ExplicitFoo;

class ExplicitStrictFoo;

class OlderSimpleUnion;

class NewerSimpleUnion;

class StrictSimpleUnion;

class UnionContainingEmptyStruct;

class StrictBoundedUnion;

class ExplicitFlexibleUnion;

class UnionWithAttributes;

class EmptyFlexibleUnion;

struct Empty {
  uint8_t __reserved = {};
};

class PizzaOrPasta {
 public:
  PizzaOrPasta();

  PizzaOrPasta(const PizzaOrPasta&) = default;
  PizzaOrPasta& operator=(const PizzaOrPasta&) = default;
  PizzaOrPasta(PizzaOrPasta&&) = default;
  PizzaOrPasta& operator=(PizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const;

  bool is_pizza() const;

  static PizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val);

  template <typename... Args>
  static PizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pizza& pizza();

  const ::test_union::wire::Pizza& pizza() const;

  bool is_pasta() const;

  static PizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val);

  template <typename... Args>
  static PizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pasta& pasta();

  const ::test_union::wire::Pasta& pasta() const;

  ::test_union::wire::PizzaOrPasta::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::PizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitPizzaOrPasta {
 public:
  ExplicitPizzaOrPasta();

  ExplicitPizzaOrPasta(const ExplicitPizzaOrPasta&) = default;
  ExplicitPizzaOrPasta& operator=(const ExplicitPizzaOrPasta&) = default;
  ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&&) = default;
  ExplicitPizzaOrPasta& operator=(ExplicitPizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  bool has_invalid_tag() const;

  bool is_pizza() const;

  static ExplicitPizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val);

  template <typename... Args>
  static ExplicitPizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pizza& pizza();

  const ::test_union::wire::Pizza& pizza() const;

  bool is_pasta() const;

  static ExplicitPizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val);

  template <typename... Args>
  static ExplicitPizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pasta& pasta();

  const ::test_union::wire::Pasta& pasta() const;

  ::test_union::wire::ExplicitPizzaOrPasta::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitPizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FlexiblePizzaOrPasta {
 public:
  FlexiblePizzaOrPasta();

  FlexiblePizzaOrPasta(const FlexiblePizzaOrPasta&) = default;
  FlexiblePizzaOrPasta& operator=(const FlexiblePizzaOrPasta&) = default;
  FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&&) = default;
  FlexiblePizzaOrPasta& operator=(FlexiblePizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::FlexiblePizzaOrPasta::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_pizza() const;

  static FlexiblePizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val);

  template <typename... Args>
  static FlexiblePizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pizza& pizza();

  const ::test_union::wire::Pizza& pizza() const;

  bool is_pasta() const;

  static FlexiblePizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val);

  template <typename... Args>
  static FlexiblePizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pasta& pasta();

  const ::test_union::wire::Pasta& pasta() const;

  ::test_union::wire::FlexiblePizzaOrPasta::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FlexiblePizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictPizzaOrPasta {
 public:
  StrictPizzaOrPasta();

  StrictPizzaOrPasta(const StrictPizzaOrPasta&) = default;
  StrictPizzaOrPasta& operator=(const StrictPizzaOrPasta&) = default;
  StrictPizzaOrPasta(StrictPizzaOrPasta&&) = default;
  StrictPizzaOrPasta& operator=(StrictPizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const;

  bool is_pizza() const;

  static StrictPizzaOrPasta WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val);

  template <typename... Args>
  static StrictPizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPizza(::fidl::ObjectView<::test_union::wire::Pizza>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pizza& pizza();

  const ::test_union::wire::Pizza& pizza() const;

  bool is_pasta() const;

  static StrictPizzaOrPasta WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val);

  template <typename... Args>
  static StrictPizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    return WithPasta(::fidl::ObjectView<::test_union::wire::Pasta>(allocator,
                                                                   std::forward<Args>(args)...));
  }

  ::test_union::wire::Pasta& pasta();

  const ::test_union::wire::Pasta& pasta() const;

  ::test_union::wire::StrictPizzaOrPasta::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictPizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class Union {
 public:
  Union();

  Union(const Union&) = default;
  Union& operator=(const Union&) = default;
  Union(Union&&) = default;
  Union& operator=(Union&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const;

  bool is_primitive() const;

  static Union WithPrimitive(int32_t val);

  int32_t& primitive();

  const int32_t& primitive() const;

  bool is_string_needs_constructor() const;

  static Union WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static Union WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                                             std::forward<Args>(args)...));
  }

  ::fidl::StringView& string_needs_constructor();

  const ::fidl::StringView& string_needs_constructor() const;

  bool is_vector_string_also_needs_constructor() const;

  static Union WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val);

  template <typename... Args>
  static Union WithVectorStringAlsoNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                                                                                           std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor();

  const ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() const;

  ::test_union::wire::Union::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::Union::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FlexibleUnion {
 public:
  FlexibleUnion();

  FlexibleUnion(const FlexibleUnion&) = default;
  FlexibleUnion& operator=(const FlexibleUnion&) = default;
  FlexibleUnion(FlexibleUnion&&) = default;
  FlexibleUnion& operator=(FlexibleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::FlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_primitive() const;

  static FlexibleUnion WithPrimitive(int32_t val);

  int32_t& primitive();

  const int32_t& primitive() const;

  bool is_string_needs_constructor() const;

  static FlexibleUnion WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static FlexibleUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                                             std::forward<Args>(args)...));
  }

  ::fidl::StringView& string_needs_constructor();

  const ::fidl::StringView& string_needs_constructor() const;

  bool is_vector_string_also_needs_constructor() const;

  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val);

  template <typename... Args>
  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                                                                                           std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor();

  const ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() const;

  ::test_union::wire::FlexibleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FlexibleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictUnion {
 public:
  StrictUnion();

  StrictUnion(const StrictUnion&) = default;
  StrictUnion& operator=(const StrictUnion&) = default;
  StrictUnion(StrictUnion&&) = default;
  StrictUnion& operator=(StrictUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const;

  bool is_primitive() const;

  static StrictUnion WithPrimitive(int32_t val);

  int32_t& primitive();

  const int32_t& primitive() const;

  bool is_string_needs_constructor() const;

  static StrictUnion WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static StrictUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                                             std::forward<Args>(args)...));
  }

  ::fidl::StringView& string_needs_constructor();

  const ::fidl::StringView& string_needs_constructor() const;

  bool is_vector_string_also_needs_constructor() const;

  static StrictUnion WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val);

  template <typename... Args>
  static StrictUnion WithVectorStringAlsoNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                                                                                           std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor();

  const ::fidl::VectorView<::fidl::StringView>& vector_string_also_needs_constructor() const;

  ::test_union::wire::StrictUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FieldCollision {
 public:
  FieldCollision();

  FieldCollision(const FieldCollision&) = default;
  FieldCollision& operator=(const FieldCollision&) = default;
  FieldCollision(FieldCollision&&) = default;
  FieldCollision& operator=(FieldCollision&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  bool has_invalid_tag() const;

  bool is_field_collision_tag() const;

  static FieldCollision WithFieldCollisionTag(int32_t val);

  int32_t& field_collision_tag();

  const int32_t& field_collision_tag() const;

  ::test_union::wire::FieldCollision::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFieldCollisionTag = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FieldCollision::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitUnion {
 public:
  ExplicitUnion();

  ExplicitUnion(const ExplicitUnion&) = default;
  ExplicitUnion& operator=(const ExplicitUnion&) = default;
  ExplicitUnion(ExplicitUnion&&) = default;
  ExplicitUnion& operator=(ExplicitUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const;

  bool is_primitive() const;

  static ExplicitUnion WithPrimitive(int32_t val);

  int32_t& primitive();

  const int32_t& primitive() const;

  bool is_string_needs_constructor() const;

  static ExplicitUnion WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static ExplicitUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator, Args&&... args) {
    return WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                                             std::forward<Args>(args)...));
  }

  ::fidl::StringView& string_needs_constructor();

  const ::fidl::StringView& string_needs_constructor() const;

  ::test_union::wire::ExplicitUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ReverseOrdinalUnion {
 public:
  ReverseOrdinalUnion();

  ReverseOrdinalUnion(const ReverseOrdinalUnion&) = default;
  ReverseOrdinalUnion& operator=(const ReverseOrdinalUnion&) = default;
  ReverseOrdinalUnion(ReverseOrdinalUnion&&) = default;
  ReverseOrdinalUnion& operator=(ReverseOrdinalUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kFirst = 1,   // 0x1
    kSecond = 2,  // 0x2
  };

  bool has_invalid_tag() const;

  bool is_first() const;

  static ReverseOrdinalUnion WithFirst(uint32_t val);

  uint32_t& first();

  const uint32_t& first() const;

  bool is_second() const;

  static ReverseOrdinalUnion WithSecond(uint32_t val);

  uint32_t& second();

  const uint32_t& second() const;

  ::test_union::wire::ReverseOrdinalUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFirst = 1,   // 0x1
    kSecond = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ReverseOrdinalUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FlexibleFoo {
 public:
  FlexibleFoo();

  FlexibleFoo(const FlexibleFoo&) = default;
  FlexibleFoo& operator=(const FlexibleFoo&) = default;
  FlexibleFoo(FlexibleFoo&&) = default;
  FlexibleFoo& operator=(FlexibleFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::FlexibleFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_s() const;

  static FlexibleFoo WithS(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static FlexibleFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                        std::forward<Args>(args)...));
  }

  ::fidl::StringView& s();

  const ::fidl::StringView& s() const;

  bool is_i() const;

  static FlexibleFoo WithI(int32_t val);

  int32_t& i();

  const int32_t& i() const;

  ::test_union::wire::FlexibleFoo::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::FlexibleFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictFoo {
 public:
  StrictFoo();

  StrictFoo(const StrictFoo&) = default;
  StrictFoo& operator=(const StrictFoo&) = default;
  StrictFoo(StrictFoo&&) = default;
  StrictFoo& operator=(StrictFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  bool has_invalid_tag() const;

  bool is_s() const;

  static StrictFoo WithS(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static StrictFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                        std::forward<Args>(args)...));
  }

  ::fidl::StringView& s();

  const ::fidl::StringView& s() const;

  bool is_i() const;

  static StrictFoo WithI(int32_t val);

  int32_t& i();

  const int32_t& i() const;

  ::test_union::wire::StrictFoo::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitFoo {
 public:
  ExplicitFoo();

  ExplicitFoo(const ExplicitFoo&) = default;
  ExplicitFoo& operator=(const ExplicitFoo&) = default;
  ExplicitFoo(ExplicitFoo&&) = default;
  ExplicitFoo& operator=(ExplicitFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::ExplicitFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_i() const;

  static ExplicitFoo WithI(int32_t val);

  int32_t& i();

  const int32_t& i() const;

  bool is_s() const;

  static ExplicitFoo WithS(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static ExplicitFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                        std::forward<Args>(args)...));
  }

  ::fidl::StringView& s();

  const ::fidl::StringView& s() const;

  ::test_union::wire::ExplicitFoo::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kS = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitStrictFoo {
 public:
  ExplicitStrictFoo();

  ExplicitStrictFoo(const ExplicitStrictFoo&) = default;
  ExplicitStrictFoo& operator=(const ExplicitStrictFoo&) = default;
  ExplicitStrictFoo(ExplicitStrictFoo&&) = default;
  ExplicitStrictFoo& operator=(ExplicitStrictFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 2,  // 0x2
    kS = 3,  // 0x3
  };

  bool has_invalid_tag() const;

  bool is_i() const;

  static ExplicitStrictFoo WithI(int32_t val);

  int32_t& i();

  const int32_t& i() const;

  bool is_s() const;

  static ExplicitStrictFoo WithS(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static ExplicitStrictFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                        std::forward<Args>(args)...));
  }

  ::fidl::StringView& s();

  const ::fidl::StringView& s() const;

  ::test_union::wire::ExplicitStrictFoo::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 2,  // 0x2
    kS = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitStrictFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class OlderSimpleUnion {
 public:
  OlderSimpleUnion();

  OlderSimpleUnion(const OlderSimpleUnion&) = default;
  OlderSimpleUnion& operator=(const OlderSimpleUnion&) = default;
  OlderSimpleUnion(OlderSimpleUnion&&) = default;
  OlderSimpleUnion& operator=(OlderSimpleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::OlderSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_i() const;

  static OlderSimpleUnion WithI(::fidl::ObjectView<int64_t> val);

  template <typename... Args>
  static OlderSimpleUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    return WithI(::fidl::ObjectView<int64_t>(allocator,
                                             std::forward<Args>(args)...));
  }

  int64_t& i();

  const int64_t& i() const;

  bool is_f() const;

  static OlderSimpleUnion WithF(float val);

  float& f();

  const float& f() const;

  ::test_union::wire::OlderSimpleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::OlderSimpleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class NewerSimpleUnion {
 public:
  NewerSimpleUnion();

  NewerSimpleUnion(const NewerSimpleUnion&) = default;
  NewerSimpleUnion& operator=(const NewerSimpleUnion&) = default;
  NewerSimpleUnion(NewerSimpleUnion&&) = default;
  NewerSimpleUnion& operator=(NewerSimpleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::NewerSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_i() const;

  static NewerSimpleUnion WithI(::fidl::ObjectView<int64_t> val);

  template <typename... Args>
  static NewerSimpleUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    return WithI(::fidl::ObjectView<int64_t>(allocator,
                                             std::forward<Args>(args)...));
  }

  int64_t& i();

  const int64_t& i() const;

  bool is_s() const;

  static NewerSimpleUnion WithS(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static NewerSimpleUnion WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                        std::forward<Args>(args)...));
  }

  ::fidl::StringView& s();

  const ::fidl::StringView& s() const;

  bool is_v() const;

  static NewerSimpleUnion WithV(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val);

  template <typename... Args>
  static NewerSimpleUnion WithV(::fidl::AnyArena& allocator, Args&&... args) {
    return WithV(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(allocator,
                                                                            std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>& v();

  const ::fidl::VectorView<::fidl::StringView>& v() const;

  ::test_union::wire::NewerSimpleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::NewerSimpleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictSimpleUnion {
 public:
  StrictSimpleUnion();

  StrictSimpleUnion(const StrictSimpleUnion&) = default;
  StrictSimpleUnion& operator=(const StrictSimpleUnion&) = default;
  StrictSimpleUnion(StrictSimpleUnion&&) = default;
  StrictSimpleUnion& operator=(StrictSimpleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  bool has_invalid_tag() const;

  bool is_i() const;

  static StrictSimpleUnion WithI(int32_t val);

  int32_t& i();

  const int32_t& i() const;

  bool is_f() const;

  static StrictSimpleUnion WithF(float val);

  float& f();

  const float& f() const;

  bool is_s() const;

  static StrictSimpleUnion WithS(::fidl::ObjectView<::fidl::StringView> val);

  template <typename... Args>
  static StrictSimpleUnion WithS(::fidl::AnyArena& allocator, Args&&... args) {
    return WithS(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                        std::forward<Args>(args)...));
  }

  ::fidl::StringView& s();

  const ::fidl::StringView& s() const;

  ::test_union::wire::StrictSimpleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictSimpleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnionContainingEmptyStruct {
 public:
  UnionContainingEmptyStruct();

  UnionContainingEmptyStruct(const UnionContainingEmptyStruct&) = default;
  UnionContainingEmptyStruct& operator=(const UnionContainingEmptyStruct&) = default;
  UnionContainingEmptyStruct(UnionContainingEmptyStruct&&) = default;
  UnionContainingEmptyStruct& operator=(UnionContainingEmptyStruct&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kEmpty = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::UnionContainingEmptyStruct::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_empty() const;

  static UnionContainingEmptyStruct WithEmpty(::test_union::wire::Empty val);

  ::test_union::wire::Empty& empty();

  const ::test_union::wire::Empty& empty() const;

  ::test_union::wire::UnionContainingEmptyStruct::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kEmpty = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::UnionContainingEmptyStruct::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictBoundedUnion {
 public:
  StrictBoundedUnion();

  StrictBoundedUnion(const StrictBoundedUnion&) = default;
  StrictBoundedUnion& operator=(const StrictBoundedUnion&) = default;
  StrictBoundedUnion(StrictBoundedUnion&&) = default;
  StrictBoundedUnion& operator=(StrictBoundedUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
  };

  bool has_invalid_tag() const;

  bool is_v() const;

  static StrictBoundedUnion WithV(::fidl::ObjectView<::fidl::VectorView<uint8_t>> val);

  template <typename... Args>
  static StrictBoundedUnion WithV(::fidl::AnyArena& allocator, Args&&... args) {
    return WithV(::fidl::ObjectView<::fidl::VectorView<uint8_t>>(allocator,
                                                                 std::forward<Args>(args)...));
  }

  ::fidl::VectorView<uint8_t>& v();

  const ::fidl::VectorView<uint8_t>& v() const;

  ::test_union::wire::StrictBoundedUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::StrictBoundedUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitFlexibleUnion {
 public:
  ExplicitFlexibleUnion();

  ExplicitFlexibleUnion(const ExplicitFlexibleUnion&) = default;
  ExplicitFlexibleUnion& operator=(const ExplicitFlexibleUnion&) = default;
  ExplicitFlexibleUnion(ExplicitFlexibleUnion&&) = default;
  ExplicitFlexibleUnion& operator=(ExplicitFlexibleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 4,  // 0x4
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::ExplicitFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_i() const;

  static ExplicitFlexibleUnion WithI(::fidl::ObjectView<int64_t> val);

  template <typename... Args>
  static ExplicitFlexibleUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    return WithI(::fidl::ObjectView<int64_t>(allocator,
                                             std::forward<Args>(args)...));
  }

  int64_t& i();

  const int64_t& i() const;

  bool is_f() const;

  static ExplicitFlexibleUnion WithF(float val);

  float& f();

  const float& f() const;

  ::test_union::wire::ExplicitFlexibleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 4,  // 0x4
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::ExplicitFlexibleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnionWithAttributes {
 public:
  UnionWithAttributes();

  UnionWithAttributes(const UnionWithAttributes&) = default;
  UnionWithAttributes& operator=(const UnionWithAttributes&) = default;
  UnionWithAttributes(UnionWithAttributes&&) = default;
  UnionWithAttributes& operator=(UnionWithAttributes&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kX = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::UnionWithAttributes::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_x() const;

  static UnionWithAttributes WithX(::fidl::ObjectView<int64_t> val);

  template <typename... Args>
  static UnionWithAttributes WithX(::fidl::AnyArena& allocator, Args&&... args) {
    return WithX(::fidl::ObjectView<int64_t>(allocator,
                                             std::forward<Args>(args)...));
  }

  int64_t& x();

  const int64_t& x() const;

  ::test_union::wire::UnionWithAttributes::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kX = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::UnionWithAttributes::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class EmptyFlexibleUnion {
 public:
  EmptyFlexibleUnion();

  EmptyFlexibleUnion(const EmptyFlexibleUnion&) = default;
  EmptyFlexibleUnion& operator=(const EmptyFlexibleUnion&) = default;
  EmptyFlexibleUnion(EmptyFlexibleUnion&&) = default;
  EmptyFlexibleUnion& operator=(EmptyFlexibleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_union::wire::EmptyFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  ::test_union::wire::EmptyFlexibleUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_union::wire::EmptyFlexibleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

struct Pizza {
  ::fidl::VectorView<::fidl::StringView> toppings = {};
};

struct Pasta {
  ::fidl::StringView sauce = {};
};

struct NullableUnionStruct {
  ::fidl::WireOptional<::test_union::wire::Union> the_union = {};
};

struct TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
  ::test_union::wire::StrictBoundedUnion xu = {};
};

struct TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
  ::test_union::wire::OlderSimpleUnion xu = {};
};

struct StructWithNullableUnion {
  ::fidl::WireOptional<::test_union::wire::OlderSimpleUnion> x1 = {};
};

struct UnionSandwich {
  uint32_t a = {};

  ::test_union::wire::ExplicitFlexibleUnion u = {};

  uint32_t b = {};
};

}  // namespace wire
}  // namespace test_union
namespace fidl {

template <>
struct TypeTraits<::test_union::wire::Pizza> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::Pizza> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::Pizza> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::Pizza> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false, 16>, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::Pizza* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::Pasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::Pasta> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::Pasta> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::Pasta> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 16>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::Pasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::NullableUnionStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::NullableUnionStruct> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::NullableUnionStruct> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::NullableUnionStruct> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_union::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::NullableUnionStruct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::Empty> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_union::wire::Empty> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::Empty> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::Empty> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::Empty* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_union::wire::StrictBoundedUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_union::wire::OlderSimpleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::StructWithNullableUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StructWithNullableUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::StructWithNullableUnion> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::StructWithNullableUnion> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_union::wire::OlderSimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_union::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::StructWithNullableUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::UnionSandwich> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 32;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::UnionSandwich> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::UnionSandwich> : public std::true_type {};
template <>
struct IsStruct<::test_union::wire::UnionSandwich> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 32;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_union::wire::ExplicitFlexibleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_union::wire::UnionSandwich* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_union::wire::PizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::PizzaOrPasta> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::PizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::PizzaOrPasta> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::PizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::ExplicitPizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitPizzaOrPasta> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::ExplicitPizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitPizzaOrPasta> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitPizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::FlexiblePizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FlexiblePizzaOrPasta> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::FlexiblePizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FlexiblePizzaOrPasta> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FlexiblePizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::StrictPizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictPizzaOrPasta> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::StrictPizzaOrPasta> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictPizzaOrPasta> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictPizzaOrPasta* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::Union> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::Union> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::Union> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::Union> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::Union* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::FlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FlexibleUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::FlexibleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FlexibleUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FlexibleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::StrictUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::StrictUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::FieldCollision> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FieldCollision> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::FieldCollision> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FieldCollision> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FieldCollision* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::ExplicitUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::ExplicitUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::ReverseOrdinalUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ReverseOrdinalUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::ReverseOrdinalUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ReverseOrdinalUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ReverseOrdinalUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::FlexibleFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::FlexibleFoo> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::FlexibleFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::FlexibleFoo> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::FlexibleFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::StrictFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictFoo> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::StrictFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictFoo> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::ExplicitFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitFoo> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::ExplicitFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitFoo> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::ExplicitStrictFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitStrictFoo> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::ExplicitStrictFoo> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitStrictFoo> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitStrictFoo* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::OlderSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::OlderSimpleUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::OlderSimpleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::OlderSimpleUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::OlderSimpleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::NewerSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::NewerSimpleUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::NewerSimpleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::NewerSimpleUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::NewerSimpleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::StrictSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictSimpleUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::StrictSimpleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictSimpleUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictSimpleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::UnionContainingEmptyStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::UnionContainingEmptyStruct> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::UnionContainingEmptyStruct> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::UnionContainingEmptyStruct> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::UnionContainingEmptyStruct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::StrictBoundedUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::StrictBoundedUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::StrictBoundedUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::StrictBoundedUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::StrictBoundedUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::ExplicitFlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::ExplicitFlexibleUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::ExplicitFlexibleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::ExplicitFlexibleUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::ExplicitFlexibleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::UnionWithAttributes> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_union::wire::UnionWithAttributes> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::UnionWithAttributes> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::UnionWithAttributes> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::UnionWithAttributes* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_union::wire::EmptyFlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_union::wire::EmptyFlexibleUnion> : public std::true_type {};
template <>
struct IsWire<::test_union::wire::EmptyFlexibleUnion> : public std::true_type {};
template <>
struct IsUnion<::test_union::wire::EmptyFlexibleUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_union::wire::EmptyFlexibleUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#pragma clang diagnostic pop

}  // namespace fidl
