// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.byteandbytes/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

::test_byteandbytes::ByteAndBytes::ByteAndBytes(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_byteandbytes::ByteAndBytes::ByteAndBytes(uint8_t single_byte) noexcept
    : storage_({.single_byte = std::move(single_byte)}) {}

::test_byteandbytes::ByteAndBytes::ByteAndBytes(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ByteAndBytes(Storage_{
                                                                                                                  .single_byte = {},
                                                                                                              }) {}
::test_byteandbytes::ByteAndBytes::ByteAndBytes(const ::test_byteandbytes::ByteAndBytes& other) noexcept : ::test_byteandbytes::ByteAndBytes(other.CloneStorage_()) {}

::test_byteandbytes::ByteAndBytes& test_byteandbytes::ByteAndBytes::operator=(const ::test_byteandbytes::ByteAndBytes& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_byteandbytes::ByteAndBytes::operator==(const ByteAndBytes& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_byteandbytes::ByteAndBytes, 1>::Equal(this, &other);
}

bool test_byteandbytes::ByteAndBytes::operator!=(const ByteAndBytes& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_byteandbytes::ByteAndBytes, 1>::Equal(this, &other);
}

::test_byteandbytes::ByteAndBytes::Storage_ test_byteandbytes::ByteAndBytes::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.single_byte)};
}
uint8_t
test_byteandbytes::ByteAndBytes::single_byte() const {
  return storage_.single_byte;
}

uint8_t& ::test_byteandbytes::ByteAndBytes::single_byte() {
  return storage_.single_byte;
}

::test_byteandbytes::ByteAndBytes& ::test_byteandbytes::ByteAndBytes::single_byte(uint8_t value) {
  storage_.single_byte = std::move(value);
  return *this;
}

#pragma clang diagnostic pop
