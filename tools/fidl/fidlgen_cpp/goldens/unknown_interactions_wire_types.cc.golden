// WARNING: This file is machine generated by fidlgen.

  // fidl_experiment = output_index_json

  #include <fidl/test.unknowninteractions/cpp/wire_types.h>

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->some_field, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, some_field) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse) == ::fidl::TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>::kPrimarySize);

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::UnknownInteractionsProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolStrictTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsProtocolStrictTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::UnknownInteractionsProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolStrictTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse val) {
      UnknownInteractionsProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolStrictTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse val) {
      UnknownInteractionsProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolStrictTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsProtocolStrictTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::UnknownInteractionsProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolStrictTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> val) {
      UnknownInteractionsProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::UnknownInteractionsProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolStrictTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolStrictTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> val) {
      UnknownInteractionsProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::UnknownInteractionsProtocolFlexibleTwoWayResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse val) {
      UnknownInteractionsProtocolFlexibleTwoWayResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayFieldsResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse val) {
      UnknownInteractionsProtocolFlexibleTwoWayFieldsResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayFieldsResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsProtocolFlexibleTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::UnknownInteractionsProtocolFlexibleTwoWayUnionResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayUnionResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> val) {
      UnknownInteractionsProtocolFlexibleTwoWayUnionResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayUnionResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::UnknownInteractionsProtocolFlexibleTwoWayTableResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayTableResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayTableResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayTableResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> val) {
      UnknownInteractionsProtocolFlexibleTwoWayTableResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayTableResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::UnknownInteractionsProtocolFlexibleTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse val) {
      UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse val) {
      UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> val) {
      UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> val) {
      UnknownInteractionsProtocolFlexibleTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsProtocolFlexibleTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsProtocolFlexibleTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::UnknownInteractionsProtocolStrictEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolStrictEventUnionRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolStrictEventUnionRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolStrictEventUnionRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::WithSomeField(int32_t val) {
      UnknownInteractionsProtocolStrictEventUnionRequest result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::UnknownInteractionsProtocolFlexibleEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsProtocolFlexibleEventUnionRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleEventUnionRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsProtocolFlexibleEventUnionRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::WithSomeField(int32_t val) {
      UnknownInteractionsProtocolFlexibleEventUnionRequest result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::UnknownInteractionsAjarProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolStrictTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse val) {
      UnknownInteractionsAjarProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse val) {
      UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> val) {
      UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> val) {
      UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::UnknownInteractionsAjarProtocolStrictEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolStrictEventUnionRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictEventUnionRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolStrictEventUnionRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::WithSomeField(int32_t val) {
      UnknownInteractionsAjarProtocolStrictEventUnionRequest result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::WithSomeField(int32_t val) {
      UnknownInteractionsAjarProtocolFlexibleEventUnionRequest result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::UnknownInteractionsClosedProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedProtocolStrictTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse val) {
      UnknownInteractionsClosedProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse val) {
      UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> val) {
      UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> val) {
      UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::UnknownInteractionsClosedProtocolStrictEventUnionRequest() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedProtocolStrictEventUnionRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictEventUnionRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedProtocolStrictEventUnionRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::WithSomeField(int32_t val) {
      UnknownInteractionsClosedProtocolStrictEventUnionRequest result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::UnknownInteractionsDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolStrictTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse val) {
      UnknownInteractionsDriverProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse val) {
      UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> val) {
      UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> val) {
      UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::UnknownInteractionsDriverProtocolFlexibleTwoWayResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::is_framework_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::WithFrameworkErr(::fidl::internal::FrameworkErr val) {
      UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr;
      result.envelope_.As<::fidl::internal::FrameworkErr>().set_data(std::move(val));
      return result;
    }

  ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::framework_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }
  const ::fidl::internal::FrameworkErr& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::framework_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal::kFrameworkErr);
    return envelope_.As<::fidl::internal::FrameworkErr>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag::kFrameworkErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::FrameworkErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::WithSomeField(int32_t val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Which() const -> ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField:
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag>(ordinal_);
  default:
    return ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::is_some_field() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::WithSomeField(int32_t val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::some_field() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::some_field() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal::kSomeField);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::kSomeField:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid), envelope_{} {}
::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag>(ordinal_);
}

void ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult) == sizeof(fidl_union_t));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::Invalid; }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse;
      result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>().set_data(std::move(val));
      return result;
    }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>().get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr; }
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::WithErr(int32_t val) {
      UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult result;
      result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::UnknownInteractionsProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::UnknownInteractionsProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::UnknownInteractionsProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::UnknownInteractionsProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::UnknownInteractionsProtocolFlexibleTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::UnknownInteractionsProtocolFlexibleTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::UnknownInteractionsProtocolStrictEventTableRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::UnknownInteractionsProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::UnknownInteractionsProtocolFlexibleEventTableRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::UnknownInteractionsProtocolFlexibleEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::UnknownInteractionsAjarProtocolStrictEventTableRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::UnknownInteractionsAjarProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::UnknownInteractionsAjarProtocolFlexibleEventTableRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::UnknownInteractionsAjarProtocolFlexibleEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::UnknownInteractionsClosedProtocolStrictEventTableRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::UnknownInteractionsClosedProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest& test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>);

bool ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!some_field_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>(allocator)) {}

::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>(allocator);
}
void test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  int32_t& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::some_field() const {
    ZX_ASSERT(has_some_field());
    return frame_ptr_->some_field_.get_data();
  }

  bool test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::has_some_field() const {
    return max_ordinal_ >= 1 && frame_ptr_->some_field_.has_data();
  }

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::clear_some_field() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->some_field_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::set_some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->some_field_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::has_some_field() const {
    return table_.has_some_field();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::clear_some_field() {
    table_.clear_some_field();
  }

  template<typename BuilderImpl>
  int32_t& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field() const {
    return table_.some_field();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl>::some_field(int32_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->some_field_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;

::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>);

  #pragma clang diagnostic pop

