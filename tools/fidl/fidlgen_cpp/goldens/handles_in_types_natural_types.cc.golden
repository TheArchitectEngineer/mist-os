// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.handlesintypes/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

void fidl::internal::NaturalCodingTraits<::test_handlesintypes::ObjType, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_handlesintypes::ObjType* value, size_t offset, size_t recursion_depth) {
  switch (*value) {
    case ::test_handlesintypes::ObjType::kNone:
    case ::test_handlesintypes::ObjType::kVmo:
      break;
    default:
      encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
      return;
  }
  *encoder->template GetPtr<::test_handlesintypes::ObjType>(offset) = *value;
}

void fidl::internal::NaturalCodingTraits<::test_handlesintypes::ObjType, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_handlesintypes::ObjType* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_handlesintypes::ObjType>(offset);
  switch (*value) {
    case ::test_handlesintypes::ObjType::kNone:
    case ::test_handlesintypes::ObjType::kVmo:
      break;
    default:
      decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
      return;
  }
}

#ifdef __Fuchsia__

::test_handlesintypes::HandlesInTypes::HandlesInTypes(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_handlesintypes::HandlesInTypes::HandlesInTypes(::zx::vmo normal_handle, ::std::vector<::zx::vmo> handle_in_vec, ::std::array<::zx::vmo, 5> handle_in_array, ::std::vector<::std::array<::zx::vmo, 5>> handle_in_mixed_vec_array, ::test_handlesintypes::TableWithHandle table_with_handle, ::test_handlesintypes::UnionWithHandle union_with_handle) noexcept
    : storage_({.normal_handle = std::move(normal_handle),
                .handle_in_vec = std::move(handle_in_vec),
                .handle_in_array = std::move(handle_in_array),
                .handle_in_mixed_vec_array = std::move(handle_in_mixed_vec_array),
                .table_with_handle = std::move(table_with_handle),
                .union_with_handle = std::move(union_with_handle)}) {}

::test_handlesintypes::HandlesInTypes::HandlesInTypes(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : HandlesInTypes(Storage_{
                                                                                                                        .normal_handle = {},
                                                                                                                        .handle_in_vec = {},
                                                                                                                        .handle_in_array = ::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::zx::vmo, 5>>::Make(),
                                                                                                                        .handle_in_mixed_vec_array = {},
                                                                                                                        .table_with_handle = ::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
                                                                                                                        .union_with_handle = ::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
                                                                                                                    }) {}
const ::zx::vmo&
test_handlesintypes::HandlesInTypes::normal_handle() const {
  return storage_.normal_handle;
}

::zx::vmo& ::test_handlesintypes::HandlesInTypes::normal_handle() {
  return storage_.normal_handle;
}

::test_handlesintypes::HandlesInTypes& ::test_handlesintypes::HandlesInTypes::normal_handle(::zx::vmo value) {
  storage_.normal_handle = std::move(value);
  return *this;
}
const ::std::vector<::zx::vmo>&
test_handlesintypes::HandlesInTypes::handle_in_vec() const {
  return storage_.handle_in_vec;
}

::std::vector<::zx::vmo>& ::test_handlesintypes::HandlesInTypes::handle_in_vec() {
  return storage_.handle_in_vec;
}

::test_handlesintypes::HandlesInTypes& ::test_handlesintypes::HandlesInTypes::handle_in_vec(::std::vector<::zx::vmo> value) {
  storage_.handle_in_vec = std::move(value);
  return *this;
}
const ::std::array<::zx::vmo, 5>&
test_handlesintypes::HandlesInTypes::handle_in_array() const {
  return storage_.handle_in_array;
}

::std::array<::zx::vmo, 5>& ::test_handlesintypes::HandlesInTypes::handle_in_array() {
  return storage_.handle_in_array;
}

::test_handlesintypes::HandlesInTypes& ::test_handlesintypes::HandlesInTypes::handle_in_array(::std::array<::zx::vmo, 5> value) {
  storage_.handle_in_array = std::move(value);
  return *this;
}
const ::std::vector<::std::array<::zx::vmo, 5>>&
test_handlesintypes::HandlesInTypes::handle_in_mixed_vec_array() const {
  return storage_.handle_in_mixed_vec_array;
}

::std::vector<::std::array<::zx::vmo, 5>>& ::test_handlesintypes::HandlesInTypes::handle_in_mixed_vec_array() {
  return storage_.handle_in_mixed_vec_array;
}

::test_handlesintypes::HandlesInTypes& ::test_handlesintypes::HandlesInTypes::handle_in_mixed_vec_array(::std::vector<::std::array<::zx::vmo, 5>> value) {
  storage_.handle_in_mixed_vec_array = std::move(value);
  return *this;
}
const ::test_handlesintypes::TableWithHandle&
test_handlesintypes::HandlesInTypes::table_with_handle() const {
  return storage_.table_with_handle;
}

::test_handlesintypes::TableWithHandle& ::test_handlesintypes::HandlesInTypes::table_with_handle() {
  return storage_.table_with_handle;
}

::test_handlesintypes::HandlesInTypes& ::test_handlesintypes::HandlesInTypes::table_with_handle(::test_handlesintypes::TableWithHandle value) {
  storage_.table_with_handle = std::move(value);
  return *this;
}
const ::test_handlesintypes::UnionWithHandle&
test_handlesintypes::HandlesInTypes::union_with_handle() const {
  return storage_.union_with_handle;
}

::test_handlesintypes::UnionWithHandle& ::test_handlesintypes::HandlesInTypes::union_with_handle() {
  return storage_.union_with_handle;
}

::test_handlesintypes::HandlesInTypes& ::test_handlesintypes::HandlesInTypes::union_with_handle(::test_handlesintypes::UnionWithHandle value) {
  storage_.union_with_handle = std::move(value);
  return *this;
}

::test_handlesintypes::EmptyResourceStruct::EmptyResourceStruct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_handlesintypes::EmptyResourceStruct::EmptyResourceStruct(uint8_t __reserved) noexcept
    : storage_({.__reserved = std::move(__reserved)}) {}

::test_handlesintypes::EmptyResourceStruct::EmptyResourceStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : EmptyResourceStruct(Storage_{
                                                                                                                                  .__reserved = 0u,
                                                                                                                              }) {}
uint8_t
test_handlesintypes::EmptyResourceStruct::__reserved() const {
  return storage_.__reserved;
}

uint8_t& ::test_handlesintypes::EmptyResourceStruct::__reserved() {
  return storage_.__reserved;
}

::test_handlesintypes::EmptyResourceStruct& ::test_handlesintypes::EmptyResourceStruct::__reserved(uint8_t value) {
  storage_.__reserved = std::move(value);
  return *this;
}

::test_handlesintypes::TableWithHandle::TableWithHandle(::test_handlesintypes::TableWithHandle::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_handlesintypes::TableWithHandle::TableWithHandle(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TableWithHandle(Storage_{}) {}

bool test_handlesintypes::TableWithHandle::IsEmpty() const {
  return !(storage_.h.has_value());
}
const std::optional<::zx::vmo>& test_handlesintypes::TableWithHandle::h() const {
  return storage_.h;
}

::std::optional<::zx::vmo>& test_handlesintypes::TableWithHandle::h() {
  return storage_.h;
}

::test_handlesintypes::TableWithHandle& test_handlesintypes::TableWithHandle::h(std::optional<::zx::vmo> value) {
  storage_.h = std::move(value);
  return *this;
}

::test_handlesintypes::EmptyResourceTable::EmptyResourceTable(::test_handlesintypes::EmptyResourceTable::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_handlesintypes::EmptyResourceTable::EmptyResourceTable(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : EmptyResourceTable(Storage_{}) {}

bool test_handlesintypes::EmptyResourceTable::IsEmpty() const {
  return true;
}

::test_handlesintypes::UnionWithHandle::UnionWithHandle(UnionWithHandle&& other) noexcept : UnionWithHandle(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_handlesintypes::UnionWithHandle& ::test_handlesintypes::UnionWithHandle::operator=(UnionWithHandle&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_handlesintypes::UnionWithHandle::UnionWithHandle(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_handlesintypes::UnionWithHandle::UnionWithHandle(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_handlesintypes::UnionWithHandle::Tag test_handlesintypes::UnionWithHandle::Which() const {
  return UnionWithHandle::IndexToTag(storage_->index()).value();
}

size_t test_handlesintypes::UnionWithHandle::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_handlesintypes::UnionWithHandle::Tag tag) {
  switch (tag) {
    case ::test_handlesintypes::UnionWithHandle::Tag::kH:
      return 1;
    default: {
      return 0;
    }
  }
}

std::optional<::test_handlesintypes::UnionWithHandle::Tag> test_handlesintypes::UnionWithHandle::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_handlesintypes::UnionWithHandle::Tag::kH;
    default:
      return ::test_handlesintypes::UnionWithHandle::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

bool test_handlesintypes::UnionWithHandle::IsUnknown() const {
  return Which() == ::test_handlesintypes::UnionWithHandle::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_handlesintypes::UnionWithHandle test_handlesintypes::UnionWithHandle::WithH(::zx::vmo val) {
  return UnionWithHandle(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_handlesintypes::UnionWithHandle::Storage_> test_handlesintypes::UnionWithHandle::h() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_handlesintypes::UnionWithHandle::Storage_> test_handlesintypes::UnionWithHandle::h() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_handlesintypes::UnionWithHandle& test_handlesintypes::UnionWithHandle::h(::zx::vmo value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_handlesintypes::EmptyResourceUnion::EmptyResourceUnion(EmptyResourceUnion&& other) noexcept : EmptyResourceUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_handlesintypes::EmptyResourceUnion& ::test_handlesintypes::EmptyResourceUnion::operator=(EmptyResourceUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_handlesintypes::EmptyResourceUnion::EmptyResourceUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_handlesintypes::EmptyResourceUnion::EmptyResourceUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_handlesintypes::EmptyResourceUnion::Tag test_handlesintypes::EmptyResourceUnion::Which() const {
  return EmptyResourceUnion::IndexToTag(storage_->index()).value();
}

size_t test_handlesintypes::EmptyResourceUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_handlesintypes::EmptyResourceUnion::Tag tag) {
  switch (tag) {
    default: {
      return 0;
    }
  }
}

std::optional<::test_handlesintypes::EmptyResourceUnion::Tag> test_handlesintypes::EmptyResourceUnion::IndexToTag(size_t index) {
  switch (index) {
    default:
      return ::test_handlesintypes::EmptyResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

bool test_handlesintypes::EmptyResourceUnion::IsUnknown() const {
  return Which() == ::test_handlesintypes::EmptyResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}

#endif  // __Fuchsia__

#pragma clang diagnostic pop
