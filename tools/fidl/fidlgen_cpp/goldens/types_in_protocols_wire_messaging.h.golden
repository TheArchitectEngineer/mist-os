// WARNING: This file is machine generated by fidlgen.

  // fidl_experiment = output_index_json

  #pragma once

  #include <fidl/test.typesinprotocols/cpp/markers.h>
  #include <fidl/test.typesinprotocols/cpp/wire_types.h>

#ifdef __Fuchsia__

  #include <lib/fidl/cpp/wire/wire_messaging.h>
  #include <lib/fidl/cpp/wire/client.h>
  #include <lib/fidl/cpp/wire/connect_service.h>
  #include <lib/fidl/cpp/wire/server.h>
  #include <lib/fidl/cpp/wire/service_handler.h>
  #include <lib/fidl/cpp/wire/sync_call.h>
  #include <lib/fidl/cpp/wire/unknown_interaction_handler.h>

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

  namespace test_typesinprotocols {

  class Protocol;

}  // namespace test_typesinprotocols

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Basic;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Basic;
      using Response = ::test_typesinprotocols::wire::Basic;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorBasic> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorBasicResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventBasic> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Basic;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Compound;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Compound;
      using Response = ::test_typesinprotocols::wire::Compound;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorCompound> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorCompoundResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventCompound> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Compound;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayBasic;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayBasic;
      using Response = ::test_typesinprotocols::wire::ArrayBasic;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorArrayBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorArrayBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventArrayBasic> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayBasic;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayCompound;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayCompound;
      using Response = ::test_typesinprotocols::wire::ArrayCompound;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorArrayCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorArrayCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventArrayCompound> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayCompound;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorBasic;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorBasic;
      using Response = ::test_typesinprotocols::wire::VectorBasic;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorVectorBasic,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorVectorBasic,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventVectorBasic> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorBasic;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorCompound;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorCompound;
      using Response = ::test_typesinprotocols::wire::VectorCompound;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorVectorCompound,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorVectorCompound,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventVectorCompound> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorCompound;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayVectorOptional> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorOptional;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorOptional;
      using Response = ::test_typesinprotocols::wire::VectorOptional;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorOptional,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayVectorOptional,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorVectorOptional,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorVectorOptional,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventVectorOptional> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::VectorOptional;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayVectorNested;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayVectorNested;
      using Response = ::test_typesinprotocols::wire::ArrayVectorNested;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayVectorNested,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayArrayVectorNested,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorArrayVectorNested,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorArrayVectorNested,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventArrayVectorNested> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::ArrayVectorNested;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::OneWayResource> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Resource;

      using Completer = fidl::Completer<>;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::TwoWayResource> {
    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Resource;
      using Response = ::test_typesinprotocols::wire::Resource;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayResource,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::TwoWayResource,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::ErrorResource> {
    static constexpr bool HasRequestPayload = false;
      using Response = ::test_typesinprotocols::wire::ProtocolErrorResourceResult;
  using DomainError = uint32_t;

      using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorResource>>;
  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorResource,
      ::fidl::internal::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_typesinprotocols::Protocol::ErrorResource,
      ::fidl::internal::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::ChannelTransport
      >
  >;
};

template<>
struct ::fidl::internal::WireMethodTypes<::test_typesinprotocols::Protocol::EventResource> {

    static constexpr bool HasRequestPayload = true;
      using Request = ::test_typesinprotocols::wire::Resource;
};

template<>
struct ::fidl::internal::WireServerDispatcher<::test_typesinprotocols::Protocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_typesinprotocols::Protocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_typesinprotocols::Protocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
  static constexpr const ::fidl::internal::UnknownMethodHandlerEntry& unknown_method_handler_entry_ =
      ::fidl::internal::UnknownMethodHandlerEntry::kClosedProtocolHandlerEntry;
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::Basic body;
  explicit TransactionalRequest(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 80 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::Basic body;
  explicit TransactionalRequest(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 80 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::test_typesinprotocols::wire::Basic {

  explicit WireResponse(::test_typesinprotocols::wire::Basic base);
  explicit WireResponse(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 80;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic> body;
  explicit TransactionalResponse(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 80 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic> final : public ::test_typesinprotocols::wire::ProtocolErrorBasicResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic> body;

    explicit TransactionalEvent(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 80 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::Compound body;
  explicit TransactionalRequest(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 72 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::Compound body;
  explicit TransactionalRequest(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 72 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::test_typesinprotocols::wire::Compound {

  explicit WireResponse(::test_typesinprotocols::wire::Compound base);
  explicit WireResponse(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 72;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 72 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound> final : public ::test_typesinprotocols::wire::ProtocolErrorCompoundResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound> body;

    explicit TransactionalEvent(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 72 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::ArrayBasic body;
  explicit TransactionalRequest(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 384 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::ArrayBasic body;
  explicit TransactionalRequest(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 384 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::test_typesinprotocols::wire::ArrayBasic {

  explicit WireResponse(::test_typesinprotocols::wire::ArrayBasic base);
  explicit WireResponse(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 384;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> body;
  explicit TransactionalResponse(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 384 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic> final : public ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic> body;

    explicit TransactionalEvent(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 384 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::ArrayCompound body;
  explicit TransactionalRequest(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 328 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::ArrayCompound body;
  explicit TransactionalRequest(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 328 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::test_typesinprotocols::wire::ArrayCompound {

  explicit WireResponse(::test_typesinprotocols::wire::ArrayCompound base);
  explicit WireResponse(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 328;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> body;
  explicit TransactionalResponse(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 328 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound> final : public ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound> body;

    explicit TransactionalEvent(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 328 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::VectorBasic body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 192 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::VectorBasic body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 192 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::test_typesinprotocols::wire::VectorBasic {

  explicit WireResponse(::test_typesinprotocols::wire::VectorBasic base);
  explicit WireResponse(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 192;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> body;
  explicit TransactionalResponse(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 192 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic> final : public ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic> body;

    explicit TransactionalEvent(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 192 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::VectorCompound body;
  explicit TransactionalRequest(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 112 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::VectorCompound body;
  explicit TransactionalRequest(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 112 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::test_typesinprotocols::wire::VectorCompound {

  explicit WireResponse(::test_typesinprotocols::wire::VectorCompound base);
  explicit WireResponse(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 112;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> body;
  explicit TransactionalResponse(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 112 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound> final : public ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound> body;

    explicit TransactionalEvent(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 112 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::VectorOptional body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 64 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::VectorOptional body;
  explicit TransactionalRequest(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 64 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::test_typesinprotocols::wire::VectorOptional {

  explicit WireResponse(::test_typesinprotocols::wire::VectorOptional base);
  explicit WireResponse(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 64;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> body;
  explicit TransactionalResponse(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 64 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional> final : public ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional> body;

    explicit TransactionalEvent(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 64 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::ArrayVectorNested body;
  explicit TransactionalRequest(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

  TransactionalRequest();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 144 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::ArrayVectorNested body;
  explicit TransactionalRequest(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 144 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::test_typesinprotocols::wire::ArrayVectorNested {

  explicit WireResponse(::test_typesinprotocols::wire::ArrayVectorNested base);
  explicit WireResponse(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 144;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> body;
  explicit TransactionalResponse(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 144 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> final : public ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult);
  TransactionalResponse();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> body;

    explicit TransactionalEvent(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

  TransactionalEvent();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 144 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::Resource body;
  explicit TransactionalRequest(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

  TransactionalRequest();
    void _CloseHandles();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 456 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::test_typesinprotocols::wire::Resource body;
  explicit TransactionalRequest(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>;
    void _CloseHandles();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 456 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource> final : public ::test_typesinprotocols::wire::Resource {

  explicit WireResponse(::test_typesinprotocols::wire::Resource base);
  explicit WireResponse(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 456;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource> body;
  explicit TransactionalResponse(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
  TransactionalResponse();
  void _CloseHandles();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 456 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  TransactionalRequest();
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>;

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource> final : public ::test_typesinprotocols::wire::ProtocolErrorResourceResult {

  explicit WireResponse(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult);
  WireResponse() = default;
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

  ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource> body;
  explicit TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult);
  TransactionalResponse();
  void _CloseHandles();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;

    ::fidl::WireEvent<::test_typesinprotocols::Protocol::EventResource> body;

    explicit TransactionalEvent(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

  TransactionalEvent();
  void _CloseHandles();

};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 456 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

namespace fidl {

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 80;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(80 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 72;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 80;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 80;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(72 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 384;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(384 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 328;
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 368;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 368;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(328 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 192;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(192 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 112;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(112 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 64;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(64 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 144;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(144 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>> : public std::true_type {};
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(456 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(456 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(456 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 456;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>> : public std::true_type {};
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
template <>
struct TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>> {
  static constexpr bool kHasServerToClientBody = true;
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>> : public std::true_type {};
template <>
struct IsResource<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>> : public std::true_type {};

template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(456 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};}  // namespace fidl

    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>>> {
      static constexpr uint32_t kNumHandles =
            fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_typesinprotocols::Protocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_typesinprotocols::Protocol>> {
   public:
    static constexpr uint32_t kNumHandles = 64;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_typesinprotocols::Protocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_typesinprotocols::Protocol>> {
   public:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_typesinprotocols::Protocol> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayBasic> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorBasic> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::Basic*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayCompound> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorCompound> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::Compound*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayBasic*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayCompound*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorBasic*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorCompound*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorOptional*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayVectorNested*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayResource> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayResource> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayResource> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayResource> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>* request);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::TwoWayResource> {
  using Type = ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayResource> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayResource> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>> decoded_;
};

template<>
struct ::fidl::internal::WireResultUnwrap<::test_typesinprotocols::Protocol::ErrorResource> {
  using Type = ::fit::result<uint32_t, ::test_typesinprotocols::wire::Resource*>;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorResource> {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>* request
  );

  explicit WireResult(const ::fidl::Status& result);
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource> final : public ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorResource> {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>* request);
    explicit WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>* response);
    explicit WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    );

  explicit WireUnownedResult(const ::fidl::Status& result);
  WireUnownedResult(WireUnownedResult&&) = default;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = default;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  private:
      ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>> decoded_;
};

template<>
class ::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void EventBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>* event) = 0;
    virtual void EventCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>* event) = 0;
    virtual void EventArrayBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* event) = 0;
    virtual void EventArrayCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* event) = 0;
    virtual void EventVectorBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* event) = 0;
    virtual void EventVectorCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* event) = 0;
    virtual void EventVectorOptional(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* event) = 0;
    virtual void EventArrayVectorNested(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* event) = 0;
    virtual void EventResource(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventResource>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void EventBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>* event) override;
    void EventCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>* event) override;
    void EventArrayBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* event) override;
    void EventArrayCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* event) override;
    void EventVectorBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* event) override;
    void EventVectorCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* event) override;
    void EventVectorOptional(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* event) override;
    void EventArrayVectorNested(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* event) override;
    void EventResource(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventResource>* event) override;
};

  template<>
  class ::fidl::WireSyncEventHandler<::test_typesinprotocols::Protocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_typesinprotocols::Protocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>* event_handler);
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingHeaderAndMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |::fidl::ClientEnd<::test_typesinprotocols::Protocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>> {
 public:

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>
    TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic>
    ErrorBasic();

    // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::OneWayStatus
    OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    // Allocates 96 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>
    TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound>
    ErrorCompound();

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>
    TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>
    ErrorArrayBasic();

    // Allocates 400 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::OneWayStatus
    OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    // Allocates 384 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>
    TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>
    ErrorArrayCompound();

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>
    TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>
    ErrorVectorBasic();

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>
    TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>
    ErrorVectorCompound();

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>
    TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>
    ErrorVectorOptional();

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>
    TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>
    ErrorArrayVectorNested();

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::OneWayStatus
    OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource>
    TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource>
    ErrorResource();

};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>> {
 public:

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>
    TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic>
    ErrorBasic();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>
    TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound>
    ErrorCompound();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>
    TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>
    ErrorArrayBasic();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>
    TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>
    ErrorArrayCompound();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>
    TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>
    ErrorVectorBasic();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>
    TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>
    ErrorVectorCompound();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>
    TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>
    ErrorVectorOptional();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>
    TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>
    ErrorArrayVectorNested();

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::OneWayStatus
    OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource>
    TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource>
    ErrorResource();

};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

 private:
  void MakeReply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

 private:
  void MakeReply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Basic*> result);
  void ReplySuccess(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Basic*> result);
  void ReplySuccess(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

 private:
  void MakeReply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

 private:
  void MakeReply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Compound*> result);
  void ReplySuccess(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Compound*> result);
  void ReplySuccess(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

 private:
  void MakeReply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

 private:
  void MakeReply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayBasic*> result);
  void ReplySuccess(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayBasic*> result);
  void ReplySuccess(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

 private:
  void MakeReply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

 private:
  void MakeReply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayCompound*> result);
  void ReplySuccess(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayCompound*> result);
  void ReplySuccess(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorBasic*> result);
  void ReplySuccess(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorBasic*> result);
  void ReplySuccess(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

 private:
  void MakeReply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

 private:
  void MakeReply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorCompound*> result);
  void ReplySuccess(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorCompound*> result);
  void ReplySuccess(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

 private:
  void MakeReply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorOptional*> result);
  void ReplySuccess(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorOptional*> result);
  void ReplySuccess(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

 private:
  void MakeReply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

 private:
  void MakeReply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayVectorNested*> result);
  void ReplySuccess(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayVectorNested*> result);
  void ReplySuccess(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayResource> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::TwoWayResource> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

 private:
  void MakeReply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayResource> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

 private:
  void MakeReply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayResource> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource> : public ::fidl::internal::CompleterImplBase<::test_typesinprotocols::Protocol::ErrorResource> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Resource*> result);
  void ReplySuccess(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Resource*> result);
  void ReplySuccess(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
  void ReplyError(uint32_t error);

 private:
  void MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorResource> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply);
  WireCompleterBase(WireCompleterBase&& other) noexcept;
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |::fidl::ClientEnd<::test_typesinprotocols::Protocol>|
// and |::fidl::ServerEnd<::test_typesinprotocols::Protocol>|).
template<>
class ::fidl::WireServer<::test_typesinprotocols::Protocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_typesinprotocols::Protocol;

  using Handler = fidl::ProtocolHandler<::test_typesinprotocols::Protocol>;

    using OneWayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayBasic>;
      using OneWayBasicRequestView = ::test_typesinprotocols::wire::Basic*;

  virtual void OneWayBasic(
      ::test_typesinprotocols::wire::Basic* request,
    OneWayBasicCompleter::Sync& completer) = 0;

    using TwoWayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayBasic>;
      using TwoWayBasicRequestView = ::test_typesinprotocols::wire::Basic*;

  virtual void TwoWayBasic(
      ::test_typesinprotocols::wire::Basic* request,
    TwoWayBasicCompleter::Sync& completer) = 0;

    using ErrorBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorBasic>;

  virtual void ErrorBasic(
    ErrorBasicCompleter::Sync& completer) = 0;

    using OneWayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayCompound>;
      using OneWayCompoundRequestView = ::test_typesinprotocols::wire::Compound*;

  virtual void OneWayCompound(
      ::test_typesinprotocols::wire::Compound* request,
    OneWayCompoundCompleter::Sync& completer) = 0;

    using TwoWayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayCompound>;
      using TwoWayCompoundRequestView = ::test_typesinprotocols::wire::Compound*;

  virtual void TwoWayCompound(
      ::test_typesinprotocols::wire::Compound* request,
    TwoWayCompoundCompleter::Sync& completer) = 0;

    using ErrorCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorCompound>;

  virtual void ErrorCompound(
    ErrorCompoundCompleter::Sync& completer) = 0;

    using OneWayArrayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayBasic>;
      using OneWayArrayBasicRequestView = ::test_typesinprotocols::wire::ArrayBasic*;

  virtual void OneWayArrayBasic(
      ::test_typesinprotocols::wire::ArrayBasic* request,
    OneWayArrayBasicCompleter::Sync& completer) = 0;

    using TwoWayArrayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayBasic>;
      using TwoWayArrayBasicRequestView = ::test_typesinprotocols::wire::ArrayBasic*;

  virtual void TwoWayArrayBasic(
      ::test_typesinprotocols::wire::ArrayBasic* request,
    TwoWayArrayBasicCompleter::Sync& completer) = 0;

    using ErrorArrayBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorArrayBasic>;

  virtual void ErrorArrayBasic(
    ErrorArrayBasicCompleter::Sync& completer) = 0;

    using OneWayArrayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayCompound>;
      using OneWayArrayCompoundRequestView = ::test_typesinprotocols::wire::ArrayCompound*;

  virtual void OneWayArrayCompound(
      ::test_typesinprotocols::wire::ArrayCompound* request,
    OneWayArrayCompoundCompleter::Sync& completer) = 0;

    using TwoWayArrayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayCompound>;
      using TwoWayArrayCompoundRequestView = ::test_typesinprotocols::wire::ArrayCompound*;

  virtual void TwoWayArrayCompound(
      ::test_typesinprotocols::wire::ArrayCompound* request,
    TwoWayArrayCompoundCompleter::Sync& completer) = 0;

    using ErrorArrayCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorArrayCompound>;

  virtual void ErrorArrayCompound(
    ErrorArrayCompoundCompleter::Sync& completer) = 0;

    using OneWayVectorBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorBasic>;
      using OneWayVectorBasicRequestView = ::test_typesinprotocols::wire::VectorBasic*;

  virtual void OneWayVectorBasic(
      ::test_typesinprotocols::wire::VectorBasic* request,
    OneWayVectorBasicCompleter::Sync& completer) = 0;

    using TwoWayVectorBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorBasic>;
      using TwoWayVectorBasicRequestView = ::test_typesinprotocols::wire::VectorBasic*;

  virtual void TwoWayVectorBasic(
      ::test_typesinprotocols::wire::VectorBasic* request,
    TwoWayVectorBasicCompleter::Sync& completer) = 0;

    using ErrorVectorBasicCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorVectorBasic>;

  virtual void ErrorVectorBasic(
    ErrorVectorBasicCompleter::Sync& completer) = 0;

    using OneWayVectorCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorCompound>;
      using OneWayVectorCompoundRequestView = ::test_typesinprotocols::wire::VectorCompound*;

  virtual void OneWayVectorCompound(
      ::test_typesinprotocols::wire::VectorCompound* request,
    OneWayVectorCompoundCompleter::Sync& completer) = 0;

    using TwoWayVectorCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorCompound>;
      using TwoWayVectorCompoundRequestView = ::test_typesinprotocols::wire::VectorCompound*;

  virtual void TwoWayVectorCompound(
      ::test_typesinprotocols::wire::VectorCompound* request,
    TwoWayVectorCompoundCompleter::Sync& completer) = 0;

    using ErrorVectorCompoundCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorVectorCompound>;

  virtual void ErrorVectorCompound(
    ErrorVectorCompoundCompleter::Sync& completer) = 0;

    using OneWayVectorOptionalCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorOptional>;
      using OneWayVectorOptionalRequestView = ::test_typesinprotocols::wire::VectorOptional*;

  virtual void OneWayVectorOptional(
      ::test_typesinprotocols::wire::VectorOptional* request,
    OneWayVectorOptionalCompleter::Sync& completer) = 0;

    using TwoWayVectorOptionalCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorOptional>;
      using TwoWayVectorOptionalRequestView = ::test_typesinprotocols::wire::VectorOptional*;

  virtual void TwoWayVectorOptional(
      ::test_typesinprotocols::wire::VectorOptional* request,
    TwoWayVectorOptionalCompleter::Sync& completer) = 0;

    using ErrorVectorOptionalCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorVectorOptional>;

  virtual void ErrorVectorOptional(
    ErrorVectorOptionalCompleter::Sync& completer) = 0;

    using OneWayArrayVectorNestedCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>;
      using OneWayArrayVectorNestedRequestView = ::test_typesinprotocols::wire::ArrayVectorNested*;

  virtual void OneWayArrayVectorNested(
      ::test_typesinprotocols::wire::ArrayVectorNested* request,
    OneWayArrayVectorNestedCompleter::Sync& completer) = 0;

    using TwoWayArrayVectorNestedCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>;
      using TwoWayArrayVectorNestedRequestView = ::test_typesinprotocols::wire::ArrayVectorNested*;

  virtual void TwoWayArrayVectorNested(
      ::test_typesinprotocols::wire::ArrayVectorNested* request,
    TwoWayArrayVectorNestedCompleter::Sync& completer) = 0;

    using ErrorArrayVectorNestedCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>;

  virtual void ErrorArrayVectorNested(
    ErrorArrayVectorNestedCompleter::Sync& completer) = 0;

    using OneWayResourceCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayResource>;
      using OneWayResourceRequestView = ::test_typesinprotocols::wire::Resource*;

  virtual void OneWayResource(
      ::test_typesinprotocols::wire::Resource* request,
    OneWayResourceCompleter::Sync& completer) = 0;

    using TwoWayResourceCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayResource>;
      using TwoWayResourceRequestView = ::test_typesinprotocols::wire::Resource*;

  virtual void TwoWayResource(
      ::test_typesinprotocols::wire::Resource* request,
    TwoWayResourceCompleter::Sync& completer) = 0;

    using ErrorResourceCompleter = ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorResource>;

  virtual void ErrorResource(
    ErrorResourceCompleter::Sync& completer) = 0;

  // |bind_handler| returns a handler that binds incoming connections to this
  // server implementation.
  //
  // The returned handler borrows the server instance.
  // The server must outlive the provided |dispatcher|. Only after
  // the dispatcher is shutdown will it be safe to destroy the servers.
  // The server should not be moved.
  Handler bind_handler(async_dispatcher_t* dispatcher);

  private:
  void dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;

  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

  // Allocates 112 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::OneWayStatus OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

  // Allocates 400 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::OneWayStatus OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::OneWayStatus OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorBasic> ErrorBasic();
    // Allocates 96 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorCompound> ErrorCompound();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayBasic> ErrorArrayBasic();
    // Allocates 384 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayCompound> ErrorArrayCompound();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorBasic> ErrorVectorBasic();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorCompound> ErrorVectorCompound();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorOptional> ErrorVectorOptional();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> ErrorArrayVectorNested();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayResource> TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorResource> ErrorResource();
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

// Caller provides the backing storage for FIDL message.
::fidl::OneWayStatus OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorBasic> ErrorBasic();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorCompound> ErrorCompound();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayBasic> ErrorArrayBasic();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayCompound> ErrorArrayCompound();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorBasic> ErrorVectorBasic();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorCompound> ErrorVectorCompound();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorOptional> ErrorVectorOptional();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> ErrorArrayVectorNested();

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayResource> TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorResource> ErrorResource();

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic> TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic> ErrorBasic();

  // Allocates 96 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound> TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound> ErrorCompound();

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic> TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic> ErrorArrayBasic();

  // Allocates 384 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound> TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound> ErrorArrayCompound();

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic> TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic> ErrorVectorBasic();

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound> TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound> ErrorVectorCompound();

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional> TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional> ErrorVectorOptional();

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> ErrorArrayVectorNested();

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource> TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource> ErrorResource();
};

template<>
class ::fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    fidl::OneWayStatus EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    fidl::OneWayStatus EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

};

template<>
class ::fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    fidl::OneWayStatus EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::OneWayStatus EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string);

    fidl::OneWayStatus EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union);

    fidl::OneWayStatus EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string);

    fidl::OneWayStatus EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union);

    fidl::OneWayStatus EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string);

    fidl::OneWayStatus EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union);

    fidl::OneWayStatus EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct);

    fidl::OneWayStatus EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8);

    fidl::OneWayStatus EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union);

};

  #pragma clang diagnostic pop

#endif  // __Fuchsia__

