// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.padding/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding1ByteEnd* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding1ByteEnd));
  } else {
    internal::WireZeroPadding<uint16_t>(encoder, position + 2);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 2, recursion_depth);
  }
  internal::WireCheckPadding<uint16_t>(decoder, position + 2, 0xff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding1ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding1ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding1ByteEnd, b) == 2);
static_assert(sizeof(::test_padding::wire::Padding1ByteEnd) == ::fidl::TypeTraits<::test_padding::wire::Padding1ByteEnd>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteEnd* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding2ByteEnd));
  } else {
    internal::WireZeroPadding<uint32_t>(encoder, position + 4);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
  internal::WireCheckPadding<uint32_t>(decoder, position + 4, 0xffff0000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding2ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding2ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding2ByteEnd, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding2ByteEnd) == ::fidl::TypeTraits<::test_padding::wire::Padding2ByteEnd>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding3ByteEnd* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding3ByteEnd));
  } else {
    internal::WireZeroPadding<uint32_t>(encoder, position + 4);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
  internal::WireCheckPadding<uint32_t>(decoder, position + 4, 0xffffff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding3ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding3ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding3ByteEnd, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding3ByteEnd) == ::fidl::TypeTraits<::test_padding::wire::Padding3ByteEnd>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteEnd* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding4ByteEnd));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 8);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding4ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding4ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding4ByteEnd, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding4ByteEnd) == ::fidl::TypeTraits<::test_padding::wire::Padding4ByteEnd>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding5ByteEnd* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding5ByteEnd));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 8);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 10, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 10, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffff000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding5ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding5ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding5ByteEnd, b) == 8);
static_assert(offsetof(::test_padding::wire::Padding5ByteEnd, c) == 10);
static_assert(sizeof(::test_padding::wire::Padding5ByteEnd) == ::fidl::TypeTraits<::test_padding::wire::Padding5ByteEnd>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding6ByteEnd* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding6ByteEnd));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 8);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffffff0000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding6ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding6ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding6ByteEnd, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding6ByteEnd) == ::fidl::TypeTraits<::test_padding::wire::Padding6ByteEnd>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding7ByteEnd* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding7ByteEnd));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 8);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffffffff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding7ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding7ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding7ByteEnd, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding7ByteEnd) == ::fidl::TypeTraits<::test_padding::wire::Padding7ByteEnd>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding1ByteMiddle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding1ByteMiddle));
  } else {
    internal::WireZeroPadding<uint16_t>(encoder, position + 0);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 2, recursion_depth);
  }
  internal::WireCheckPadding<uint16_t>(decoder, position + 0, 0xff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding1ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding1ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding1ByteMiddle, b) == 2);
static_assert(sizeof(::test_padding::wire::Padding1ByteMiddle) == ::fidl::TypeTraits<::test_padding::wire::Padding1ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteMiddle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding2ByteMiddle));
  } else {
    internal::WireZeroPadding<uint32_t>(encoder, position + 0);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
  internal::WireCheckPadding<uint32_t>(decoder, position + 0, 0xffff0000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding2ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding2ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding2ByteMiddle, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding2ByteMiddle) == ::fidl::TypeTraits<::test_padding::wire::Padding2ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding3ByteMiddle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding3ByteMiddle));
  } else {
    internal::WireZeroPadding<uint32_t>(encoder, position + 0);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
  internal::WireCheckPadding<uint32_t>(decoder, position + 0, 0xffffff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding3ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding3ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding3ByteMiddle, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding3ByteMiddle) == ::fidl::TypeTraits<::test_padding::wire::Padding3ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteMiddle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding4ByteMiddle));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding4ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding4ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding4ByteMiddle, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding4ByteMiddle) == ::fidl::TypeTraits<::test_padding::wire::Padding4ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding5ByteMiddle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding5ByteMiddle));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 2, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffffff000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding5ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding5ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding5ByteMiddle, b) == 2);
static_assert(offsetof(::test_padding::wire::Padding5ByteMiddle, c) == 8);
static_assert(sizeof(::test_padding::wire::Padding5ByteMiddle) == ::fidl::TypeTraits<::test_padding::wire::Padding5ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding6ByteMiddle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding6ByteMiddle));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffffffff0000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding6ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding6ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding6ByteMiddle, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding6ByteMiddle) == ::fidl::TypeTraits<::test_padding::wire::Padding6ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding7ByteMiddle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding7ByteMiddle));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffffffffff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding7ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding7ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding7ByteMiddle, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding7ByteMiddle) == ::fidl::TypeTraits<::test_padding::wire::Padding7ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteAlignmentLength12* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding4ByteAlignmentLength12));
  } else {
    internal::WireZeroPadding<uint32_t>(encoder, position + 4);
    internal::WireZeroPadding<uint32_t>(encoder, position + 8);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 6, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->d, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 6, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
  internal::WireCheckPadding<uint32_t>(decoder, position + 4, 0xff00);
  internal::WireCheckPadding<uint32_t>(decoder, position + 8, 0xffff0000);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding4ByteAlignmentLength12>);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, b) == 4);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, c) == 6);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, d) == 8);
static_assert(sizeof(::test_padding::wire::Padding4ByteAlignmentLength12) == ::fidl::TypeTraits<::test_padding::wire::Padding4ByteAlignmentLength12>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteAlignmentLength6* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding2ByteAlignmentLength6));
  } else {
    internal::WireZeroPadding<uint16_t>(encoder, position + 0);
    internal::WireZeroPadding<uint16_t>(encoder, position + 4);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 2, recursion_depth);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
  internal::WireCheckPadding<uint16_t>(decoder, position + 0, 0xff00);
  internal::WireCheckPadding<uint16_t>(decoder, position + 4, 0xff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_padding::wire::Padding2ByteAlignmentLength6>);
static_assert(offsetof(::test_padding::wire::Padding2ByteAlignmentLength6, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding2ByteAlignmentLength6, b) == 2);
static_assert(offsetof(::test_padding::wire::Padding2ByteAlignmentLength6, c) == 4);
static_assert(sizeof(::test_padding::wire::Padding2ByteAlignmentLength6) == ::fidl::TypeTraits<::test_padding::wire::Padding2ByteAlignmentLength6>::kPrimarySize);

#pragma clang diagnostic pop
