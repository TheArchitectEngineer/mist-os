// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.union/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

::test_union::Pizza::Pizza(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::Pizza::Pizza(::std::vector<::std::string> toppings) noexcept
    : storage_({.toppings = std::move(toppings)}) {}

::test_union::Pizza::Pizza(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Pizza(Storage_{
                                                                                             .toppings = {},
                                                                                         }) {}
::test_union::Pizza::Pizza(const ::test_union::Pizza& other) noexcept : ::test_union::Pizza(other.CloneStorage_()) {}

::test_union::Pizza& test_union::Pizza::operator=(const ::test_union::Pizza& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::Pizza::operator==(const Pizza& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza, 16>::Equal(this, &other);
}

bool test_union::Pizza::operator!=(const Pizza& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza, 16>::Equal(this, &other);
}

::test_union::Pizza::Storage_ test_union::Pizza::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.toppings)};
}
const ::std::vector<::std::string>&
test_union::Pizza::toppings() const {
  return storage_.toppings;
}

::std::vector<::std::string>& ::test_union::Pizza::toppings() {
  return storage_.toppings;
}

::test_union::Pizza& ::test_union::Pizza::toppings(::std::vector<::std::string> value) {
  storage_.toppings = std::move(value);
  return *this;
}

::test_union::Pasta::Pasta(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::Pasta::Pasta(::std::string sauce) noexcept
    : storage_({.sauce = std::move(sauce)}) {}

::test_union::Pasta::Pasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Pasta(Storage_{
                                                                                             .sauce = {},
                                                                                         }) {}
::test_union::Pasta::Pasta(const ::test_union::Pasta& other) noexcept : ::test_union::Pasta(other.CloneStorage_()) {}

::test_union::Pasta& test_union::Pasta::operator=(const ::test_union::Pasta& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::Pasta::operator==(const Pasta& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta, 16>::Equal(this, &other);
}

bool test_union::Pasta::operator!=(const Pasta& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta, 16>::Equal(this, &other);
}

::test_union::Pasta::Storage_ test_union::Pasta::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.sauce)};
}
const ::std::string&
test_union::Pasta::sauce() const {
  return storage_.sauce;
}

::std::string& ::test_union::Pasta::sauce() {
  return storage_.sauce;
}

::test_union::Pasta& ::test_union::Pasta::sauce(::std::string value) {
  storage_.sauce = std::move(value);
  return *this;
}

::test_union::NullableUnionStruct::NullableUnionStruct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::NullableUnionStruct::NullableUnionStruct(::fidl::Box<::test_union::Union> the_union) noexcept
    : storage_({.the_union = std::move(the_union)}) {}

::test_union::NullableUnionStruct::NullableUnionStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : NullableUnionStruct(Storage_{
                                                                                                                         .the_union = {},
                                                                                                                     }) {}
::test_union::NullableUnionStruct::NullableUnionStruct(const ::test_union::NullableUnionStruct& other) noexcept : ::test_union::NullableUnionStruct(other.CloneStorage_()) {}

::test_union::NullableUnionStruct& test_union::NullableUnionStruct::operator=(const ::test_union::NullableUnionStruct& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::NullableUnionStruct::operator==(const NullableUnionStruct& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::NullableUnionStruct, 16>::Equal(this, &other);
}

bool test_union::NullableUnionStruct::operator!=(const NullableUnionStruct& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::NullableUnionStruct, 16>::Equal(this, &other);
}

::test_union::NullableUnionStruct::Storage_ test_union::NullableUnionStruct::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.the_union)};
}
const ::fidl::Box<::test_union::Union>&
test_union::NullableUnionStruct::the_union() const {
  return storage_.the_union;
}

::fidl::Box<::test_union::Union>& ::test_union::NullableUnionStruct::the_union() {
  return storage_.the_union;
}

::test_union::NullableUnionStruct& ::test_union::NullableUnionStruct::the_union(::fidl::Box<::test_union::Union> value) {
  storage_.the_union = std::move(value);
  return *this;
}

::test_union::Empty::Empty(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::Empty::Empty(uint8_t __reserved) noexcept
    : storage_({.__reserved = std::move(__reserved)}) {}

::test_union::Empty::Empty(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Empty(Storage_{
                                                                                             .__reserved = 0u,
                                                                                         }) {}
::test_union::Empty::Empty(const ::test_union::Empty& other) noexcept : ::test_union::Empty(other.CloneStorage_()) {}

::test_union::Empty& test_union::Empty::operator=(const ::test_union::Empty& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::Empty::operator==(const Empty& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::Empty, 1>::Equal(this, &other);
}

bool test_union::Empty::operator!=(const Empty& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::Empty, 1>::Equal(this, &other);
}

::test_union::Empty::Storage_ test_union::Empty::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.__reserved)};
}
uint8_t
test_union::Empty::__reserved() const {
  return storage_.__reserved;
}

uint8_t& ::test_union::Empty::__reserved() {
  return storage_.__reserved;
}

::test_union::Empty& ::test_union::Empty::__reserved(uint8_t value) {
  storage_.__reserved = std::move(value);
  return *this;
}

::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(::test_union::StrictBoundedUnion xu) noexcept
    : storage_({.xu = std::move(xu)}) {}

::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(Storage_{
                                                                                                                                                                                                                 .xu = ::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
                                                                                                                                                                                                             }) {}
::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(const ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) noexcept : ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(other.CloneStorage_()) {}

::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::operator=(const ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::operator==(const TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, 16>::Equal(this, &other);
}

bool test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::operator!=(const TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, 16>::Equal(this, &other);
}

::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::Storage_ test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.xu)};
}
const ::test_union::StrictBoundedUnion&
test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::xu() const {
  return storage_.xu;
}

::test_union::StrictBoundedUnion& ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::xu() {
  return storage_.xu;
}

::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& ::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse::xu(::test_union::StrictBoundedUnion value) {
  storage_.xu = std::move(value);
  return *this;
}

::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(::test_union::OlderSimpleUnion xu) noexcept
    : storage_({.xu = std::move(xu)}) {}

::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(Storage_{
                                                                                                                                                                                                                     .xu = ::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
                                                                                                                                                                                                                 }) {}
::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(const ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) noexcept : ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(other.CloneStorage_()) {}

::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::operator=(const ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::operator==(const TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, 16>::Equal(this, &other);
}

bool test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::operator!=(const TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, 16>::Equal(this, &other);
}

::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::Storage_ test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.xu)};
}
const ::test_union::OlderSimpleUnion&
test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::xu() const {
  return storage_.xu;
}

::test_union::OlderSimpleUnion& ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::xu() {
  return storage_.xu;
}

::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& ::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse::xu(::test_union::OlderSimpleUnion value) {
  storage_.xu = std::move(value);
  return *this;
}

::test_union::StructWithNullableUnion::StructWithNullableUnion(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::StructWithNullableUnion::StructWithNullableUnion(::fidl::Box<::test_union::OlderSimpleUnion> x1) noexcept
    : storage_({.x1 = std::move(x1)}) {}

::test_union::StructWithNullableUnion::StructWithNullableUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : StructWithNullableUnion(Storage_{
                                                                                                                                 .x1 = {},
                                                                                                                             }) {}
::test_union::StructWithNullableUnion::StructWithNullableUnion(const ::test_union::StructWithNullableUnion& other) noexcept : ::test_union::StructWithNullableUnion(other.CloneStorage_()) {}

::test_union::StructWithNullableUnion& test_union::StructWithNullableUnion::operator=(const ::test_union::StructWithNullableUnion& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::StructWithNullableUnion::operator==(const StructWithNullableUnion& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::StructWithNullableUnion, 16>::Equal(this, &other);
}

bool test_union::StructWithNullableUnion::operator!=(const StructWithNullableUnion& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::StructWithNullableUnion, 16>::Equal(this, &other);
}

::test_union::StructWithNullableUnion::Storage_ test_union::StructWithNullableUnion::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.x1)};
}
const ::fidl::Box<::test_union::OlderSimpleUnion>&
test_union::StructWithNullableUnion::x1() const {
  return storage_.x1;
}

::fidl::Box<::test_union::OlderSimpleUnion>& ::test_union::StructWithNullableUnion::x1() {
  return storage_.x1;
}

::test_union::StructWithNullableUnion& ::test_union::StructWithNullableUnion::x1(::fidl::Box<::test_union::OlderSimpleUnion> value) {
  storage_.x1 = std::move(value);
  return *this;
}

::test_union::UnionSandwich::UnionSandwich(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_union::UnionSandwich::UnionSandwich(uint32_t a, ::test_union::ExplicitFlexibleUnion u, uint32_t b) noexcept
    : storage_({.a = std::move(a),
                .u = std::move(u),
                .b = std::move(b)}) {}

::test_union::UnionSandwich::UnionSandwich(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : UnionSandwich(Storage_{
                                                                                                             .a = {},
                                                                                                             .u = ::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
                                                                                                             .b = {},
                                                                                                         }) {}
::test_union::UnionSandwich::UnionSandwich(const ::test_union::UnionSandwich& other) noexcept : ::test_union::UnionSandwich(other.CloneStorage_()) {}

::test_union::UnionSandwich& test_union::UnionSandwich::operator=(const ::test_union::UnionSandwich& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_union::UnionSandwich::operator==(const UnionSandwich& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_union::UnionSandwich, 32>::Equal(this, &other);
}

bool test_union::UnionSandwich::operator!=(const UnionSandwich& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_union::UnionSandwich, 32>::Equal(this, &other);
}

::test_union::UnionSandwich::Storage_ test_union::UnionSandwich::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.a),
      ::fidl::internal::NaturalClone(storage_.u),
      ::fidl::internal::NaturalClone(storage_.b)};
}
uint32_t
test_union::UnionSandwich::a() const {
  return storage_.a;
}

uint32_t& ::test_union::UnionSandwich::a() {
  return storage_.a;
}

::test_union::UnionSandwich& ::test_union::UnionSandwich::a(uint32_t value) {
  storage_.a = std::move(value);
  return *this;
}
const ::test_union::ExplicitFlexibleUnion&
test_union::UnionSandwich::u() const {
  return storage_.u;
}

::test_union::ExplicitFlexibleUnion& ::test_union::UnionSandwich::u() {
  return storage_.u;
}

::test_union::UnionSandwich& ::test_union::UnionSandwich::u(::test_union::ExplicitFlexibleUnion value) {
  storage_.u = std::move(value);
  return *this;
}
uint32_t
test_union::UnionSandwich::b() const {
  return storage_.b;
}

uint32_t& ::test_union::UnionSandwich::b() {
  return storage_.b;
}

::test_union::UnionSandwich& ::test_union::UnionSandwich::b(uint32_t value) {
  storage_.b = std::move(value);
  return *this;
}

::test_union::PizzaOrPasta::PizzaOrPasta(PizzaOrPasta&& other) noexcept : PizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::PizzaOrPasta& ::test_union::PizzaOrPasta::operator=(PizzaOrPasta&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::PizzaOrPasta::PizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::PizzaOrPasta::PizzaOrPasta(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::PizzaOrPasta::Tag test_union::PizzaOrPasta::Which() const {
  return PizzaOrPasta::IndexToTag(storage_->index()).value();
}

size_t test_union::PizzaOrPasta::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::PizzaOrPasta::Tag tag) {
  switch (tag) {
    case ::test_union::PizzaOrPasta::Tag::kPizza:
      return 1;
    case ::test_union::PizzaOrPasta::Tag::kPasta:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::PizzaOrPasta::Tag> test_union::PizzaOrPasta::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::PizzaOrPasta::Tag::kPizza;
    case 2:
      return ::test_union::PizzaOrPasta::Tag::kPasta;
    default:
      return std::nullopt;
  }
}

::test_union::PizzaOrPasta::PizzaOrPasta(const PizzaOrPasta& other) noexcept : PizzaOrPasta(other.CloneStorage_()) {}

::test_union::PizzaOrPasta& test_union::PizzaOrPasta::operator=(const PizzaOrPasta& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::PizzaOrPasta::operator==(const PizzaOrPasta& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::PizzaOrPasta::operator!=(const PizzaOrPasta& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::PizzaOrPasta::Storage_> test_union::PizzaOrPasta::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::PizzaOrPasta test_union::PizzaOrPasta::WithPizza(::test_union::Pizza val) {
  return PizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::PizzaOrPasta::Storage_> test_union::PizzaOrPasta::pizza() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::PizzaOrPasta::Storage_> test_union::PizzaOrPasta::pizza() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::PizzaOrPasta& test_union::PizzaOrPasta::pizza(::test_union::Pizza value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::PizzaOrPasta test_union::PizzaOrPasta::WithPasta(::test_union::Pasta val) {
  return PizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::PizzaOrPasta::Storage_> test_union::PizzaOrPasta::pasta() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::PizzaOrPasta::Storage_> test_union::PizzaOrPasta::pasta() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::PizzaOrPasta& test_union::PizzaOrPasta::pasta(::test_union::Pasta value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::ExplicitPizzaOrPasta::ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&& other) noexcept : ExplicitPizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::ExplicitPizzaOrPasta& ::test_union::ExplicitPizzaOrPasta::operator=(ExplicitPizzaOrPasta&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::ExplicitPizzaOrPasta::ExplicitPizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::ExplicitPizzaOrPasta::ExplicitPizzaOrPasta(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::ExplicitPizzaOrPasta::Tag test_union::ExplicitPizzaOrPasta::Which() const {
  return ExplicitPizzaOrPasta::IndexToTag(storage_->index()).value();
}

size_t test_union::ExplicitPizzaOrPasta::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitPizzaOrPasta::Tag tag) {
  switch (tag) {
    case ::test_union::ExplicitPizzaOrPasta::Tag::kPizza:
      return 1;
    case ::test_union::ExplicitPizzaOrPasta::Tag::kPasta:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::ExplicitPizzaOrPasta::Tag> test_union::ExplicitPizzaOrPasta::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::ExplicitPizzaOrPasta::Tag::kPizza;
    case 2:
      return ::test_union::ExplicitPizzaOrPasta::Tag::kPasta;
    default:
      return std::nullopt;
  }
}

::test_union::ExplicitPizzaOrPasta::ExplicitPizzaOrPasta(const ExplicitPizzaOrPasta& other) noexcept : ExplicitPizzaOrPasta(other.CloneStorage_()) {}

::test_union::ExplicitPizzaOrPasta& test_union::ExplicitPizzaOrPasta::operator=(const ExplicitPizzaOrPasta& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::ExplicitPizzaOrPasta::operator==(const ExplicitPizzaOrPasta& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::ExplicitPizzaOrPasta::operator!=(const ExplicitPizzaOrPasta& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::ExplicitPizzaOrPasta::Storage_> test_union::ExplicitPizzaOrPasta::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::ExplicitPizzaOrPasta test_union::ExplicitPizzaOrPasta::WithPizza(::test_union::Pizza val) {
  return ExplicitPizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::ExplicitPizzaOrPasta::Storage_> test_union::ExplicitPizzaOrPasta::pizza() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::ExplicitPizzaOrPasta::Storage_> test_union::ExplicitPizzaOrPasta::pizza() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::ExplicitPizzaOrPasta& test_union::ExplicitPizzaOrPasta::pizza(::test_union::Pizza value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::ExplicitPizzaOrPasta test_union::ExplicitPizzaOrPasta::WithPasta(::test_union::Pasta val) {
  return ExplicitPizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::ExplicitPizzaOrPasta::Storage_> test_union::ExplicitPizzaOrPasta::pasta() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::ExplicitPizzaOrPasta::Storage_> test_union::ExplicitPizzaOrPasta::pasta() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::ExplicitPizzaOrPasta& test_union::ExplicitPizzaOrPasta::pasta(::test_union::Pasta value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::FlexiblePizzaOrPasta::FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&& other) noexcept : FlexiblePizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::FlexiblePizzaOrPasta& ::test_union::FlexiblePizzaOrPasta::operator=(FlexiblePizzaOrPasta&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::FlexiblePizzaOrPasta::FlexiblePizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::FlexiblePizzaOrPasta::FlexiblePizzaOrPasta(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::FlexiblePizzaOrPasta::Tag test_union::FlexiblePizzaOrPasta::Which() const {
  return FlexiblePizzaOrPasta::IndexToTag(storage_->index()).value();
}

size_t test_union::FlexiblePizzaOrPasta::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FlexiblePizzaOrPasta::Tag tag) {
  switch (tag) {
    case ::test_union::FlexiblePizzaOrPasta::Tag::kPizza:
      return 1;
    case ::test_union::FlexiblePizzaOrPasta::Tag::kPasta:
      return 2;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::FlexiblePizzaOrPasta::Tag> test_union::FlexiblePizzaOrPasta::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::FlexiblePizzaOrPasta::Tag::kPizza;
    case 2:
      return ::test_union::FlexiblePizzaOrPasta::Tag::kPasta;
    default:
      return ::test_union::FlexiblePizzaOrPasta::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::FlexiblePizzaOrPasta::FlexiblePizzaOrPasta(const FlexiblePizzaOrPasta& other) noexcept : FlexiblePizzaOrPasta(other.CloneStorage_()) {}

::test_union::FlexiblePizzaOrPasta& test_union::FlexiblePizzaOrPasta::operator=(const FlexiblePizzaOrPasta& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::FlexiblePizzaOrPasta::operator==(const FlexiblePizzaOrPasta& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::FlexiblePizzaOrPasta::operator!=(const FlexiblePizzaOrPasta& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::FlexiblePizzaOrPasta::Storage_> test_union::FlexiblePizzaOrPasta::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::FlexiblePizzaOrPasta::IsUnknown() const {
  return Which() == ::test_union::FlexiblePizzaOrPasta::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::FlexiblePizzaOrPasta test_union::FlexiblePizzaOrPasta::WithPizza(::test_union::Pizza val) {
  return FlexiblePizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::FlexiblePizzaOrPasta::Storage_> test_union::FlexiblePizzaOrPasta::pizza() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::FlexiblePizzaOrPasta::Storage_> test_union::FlexiblePizzaOrPasta::pizza() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::FlexiblePizzaOrPasta& test_union::FlexiblePizzaOrPasta::pizza(::test_union::Pizza value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::FlexiblePizzaOrPasta test_union::FlexiblePizzaOrPasta::WithPasta(::test_union::Pasta val) {
  return FlexiblePizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::FlexiblePizzaOrPasta::Storage_> test_union::FlexiblePizzaOrPasta::pasta() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::FlexiblePizzaOrPasta::Storage_> test_union::FlexiblePizzaOrPasta::pasta() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::FlexiblePizzaOrPasta& test_union::FlexiblePizzaOrPasta::pasta(::test_union::Pasta value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::StrictPizzaOrPasta::StrictPizzaOrPasta(StrictPizzaOrPasta&& other) noexcept : StrictPizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::StrictPizzaOrPasta& ::test_union::StrictPizzaOrPasta::operator=(StrictPizzaOrPasta&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::StrictPizzaOrPasta::StrictPizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::StrictPizzaOrPasta::StrictPizzaOrPasta(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::StrictPizzaOrPasta::Tag test_union::StrictPizzaOrPasta::Which() const {
  return StrictPizzaOrPasta::IndexToTag(storage_->index()).value();
}

size_t test_union::StrictPizzaOrPasta::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictPizzaOrPasta::Tag tag) {
  switch (tag) {
    case ::test_union::StrictPizzaOrPasta::Tag::kPizza:
      return 1;
    case ::test_union::StrictPizzaOrPasta::Tag::kPasta:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::StrictPizzaOrPasta::Tag> test_union::StrictPizzaOrPasta::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::StrictPizzaOrPasta::Tag::kPizza;
    case 2:
      return ::test_union::StrictPizzaOrPasta::Tag::kPasta;
    default:
      return std::nullopt;
  }
}

::test_union::StrictPizzaOrPasta::StrictPizzaOrPasta(const StrictPizzaOrPasta& other) noexcept : StrictPizzaOrPasta(other.CloneStorage_()) {}

::test_union::StrictPizzaOrPasta& test_union::StrictPizzaOrPasta::operator=(const StrictPizzaOrPasta& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::StrictPizzaOrPasta::operator==(const StrictPizzaOrPasta& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::StrictPizzaOrPasta::operator!=(const StrictPizzaOrPasta& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::StrictPizzaOrPasta::Storage_> test_union::StrictPizzaOrPasta::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::StrictPizzaOrPasta test_union::StrictPizzaOrPasta::WithPizza(::test_union::Pizza val) {
  return StrictPizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::StrictPizzaOrPasta::Storage_> test_union::StrictPizzaOrPasta::pizza() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::StrictPizzaOrPasta::Storage_> test_union::StrictPizzaOrPasta::pizza() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::StrictPizzaOrPasta& test_union::StrictPizzaOrPasta::pizza(::test_union::Pizza value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::StrictPizzaOrPasta test_union::StrictPizzaOrPasta::WithPasta(::test_union::Pasta val) {
  return StrictPizzaOrPasta(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::StrictPizzaOrPasta::Storage_> test_union::StrictPizzaOrPasta::pasta() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::StrictPizzaOrPasta::Storage_> test_union::StrictPizzaOrPasta::pasta() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::StrictPizzaOrPasta& test_union::StrictPizzaOrPasta::pasta(::test_union::Pasta value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::Union::Union(Union&& other) noexcept : Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::Union& ::test_union::Union::operator=(Union&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::Union::Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::Union::Union(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::Union::Tag test_union::Union::Which() const {
  return Union::IndexToTag(storage_->index()).value();
}

size_t test_union::Union::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::Union::Tag tag) {
  switch (tag) {
    case ::test_union::Union::Tag::kPrimitive:
      return 1;
    case ::test_union::Union::Tag::kStringNeedsConstructor:
      return 2;
    case ::test_union::Union::Tag::kVectorStringAlsoNeedsConstructor:
      return 3;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::Union::Tag> test_union::Union::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::Union::Tag::kPrimitive;
    case 2:
      return ::test_union::Union::Tag::kStringNeedsConstructor;
    case 3:
      return ::test_union::Union::Tag::kVectorStringAlsoNeedsConstructor;
    default:
      return std::nullopt;
  }
}

::test_union::Union::Union(const Union& other) noexcept : Union(other.CloneStorage_()) {}

::test_union::Union& test_union::Union::operator=(const Union& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::Union::operator==(const Union& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::Union::operator!=(const Union& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::Union::Storage_> test_union::Union::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    case 3:
      return std::make_shared<Storage_>(
          std::in_place_index<3>,
          ::fidl::internal::NaturalClone(std::get<3>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::Union test_union::Union::WithPrimitive(int32_t val) {
  return Union(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::Union::Storage_> test_union::Union::primitive() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::Union::Storage_> test_union::Union::primitive() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::Union& test_union::Union::primitive(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::Union test_union::Union::WithStringNeedsConstructor(::std::string val) {
  return Union(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::Union::Storage_> test_union::Union::string_needs_constructor() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::Union::Storage_> test_union::Union::string_needs_constructor() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::Union& test_union::Union::string_needs_constructor(::std::string value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}
::test_union::Union test_union::Union::WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string> val) {
  return Union(std::make_shared<Storage_>(
      std::in_place_index_t<3>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<3, ::test_union::Union::Storage_> test_union::Union::vector_string_also_needs_constructor() const {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<3, ::test_union::Union::Storage_> test_union::Union::vector_string_also_needs_constructor() {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::test_union::Union& test_union::Union::vector_string_also_needs_constructor(::std::vector<::std::string> value) {
  storage_->emplace<3>(std::move(value));
  return *this;
}

::test_union::FlexibleUnion::FlexibleUnion(FlexibleUnion&& other) noexcept : FlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::FlexibleUnion& ::test_union::FlexibleUnion::operator=(FlexibleUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::FlexibleUnion::FlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::FlexibleUnion::FlexibleUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::FlexibleUnion::Tag test_union::FlexibleUnion::Which() const {
  return FlexibleUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::FlexibleUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FlexibleUnion::Tag tag) {
  switch (tag) {
    case ::test_union::FlexibleUnion::Tag::kPrimitive:
      return 1;
    case ::test_union::FlexibleUnion::Tag::kStringNeedsConstructor:
      return 2;
    case ::test_union::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
      return 3;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::FlexibleUnion::Tag> test_union::FlexibleUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::FlexibleUnion::Tag::kPrimitive;
    case 2:
      return ::test_union::FlexibleUnion::Tag::kStringNeedsConstructor;
    case 3:
      return ::test_union::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor;
    default:
      return ::test_union::FlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::FlexibleUnion::FlexibleUnion(const FlexibleUnion& other) noexcept : FlexibleUnion(other.CloneStorage_()) {}

::test_union::FlexibleUnion& test_union::FlexibleUnion::operator=(const FlexibleUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::FlexibleUnion::operator==(const FlexibleUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::FlexibleUnion::operator!=(const FlexibleUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::FlexibleUnion::Storage_> test_union::FlexibleUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    case 3:
      return std::make_shared<Storage_>(
          std::in_place_index<3>,
          ::fidl::internal::NaturalClone(std::get<3>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::FlexibleUnion::IsUnknown() const {
  return Which() == ::test_union::FlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::FlexibleUnion test_union::FlexibleUnion::WithPrimitive(int32_t val) {
  return FlexibleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::FlexibleUnion::Storage_> test_union::FlexibleUnion::primitive() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::FlexibleUnion::Storage_> test_union::FlexibleUnion::primitive() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::FlexibleUnion& test_union::FlexibleUnion::primitive(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::FlexibleUnion test_union::FlexibleUnion::WithStringNeedsConstructor(::std::string val) {
  return FlexibleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::FlexibleUnion::Storage_> test_union::FlexibleUnion::string_needs_constructor() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::FlexibleUnion::Storage_> test_union::FlexibleUnion::string_needs_constructor() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::FlexibleUnion& test_union::FlexibleUnion::string_needs_constructor(::std::string value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}
::test_union::FlexibleUnion test_union::FlexibleUnion::WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string> val) {
  return FlexibleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<3>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<3, ::test_union::FlexibleUnion::Storage_> test_union::FlexibleUnion::vector_string_also_needs_constructor() const {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<3, ::test_union::FlexibleUnion::Storage_> test_union::FlexibleUnion::vector_string_also_needs_constructor() {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::test_union::FlexibleUnion& test_union::FlexibleUnion::vector_string_also_needs_constructor(::std::vector<::std::string> value) {
  storage_->emplace<3>(std::move(value));
  return *this;
}

::test_union::StrictUnion::StrictUnion(StrictUnion&& other) noexcept : StrictUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::StrictUnion& ::test_union::StrictUnion::operator=(StrictUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::StrictUnion::StrictUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::StrictUnion::StrictUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::StrictUnion::Tag test_union::StrictUnion::Which() const {
  return StrictUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::StrictUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictUnion::Tag tag) {
  switch (tag) {
    case ::test_union::StrictUnion::Tag::kPrimitive:
      return 1;
    case ::test_union::StrictUnion::Tag::kStringNeedsConstructor:
      return 2;
    case ::test_union::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
      return 3;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::StrictUnion::Tag> test_union::StrictUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::StrictUnion::Tag::kPrimitive;
    case 2:
      return ::test_union::StrictUnion::Tag::kStringNeedsConstructor;
    case 3:
      return ::test_union::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor;
    default:
      return std::nullopt;
  }
}

::test_union::StrictUnion::StrictUnion(const StrictUnion& other) noexcept : StrictUnion(other.CloneStorage_()) {}

::test_union::StrictUnion& test_union::StrictUnion::operator=(const StrictUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::StrictUnion::operator==(const StrictUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::StrictUnion::operator!=(const StrictUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::StrictUnion::Storage_> test_union::StrictUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    case 3:
      return std::make_shared<Storage_>(
          std::in_place_index<3>,
          ::fidl::internal::NaturalClone(std::get<3>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::StrictUnion test_union::StrictUnion::WithPrimitive(int32_t val) {
  return StrictUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::StrictUnion::Storage_> test_union::StrictUnion::primitive() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::StrictUnion::Storage_> test_union::StrictUnion::primitive() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::StrictUnion& test_union::StrictUnion::primitive(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::StrictUnion test_union::StrictUnion::WithStringNeedsConstructor(::std::string val) {
  return StrictUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::StrictUnion::Storage_> test_union::StrictUnion::string_needs_constructor() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::StrictUnion::Storage_> test_union::StrictUnion::string_needs_constructor() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::StrictUnion& test_union::StrictUnion::string_needs_constructor(::std::string value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}
::test_union::StrictUnion test_union::StrictUnion::WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string> val) {
  return StrictUnion(std::make_shared<Storage_>(
      std::in_place_index_t<3>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<3, ::test_union::StrictUnion::Storage_> test_union::StrictUnion::vector_string_also_needs_constructor() const {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<3, ::test_union::StrictUnion::Storage_> test_union::StrictUnion::vector_string_also_needs_constructor() {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::test_union::StrictUnion& test_union::StrictUnion::vector_string_also_needs_constructor(::std::vector<::std::string> value) {
  storage_->emplace<3>(std::move(value));
  return *this;
}

::test_union::FieldCollision::FieldCollision(FieldCollision&& other) noexcept : FieldCollision(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::FieldCollision& ::test_union::FieldCollision::operator=(FieldCollision&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::FieldCollision::FieldCollision(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::FieldCollision::FieldCollision(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::FieldCollision::Tag test_union::FieldCollision::Which() const {
  return FieldCollision::IndexToTag(storage_->index()).value();
}

size_t test_union::FieldCollision::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FieldCollision::Tag tag) {
  switch (tag) {
    case ::test_union::FieldCollision::Tag::kFieldCollisionTag:
      return 1;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::FieldCollision::Tag> test_union::FieldCollision::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::FieldCollision::Tag::kFieldCollisionTag;
    default:
      return std::nullopt;
  }
}

::test_union::FieldCollision::FieldCollision(const FieldCollision& other) noexcept : FieldCollision(other.CloneStorage_()) {}

::test_union::FieldCollision& test_union::FieldCollision::operator=(const FieldCollision& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::FieldCollision::operator==(const FieldCollision& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::FieldCollision::operator!=(const FieldCollision& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::FieldCollision::Storage_> test_union::FieldCollision::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::FieldCollision test_union::FieldCollision::WithFieldCollisionTag(int32_t val) {
  return FieldCollision(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::FieldCollision::Storage_> test_union::FieldCollision::field_collision_tag() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::FieldCollision::Storage_> test_union::FieldCollision::field_collision_tag() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::FieldCollision& test_union::FieldCollision::field_collision_tag(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_union::ExplicitUnion::ExplicitUnion(ExplicitUnion&& other) noexcept : ExplicitUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::ExplicitUnion& ::test_union::ExplicitUnion::operator=(ExplicitUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::ExplicitUnion::ExplicitUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::ExplicitUnion::ExplicitUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::ExplicitUnion::Tag test_union::ExplicitUnion::Which() const {
  return ExplicitUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::ExplicitUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitUnion::Tag tag) {
  switch (tag) {
    case ::test_union::ExplicitUnion::Tag::kPrimitive:
      return 1;
    case ::test_union::ExplicitUnion::Tag::kStringNeedsConstructor:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::ExplicitUnion::Tag> test_union::ExplicitUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::ExplicitUnion::Tag::kPrimitive;
    case 2:
      return ::test_union::ExplicitUnion::Tag::kStringNeedsConstructor;
    default:
      return std::nullopt;
  }
}

::test_union::ExplicitUnion::ExplicitUnion(const ExplicitUnion& other) noexcept : ExplicitUnion(other.CloneStorage_()) {}

::test_union::ExplicitUnion& test_union::ExplicitUnion::operator=(const ExplicitUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::ExplicitUnion::operator==(const ExplicitUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::ExplicitUnion::operator!=(const ExplicitUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::ExplicitUnion::Storage_> test_union::ExplicitUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::ExplicitUnion test_union::ExplicitUnion::WithPrimitive(int32_t val) {
  return ExplicitUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::ExplicitUnion::Storage_> test_union::ExplicitUnion::primitive() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::ExplicitUnion::Storage_> test_union::ExplicitUnion::primitive() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::ExplicitUnion& test_union::ExplicitUnion::primitive(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::ExplicitUnion test_union::ExplicitUnion::WithStringNeedsConstructor(::std::string val) {
  return ExplicitUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::ExplicitUnion::Storage_> test_union::ExplicitUnion::string_needs_constructor() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::ExplicitUnion::Storage_> test_union::ExplicitUnion::string_needs_constructor() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::ExplicitUnion& test_union::ExplicitUnion::string_needs_constructor(::std::string value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::ReverseOrdinalUnion::ReverseOrdinalUnion(ReverseOrdinalUnion&& other) noexcept : ReverseOrdinalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::ReverseOrdinalUnion& ::test_union::ReverseOrdinalUnion::operator=(ReverseOrdinalUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::ReverseOrdinalUnion::ReverseOrdinalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::ReverseOrdinalUnion::ReverseOrdinalUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::ReverseOrdinalUnion::Tag test_union::ReverseOrdinalUnion::Which() const {
  return ReverseOrdinalUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::ReverseOrdinalUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ReverseOrdinalUnion::Tag tag) {
  switch (tag) {
    case ::test_union::ReverseOrdinalUnion::Tag::kFirst:
      return 1;
    case ::test_union::ReverseOrdinalUnion::Tag::kSecond:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::ReverseOrdinalUnion::Tag> test_union::ReverseOrdinalUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::ReverseOrdinalUnion::Tag::kFirst;
    case 2:
      return ::test_union::ReverseOrdinalUnion::Tag::kSecond;
    default:
      return std::nullopt;
  }
}

::test_union::ReverseOrdinalUnion::ReverseOrdinalUnion(const ReverseOrdinalUnion& other) noexcept : ReverseOrdinalUnion(other.CloneStorage_()) {}

::test_union::ReverseOrdinalUnion& test_union::ReverseOrdinalUnion::operator=(const ReverseOrdinalUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::ReverseOrdinalUnion::operator==(const ReverseOrdinalUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::ReverseOrdinalUnion::operator!=(const ReverseOrdinalUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::ReverseOrdinalUnion::Storage_> test_union::ReverseOrdinalUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::ReverseOrdinalUnion test_union::ReverseOrdinalUnion::WithFirst(uint32_t val) {
  return ReverseOrdinalUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::ReverseOrdinalUnion::Storage_> test_union::ReverseOrdinalUnion::first() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::ReverseOrdinalUnion::Storage_> test_union::ReverseOrdinalUnion::first() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::ReverseOrdinalUnion& test_union::ReverseOrdinalUnion::first(uint32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::ReverseOrdinalUnion test_union::ReverseOrdinalUnion::WithSecond(uint32_t val) {
  return ReverseOrdinalUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::ReverseOrdinalUnion::Storage_> test_union::ReverseOrdinalUnion::second() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::ReverseOrdinalUnion::Storage_> test_union::ReverseOrdinalUnion::second() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::ReverseOrdinalUnion& test_union::ReverseOrdinalUnion::second(uint32_t value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::FlexibleFoo::FlexibleFoo(FlexibleFoo&& other) noexcept : FlexibleFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::FlexibleFoo& ::test_union::FlexibleFoo::operator=(FlexibleFoo&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::FlexibleFoo::FlexibleFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::FlexibleFoo::FlexibleFoo(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::FlexibleFoo::Tag test_union::FlexibleFoo::Which() const {
  return FlexibleFoo::IndexToTag(storage_->index()).value();
}

size_t test_union::FlexibleFoo::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FlexibleFoo::Tag tag) {
  switch (tag) {
    case ::test_union::FlexibleFoo::Tag::kS:
      return 1;
    case ::test_union::FlexibleFoo::Tag::kI:
      return 2;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::FlexibleFoo::Tag> test_union::FlexibleFoo::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::FlexibleFoo::Tag::kS;
    case 2:
      return ::test_union::FlexibleFoo::Tag::kI;
    default:
      return ::test_union::FlexibleFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::FlexibleFoo::FlexibleFoo(const FlexibleFoo& other) noexcept : FlexibleFoo(other.CloneStorage_()) {}

::test_union::FlexibleFoo& test_union::FlexibleFoo::operator=(const FlexibleFoo& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::FlexibleFoo::operator==(const FlexibleFoo& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::FlexibleFoo::operator!=(const FlexibleFoo& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::FlexibleFoo::Storage_> test_union::FlexibleFoo::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::FlexibleFoo::IsUnknown() const {
  return Which() == ::test_union::FlexibleFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::FlexibleFoo test_union::FlexibleFoo::WithS(::std::string val) {
  return FlexibleFoo(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::FlexibleFoo::Storage_> test_union::FlexibleFoo::s() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::FlexibleFoo::Storage_> test_union::FlexibleFoo::s() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::FlexibleFoo& test_union::FlexibleFoo::s(::std::string value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::FlexibleFoo test_union::FlexibleFoo::WithI(int32_t val) {
  return FlexibleFoo(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::FlexibleFoo::Storage_> test_union::FlexibleFoo::i() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::FlexibleFoo::Storage_> test_union::FlexibleFoo::i() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::FlexibleFoo& test_union::FlexibleFoo::i(int32_t value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::StrictFoo::StrictFoo(StrictFoo&& other) noexcept : StrictFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::StrictFoo& ::test_union::StrictFoo::operator=(StrictFoo&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::StrictFoo::StrictFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::StrictFoo::StrictFoo(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::StrictFoo::Tag test_union::StrictFoo::Which() const {
  return StrictFoo::IndexToTag(storage_->index()).value();
}

size_t test_union::StrictFoo::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictFoo::Tag tag) {
  switch (tag) {
    case ::test_union::StrictFoo::Tag::kS:
      return 1;
    case ::test_union::StrictFoo::Tag::kI:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::StrictFoo::Tag> test_union::StrictFoo::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::StrictFoo::Tag::kS;
    case 2:
      return ::test_union::StrictFoo::Tag::kI;
    default:
      return std::nullopt;
  }
}

::test_union::StrictFoo::StrictFoo(const StrictFoo& other) noexcept : StrictFoo(other.CloneStorage_()) {}

::test_union::StrictFoo& test_union::StrictFoo::operator=(const StrictFoo& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::StrictFoo::operator==(const StrictFoo& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::StrictFoo::operator!=(const StrictFoo& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::StrictFoo::Storage_> test_union::StrictFoo::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::StrictFoo test_union::StrictFoo::WithS(::std::string val) {
  return StrictFoo(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::StrictFoo::Storage_> test_union::StrictFoo::s() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::StrictFoo::Storage_> test_union::StrictFoo::s() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::StrictFoo& test_union::StrictFoo::s(::std::string value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::StrictFoo test_union::StrictFoo::WithI(int32_t val) {
  return StrictFoo(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::StrictFoo::Storage_> test_union::StrictFoo::i() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::StrictFoo::Storage_> test_union::StrictFoo::i() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::StrictFoo& test_union::StrictFoo::i(int32_t value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::ExplicitFoo::ExplicitFoo(ExplicitFoo&& other) noexcept : ExplicitFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::ExplicitFoo& ::test_union::ExplicitFoo::operator=(ExplicitFoo&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::ExplicitFoo::ExplicitFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::ExplicitFoo::ExplicitFoo(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::ExplicitFoo::Tag test_union::ExplicitFoo::Which() const {
  return ExplicitFoo::IndexToTag(storage_->index()).value();
}

size_t test_union::ExplicitFoo::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitFoo::Tag tag) {
  switch (tag) {
    case ::test_union::ExplicitFoo::Tag::kI:
      return 1;
    case ::test_union::ExplicitFoo::Tag::kS:
      return 2;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::ExplicitFoo::Tag> test_union::ExplicitFoo::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::ExplicitFoo::Tag::kI;
    case 2:
      return ::test_union::ExplicitFoo::Tag::kS;
    default:
      return ::test_union::ExplicitFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::ExplicitFoo::ExplicitFoo(const ExplicitFoo& other) noexcept : ExplicitFoo(other.CloneStorage_()) {}

::test_union::ExplicitFoo& test_union::ExplicitFoo::operator=(const ExplicitFoo& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::ExplicitFoo::operator==(const ExplicitFoo& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::ExplicitFoo::operator!=(const ExplicitFoo& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::ExplicitFoo::Storage_> test_union::ExplicitFoo::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::ExplicitFoo::IsUnknown() const {
  return Which() == ::test_union::ExplicitFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::ExplicitFoo test_union::ExplicitFoo::WithI(int32_t val) {
  return ExplicitFoo(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::ExplicitFoo::Storage_> test_union::ExplicitFoo::i() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::ExplicitFoo::Storage_> test_union::ExplicitFoo::i() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::ExplicitFoo& test_union::ExplicitFoo::i(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::ExplicitFoo test_union::ExplicitFoo::WithS(::std::string val) {
  return ExplicitFoo(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::ExplicitFoo::Storage_> test_union::ExplicitFoo::s() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::ExplicitFoo::Storage_> test_union::ExplicitFoo::s() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::ExplicitFoo& test_union::ExplicitFoo::s(::std::string value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::ExplicitStrictFoo::ExplicitStrictFoo(ExplicitStrictFoo&& other) noexcept : ExplicitStrictFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::ExplicitStrictFoo& ::test_union::ExplicitStrictFoo::operator=(ExplicitStrictFoo&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::ExplicitStrictFoo::ExplicitStrictFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::ExplicitStrictFoo::ExplicitStrictFoo(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::ExplicitStrictFoo::Tag test_union::ExplicitStrictFoo::Which() const {
  return ExplicitStrictFoo::IndexToTag(storage_->index()).value();
}

size_t test_union::ExplicitStrictFoo::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitStrictFoo::Tag tag) {
  switch (tag) {
    case ::test_union::ExplicitStrictFoo::Tag::kI:
      return 1;
    case ::test_union::ExplicitStrictFoo::Tag::kS:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::ExplicitStrictFoo::Tag> test_union::ExplicitStrictFoo::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::ExplicitStrictFoo::Tag::kI;
    case 2:
      return ::test_union::ExplicitStrictFoo::Tag::kS;
    default:
      return std::nullopt;
  }
}

::test_union::ExplicitStrictFoo::ExplicitStrictFoo(const ExplicitStrictFoo& other) noexcept : ExplicitStrictFoo(other.CloneStorage_()) {}

::test_union::ExplicitStrictFoo& test_union::ExplicitStrictFoo::operator=(const ExplicitStrictFoo& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::ExplicitStrictFoo::operator==(const ExplicitStrictFoo& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::ExplicitStrictFoo::operator!=(const ExplicitStrictFoo& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::ExplicitStrictFoo::Storage_> test_union::ExplicitStrictFoo::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::ExplicitStrictFoo test_union::ExplicitStrictFoo::WithI(int32_t val) {
  return ExplicitStrictFoo(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::ExplicitStrictFoo::Storage_> test_union::ExplicitStrictFoo::i() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::ExplicitStrictFoo::Storage_> test_union::ExplicitStrictFoo::i() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::ExplicitStrictFoo& test_union::ExplicitStrictFoo::i(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::ExplicitStrictFoo test_union::ExplicitStrictFoo::WithS(::std::string val) {
  return ExplicitStrictFoo(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::ExplicitStrictFoo::Storage_> test_union::ExplicitStrictFoo::s() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::ExplicitStrictFoo::Storage_> test_union::ExplicitStrictFoo::s() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::ExplicitStrictFoo& test_union::ExplicitStrictFoo::s(::std::string value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::OlderSimpleUnion::OlderSimpleUnion(OlderSimpleUnion&& other) noexcept : OlderSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::OlderSimpleUnion& ::test_union::OlderSimpleUnion::operator=(OlderSimpleUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::OlderSimpleUnion::OlderSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::OlderSimpleUnion::OlderSimpleUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::OlderSimpleUnion::Tag test_union::OlderSimpleUnion::Which() const {
  return OlderSimpleUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::OlderSimpleUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::OlderSimpleUnion::Tag tag) {
  switch (tag) {
    case ::test_union::OlderSimpleUnion::Tag::kI:
      return 1;
    case ::test_union::OlderSimpleUnion::Tag::kF:
      return 2;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::OlderSimpleUnion::Tag> test_union::OlderSimpleUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::OlderSimpleUnion::Tag::kI;
    case 2:
      return ::test_union::OlderSimpleUnion::Tag::kF;
    default:
      return ::test_union::OlderSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::OlderSimpleUnion::OlderSimpleUnion(const OlderSimpleUnion& other) noexcept : OlderSimpleUnion(other.CloneStorage_()) {}

::test_union::OlderSimpleUnion& test_union::OlderSimpleUnion::operator=(const OlderSimpleUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::OlderSimpleUnion::operator==(const OlderSimpleUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::OlderSimpleUnion::operator!=(const OlderSimpleUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::OlderSimpleUnion::Storage_> test_union::OlderSimpleUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::OlderSimpleUnion::IsUnknown() const {
  return Which() == ::test_union::OlderSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::OlderSimpleUnion test_union::OlderSimpleUnion::WithI(int64_t val) {
  return OlderSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::OlderSimpleUnion::Storage_> test_union::OlderSimpleUnion::i() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::OlderSimpleUnion::Storage_> test_union::OlderSimpleUnion::i() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::OlderSimpleUnion& test_union::OlderSimpleUnion::i(int64_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::OlderSimpleUnion test_union::OlderSimpleUnion::WithF(float val) {
  return OlderSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::OlderSimpleUnion::Storage_> test_union::OlderSimpleUnion::f() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::OlderSimpleUnion::Storage_> test_union::OlderSimpleUnion::f() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::OlderSimpleUnion& test_union::OlderSimpleUnion::f(float value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::NewerSimpleUnion::NewerSimpleUnion(NewerSimpleUnion&& other) noexcept : NewerSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::NewerSimpleUnion& ::test_union::NewerSimpleUnion::operator=(NewerSimpleUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::NewerSimpleUnion::NewerSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::NewerSimpleUnion::NewerSimpleUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::NewerSimpleUnion::Tag test_union::NewerSimpleUnion::Which() const {
  return NewerSimpleUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::NewerSimpleUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::NewerSimpleUnion::Tag tag) {
  switch (tag) {
    case ::test_union::NewerSimpleUnion::Tag::kI:
      return 1;
    case ::test_union::NewerSimpleUnion::Tag::kS:
      return 2;
    case ::test_union::NewerSimpleUnion::Tag::kV:
      return 3;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::NewerSimpleUnion::Tag> test_union::NewerSimpleUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::NewerSimpleUnion::Tag::kI;
    case 2:
      return ::test_union::NewerSimpleUnion::Tag::kS;
    case 3:
      return ::test_union::NewerSimpleUnion::Tag::kV;
    default:
      return ::test_union::NewerSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::NewerSimpleUnion::NewerSimpleUnion(const NewerSimpleUnion& other) noexcept : NewerSimpleUnion(other.CloneStorage_()) {}

::test_union::NewerSimpleUnion& test_union::NewerSimpleUnion::operator=(const NewerSimpleUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::NewerSimpleUnion::operator==(const NewerSimpleUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::NewerSimpleUnion::operator!=(const NewerSimpleUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::NewerSimpleUnion::Storage_> test_union::NewerSimpleUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    case 3:
      return std::make_shared<Storage_>(
          std::in_place_index<3>,
          ::fidl::internal::NaturalClone(std::get<3>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::NewerSimpleUnion::IsUnknown() const {
  return Which() == ::test_union::NewerSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::NewerSimpleUnion test_union::NewerSimpleUnion::WithI(int64_t val) {
  return NewerSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::NewerSimpleUnion::Storage_> test_union::NewerSimpleUnion::i() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::NewerSimpleUnion::Storage_> test_union::NewerSimpleUnion::i() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::NewerSimpleUnion& test_union::NewerSimpleUnion::i(int64_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::NewerSimpleUnion test_union::NewerSimpleUnion::WithS(::std::string val) {
  return NewerSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::NewerSimpleUnion::Storage_> test_union::NewerSimpleUnion::s() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::NewerSimpleUnion::Storage_> test_union::NewerSimpleUnion::s() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::NewerSimpleUnion& test_union::NewerSimpleUnion::s(::std::string value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}
::test_union::NewerSimpleUnion test_union::NewerSimpleUnion::WithV(::std::vector<::std::string> val) {
  return NewerSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<3>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<3, ::test_union::NewerSimpleUnion::Storage_> test_union::NewerSimpleUnion::v() const {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<3, ::test_union::NewerSimpleUnion::Storage_> test_union::NewerSimpleUnion::v() {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::test_union::NewerSimpleUnion& test_union::NewerSimpleUnion::v(::std::vector<::std::string> value) {
  storage_->emplace<3>(std::move(value));
  return *this;
}

::test_union::StrictSimpleUnion::StrictSimpleUnion(StrictSimpleUnion&& other) noexcept : StrictSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::StrictSimpleUnion& ::test_union::StrictSimpleUnion::operator=(StrictSimpleUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::StrictSimpleUnion::StrictSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::StrictSimpleUnion::StrictSimpleUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::StrictSimpleUnion::Tag test_union::StrictSimpleUnion::Which() const {
  return StrictSimpleUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::StrictSimpleUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictSimpleUnion::Tag tag) {
  switch (tag) {
    case ::test_union::StrictSimpleUnion::Tag::kI:
      return 1;
    case ::test_union::StrictSimpleUnion::Tag::kF:
      return 2;
    case ::test_union::StrictSimpleUnion::Tag::kS:
      return 3;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::StrictSimpleUnion::Tag> test_union::StrictSimpleUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::StrictSimpleUnion::Tag::kI;
    case 2:
      return ::test_union::StrictSimpleUnion::Tag::kF;
    case 3:
      return ::test_union::StrictSimpleUnion::Tag::kS;
    default:
      return std::nullopt;
  }
}

::test_union::StrictSimpleUnion::StrictSimpleUnion(const StrictSimpleUnion& other) noexcept : StrictSimpleUnion(other.CloneStorage_()) {}

::test_union::StrictSimpleUnion& test_union::StrictSimpleUnion::operator=(const StrictSimpleUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::StrictSimpleUnion::operator==(const StrictSimpleUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::StrictSimpleUnion::operator!=(const StrictSimpleUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::StrictSimpleUnion::Storage_> test_union::StrictSimpleUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    case 3:
      return std::make_shared<Storage_>(
          std::in_place_index<3>,
          ::fidl::internal::NaturalClone(std::get<3>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::StrictSimpleUnion test_union::StrictSimpleUnion::WithI(int32_t val) {
  return StrictSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::StrictSimpleUnion::Storage_> test_union::StrictSimpleUnion::i() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::StrictSimpleUnion::Storage_> test_union::StrictSimpleUnion::i() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::StrictSimpleUnion& test_union::StrictSimpleUnion::i(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::StrictSimpleUnion test_union::StrictSimpleUnion::WithF(float val) {
  return StrictSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::StrictSimpleUnion::Storage_> test_union::StrictSimpleUnion::f() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::StrictSimpleUnion::Storage_> test_union::StrictSimpleUnion::f() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::StrictSimpleUnion& test_union::StrictSimpleUnion::f(float value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}
::test_union::StrictSimpleUnion test_union::StrictSimpleUnion::WithS(::std::string val) {
  return StrictSimpleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<3>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<3, ::test_union::StrictSimpleUnion::Storage_> test_union::StrictSimpleUnion::s() const {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<3, ::test_union::StrictSimpleUnion::Storage_> test_union::StrictSimpleUnion::s() {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::test_union::StrictSimpleUnion& test_union::StrictSimpleUnion::s(::std::string value) {
  storage_->emplace<3>(std::move(value));
  return *this;
}

::test_union::UnionContainingEmptyStruct::UnionContainingEmptyStruct(UnionContainingEmptyStruct&& other) noexcept : UnionContainingEmptyStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::UnionContainingEmptyStruct& ::test_union::UnionContainingEmptyStruct::operator=(UnionContainingEmptyStruct&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::UnionContainingEmptyStruct::UnionContainingEmptyStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::UnionContainingEmptyStruct::UnionContainingEmptyStruct(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::UnionContainingEmptyStruct::Tag test_union::UnionContainingEmptyStruct::Which() const {
  return UnionContainingEmptyStruct::IndexToTag(storage_->index()).value();
}

size_t test_union::UnionContainingEmptyStruct::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::UnionContainingEmptyStruct::Tag tag) {
  switch (tag) {
    case ::test_union::UnionContainingEmptyStruct::Tag::kEmpty:
      return 1;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::UnionContainingEmptyStruct::Tag> test_union::UnionContainingEmptyStruct::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::UnionContainingEmptyStruct::Tag::kEmpty;
    default:
      return ::test_union::UnionContainingEmptyStruct::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::UnionContainingEmptyStruct::UnionContainingEmptyStruct(const UnionContainingEmptyStruct& other) noexcept : UnionContainingEmptyStruct(other.CloneStorage_()) {}

::test_union::UnionContainingEmptyStruct& test_union::UnionContainingEmptyStruct::operator=(const UnionContainingEmptyStruct& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::UnionContainingEmptyStruct::operator==(const UnionContainingEmptyStruct& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::UnionContainingEmptyStruct::operator!=(const UnionContainingEmptyStruct& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::UnionContainingEmptyStruct::Storage_> test_union::UnionContainingEmptyStruct::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::UnionContainingEmptyStruct::IsUnknown() const {
  return Which() == ::test_union::UnionContainingEmptyStruct::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::UnionContainingEmptyStruct test_union::UnionContainingEmptyStruct::WithEmpty(::test_union::Empty val) {
  return UnionContainingEmptyStruct(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::UnionContainingEmptyStruct::Storage_> test_union::UnionContainingEmptyStruct::empty() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::UnionContainingEmptyStruct::Storage_> test_union::UnionContainingEmptyStruct::empty() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::UnionContainingEmptyStruct& test_union::UnionContainingEmptyStruct::empty(::test_union::Empty value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_union::StrictBoundedUnion::StrictBoundedUnion(StrictBoundedUnion&& other) noexcept : StrictBoundedUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::StrictBoundedUnion& ::test_union::StrictBoundedUnion::operator=(StrictBoundedUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::StrictBoundedUnion::StrictBoundedUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::StrictBoundedUnion::StrictBoundedUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::StrictBoundedUnion::Tag test_union::StrictBoundedUnion::Which() const {
  return StrictBoundedUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::StrictBoundedUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictBoundedUnion::Tag tag) {
  switch (tag) {
    case ::test_union::StrictBoundedUnion::Tag::kV:
      return 1;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_union::StrictBoundedUnion::Tag> test_union::StrictBoundedUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::StrictBoundedUnion::Tag::kV;
    default:
      return std::nullopt;
  }
}

::test_union::StrictBoundedUnion::StrictBoundedUnion(const StrictBoundedUnion& other) noexcept : StrictBoundedUnion(other.CloneStorage_()) {}

::test_union::StrictBoundedUnion& test_union::StrictBoundedUnion::operator=(const StrictBoundedUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::StrictBoundedUnion::operator==(const StrictBoundedUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::StrictBoundedUnion::operator!=(const StrictBoundedUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::StrictBoundedUnion::Storage_> test_union::StrictBoundedUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_union::StrictBoundedUnion test_union::StrictBoundedUnion::WithV(::std::vector<uint8_t> val) {
  return StrictBoundedUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::StrictBoundedUnion::Storage_> test_union::StrictBoundedUnion::v() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::StrictBoundedUnion::Storage_> test_union::StrictBoundedUnion::v() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::StrictBoundedUnion& test_union::StrictBoundedUnion::v(::std::vector<uint8_t> value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_union::ExplicitFlexibleUnion::ExplicitFlexibleUnion(ExplicitFlexibleUnion&& other) noexcept : ExplicitFlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::ExplicitFlexibleUnion& ::test_union::ExplicitFlexibleUnion::operator=(ExplicitFlexibleUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::ExplicitFlexibleUnion::ExplicitFlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::ExplicitFlexibleUnion::ExplicitFlexibleUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::ExplicitFlexibleUnion::Tag test_union::ExplicitFlexibleUnion::Which() const {
  return ExplicitFlexibleUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::ExplicitFlexibleUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitFlexibleUnion::Tag tag) {
  switch (tag) {
    case ::test_union::ExplicitFlexibleUnion::Tag::kI:
      return 1;
    case ::test_union::ExplicitFlexibleUnion::Tag::kF:
      return 2;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::ExplicitFlexibleUnion::Tag> test_union::ExplicitFlexibleUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::ExplicitFlexibleUnion::Tag::kI;
    case 2:
      return ::test_union::ExplicitFlexibleUnion::Tag::kF;
    default:
      return ::test_union::ExplicitFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::ExplicitFlexibleUnion::ExplicitFlexibleUnion(const ExplicitFlexibleUnion& other) noexcept : ExplicitFlexibleUnion(other.CloneStorage_()) {}

::test_union::ExplicitFlexibleUnion& test_union::ExplicitFlexibleUnion::operator=(const ExplicitFlexibleUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::ExplicitFlexibleUnion::operator==(const ExplicitFlexibleUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::ExplicitFlexibleUnion::operator!=(const ExplicitFlexibleUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::ExplicitFlexibleUnion::Storage_> test_union::ExplicitFlexibleUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::ExplicitFlexibleUnion::IsUnknown() const {
  return Which() == ::test_union::ExplicitFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::ExplicitFlexibleUnion test_union::ExplicitFlexibleUnion::WithI(int64_t val) {
  return ExplicitFlexibleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::ExplicitFlexibleUnion::Storage_> test_union::ExplicitFlexibleUnion::i() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::ExplicitFlexibleUnion::Storage_> test_union::ExplicitFlexibleUnion::i() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::ExplicitFlexibleUnion& test_union::ExplicitFlexibleUnion::i(int64_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_union::ExplicitFlexibleUnion test_union::ExplicitFlexibleUnion::WithF(float val) {
  return ExplicitFlexibleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_union::ExplicitFlexibleUnion::Storage_> test_union::ExplicitFlexibleUnion::f() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_union::ExplicitFlexibleUnion::Storage_> test_union::ExplicitFlexibleUnion::f() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_union::ExplicitFlexibleUnion& test_union::ExplicitFlexibleUnion::f(float value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

::test_union::UnionWithAttributes::UnionWithAttributes(UnionWithAttributes&& other) noexcept : UnionWithAttributes(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::UnionWithAttributes& ::test_union::UnionWithAttributes::operator=(UnionWithAttributes&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::UnionWithAttributes::UnionWithAttributes(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::UnionWithAttributes::UnionWithAttributes(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::UnionWithAttributes::Tag test_union::UnionWithAttributes::Which() const {
  return UnionWithAttributes::IndexToTag(storage_->index()).value();
}

size_t test_union::UnionWithAttributes::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::UnionWithAttributes::Tag tag) {
  switch (tag) {
    case ::test_union::UnionWithAttributes::Tag::kX:
      return 1;
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::UnionWithAttributes::Tag> test_union::UnionWithAttributes::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_union::UnionWithAttributes::Tag::kX;
    default:
      return ::test_union::UnionWithAttributes::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::UnionWithAttributes::UnionWithAttributes(const UnionWithAttributes& other) noexcept : UnionWithAttributes(other.CloneStorage_()) {}

::test_union::UnionWithAttributes& test_union::UnionWithAttributes::operator=(const UnionWithAttributes& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::UnionWithAttributes::operator==(const UnionWithAttributes& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::UnionWithAttributes::operator!=(const UnionWithAttributes& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::UnionWithAttributes::Storage_> test_union::UnionWithAttributes::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::UnionWithAttributes::IsUnknown() const {
  return Which() == ::test_union::UnionWithAttributes::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_union::UnionWithAttributes test_union::UnionWithAttributes::WithX(int64_t val) {
  return UnionWithAttributes(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_union::UnionWithAttributes::Storage_> test_union::UnionWithAttributes::x() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_union::UnionWithAttributes::Storage_> test_union::UnionWithAttributes::x() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_union::UnionWithAttributes& test_union::UnionWithAttributes::x(int64_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_union::EmptyFlexibleUnion::EmptyFlexibleUnion(EmptyFlexibleUnion&& other) noexcept : EmptyFlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_union::EmptyFlexibleUnion& ::test_union::EmptyFlexibleUnion::operator=(EmptyFlexibleUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_union::EmptyFlexibleUnion::EmptyFlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_union::EmptyFlexibleUnion::EmptyFlexibleUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_union::EmptyFlexibleUnion::Tag test_union::EmptyFlexibleUnion::Which() const {
  return EmptyFlexibleUnion::IndexToTag(storage_->index()).value();
}

size_t test_union::EmptyFlexibleUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::EmptyFlexibleUnion::Tag tag) {
  switch (tag) {
    default: {
      return 0;
    }
  }
}

std::optional<::test_union::EmptyFlexibleUnion::Tag> test_union::EmptyFlexibleUnion::IndexToTag(size_t index) {
  switch (index) {
    default:
      return ::test_union::EmptyFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_union::EmptyFlexibleUnion::EmptyFlexibleUnion(const EmptyFlexibleUnion& other) noexcept : EmptyFlexibleUnion(other.CloneStorage_()) {}

::test_union::EmptyFlexibleUnion& test_union::EmptyFlexibleUnion::operator=(const EmptyFlexibleUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_union::EmptyFlexibleUnion::operator==(const EmptyFlexibleUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_union::EmptyFlexibleUnion::operator!=(const EmptyFlexibleUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_union::EmptyFlexibleUnion::Storage_> test_union::EmptyFlexibleUnion::CloneStorage_() const {
  switch (storage_->index()) {
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_union::EmptyFlexibleUnion::IsUnknown() const {
  return Which() == ::test_union::EmptyFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}

#pragma clang diagnostic pop
