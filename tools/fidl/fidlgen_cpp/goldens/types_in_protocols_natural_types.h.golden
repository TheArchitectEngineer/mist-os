// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <fidl/test.typesinprotocols/cpp/common_types.h>
#include <fidl/test.typesinprotocols/cpp/markers.h>
#include <lib/fidl/cpp/natural_coding_traits.h>
#include <lib/fidl/cpp/natural_types.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/vmo.h>

#endif  // __Fuchsia__

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_typesinprotocols {

class Struct;

class ResourceStruct;

class Basic;

class Compound;

class ArrayBasic;

class ArrayCompound;

class VectorBasic;

class VectorCompound;

class VectorOptional;

class ArrayVectorNested;

class Resource;

class Table;

class ResourceTable;

class Union;

class ResourceUnion;

class ProtocolErrorBasicResult;

class ProtocolErrorCompoundResult;

class ProtocolErrorArrayBasicResult;

class ProtocolErrorArrayCompoundResult;

class ProtocolErrorVectorBasicResult;

class ProtocolErrorVectorCompoundResult;

class ProtocolErrorVectorOptionalResult;

class ProtocolErrorArrayVectorNestedResult;

class ProtocolErrorResourceResult;

class Struct {
 private:
  struct Storage_;

 public:
  Struct(Storage_ storage) noexcept;
  Struct(uint8_t __reserved) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Struct| only if all of its members are default constructible.
  Struct() = default;
#pragma clang diagnostic pop

  Struct(Struct&&) noexcept = default;
  Struct& operator=(Struct&&) noexcept = default;
  Struct(const Struct& other) noexcept;
  Struct& operator=(const Struct& other) noexcept;

  bool operator==(const Struct& other) const noexcept;
  bool operator!=(const Struct& other) const noexcept;

  uint8_t
  __reserved() const;

  uint8_t& __reserved();

  // Setter for __reserved.
  //

  Struct& __reserved(uint8_t value);

  Struct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    uint8_t __reserved = 0u;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Struct, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Struct>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::__reserved, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class Table {
 private:
  struct Storage_;

 public:
  Table(Storage_ storage) noexcept;
  Table() noexcept = default;
  Table(Table&&) noexcept = default;
  Table& operator=(Table&&) noexcept = default;
  Table(const Table& other) noexcept;
  Table& operator=(const Table& other) noexcept;
  bool operator==(const Table& other) const noexcept;
  bool operator!=(const Table& other) const noexcept;

  bool IsEmpty() const;

  Table(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
  };

  // TODO(https://fxbug.dev/42172795): Box the storage.
  Storage_ storage_;
  Storage_ CloneStorage_() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Table>;
  static constexpr auto kMembers = std::make_tuple();
};

class Union {
 private:
  using Storage_ =
      std::variant<
          std::monostate, bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  Union(Union&& other) noexcept;
  Union& operator=(Union&& other) noexcept;
  Union(const Union& other) noexcept;
  Union& operator=(const Union& other) noexcept;
  bool operator==(const Union& other) const noexcept;
  bool operator!=(const Union& other) const noexcept;
  bool IsUnknown() const;

  ::test_typesinprotocols::Union::Tag Which() const;
  static Union WithB(bool val);
  const ::fidl::internal::UnionMemberView<1, Storage_> b() const;
  ::fidl::internal::UnionMemberView<1, Storage_> b();

  // Sets the union to hold the b member.
  //

  Union& b(bool value);

  Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::Union>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit Union(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::Union::Tag tag);
  static std::optional<::test_typesinprotocols::Union::Tag> IndexToTag(size_t index);
};

#ifdef __Fuchsia__

class ResourceStruct {
 private:
  struct Storage_;

 public:
  ResourceStruct(Storage_ storage) noexcept;
  ResourceStruct(uint8_t __reserved) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ResourceStruct| only if all of its members are default constructible.
  ResourceStruct() = default;
#pragma clang diagnostic pop

  ResourceStruct(ResourceStruct&&) noexcept = default;
  ResourceStruct& operator=(ResourceStruct&&) noexcept = default;

  uint8_t
  __reserved() const;

  uint8_t& __reserved();

  // Setter for __reserved.
  //

  ResourceStruct& __reserved(uint8_t value);

  ResourceStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    uint8_t __reserved = 0u;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ResourceStruct, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ResourceStruct>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::__reserved, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class ResourceTable {
 private:
  struct Storage_;

 public:
  ResourceTable(Storage_ storage) noexcept;
  ResourceTable() noexcept = default;
  ResourceTable(ResourceTable&&) noexcept = default;
  ResourceTable& operator=(ResourceTable&&) noexcept = default;

  bool IsEmpty() const;

  ResourceTable(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
  };

  // TODO(https://fxbug.dev/42172795): Box the storage.
  Storage_ storage_;
  friend struct ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::ResourceTable>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ResourceTable>;
  static constexpr auto kMembers = std::make_tuple();
};

class ResourceUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, bool>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  ResourceUnion(ResourceUnion&& other) noexcept;
  ResourceUnion& operator=(ResourceUnion&& other) noexcept;
  bool IsUnknown() const;

  ::test_typesinprotocols::ResourceUnion::Tag Which() const;
  static ResourceUnion WithB(bool val);
  const ::fidl::internal::UnionMemberView<1, Storage_> b() const;
  ::fidl::internal::UnionMemberView<1, Storage_> b();

  // Sets the union to hold the b member.
  //

  ResourceUnion& b(bool value);

  ResourceUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ResourceUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ResourceUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ResourceUnion::Tag tag);
  static std::optional<::test_typesinprotocols::ResourceUnion::Tag> IndexToTag(size_t index);
};

#endif  // __Fuchsia__

class Basic {
 private:
  struct Storage_;

 public:
  Basic(Storage_ storage) noexcept;
  Basic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::std::optional<::std::string> opt_string) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Basic| only if all of its members are default constructible.
  Basic() = default;
#pragma clang diagnostic pop

  Basic(Basic&&) noexcept = default;
  Basic& operator=(Basic&&) noexcept = default;
  Basic(const Basic& other) noexcept;
  Basic& operator=(const Basic& other) noexcept;

  bool operator==(const Basic& other) const noexcept;
  bool operator!=(const Basic& other) const noexcept;

  uint8_t
  uint8() const;

  uint8_t& uint8();

  // Setter for uint8.
  //

  Basic& uint8(uint8_t value);

  uint16_t
  uint16() const;

  uint16_t& uint16();

  // Setter for uint16.
  //

  Basic& uint16(uint16_t value);

  uint32_t
  uint32() const;

  uint32_t& uint32();

  // Setter for uint32.
  //

  Basic& uint32(uint32_t value);

  uint64_t
  uint64() const;

  uint64_t& uint64();

  // Setter for uint64.
  //

  Basic& uint64(uint64_t value);

  int8_t
  int8() const;

  int8_t& int8();

  // Setter for int8.
  //

  Basic& int8(int8_t value);

  int16_t
  int16() const;

  int16_t& int16();

  // Setter for int16.
  //

  Basic& int16(int16_t value);

  int32_t
  int32() const;

  int32_t& int32();

  // Setter for int32.
  //

  Basic& int32(int32_t value);

  int64_t
  int64() const;

  int64_t& int64();

  // Setter for int64.
  //

  Basic& int64(int64_t value);

  float
  float32() const;

  float& float32();

  // Setter for float32.
  //

  Basic& float32(float value);

  double
  float64() const;

  double& float64();

  // Setter for float64.
  //

  Basic& float64(double value);

  const ::std::string&
  string() const;

  ::std::string& string();

  // Setter for string.
  //

  Basic& string(::std::string value);

  const ::std::optional<::std::string>&
  opt_string() const;

  ::std::optional<::std::string>& opt_string();

  // Setter for opt_string.
  //

  Basic& opt_string(::std::optional<::std::string> value);

  Basic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    uint8_t uint8 = {};
    uint16_t uint16 = {};
    uint32_t uint32 = {};
    uint64_t uint64 = {};
    int8_t int8 = {};
    int16_t int16 = {};
    int32_t int32 = {};
    int64_t int64 = {};
    float float32 = {};
    double float64 = {};
    ::std::string string;
    ::std::optional<::std::string> opt_string;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Basic>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
                                                       &Storage_::uint8, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, uint16_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::uint16, 2}, ::fidl::internal::NaturalStructMember<Storage_, uint32_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::uint32, 4}, ::fidl::internal::NaturalStructMember<Storage_, uint64_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::uint64, 8}, ::fidl::internal::NaturalStructMember<Storage_, int8_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::int8, 16}, ::fidl::internal::NaturalStructMember<Storage_, int16_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::int16, 18}, ::fidl::internal::NaturalStructMember<Storage_, int32_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::int32, 20}, ::fidl::internal::NaturalStructMember<Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::int64, 24}, ::fidl::internal::NaturalStructMember<Storage_, float, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::float32, 32}, ::fidl::internal::NaturalStructMember<Storage_, double, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::float64, 40}, ::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<>>{&Storage_::string, 48}, ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::string>, fidl::internal::NaturalCodingConstraintString<>>{&Storage_::opt_string, 64});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 0,
                                                       .mask = 0xff00,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 16,
                                                       .mask = 0xff00,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 32,
                                                       .mask = 0xffffffff00000000,
                                                   });
};

class Compound {
 private:
  struct Storage_;

 public:
  Compound(Storage_ storage) noexcept;
  Compound(::test_typesinprotocols::Bits bits, ::test_typesinprotocols::Enum enum_, ::test_typesinprotocols::Struct struct_, ::test_typesinprotocols::Table table, ::test_typesinprotocols::Union union_, ::fidl::Box<::test_typesinprotocols::Struct> opt_struct, ::fidl::Box<::test_typesinprotocols::Union> opt_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Compound| only if all of its members are default constructible.
  Compound() = default;
#pragma clang diagnostic pop

  Compound(Compound&&) noexcept = default;
  Compound& operator=(Compound&&) noexcept = default;
  Compound(const Compound& other) noexcept;
  Compound& operator=(const Compound& other) noexcept;

  bool operator==(const Compound& other) const noexcept;
  bool operator!=(const Compound& other) const noexcept;

  ::test_typesinprotocols::Bits
  bits() const;

  ::test_typesinprotocols::Bits& bits();

  // Setter for bits.
  //

  Compound& bits(::test_typesinprotocols::Bits value);

  ::test_typesinprotocols::Enum
  enum_() const;

  ::test_typesinprotocols::Enum& enum_();

  // Setter for enum_.
  //

  Compound& enum_(::test_typesinprotocols::Enum value);

  const ::test_typesinprotocols::Struct&
  struct_() const;

  ::test_typesinprotocols::Struct& struct_();

  // Setter for struct_.
  //

  Compound& struct_(::test_typesinprotocols::Struct value);

  const ::test_typesinprotocols::Table&
  table() const;

  ::test_typesinprotocols::Table& table();

  // Setter for table.
  //

  Compound& table(::test_typesinprotocols::Table value);

  const ::test_typesinprotocols::Union&
  union_() const;

  ::test_typesinprotocols::Union& union_();

  // Setter for union_.
  //

  Compound& union_(::test_typesinprotocols::Union value);

  const ::fidl::Box<::test_typesinprotocols::Struct>&
  opt_struct() const;

  ::fidl::Box<::test_typesinprotocols::Struct>& opt_struct();

  // Setter for opt_struct.
  //

  Compound& opt_struct(::fidl::Box<::test_typesinprotocols::Struct> value);

  const ::fidl::Box<::test_typesinprotocols::Union>&
  opt_union() const;

  ::fidl::Box<::test_typesinprotocols::Union>& opt_union();

  // Setter for opt_union.
  //

  Compound& opt_union(::fidl::Box<::test_typesinprotocols::Union> value);

  Compound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::test_typesinprotocols::Bits bits = {};
    ::test_typesinprotocols::Enum enum_ = {};
    ::test_typesinprotocols::Struct struct_;
    ::test_typesinprotocols::Table table;
    ::test_typesinprotocols::Union union_;
    ::fidl::Box<::test_typesinprotocols::Struct> opt_struct;
    ::fidl::Box<::test_typesinprotocols::Union> opt_union;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Compound>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Bits, fidl::internal::NaturalCodingConstraintEmpty>{
                                                       &Storage_::bits, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Enum, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::enum_, 4}, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Struct, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::struct_, 8}, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Table, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::table, 16}, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::Union, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::union_, 32}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::Struct>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::opt_struct, 48}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::Union>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::opt_union, 56});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
      .offset = 8,
      .mask = 0xffffffffffffff00,
  });
};

class ArrayBasic {
 private:
  struct Storage_;

 public:
  ArrayBasic(Storage_ storage) noexcept;
  ArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::std::optional<::std::string>, 5> array_opt_string) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ArrayBasic| only if all of its members are default constructible.
  ArrayBasic() = default;
#pragma clang diagnostic pop

  ArrayBasic(ArrayBasic&&) noexcept = default;
  ArrayBasic& operator=(ArrayBasic&&) noexcept = default;
  ArrayBasic(const ArrayBasic& other) noexcept;
  ArrayBasic& operator=(const ArrayBasic& other) noexcept;

  bool operator==(const ArrayBasic& other) const noexcept;
  bool operator!=(const ArrayBasic& other) const noexcept;

  const ::std::array<uint8_t, 5>&
  array_uint8() const;

  ::std::array<uint8_t, 5>& array_uint8();

  // Setter for array_uint8.
  //

  ArrayBasic& array_uint8(::std::array<uint8_t, 5> value);

  const ::std::array<uint16_t, 5>&
  array_uint16() const;

  ::std::array<uint16_t, 5>& array_uint16();

  // Setter for array_uint16.
  //

  ArrayBasic& array_uint16(::std::array<uint16_t, 5> value);

  const ::std::array<uint32_t, 5>&
  array_uint32() const;

  ::std::array<uint32_t, 5>& array_uint32();

  // Setter for array_uint32.
  //

  ArrayBasic& array_uint32(::std::array<uint32_t, 5> value);

  const ::std::array<uint64_t, 5>&
  array_uint64() const;

  ::std::array<uint64_t, 5>& array_uint64();

  // Setter for array_uint64.
  //

  ArrayBasic& array_uint64(::std::array<uint64_t, 5> value);

  const ::std::array<int8_t, 5>&
  array_int8() const;

  ::std::array<int8_t, 5>& array_int8();

  // Setter for array_int8.
  //

  ArrayBasic& array_int8(::std::array<int8_t, 5> value);

  const ::std::array<int16_t, 5>&
  array_int16() const;

  ::std::array<int16_t, 5>& array_int16();

  // Setter for array_int16.
  //

  ArrayBasic& array_int16(::std::array<int16_t, 5> value);

  const ::std::array<int32_t, 5>&
  array_int32() const;

  ::std::array<int32_t, 5>& array_int32();

  // Setter for array_int32.
  //

  ArrayBasic& array_int32(::std::array<int32_t, 5> value);

  const ::std::array<int64_t, 5>&
  array_int64() const;

  ::std::array<int64_t, 5>& array_int64();

  // Setter for array_int64.
  //

  ArrayBasic& array_int64(::std::array<int64_t, 5> value);

  const ::std::array<float, 5>&
  array_float32() const;

  ::std::array<float, 5>& array_float32();

  // Setter for array_float32.
  //

  ArrayBasic& array_float32(::std::array<float, 5> value);

  const ::std::array<double, 5>&
  array_float64() const;

  ::std::array<double, 5>& array_float64();

  // Setter for array_float64.
  //

  ArrayBasic& array_float64(::std::array<double, 5> value);

  const ::std::array<::std::string, 5>&
  array_string() const;

  ::std::array<::std::string, 5>& array_string();

  // Setter for array_string.
  //

  ArrayBasic& array_string(::std::array<::std::string, 5> value);

  const ::std::array<::std::optional<::std::string>, 5>&
  array_opt_string() const;

  ::std::array<::std::optional<::std::string>, 5>& array_opt_string();

  // Setter for array_opt_string.
  //

  ArrayBasic& array_opt_string(::std::array<::std::optional<::std::string>, 5> value);

  ArrayBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::array<uint8_t, 5> array_uint8 = {};
    ::std::array<uint16_t, 5> array_uint16 = {};
    ::std::array<uint32_t, 5> array_uint32 = {};
    ::std::array<uint64_t, 5> array_uint64 = {};
    ::std::array<int8_t, 5> array_int8 = {};
    ::std::array<int16_t, 5> array_int16 = {};
    ::std::array<int32_t, 5> array_int32 = {};
    ::std::array<int64_t, 5> array_int64 = {};
    ::std::array<float, 5> array_float32 = {};
    ::std::array<double, 5> array_float64 = {};
    ::std::array<::std::string, 5> array_string;
    ::std::array<::std::optional<::std::string>, 5> array_opt_string;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ArrayBasic>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint8_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
                                                       &Storage_::array_uint8, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint16_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_uint16, 6}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint32_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_uint32, 16}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<uint64_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_uint64, 40}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int8_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_int8, 80}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int16_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_int16, 86}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int32_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_int32, 96}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<int64_t, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_int64, 120}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<float, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_float32, 160}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<double, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_float64, 184}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::string, 5>, fidl::internal::NaturalCodingConstraintString<>>{&Storage_::array_string, 224}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::optional<::std::string>, 5>, fidl::internal::NaturalCodingConstraintString<>>{&Storage_::array_opt_string, 304});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 0,
                                                       .mask = 0xff0000000000,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 32,
                                                       .mask = 0xffffffff00000000,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 80,
                                                       .mask = 0xff0000000000,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 112,
                                                       .mask = 0xffffffff00000000,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 176,
                                                       .mask = 0xffffffff00000000,
                                                   });
};

class ArrayCompound {
 private:
  struct Storage_;

 public:
  ArrayCompound(Storage_ storage) noexcept;
  ArrayCompound(::std::array<::test_typesinprotocols::Bits, 5> array_bits, ::std::array<::test_typesinprotocols::Enum, 5> array_enum, ::std::array<::test_typesinprotocols::Struct, 5> array_struct, ::std::array<::test_typesinprotocols::Table, 5> array_table, ::std::array<::test_typesinprotocols::Union, 5> array_union, ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> array_opt_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ArrayCompound| only if all of its members are default constructible.
  ArrayCompound() = default;
#pragma clang diagnostic pop

  ArrayCompound(ArrayCompound&&) noexcept = default;
  ArrayCompound& operator=(ArrayCompound&&) noexcept = default;
  ArrayCompound(const ArrayCompound& other) noexcept;
  ArrayCompound& operator=(const ArrayCompound& other) noexcept;

  bool operator==(const ArrayCompound& other) const noexcept;
  bool operator!=(const ArrayCompound& other) const noexcept;

  const ::std::array<::test_typesinprotocols::Bits, 5>&
  array_bits() const;

  ::std::array<::test_typesinprotocols::Bits, 5>& array_bits();

  // Setter for array_bits.
  //

  ArrayCompound& array_bits(::std::array<::test_typesinprotocols::Bits, 5> value);

  const ::std::array<::test_typesinprotocols::Enum, 5>&
  array_enum() const;

  ::std::array<::test_typesinprotocols::Enum, 5>& array_enum();

  // Setter for array_enum.
  //

  ArrayCompound& array_enum(::std::array<::test_typesinprotocols::Enum, 5> value);

  const ::std::array<::test_typesinprotocols::Struct, 5>&
  array_struct() const;

  ::std::array<::test_typesinprotocols::Struct, 5>& array_struct();

  // Setter for array_struct.
  //

  ArrayCompound& array_struct(::std::array<::test_typesinprotocols::Struct, 5> value);

  const ::std::array<::test_typesinprotocols::Table, 5>&
  array_table() const;

  ::std::array<::test_typesinprotocols::Table, 5>& array_table();

  // Setter for array_table.
  //

  ArrayCompound& array_table(::std::array<::test_typesinprotocols::Table, 5> value);

  const ::std::array<::test_typesinprotocols::Union, 5>&
  array_union() const;

  ::std::array<::test_typesinprotocols::Union, 5>& array_union();

  // Setter for array_union.
  //

  ArrayCompound& array_union(::std::array<::test_typesinprotocols::Union, 5> value);

  const ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>&
  array_opt_struct() const;

  ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>& array_opt_struct();

  // Setter for array_opt_struct.
  //

  ArrayCompound& array_opt_struct(::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> value);

  const ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>&
  array_opt_union() const;

  ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>& array_opt_union();

  // Setter for array_opt_union.
  //

  ArrayCompound& array_opt_union(::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> value);

  ArrayCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::array<::test_typesinprotocols::Bits, 5> array_bits = {};
    ::std::array<::test_typesinprotocols::Enum, 5> array_enum = {};
    ::std::array<::test_typesinprotocols::Struct, 5> array_struct;
    ::std::array<::test_typesinprotocols::Table, 5> array_table;
    ::std::array<::test_typesinprotocols::Union, 5> array_union;
    ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> array_opt_struct;
    ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> array_opt_union;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ArrayCompound>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Bits, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
                                                       &Storage_::array_bits, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Enum, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_enum, 20}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Struct, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_struct, 40}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Table, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_table, 48}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::Union, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_union, 128}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_opt_struct, 208}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_opt_union, 248});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
      .offset = 40,
      .mask = 0xffffff0000000000,
  });
};

class VectorBasic {
 private:
  struct Storage_;

 public:
  VectorBasic(Storage_ storage) noexcept;
  VectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::std::optional<::std::string>> vector_opt_string) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |VectorBasic| only if all of its members are default constructible.
  VectorBasic() = default;
#pragma clang diagnostic pop

  VectorBasic(VectorBasic&&) noexcept = default;
  VectorBasic& operator=(VectorBasic&&) noexcept = default;
  VectorBasic(const VectorBasic& other) noexcept;
  VectorBasic& operator=(const VectorBasic& other) noexcept;

  bool operator==(const VectorBasic& other) const noexcept;
  bool operator!=(const VectorBasic& other) const noexcept;

  const ::std::vector<uint8_t>&
  vector_uint8() const;

  ::std::vector<uint8_t>& vector_uint8();

  // Setter for vector_uint8.
  //

  VectorBasic& vector_uint8(::std::vector<uint8_t> value);

  const ::std::vector<uint16_t>&
  vector_uint16() const;

  ::std::vector<uint16_t>& vector_uint16();

  // Setter for vector_uint16.
  //

  VectorBasic& vector_uint16(::std::vector<uint16_t> value);

  const ::std::vector<uint32_t>&
  vector_uint32() const;

  ::std::vector<uint32_t>& vector_uint32();

  // Setter for vector_uint32.
  //

  VectorBasic& vector_uint32(::std::vector<uint32_t> value);

  const ::std::vector<uint64_t>&
  vector_uint64() const;

  ::std::vector<uint64_t>& vector_uint64();

  // Setter for vector_uint64.
  //

  VectorBasic& vector_uint64(::std::vector<uint64_t> value);

  const ::std::vector<int8_t>&
  vector_int8() const;

  ::std::vector<int8_t>& vector_int8();

  // Setter for vector_int8.
  //

  VectorBasic& vector_int8(::std::vector<int8_t> value);

  const ::std::vector<int16_t>&
  vector_int16() const;

  ::std::vector<int16_t>& vector_int16();

  // Setter for vector_int16.
  //

  VectorBasic& vector_int16(::std::vector<int16_t> value);

  const ::std::vector<int32_t>&
  vector_int32() const;

  ::std::vector<int32_t>& vector_int32();

  // Setter for vector_int32.
  //

  VectorBasic& vector_int32(::std::vector<int32_t> value);

  const ::std::vector<int64_t>&
  vector_int64() const;

  ::std::vector<int64_t>& vector_int64();

  // Setter for vector_int64.
  //

  VectorBasic& vector_int64(::std::vector<int64_t> value);

  const ::std::vector<float>&
  vector_float32() const;

  ::std::vector<float>& vector_float32();

  // Setter for vector_float32.
  //

  VectorBasic& vector_float32(::std::vector<float> value);

  const ::std::vector<double>&
  vector_float64() const;

  ::std::vector<double>& vector_float64();

  // Setter for vector_float64.
  //

  VectorBasic& vector_float64(::std::vector<double> value);

  const ::std::vector<::std::string>&
  vector_string() const;

  ::std::vector<::std::string>& vector_string();

  // Setter for vector_string.
  //

  VectorBasic& vector_string(::std::vector<::std::string> value);

  const ::std::vector<::std::optional<::std::string>>&
  vector_opt_string() const;

  ::std::vector<::std::optional<::std::string>>& vector_opt_string();

  // Setter for vector_opt_string.
  //

  VectorBasic& vector_opt_string(::std::vector<::std::optional<::std::string>> value);

  VectorBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::vector<uint8_t> vector_uint8;
    ::std::vector<uint16_t> vector_uint16;
    ::std::vector<uint32_t> vector_uint32;
    ::std::vector<uint64_t> vector_uint64;
    ::std::vector<int8_t> vector_int8;
    ::std::vector<int16_t> vector_int16;
    ::std::vector<int32_t> vector_int32;
    ::std::vector<int64_t> vector_int64;
    ::std::vector<float> vector_float32;
    ::std::vector<double> vector_float64;
    ::std::vector<::std::string> vector_string;
    ::std::vector<::std::optional<::std::string>> vector_opt_string;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::VectorBasic>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
                                                       &Storage_::vector_uint8, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint16_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_uint16, 16}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint32_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_uint32, 32}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<uint64_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_uint64, 48}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int8_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_int8, 64}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int16_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_int16, 80}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int32_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_int32, 96}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<int64_t>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_int64, 112}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<float>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_float32, 128}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<double>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_float64, 144}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::string>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>{&Storage_::vector_string, 160}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::optional<::std::string>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>{&Storage_::vector_opt_string, 176});
  static constexpr auto kPadding = std::make_tuple();
};

class VectorCompound {
 private:
  struct Storage_;

 public:
  VectorCompound(Storage_ storage) noexcept;
  VectorCompound(::std::vector<::test_typesinprotocols::Bits> vector_bits, ::std::vector<::test_typesinprotocols::Enum> vector_enum, ::std::vector<::test_typesinprotocols::Struct> vector_struct, ::std::vector<::test_typesinprotocols::Table> vector_table, ::std::vector<::test_typesinprotocols::Union> vector_union, ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> vector_opt_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |VectorCompound| only if all of its members are default constructible.
  VectorCompound() = default;
#pragma clang diagnostic pop

  VectorCompound(VectorCompound&&) noexcept = default;
  VectorCompound& operator=(VectorCompound&&) noexcept = default;
  VectorCompound(const VectorCompound& other) noexcept;
  VectorCompound& operator=(const VectorCompound& other) noexcept;

  bool operator==(const VectorCompound& other) const noexcept;
  bool operator!=(const VectorCompound& other) const noexcept;

  const ::std::vector<::test_typesinprotocols::Bits>&
  vector_bits() const;

  ::std::vector<::test_typesinprotocols::Bits>& vector_bits();

  // Setter for vector_bits.
  //

  VectorCompound& vector_bits(::std::vector<::test_typesinprotocols::Bits> value);

  const ::std::vector<::test_typesinprotocols::Enum>&
  vector_enum() const;

  ::std::vector<::test_typesinprotocols::Enum>& vector_enum();

  // Setter for vector_enum.
  //

  VectorCompound& vector_enum(::std::vector<::test_typesinprotocols::Enum> value);

  const ::std::vector<::test_typesinprotocols::Struct>&
  vector_struct() const;

  ::std::vector<::test_typesinprotocols::Struct>& vector_struct();

  // Setter for vector_struct.
  //

  VectorCompound& vector_struct(::std::vector<::test_typesinprotocols::Struct> value);

  const ::std::vector<::test_typesinprotocols::Table>&
  vector_table() const;

  ::std::vector<::test_typesinprotocols::Table>& vector_table();

  // Setter for vector_table.
  //

  VectorCompound& vector_table(::std::vector<::test_typesinprotocols::Table> value);

  const ::std::vector<::test_typesinprotocols::Union>&
  vector_union() const;

  ::std::vector<::test_typesinprotocols::Union>& vector_union();

  // Setter for vector_union.
  //

  VectorCompound& vector_union(::std::vector<::test_typesinprotocols::Union> value);

  const ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>&
  vector_opt_struct() const;

  ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>& vector_opt_struct();

  // Setter for vector_opt_struct.
  //

  VectorCompound& vector_opt_struct(::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> value);

  const ::std::vector<::fidl::Box<::test_typesinprotocols::Union>>&
  vector_opt_union() const;

  ::std::vector<::fidl::Box<::test_typesinprotocols::Union>>& vector_opt_union();

  // Setter for vector_opt_union.
  //

  VectorCompound& vector_opt_union(::std::vector<::fidl::Box<::test_typesinprotocols::Union>> value);

  VectorCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::vector<::test_typesinprotocols::Bits> vector_bits;
    ::std::vector<::test_typesinprotocols::Enum> vector_enum;
    ::std::vector<::test_typesinprotocols::Struct> vector_struct;
    ::std::vector<::test_typesinprotocols::Table> vector_table;
    ::std::vector<::test_typesinprotocols::Union> vector_union;
    ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> vector_opt_struct;
    ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> vector_opt_union;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::VectorCompound>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Bits>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
                                                       &Storage_::vector_bits, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Enum>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_enum, 16}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Struct>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_struct, 32}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Table>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_table, 48}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::Union>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_union, 64}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_opt_struct, 80}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::Box<::test_typesinprotocols::Union>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_opt_union, 96});
  static constexpr auto kPadding = std::make_tuple();
};

class VectorOptional {
 private:
  struct Storage_;

 public:
  VectorOptional(Storage_ storage) noexcept;
  VectorOptional(::std::optional<::std::vector<uint8_t>> opt_vector_uint8, ::std::optional<::std::vector<::std::string>> opt_vector_string, ::std::optional<::std::vector<::test_typesinprotocols::Struct>> opt_vector_struct, ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> opt_vector_opt_struct) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |VectorOptional| only if all of its members are default constructible.
  VectorOptional() = default;
#pragma clang diagnostic pop

  VectorOptional(VectorOptional&&) noexcept = default;
  VectorOptional& operator=(VectorOptional&&) noexcept = default;
  VectorOptional(const VectorOptional& other) noexcept;
  VectorOptional& operator=(const VectorOptional& other) noexcept;

  bool operator==(const VectorOptional& other) const noexcept;
  bool operator!=(const VectorOptional& other) const noexcept;

  const ::std::optional<::std::vector<uint8_t>>&
  opt_vector_uint8() const;

  ::std::optional<::std::vector<uint8_t>>& opt_vector_uint8();

  // Setter for opt_vector_uint8.
  //

  VectorOptional& opt_vector_uint8(::std::optional<::std::vector<uint8_t>> value);

  const ::std::optional<::std::vector<::std::string>>&
  opt_vector_string() const;

  ::std::optional<::std::vector<::std::string>>& opt_vector_string();

  // Setter for opt_vector_string.
  //

  VectorOptional& opt_vector_string(::std::optional<::std::vector<::std::string>> value);

  const ::std::optional<::std::vector<::test_typesinprotocols::Struct>>&
  opt_vector_struct() const;

  ::std::optional<::std::vector<::test_typesinprotocols::Struct>>& opt_vector_struct();

  // Setter for opt_vector_struct.
  //

  VectorOptional& opt_vector_struct(::std::optional<::std::vector<::test_typesinprotocols::Struct>> value);

  const ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>>&
  opt_vector_opt_struct() const;

  ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>>& opt_vector_opt_struct();

  // Setter for opt_vector_opt_struct.
  //

  VectorOptional& opt_vector_opt_struct(::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> value);

  VectorOptional(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::optional<::std::vector<uint8_t>> opt_vector_uint8;
    ::std::optional<::std::vector<::std::string>> opt_vector_string;
    ::std::optional<::std::vector<::test_typesinprotocols::Struct>> opt_vector_struct;
    ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> opt_vector_opt_struct;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::VectorOptional>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<uint8_t>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{
                                                       &Storage_::opt_vector_uint8, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<::std::string>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>{&Storage_::opt_vector_string, 16}, ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<::test_typesinprotocols::Struct>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::opt_vector_struct, 32}, ::fidl::internal::NaturalStructMember<Storage_, ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::opt_vector_opt_struct, 48});
  static constexpr auto kPadding = std::make_tuple();
};

class ArrayVectorNested {
 private:
  struct Storage_;

 public:
  ArrayVectorNested(Storage_ storage) noexcept;
  ArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |ArrayVectorNested| only if all of its members are default constructible.
  ArrayVectorNested() = default;
#pragma clang diagnostic pop

  ArrayVectorNested(ArrayVectorNested&&) noexcept = default;
  ArrayVectorNested& operator=(ArrayVectorNested&&) noexcept = default;
  ArrayVectorNested(const ArrayVectorNested& other) noexcept;
  ArrayVectorNested& operator=(const ArrayVectorNested& other) noexcept;

  bool operator==(const ArrayVectorNested& other) const noexcept;
  bool operator!=(const ArrayVectorNested& other) const noexcept;

  const ::std::array<::std::array<uint8_t, 5>, 5>&
  array_array_uint8() const;

  ::std::array<::std::array<uint8_t, 5>, 5>& array_array_uint8();

  // Setter for array_array_uint8.
  //

  ArrayVectorNested& array_array_uint8(::std::array<::std::array<uint8_t, 5>, 5> value);

  const ::std::array<::std::vector<uint8_t>, 5>&
  array_vector_uint8() const;

  ::std::array<::std::vector<uint8_t>, 5>& array_vector_uint8();

  // Setter for array_vector_uint8.
  //

  ArrayVectorNested& array_vector_uint8(::std::array<::std::vector<uint8_t>, 5> value);

  const ::std::vector<::std::array<uint8_t, 5>>&
  vector_array_uint8() const;

  ::std::vector<::std::array<uint8_t, 5>>& vector_array_uint8();

  // Setter for vector_array_uint8.
  //

  ArrayVectorNested& vector_array_uint8(::std::vector<::std::array<uint8_t, 5>> value);

  const ::std::vector<::std::vector<uint8_t>>&
  vector_vector_uint8() const;

  ::std::vector<::std::vector<uint8_t>>& vector_vector_uint8();

  // Setter for vector_vector_uint8.
  //

  ArrayVectorNested& vector_vector_uint8(::std::vector<::std::vector<uint8_t>> value);

  ArrayVectorNested(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8 = {};
    ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8;
    ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8;
    ::std::vector<::std::vector<uint8_t>> vector_vector_uint8;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::ArrayVectorNested>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::array<uint8_t, 5>, 5>, fidl::internal::NaturalCodingConstraintEmpty>{
                                                       &Storage_::array_array_uint8, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::std::vector<uint8_t>, 5>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::array_vector_uint8, 32}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::array<uint8_t, 5>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_array_uint8, 112}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::vector<uint8_t>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>>{&Storage_::vector_vector_uint8, 128});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
      .offset = 24,
      .mask = 0xffffffffffffff00,
  });
};

#ifdef __Fuchsia__

class Resource {
 private:
  struct Storage_;

 public:
  Resource(Storage_ storage) noexcept;
  Resource(::zx::handle handle, ::zx::vmo vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end, ::test_typesinprotocols::ResourceStruct struct_, ::test_typesinprotocols::ResourceTable table, ::test_typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end, ::fidl::Box<::test_typesinprotocols::ResourceStruct> opt_struct, ::fidl::Box<::test_typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test_typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test_typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test_typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test_typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test_typesinprotocols::ResourceTable> vector_table, ::std::vector<::test_typesinprotocols::ResourceUnion> vector_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Resource| only if all of its members are default constructible.
  Resource() = default;
#pragma clang diagnostic pop

  Resource(Resource&&) noexcept = default;
  Resource& operator=(Resource&&) noexcept = default;

  const ::zx::handle&
  handle() const;

  ::zx::handle& handle();

  // Setter for handle.
  //

  Resource& handle(::zx::handle value);

  const ::zx::vmo&
  vmo() const;

  ::zx::vmo& vmo();

  // Setter for vmo.
  //

  Resource& vmo(::zx::vmo value);

  const ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&
  client_end() const;

  ::fidl::ClientEnd<::test_typesinprotocols::Protocol>& client_end();

  // Setter for client_end.
  //

  Resource& client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value);

  const ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&
  server_end() const;

  ::fidl::ServerEnd<::test_typesinprotocols::Protocol>& server_end();

  // Setter for server_end.
  //

  Resource& server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value);

  const ::test_typesinprotocols::ResourceStruct&
  struct_() const;

  ::test_typesinprotocols::ResourceStruct& struct_();

  // Setter for struct_.
  //

  Resource& struct_(::test_typesinprotocols::ResourceStruct value);

  const ::test_typesinprotocols::ResourceTable&
  table() const;

  ::test_typesinprotocols::ResourceTable& table();

  // Setter for table.
  //

  Resource& table(::test_typesinprotocols::ResourceTable value);

  const ::test_typesinprotocols::ResourceUnion&
  union_() const;

  ::test_typesinprotocols::ResourceUnion& union_();

  // Setter for union_.
  //

  Resource& union_(::test_typesinprotocols::ResourceUnion value);

  const ::zx::handle&
  opt_handle() const;

  ::zx::handle& opt_handle();

  // Setter for opt_handle.
  //

  Resource& opt_handle(::zx::handle value);

  const ::zx::vmo&
  opt_vmo() const;

  ::zx::vmo& opt_vmo();

  // Setter for opt_vmo.
  //

  Resource& opt_vmo(::zx::vmo value);

  const ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&
  opt_client_end() const;

  ::fidl::ClientEnd<::test_typesinprotocols::Protocol>& opt_client_end();

  // Setter for opt_client_end.
  //

  Resource& opt_client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value);

  const ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&
  opt_server_end() const;

  ::fidl::ServerEnd<::test_typesinprotocols::Protocol>& opt_server_end();

  // Setter for opt_server_end.
  //

  Resource& opt_server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value);

  const ::fidl::Box<::test_typesinprotocols::ResourceStruct>&
  opt_struct() const;

  ::fidl::Box<::test_typesinprotocols::ResourceStruct>& opt_struct();

  // Setter for opt_struct.
  //

  Resource& opt_struct(::fidl::Box<::test_typesinprotocols::ResourceStruct> value);

  const ::fidl::Box<::test_typesinprotocols::ResourceUnion>&
  opt_union() const;

  ::fidl::Box<::test_typesinprotocols::ResourceUnion>& opt_union();

  // Setter for opt_union.
  //

  Resource& opt_union(::fidl::Box<::test_typesinprotocols::ResourceUnion> value);

  const ::std::array<::zx::handle, 5>&
  array_handle() const;

  ::std::array<::zx::handle, 5>& array_handle();

  // Setter for array_handle.
  //

  Resource& array_handle(::std::array<::zx::handle, 5> value);

  const ::std::array<::zx::vmo, 5>&
  array_vmo() const;

  ::std::array<::zx::vmo, 5>& array_vmo();

  // Setter for array_vmo.
  //

  Resource& array_vmo(::std::array<::zx::vmo, 5> value);

  const ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&
  array_client_end() const;

  ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>& array_client_end();

  // Setter for array_client_end.
  //

  Resource& array_client_end(::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> value);

  const ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&
  array_server_end() const;

  ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>& array_server_end();

  // Setter for array_server_end.
  //

  Resource& array_server_end(::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> value);

  const ::std::array<::test_typesinprotocols::ResourceStruct, 5>&
  array_struct() const;

  ::std::array<::test_typesinprotocols::ResourceStruct, 5>& array_struct();

  // Setter for array_struct.
  //

  Resource& array_struct(::std::array<::test_typesinprotocols::ResourceStruct, 5> value);

  const ::std::array<::test_typesinprotocols::ResourceTable, 5>&
  array_table() const;

  ::std::array<::test_typesinprotocols::ResourceTable, 5>& array_table();

  // Setter for array_table.
  //

  Resource& array_table(::std::array<::test_typesinprotocols::ResourceTable, 5> value);

  const ::std::array<::test_typesinprotocols::ResourceUnion, 5>&
  array_union() const;

  ::std::array<::test_typesinprotocols::ResourceUnion, 5>& array_union();

  // Setter for array_union.
  //

  Resource& array_union(::std::array<::test_typesinprotocols::ResourceUnion, 5> value);

  const ::std::vector<::zx::handle>&
  vector_handle() const;

  ::std::vector<::zx::handle>& vector_handle();

  // Setter for vector_handle.
  //

  Resource& vector_handle(::std::vector<::zx::handle> value);

  const ::std::vector<::zx::vmo>&
  vector_vmo() const;

  ::std::vector<::zx::vmo>& vector_vmo();

  // Setter for vector_vmo.
  //

  Resource& vector_vmo(::std::vector<::zx::vmo> value);

  const ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>&
  vector_client_end() const;

  ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>& vector_client_end();

  // Setter for vector_client_end.
  //

  Resource& vector_client_end(::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> value);

  const ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>&
  vector_server_end() const;

  ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>& vector_server_end();

  // Setter for vector_server_end.
  //

  Resource& vector_server_end(::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> value);

  const ::std::vector<::test_typesinprotocols::ResourceStruct>&
  vector_struct() const;

  ::std::vector<::test_typesinprotocols::ResourceStruct>& vector_struct();

  // Setter for vector_struct.
  //

  Resource& vector_struct(::std::vector<::test_typesinprotocols::ResourceStruct> value);

  const ::std::vector<::test_typesinprotocols::ResourceTable>&
  vector_table() const;

  ::std::vector<::test_typesinprotocols::ResourceTable>& vector_table();

  // Setter for vector_table.
  //

  Resource& vector_table(::std::vector<::test_typesinprotocols::ResourceTable> value);

  const ::std::vector<::test_typesinprotocols::ResourceUnion>&
  vector_union() const;

  ::std::vector<::test_typesinprotocols::ResourceUnion>& vector_union();

  // Setter for vector_union.
  //

  Resource& vector_union(::std::vector<::test_typesinprotocols::ResourceUnion> value);

  Resource(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::zx::handle handle;
    ::zx::vmo vmo;
    ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end;
    ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end;
    ::test_typesinprotocols::ResourceStruct struct_;
    ::test_typesinprotocols::ResourceTable table;
    ::test_typesinprotocols::ResourceUnion union_;
    ::zx::handle opt_handle;
    ::zx::vmo opt_vmo;
    ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end;
    ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end;
    ::fidl::Box<::test_typesinprotocols::ResourceStruct> opt_struct;
    ::fidl::Box<::test_typesinprotocols::ResourceUnion> opt_union;
    ::std::array<::zx::handle, 5> array_handle;
    ::std::array<::zx::vmo, 5> array_vmo;
    ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end;
    ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end;
    ::std::array<::test_typesinprotocols::ResourceStruct, 5> array_struct;
    ::std::array<::test_typesinprotocols::ResourceTable, 5> array_table;
    ::std::array<::test_typesinprotocols::ResourceUnion, 5> array_union;
    ::std::vector<::zx::handle> vector_handle;
    ::std::vector<::zx::vmo> vector_vmo;
    ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end;
    ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end;
    ::std::vector<::test_typesinprotocols::ResourceStruct> vector_struct;
    ::std::vector<::test_typesinprotocols::ResourceTable> vector_table;
    ::std::vector<::test_typesinprotocols::ResourceUnion> vector_union;
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Resource, 456>;
  friend struct ::fidl::internal::MemberVisitor<::test_typesinprotocols::Resource>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{
                                                       &Storage_::handle, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>{&Storage_::vmo, 4}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::client_end, 8}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::server_end, 12}, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ResourceStruct, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::struct_, 16}, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ResourceTable, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::table, 24}, ::fidl::internal::NaturalStructMember<Storage_, ::test_typesinprotocols::ResourceUnion, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::union_, 40}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::handle, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>>{&Storage_::opt_handle, 56}, ::fidl::internal::NaturalStructMember<Storage_, ::zx::vmo, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>>{&Storage_::opt_vmo, 60}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{&Storage_::opt_client_end, 64}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{&Storage_::opt_server_end, 68}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::ResourceStruct>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::opt_struct, 72}, ::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_typesinprotocols::ResourceUnion>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::opt_union, 80}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::zx::handle, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>{&Storage_::array_handle, 96}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::zx::vmo, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>{&Storage_::array_vmo, 116}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::array_client_end, 136}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{&Storage_::array_server_end, 156}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::ResourceStruct, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_struct, 176}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::ResourceTable, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_table, 184}, ::fidl::internal::NaturalStructMember<Storage_, ::std::array<::test_typesinprotocols::ResourceUnion, 5>, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::array_union, 264}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::zx::handle>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>>>{&Storage_::vector_handle, 344}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::zx::vmo>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>>>{&Storage_::vector_vmo, 360}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>>{&Storage_::vector_client_end, 376}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>>{&Storage_::vector_server_end, 392}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::ResourceStruct>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_struct, 408}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::ResourceTable>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_table, 424}, ::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::test_typesinprotocols::ResourceUnion>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty>>{&Storage_::vector_union, 440});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 16,
                                                       .mask = 0xffffffffffffff00,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 176,
                                                       .mask = 0xffffff0000000000,
                                                   });
};

#endif  // __Fuchsia__

class ProtocolErrorBasicResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::Basic, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorBasicResult(ProtocolErrorBasicResult&& other) noexcept;
  ProtocolErrorBasicResult& operator=(ProtocolErrorBasicResult&& other) noexcept;
  ProtocolErrorBasicResult(const ProtocolErrorBasicResult& other) noexcept;
  ProtocolErrorBasicResult& operator=(const ProtocolErrorBasicResult& other) noexcept;
  bool operator==(const ProtocolErrorBasicResult& other) const noexcept;
  bool operator!=(const ProtocolErrorBasicResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorBasicResult::Tag Which() const;
  static ProtocolErrorBasicResult WithResponse(::test_typesinprotocols::Basic val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorBasicResult& response(::test_typesinprotocols::Basic value);
  static ProtocolErrorBasicResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorBasicResult& err(uint32_t value);

  ProtocolErrorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorBasicResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorBasicResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorBasicResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorBasicResult::Tag> IndexToTag(size_t index);
};

class ProtocolErrorCompoundResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::Compound, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorCompoundResult(ProtocolErrorCompoundResult&& other) noexcept;
  ProtocolErrorCompoundResult& operator=(ProtocolErrorCompoundResult&& other) noexcept;
  ProtocolErrorCompoundResult(const ProtocolErrorCompoundResult& other) noexcept;
  ProtocolErrorCompoundResult& operator=(const ProtocolErrorCompoundResult& other) noexcept;
  bool operator==(const ProtocolErrorCompoundResult& other) const noexcept;
  bool operator!=(const ProtocolErrorCompoundResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag Which() const;
  static ProtocolErrorCompoundResult WithResponse(::test_typesinprotocols::Compound val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorCompoundResult& response(::test_typesinprotocols::Compound value);
  static ProtocolErrorCompoundResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorCompoundResult& err(uint32_t value);

  ProtocolErrorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorCompoundResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorCompoundResult::Tag> IndexToTag(size_t index);
};

class ProtocolErrorArrayBasicResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::ArrayBasic, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorArrayBasicResult(ProtocolErrorArrayBasicResult&& other) noexcept;
  ProtocolErrorArrayBasicResult& operator=(ProtocolErrorArrayBasicResult&& other) noexcept;
  ProtocolErrorArrayBasicResult(const ProtocolErrorArrayBasicResult& other) noexcept;
  ProtocolErrorArrayBasicResult& operator=(const ProtocolErrorArrayBasicResult& other) noexcept;
  bool operator==(const ProtocolErrorArrayBasicResult& other) const noexcept;
  bool operator!=(const ProtocolErrorArrayBasicResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag Which() const;
  static ProtocolErrorArrayBasicResult WithResponse(::test_typesinprotocols::ArrayBasic val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorArrayBasicResult& response(::test_typesinprotocols::ArrayBasic value);
  static ProtocolErrorArrayBasicResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorArrayBasicResult& err(uint32_t value);

  ProtocolErrorArrayBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorArrayBasicResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag> IndexToTag(size_t index);
};

class ProtocolErrorArrayCompoundResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::ArrayCompound, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorArrayCompoundResult(ProtocolErrorArrayCompoundResult&& other) noexcept;
  ProtocolErrorArrayCompoundResult& operator=(ProtocolErrorArrayCompoundResult&& other) noexcept;
  ProtocolErrorArrayCompoundResult(const ProtocolErrorArrayCompoundResult& other) noexcept;
  ProtocolErrorArrayCompoundResult& operator=(const ProtocolErrorArrayCompoundResult& other) noexcept;
  bool operator==(const ProtocolErrorArrayCompoundResult& other) const noexcept;
  bool operator!=(const ProtocolErrorArrayCompoundResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag Which() const;
  static ProtocolErrorArrayCompoundResult WithResponse(::test_typesinprotocols::ArrayCompound val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorArrayCompoundResult& response(::test_typesinprotocols::ArrayCompound value);
  static ProtocolErrorArrayCompoundResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorArrayCompoundResult& err(uint32_t value);

  ProtocolErrorArrayCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorArrayCompoundResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag> IndexToTag(size_t index);
};

class ProtocolErrorVectorBasicResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::VectorBasic, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorVectorBasicResult(ProtocolErrorVectorBasicResult&& other) noexcept;
  ProtocolErrorVectorBasicResult& operator=(ProtocolErrorVectorBasicResult&& other) noexcept;
  ProtocolErrorVectorBasicResult(const ProtocolErrorVectorBasicResult& other) noexcept;
  ProtocolErrorVectorBasicResult& operator=(const ProtocolErrorVectorBasicResult& other) noexcept;
  bool operator==(const ProtocolErrorVectorBasicResult& other) const noexcept;
  bool operator!=(const ProtocolErrorVectorBasicResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag Which() const;
  static ProtocolErrorVectorBasicResult WithResponse(::test_typesinprotocols::VectorBasic val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorVectorBasicResult& response(::test_typesinprotocols::VectorBasic value);
  static ProtocolErrorVectorBasicResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorVectorBasicResult& err(uint32_t value);

  ProtocolErrorVectorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorVectorBasicResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag> IndexToTag(size_t index);
};

class ProtocolErrorVectorCompoundResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::VectorCompound, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorVectorCompoundResult(ProtocolErrorVectorCompoundResult&& other) noexcept;
  ProtocolErrorVectorCompoundResult& operator=(ProtocolErrorVectorCompoundResult&& other) noexcept;
  ProtocolErrorVectorCompoundResult(const ProtocolErrorVectorCompoundResult& other) noexcept;
  ProtocolErrorVectorCompoundResult& operator=(const ProtocolErrorVectorCompoundResult& other) noexcept;
  bool operator==(const ProtocolErrorVectorCompoundResult& other) const noexcept;
  bool operator!=(const ProtocolErrorVectorCompoundResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag Which() const;
  static ProtocolErrorVectorCompoundResult WithResponse(::test_typesinprotocols::VectorCompound val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorVectorCompoundResult& response(::test_typesinprotocols::VectorCompound value);
  static ProtocolErrorVectorCompoundResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorVectorCompoundResult& err(uint32_t value);

  ProtocolErrorVectorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorVectorCompoundResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag> IndexToTag(size_t index);
};

class ProtocolErrorVectorOptionalResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::VectorOptional, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorVectorOptionalResult(ProtocolErrorVectorOptionalResult&& other) noexcept;
  ProtocolErrorVectorOptionalResult& operator=(ProtocolErrorVectorOptionalResult&& other) noexcept;
  ProtocolErrorVectorOptionalResult(const ProtocolErrorVectorOptionalResult& other) noexcept;
  ProtocolErrorVectorOptionalResult& operator=(const ProtocolErrorVectorOptionalResult& other) noexcept;
  bool operator==(const ProtocolErrorVectorOptionalResult& other) const noexcept;
  bool operator!=(const ProtocolErrorVectorOptionalResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag Which() const;
  static ProtocolErrorVectorOptionalResult WithResponse(::test_typesinprotocols::VectorOptional val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorVectorOptionalResult& response(::test_typesinprotocols::VectorOptional value);
  static ProtocolErrorVectorOptionalResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorVectorOptionalResult& err(uint32_t value);

  ProtocolErrorVectorOptionalResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorVectorOptionalResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag> IndexToTag(size_t index);
};

class ProtocolErrorArrayVectorNestedResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::ArrayVectorNested, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorArrayVectorNestedResult(ProtocolErrorArrayVectorNestedResult&& other) noexcept;
  ProtocolErrorArrayVectorNestedResult& operator=(ProtocolErrorArrayVectorNestedResult&& other) noexcept;
  ProtocolErrorArrayVectorNestedResult(const ProtocolErrorArrayVectorNestedResult& other) noexcept;
  ProtocolErrorArrayVectorNestedResult& operator=(const ProtocolErrorArrayVectorNestedResult& other) noexcept;
  bool operator==(const ProtocolErrorArrayVectorNestedResult& other) const noexcept;
  bool operator!=(const ProtocolErrorArrayVectorNestedResult& other) const noexcept;

  ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag Which() const;
  static ProtocolErrorArrayVectorNestedResult WithResponse(::test_typesinprotocols::ArrayVectorNested val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorArrayVectorNestedResult& response(::test_typesinprotocols::ArrayVectorNested value);
  static ProtocolErrorArrayVectorNestedResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorArrayVectorNestedResult& err(uint32_t value);

  ProtocolErrorArrayVectorNestedResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorArrayVectorNestedResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag> IndexToTag(size_t index);
};

#ifdef __Fuchsia__

class ProtocolErrorResourceResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_typesinprotocols::Resource, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  ProtocolErrorResourceResult(ProtocolErrorResourceResult&& other) noexcept;
  ProtocolErrorResourceResult& operator=(ProtocolErrorResourceResult&& other) noexcept;

  ::test_typesinprotocols::ProtocolErrorResourceResult::Tag Which() const;
  static ProtocolErrorResourceResult WithResponse(::test_typesinprotocols::Resource val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  ProtocolErrorResourceResult& response(::test_typesinprotocols::Resource value);
  static ProtocolErrorResourceResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  ProtocolErrorResourceResult& err(uint32_t value);

  ProtocolErrorResourceResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorResourceResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ProtocolErrorResourceResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorResourceResult::Tag tag);
  static std::optional<::test_typesinprotocols::ProtocolErrorResourceResult::Tag> IndexToTag(size_t index);
};

#endif  // __Fuchsia__

}  // namespace test_typesinprotocols
namespace fidl {

template <>
struct IsFidlType<::test_typesinprotocols::Struct> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::Struct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_typesinprotocols::Struct> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Struct, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalEmptyStructCodingTraits<::test_typesinprotocols::Struct> {};
#ifdef __Fuchsia__

template <>
struct IsResource<::test_typesinprotocols::ResourceStruct> : public std::true_type {};
template <>
struct IsFidlType<::test_typesinprotocols::ResourceStruct> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ResourceStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_typesinprotocols::ResourceStruct> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ResourceStruct, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalEmptyStructCodingTraits<::test_typesinprotocols::ResourceStruct> {};

#endif  // __Fuchsia__

template <>
struct IsFidlType<::test_typesinprotocols::Basic> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::Basic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 80;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::Basic> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Basic, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80> {};
template <>
struct IsFidlType<::test_typesinprotocols::Compound> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::Compound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 72;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::Compound> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Compound, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72> {};
template <>
struct IsFidlType<::test_typesinprotocols::ArrayBasic> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ArrayBasic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 384;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::ArrayBasic> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ArrayBasic, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384> {};
template <>
struct IsFidlType<::test_typesinprotocols::ArrayCompound> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ArrayCompound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 328;
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::ArrayCompound> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ArrayCompound, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328> {};
template <>
struct IsFidlType<::test_typesinprotocols::VectorBasic> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::VectorBasic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 192;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::VectorBasic> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::VectorBasic, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192> {};
template <>
struct IsFidlType<::test_typesinprotocols::VectorCompound> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::VectorCompound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 112;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::VectorCompound> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::VectorCompound, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112> {};
template <>
struct IsFidlType<::test_typesinprotocols::VectorOptional> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::VectorOptional> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 64;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::VectorOptional> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::VectorOptional, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64> {};
template <>
struct IsFidlType<::test_typesinprotocols::ArrayVectorNested> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ArrayVectorNested> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 144;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::ArrayVectorNested> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ArrayVectorNested, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144> {};
#ifdef __Fuchsia__

template <>
struct IsResource<::test_typesinprotocols::Resource> : public std::true_type {};
template <>
struct IsFidlType<::test_typesinprotocols::Resource> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::Resource> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 456;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_typesinprotocols::Resource> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Resource, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Resource, 456> {};

#endif  // __Fuchsia__

template <>
struct IsFidlType<::test_typesinprotocols::Table> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::Table> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsTable<::test_typesinprotocols::Table> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Table, ::fidl::internal::NaturalCodingConstraintEmpty> : public ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table> {};
#ifdef __Fuchsia__

template <>
struct IsResource<::test_typesinprotocols::ResourceTable> : public std::true_type {};
template <>
struct IsFidlType<::test_typesinprotocols::ResourceTable> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ResourceTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsTable<::test_typesinprotocols::ResourceTable> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ResourceTable, ::fidl::internal::NaturalCodingConstraintEmpty> : public ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::ResourceTable> {};

#endif  // __Fuchsia__

template <>
struct IsFidlType<::test_typesinprotocols::Union> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::Union> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::Union> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Union, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::Union> {};
#ifdef __Fuchsia__

template <>
struct IsResource<::test_typesinprotocols::ResourceUnion> : public std::true_type {};
template <>
struct IsFidlType<::test_typesinprotocols::ResourceUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ResourceUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ResourceUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ResourceUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ResourceUnion> {};

#endif  // __Fuchsia__

template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorBasicResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorBasicResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorBasicResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorBasicResult> {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorCompoundResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 80;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorCompoundResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorCompoundResult> {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayBasicResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorArrayBasicResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayBasicResult> {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 368;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayCompoundResult> {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorBasicResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorVectorBasicResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorBasicResult> {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorCompoundResult> {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorVectorOptionalResult> {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult> {};
#ifdef __Fuchsia__

template <>
struct IsResource<::test_typesinprotocols::ProtocolErrorResourceResult> : public std::true_type {};
template <>
struct IsFidlType<::test_typesinprotocols::ProtocolErrorResourceResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::ProtocolErrorResourceResult> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_typesinprotocols::ProtocolErrorResourceResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::ProtocolErrorResourceResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_typesinprotocols::ProtocolErrorResourceResult> {};

#endif  // __Fuchsia__

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Bits, ::fidl::internal::NaturalCodingConstraintEmpty> {
  static constexpr size_t kInlineSize = sizeof(uint32_t);
  static constexpr bool kIsMemcpyCompatible = true;

  static void Encode(internal::NaturalEncoder* encoder, ::test_typesinprotocols::Bits* value, size_t offset, size_t recursion_depth);
  static void Decode(internal::NaturalDecoder* decoder, ::test_typesinprotocols::Bits* value, size_t offset, size_t recursion_depth);
};

template <>
struct internal::NaturalCodingTraits<::test_typesinprotocols::Enum, ::fidl::internal::NaturalCodingConstraintEmpty> {
  static constexpr size_t kInlineSize = sizeof(uint32_t);
  static constexpr bool kIsMemcpyCompatible = true;

  static void Encode(internal::NaturalEncoder* encoder, ::test_typesinprotocols::Enum* value, size_t offset, size_t recursion_depth);
  static void Decode(internal::NaturalDecoder* decoder, ::test_typesinprotocols::Enum* value, size_t offset, size_t recursion_depth);
};

#pragma clang diagnostic pop

}  // namespace fidl
