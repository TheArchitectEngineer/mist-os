// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.unionsandwich/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize8Alignment4, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::SandwichUnionSize8Alignment4* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 24);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->before, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->after, position + 24, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize8Alignment4, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize8Alignment4, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize8Alignment4, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::SandwichUnionSize8Alignment4>);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4, before) == 0);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4, union_) == 8);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4, after) == 24);
static_assert(sizeof(::test_unionsandwich::wire::SandwichUnionSize8Alignment4) == ::fidl::TypeTraits<::test_unionsandwich::wire::SandwichUnionSize8Alignment4>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize12Alignment4, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::SandwichUnionSize12Alignment4* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 24);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->before, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 8, recursion_depth);
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->after, position + 24, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize12Alignment4, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize12Alignment4, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize12Alignment4, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::SandwichUnionSize12Alignment4>);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4, before) == 0);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4, union_) == 8);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4, after) == 24);
static_assert(sizeof(::test_unionsandwich::wire::SandwichUnionSize12Alignment4) == ::fidl::TypeTraits<::test_unionsandwich::wire::SandwichUnionSize12Alignment4>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::StructSize16Alignment8, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::StructSize16Alignment8* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unionsandwich::wire::StructSize16Alignment8));
  } else {
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->f1, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->f2, position + 8, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::StructSize16Alignment8, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::StructSize16Alignment8, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::StructSize16Alignment8, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::StructSize16Alignment8>);
static_assert(offsetof(::test_unionsandwich::wire::StructSize16Alignment8, f1) == 0);
static_assert(offsetof(::test_unionsandwich::wire::StructSize16Alignment8, f2) == 8);
static_assert(sizeof(::test_unionsandwich::wire::StructSize16Alignment8) == ::fidl::TypeTraits<::test_unionsandwich::wire::StructSize16Alignment8>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize24Alignment8, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::SandwichUnionSize24Alignment8* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 24);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->before, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->after, position + 24, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize24Alignment8, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize24Alignment8, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize24Alignment8, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::SandwichUnionSize24Alignment8>);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8, before) == 0);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8, union_) == 8);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8, after) == 24);
static_assert(sizeof(::test_unionsandwich::wire::SandwichUnionSize24Alignment8) == ::fidl::TypeTraits<::test_unionsandwich::wire::SandwichUnionSize24Alignment8>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize36Alignment4, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::SandwichUnionSize36Alignment4* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 24);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->before, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->after, position + 24, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize36Alignment4, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize36Alignment4, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::SandwichUnionSize36Alignment4, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::SandwichUnionSize36Alignment4>);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4, before) == 0);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4, union_) == 8);
static_assert(offsetof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4, after) == 24);
static_assert(sizeof(::test_unionsandwich::wire::SandwichUnionSize36Alignment4) == ::fidl::TypeTraits<::test_unionsandwich::wire::SandwichUnionSize36Alignment4>::kPrimarySize);

::test_unionsandwich::wire::UnionSize8Alignment4::UnionSize8Alignment4() : ordinal_(::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::Invalid), envelope_{} {}
::test_unionsandwich::wire::UnionSize8Alignment4::Tag test_unionsandwich::wire::UnionSize8Alignment4::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unionsandwich::wire::UnionSize8Alignment4::Tag>(ordinal_);
}

void ::test_unionsandwich::wire::UnionSize8Alignment4::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionSize8Alignment4) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionSize8Alignment4, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionSize8Alignment4, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unionsandwich::wire::UnionSize8Alignment4::has_invalid_tag() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::Invalid; }

bool test_unionsandwich::wire::UnionSize8Alignment4::is_variant() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant; }
::test_unionsandwich::wire::UnionSize8Alignment4 test_unionsandwich::wire::UnionSize8Alignment4::WithVariant(uint32_t val) {
  UnionSize8Alignment4 result;
  result.ordinal_ = ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_unionsandwich::wire::UnionSize8Alignment4::variant() {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_unionsandwich::wire::UnionSize8Alignment4::variant() const {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize8Alignment4::Ordinal::kVariant);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::UnionSize8Alignment4>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::UnionSize8Alignment4* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize8Alignment4::Tag::kVariant
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize8Alignment4::Tag::kVariant
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_unionsandwich::wire::UnionSize8Alignment4::Tag tag = *position.As<::test_unionsandwich::wire::UnionSize8Alignment4::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize8Alignment4::Tag::kVariant:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize8Alignment4::Tag::kVariant:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize8Alignment4, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unionsandwich::wire::UnionSize12Alignment4::UnionSize12Alignment4() : ordinal_(::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::Invalid), envelope_{} {}
::test_unionsandwich::wire::UnionSize12Alignment4::Tag test_unionsandwich::wire::UnionSize12Alignment4::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unionsandwich::wire::UnionSize12Alignment4::Tag>(ordinal_);
}

void ::test_unionsandwich::wire::UnionSize12Alignment4::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionSize12Alignment4) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionSize12Alignment4, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionSize12Alignment4, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unionsandwich::wire::UnionSize12Alignment4::has_invalid_tag() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::Invalid; }

bool test_unionsandwich::wire::UnionSize12Alignment4::is_variant() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant; }
::test_unionsandwich::wire::UnionSize12Alignment4 test_unionsandwich::wire::UnionSize12Alignment4::WithVariant(::fidl::ObjectView<::fidl::Array<uint8_t, 6>> val) {
  UnionSize12Alignment4 result;
  result.ordinal_ = ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant;
  result.envelope_.As<::fidl::Array<uint8_t, 6>>().set_data(std::move(val));
  return result;
}

::fidl::Array<uint8_t, 6>& test_unionsandwich::wire::UnionSize12Alignment4::variant() {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant);
  return envelope_.As<::fidl::Array<uint8_t, 6>>().get_data();
}
const ::fidl::Array<uint8_t, 6>& test_unionsandwich::wire::UnionSize12Alignment4::variant() const {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize12Alignment4::Ordinal::kVariant);
  return envelope_.As<::fidl::Array<uint8_t, 6>>().get_data();
}

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::UnionSize12Alignment4>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::UnionSize12Alignment4* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize12Alignment4::Tag::kVariant
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<uint8_t, 6>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize12Alignment4::Tag::kVariant
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::Array<uint8_t, 6>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_unionsandwich::wire::UnionSize12Alignment4::Tag tag = *position.As<::test_unionsandwich::wire::UnionSize12Alignment4::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize12Alignment4::Tag::kVariant:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<uint8_t, 6>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize12Alignment4::Tag::kVariant:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::Array<uint8_t, 6>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize12Alignment4, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unionsandwich::wire::UnionSize24Alignment8::UnionSize24Alignment8() : ordinal_(::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::Invalid), envelope_{} {}
::test_unionsandwich::wire::UnionSize24Alignment8::Tag test_unionsandwich::wire::UnionSize24Alignment8::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unionsandwich::wire::UnionSize24Alignment8::Tag>(ordinal_);
}

void ::test_unionsandwich::wire::UnionSize24Alignment8::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionSize24Alignment8) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionSize24Alignment8, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionSize24Alignment8, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unionsandwich::wire::UnionSize24Alignment8::has_invalid_tag() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::Invalid; }

bool test_unionsandwich::wire::UnionSize24Alignment8::is_variant() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant; }
::test_unionsandwich::wire::UnionSize24Alignment8 test_unionsandwich::wire::UnionSize24Alignment8::WithVariant(::fidl::ObjectView<::test_unionsandwich::wire::StructSize16Alignment8> val) {
  UnionSize24Alignment8 result;
  result.ordinal_ = ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant;
  result.envelope_.As<::test_unionsandwich::wire::StructSize16Alignment8>().set_data(std::move(val));
  return result;
}

::test_unionsandwich::wire::StructSize16Alignment8& test_unionsandwich::wire::UnionSize24Alignment8::variant() {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant);
  return envelope_.As<::test_unionsandwich::wire::StructSize16Alignment8>().get_data();
}
const ::test_unionsandwich::wire::StructSize16Alignment8& test_unionsandwich::wire::UnionSize24Alignment8::variant() const {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize24Alignment8::Ordinal::kVariant);
  return envelope_.As<::test_unionsandwich::wire::StructSize16Alignment8>().get_data();
}

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::UnionSize24Alignment8>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::UnionSize24Alignment8* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize24Alignment8::Tag::kVariant
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::StructSize16Alignment8, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize24Alignment8::Tag::kVariant
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_unionsandwich::wire::StructSize16Alignment8, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_unionsandwich::wire::UnionSize24Alignment8::Tag tag = *position.As<::test_unionsandwich::wire::UnionSize24Alignment8::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize24Alignment8::Tag::kVariant:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::StructSize16Alignment8, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize24Alignment8::Tag::kVariant:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_unionsandwich::wire::StructSize16Alignment8, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize24Alignment8, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_unionsandwich::wire::UnionSize36Alignment4::UnionSize36Alignment4() : ordinal_(::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::Invalid), envelope_{} {}
::test_unionsandwich::wire::UnionSize36Alignment4::Tag test_unionsandwich::wire::UnionSize36Alignment4::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_unionsandwich::wire::UnionSize36Alignment4::Tag>(ordinal_);
}

void ::test_unionsandwich::wire::UnionSize36Alignment4::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionSize36Alignment4) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionSize36Alignment4, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionSize36Alignment4, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_unionsandwich::wire::UnionSize36Alignment4::has_invalid_tag() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::Invalid; }

bool test_unionsandwich::wire::UnionSize36Alignment4::is_variant() const { return ordinal_ == ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant; }
::test_unionsandwich::wire::UnionSize36Alignment4 test_unionsandwich::wire::UnionSize36Alignment4::WithVariant(::fidl::ObjectView<::fidl::Array<uint8_t, 32>> val) {
  UnionSize36Alignment4 result;
  result.ordinal_ = ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant;
  result.envelope_.As<::fidl::Array<uint8_t, 32>>().set_data(std::move(val));
  return result;
}

::fidl::Array<uint8_t, 32>& test_unionsandwich::wire::UnionSize36Alignment4::variant() {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant);
  return envelope_.As<::fidl::Array<uint8_t, 32>>().get_data();
}
const ::fidl::Array<uint8_t, 32>& test_unionsandwich::wire::UnionSize36Alignment4::variant() const {
  ZX_ASSERT(ordinal_ == ::test_unionsandwich::wire::UnionSize36Alignment4::Ordinal::kVariant);
  return envelope_.As<::fidl::Array<uint8_t, 32>>().get_data();
}

static_assert(std::is_standard_layout_v<::test_unionsandwich::wire::UnionSize36Alignment4>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_unionsandwich::wire::UnionSize36Alignment4* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize36Alignment4::Tag::kVariant
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<uint8_t, 32>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_unionsandwich::wire::UnionSize36Alignment4::Tag::kVariant
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::Array<uint8_t, 32>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_unionsandwich::wire::UnionSize36Alignment4::Tag tag = *position.As<::test_unionsandwich::wire::UnionSize36Alignment4::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize36Alignment4::Tag::kVariant:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::Array<uint8_t, 32>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_unionsandwich::wire::UnionSize36Alignment4::Tag::kVariant:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::Array<uint8_t, 32>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_unionsandwich::wire::UnionSize36Alignment4, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#pragma clang diagnostic pop
