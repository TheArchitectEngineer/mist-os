// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.anonymous/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

void fidl::internal::NaturalCodingTraits<::test_anonymous::Flags, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_anonymous::Flags* value, size_t offset, size_t recursion_depth) {
  *encoder->template GetPtr<::test_anonymous::Flags>(offset) = *value;
}
void fidl::internal::NaturalCodingTraits<::test_anonymous::Flags, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_anonymous::Flags* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_anonymous::Flags>(offset);
}

void fidl::internal::NaturalCodingTraits<::test_anonymous::BitsMember, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_anonymous::BitsMember* value, size_t offset, size_t recursion_depth) {
  *encoder->template GetPtr<::test_anonymous::BitsMember>(offset) = *value;
}
void fidl::internal::NaturalCodingTraits<::test_anonymous::BitsMember, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_anonymous::BitsMember* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_anonymous::BitsMember>(offset);
}

void fidl::internal::NaturalCodingTraits<::test_anonymous::Op, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_anonymous::Op* value, size_t offset, size_t recursion_depth) {
  *encoder->template GetPtr<::test_anonymous::Op>(offset) = *value;
}

void fidl::internal::NaturalCodingTraits<::test_anonymous::Op, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_anonymous::Op* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_anonymous::Op>(offset);
}

void fidl::internal::NaturalCodingTraits<::test_anonymous::SomeProtocolSomeMethodError, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_anonymous::SomeProtocolSomeMethodError* value, size_t offset, size_t recursion_depth) {
  *encoder->template GetPtr<::test_anonymous::SomeProtocolSomeMethodError>(offset) = *value;
}

void fidl::internal::NaturalCodingTraits<::test_anonymous::SomeProtocolSomeMethodError, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_anonymous::SomeProtocolSomeMethodError* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_anonymous::SomeProtocolSomeMethodError>(offset);
}

::test_anonymous::OverrideTest::OverrideTest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_anonymous::OverrideTest::OverrideTest(::test_anonymous::Op op, ::fidl::Box<::test_anonymous::Expression> left, ::fidl::Box<::test_anonymous::Expression> right) noexcept
    : storage_({.op = std::move(op),
                .left = std::move(left),
                .right = std::move(right)}) {}

::test_anonymous::OverrideTest::OverrideTest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : OverrideTest(Storage_{
                                                                                                               .op = {},
                                                                                                               .left = {},
                                                                                                               .right = {},
                                                                                                           }) {}
::test_anonymous::OverrideTest::OverrideTest(const ::test_anonymous::OverrideTest& other) noexcept : ::test_anonymous::OverrideTest(other.CloneStorage_()) {}

::test_anonymous::OverrideTest& test_anonymous::OverrideTest::operator=(const ::test_anonymous::OverrideTest& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_anonymous::OverrideTest::operator==(const OverrideTest& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_anonymous::OverrideTest, 40>::Equal(this, &other);
}

bool test_anonymous::OverrideTest::operator!=(const OverrideTest& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_anonymous::OverrideTest, 40>::Equal(this, &other);
}

::test_anonymous::OverrideTest::Storage_ test_anonymous::OverrideTest::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.op),
      ::fidl::internal::NaturalClone(storage_.left),
      ::fidl::internal::NaturalClone(storage_.right)};
}
::test_anonymous::Op
test_anonymous::OverrideTest::op() const {
  return storage_.op;
}

::test_anonymous::Op& ::test_anonymous::OverrideTest::op() {
  return storage_.op;
}

::test_anonymous::OverrideTest& ::test_anonymous::OverrideTest::op(::test_anonymous::Op value) {
  storage_.op = std::move(value);
  return *this;
}
const ::fidl::Box<::test_anonymous::Expression>&
test_anonymous::OverrideTest::left() const {
  return storage_.left;
}

::fidl::Box<::test_anonymous::Expression>& ::test_anonymous::OverrideTest::left() {
  return storage_.left;
}

::test_anonymous::OverrideTest& ::test_anonymous::OverrideTest::left(::fidl::Box<::test_anonymous::Expression> value) {
  storage_.left = std::move(value);
  return *this;
}
const ::fidl::Box<::test_anonymous::Expression>&
test_anonymous::OverrideTest::right() const {
  return storage_.right;
}

::fidl::Box<::test_anonymous::Expression>& ::test_anonymous::OverrideTest::right() {
  return storage_.right;
}

::test_anonymous::OverrideTest& ::test_anonymous::OverrideTest::right(::fidl::Box<::test_anonymous::Expression> value) {
  storage_.right = std::move(value);
  return *this;
}

::test_anonymous::TableData::TableData(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_anonymous::TableData::TableData(uint8_t data) noexcept
    : storage_({.data = std::move(data)}) {}

::test_anonymous::TableData::TableData(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TableData(Storage_{
                                                                                                         .data = {},
                                                                                                     }) {}
::test_anonymous::TableData::TableData(const ::test_anonymous::TableData& other) noexcept : ::test_anonymous::TableData(other.CloneStorage_()) {}

::test_anonymous::TableData& test_anonymous::TableData::operator=(const ::test_anonymous::TableData& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_anonymous::TableData::operator==(const TableData& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_anonymous::TableData, 1>::Equal(this, &other);
}

bool test_anonymous::TableData::operator!=(const TableData& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_anonymous::TableData, 1>::Equal(this, &other);
}

::test_anonymous::TableData::Storage_ test_anonymous::TableData::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.data)};
}
uint8_t
test_anonymous::TableData::data() const {
  return storage_.data;
}

uint8_t& ::test_anonymous::TableData::data() {
  return storage_.data;
}

::test_anonymous::TableData& ::test_anonymous::TableData::data(uint8_t value) {
  storage_.data = std::move(value);
  return *this;
}

::test_anonymous::SomeProtocolSomeMethodRequest::SomeProtocolSomeMethodRequest(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_anonymous::SomeProtocolSomeMethodRequest::SomeProtocolSomeMethodRequest(::test_anonymous::UnionMember union_member, ::test_anonymous::TableMember table_member) noexcept
    : storage_({.union_member = std::move(union_member),
                .table_member = std::move(table_member)}) {}

::test_anonymous::SomeProtocolSomeMethodRequest::SomeProtocolSomeMethodRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : SomeProtocolSomeMethodRequest(Storage_{
                                                                                                                                                 .union_member = ::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
                                                                                                                                                 .table_member = ::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
                                                                                                                                             }) {}
::test_anonymous::SomeProtocolSomeMethodRequest::SomeProtocolSomeMethodRequest(const ::test_anonymous::SomeProtocolSomeMethodRequest& other) noexcept : ::test_anonymous::SomeProtocolSomeMethodRequest(other.CloneStorage_()) {}

::test_anonymous::SomeProtocolSomeMethodRequest& test_anonymous::SomeProtocolSomeMethodRequest::operator=(const ::test_anonymous::SomeProtocolSomeMethodRequest& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_anonymous::SomeProtocolSomeMethodRequest::operator==(const SomeProtocolSomeMethodRequest& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_anonymous::SomeProtocolSomeMethodRequest, 32>::Equal(this, &other);
}

bool test_anonymous::SomeProtocolSomeMethodRequest::operator!=(const SomeProtocolSomeMethodRequest& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_anonymous::SomeProtocolSomeMethodRequest, 32>::Equal(this, &other);
}

::test_anonymous::SomeProtocolSomeMethodRequest::Storage_ test_anonymous::SomeProtocolSomeMethodRequest::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.union_member),
      ::fidl::internal::NaturalClone(storage_.table_member)};
}
const ::test_anonymous::UnionMember&
test_anonymous::SomeProtocolSomeMethodRequest::union_member() const {
  return storage_.union_member;
}

::test_anonymous::UnionMember& ::test_anonymous::SomeProtocolSomeMethodRequest::union_member() {
  return storage_.union_member;
}

::test_anonymous::SomeProtocolSomeMethodRequest& ::test_anonymous::SomeProtocolSomeMethodRequest::union_member(::test_anonymous::UnionMember value) {
  storage_.union_member = std::move(value);
  return *this;
}
const ::test_anonymous::TableMember&
test_anonymous::SomeProtocolSomeMethodRequest::table_member() const {
  return storage_.table_member;
}

::test_anonymous::TableMember& ::test_anonymous::SomeProtocolSomeMethodRequest::table_member() {
  return storage_.table_member;
}

::test_anonymous::SomeProtocolSomeMethodRequest& ::test_anonymous::SomeProtocolSomeMethodRequest::table_member(::test_anonymous::TableMember value) {
  storage_.table_member = std::move(value);
  return *this;
}

::test_anonymous::SomeProtocolSomeMethodResponse::SomeProtocolSomeMethodResponse(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_anonymous::SomeProtocolSomeMethodResponse::SomeProtocolSomeMethodResponse(::test_anonymous::BitsMember bits_member) noexcept
    : storage_({.bits_member = std::move(bits_member)}) {}

::test_anonymous::SomeProtocolSomeMethodResponse::SomeProtocolSomeMethodResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : SomeProtocolSomeMethodResponse(Storage_{
                                                                                                                                                   .bits_member = {},
                                                                                                                                               }) {}
::test_anonymous::SomeProtocolSomeMethodResponse::SomeProtocolSomeMethodResponse(const ::test_anonymous::SomeProtocolSomeMethodResponse& other) noexcept : ::test_anonymous::SomeProtocolSomeMethodResponse(other.CloneStorage_()) {}

::test_anonymous::SomeProtocolSomeMethodResponse& test_anonymous::SomeProtocolSomeMethodResponse::operator=(const ::test_anonymous::SomeProtocolSomeMethodResponse& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_anonymous::SomeProtocolSomeMethodResponse::operator==(const SomeProtocolSomeMethodResponse& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_anonymous::SomeProtocolSomeMethodResponse, 4>::Equal(this, &other);
}

bool test_anonymous::SomeProtocolSomeMethodResponse::operator!=(const SomeProtocolSomeMethodResponse& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_anonymous::SomeProtocolSomeMethodResponse, 4>::Equal(this, &other);
}

::test_anonymous::SomeProtocolSomeMethodResponse::Storage_ test_anonymous::SomeProtocolSomeMethodResponse::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.bits_member)};
}
::test_anonymous::BitsMember
test_anonymous::SomeProtocolSomeMethodResponse::bits_member() const {
  return storage_.bits_member;
}

::test_anonymous::BitsMember& ::test_anonymous::SomeProtocolSomeMethodResponse::bits_member() {
  return storage_.bits_member;
}

::test_anonymous::SomeProtocolSomeMethodResponse& ::test_anonymous::SomeProtocolSomeMethodResponse::bits_member(::test_anonymous::BitsMember value) {
  storage_.bits_member = std::move(value);
  return *this;
}

::test_anonymous::FunctionApplication::FunctionApplication(::test_anonymous::FunctionApplication::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_anonymous::FunctionApplication::FunctionApplication(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : FunctionApplication(Storage_{}) {}

::test_anonymous::FunctionApplication::FunctionApplication(const ::test_anonymous::FunctionApplication& other) noexcept : FunctionApplication(other.CloneStorage_()) {}

::test_anonymous::FunctionApplication& ::test_anonymous::FunctionApplication::operator=(const ::test_anonymous::FunctionApplication& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_anonymous::FunctionApplication::operator==(const FunctionApplication& other) const noexcept {
  return ::fidl::internal::NaturalTableCodingTraits<::test_anonymous::FunctionApplication>::Equal(this, &other);
}
bool test_anonymous::FunctionApplication::operator!=(const FunctionApplication& other) const noexcept {
  return !::fidl::internal::NaturalTableCodingTraits<::test_anonymous::FunctionApplication>::Equal(this, &other);
}

::test_anonymous::FunctionApplication::Storage_ test_anonymous::FunctionApplication::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.func),
      ::fidl::internal::NaturalClone(storage_.args),
      ::fidl::internal::NaturalClone(storage_.flags)};
}

bool test_anonymous::FunctionApplication::IsEmpty() const {
  return !(storage_.func.has_value() || storage_.args.has_value() || storage_.flags.has_value());
}
const std::optional<::std::string>& test_anonymous::FunctionApplication::func() const {
  return storage_.func;
}

::std::optional<::std::string>& test_anonymous::FunctionApplication::func() {
  return storage_.func;
}

::test_anonymous::FunctionApplication& test_anonymous::FunctionApplication::func(std::optional<::std::string> value) {
  storage_.func = std::move(value);
  return *this;
}
const std::optional<::std::vector<::fidl::Box<::test_anonymous::Expression>>>& test_anonymous::FunctionApplication::args() const {
  return storage_.args;
}

::std::optional<::std::vector<::fidl::Box<::test_anonymous::Expression>>>& test_anonymous::FunctionApplication::args() {
  return storage_.args;
}

::test_anonymous::FunctionApplication& test_anonymous::FunctionApplication::args(std::optional<::std::vector<::fidl::Box<::test_anonymous::Expression>>> value) {
  storage_.args = std::move(value);
  return *this;
}
const std::optional<::test_anonymous::Flags>& test_anonymous::FunctionApplication::flags() const {
  return storage_.flags;
}

::std::optional<::test_anonymous::Flags>& test_anonymous::FunctionApplication::flags() {
  return storage_.flags;
}

::test_anonymous::FunctionApplication& test_anonymous::FunctionApplication::flags(std::optional<::test_anonymous::Flags> value) {
  storage_.flags = std::move(value);
  return *this;
}

::test_anonymous::TableMember::TableMember(::test_anonymous::TableMember::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_anonymous::TableMember::TableMember(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : TableMember(Storage_{}) {}

::test_anonymous::TableMember::TableMember(const ::test_anonymous::TableMember& other) noexcept : TableMember(other.CloneStorage_()) {}

::test_anonymous::TableMember& ::test_anonymous::TableMember::operator=(const ::test_anonymous::TableMember& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_anonymous::TableMember::operator==(const TableMember& other) const noexcept {
  return ::fidl::internal::NaturalTableCodingTraits<::test_anonymous::TableMember>::Equal(this, &other);
}
bool test_anonymous::TableMember::operator!=(const TableMember& other) const noexcept {
  return !::fidl::internal::NaturalTableCodingTraits<::test_anonymous::TableMember>::Equal(this, &other);
}

::test_anonymous::TableMember::Storage_ test_anonymous::TableMember::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.table_data)};
}

bool test_anonymous::TableMember::IsEmpty() const {
  return !(storage_.table_data.has_value());
}
const std::optional<::std::vector<::test_anonymous::TableData>>& test_anonymous::TableMember::table_data() const {
  return storage_.table_data;
}

::std::optional<::std::vector<::test_anonymous::TableData>>& test_anonymous::TableMember::table_data() {
  return storage_.table_data;
}

::test_anonymous::TableMember& test_anonymous::TableMember::table_data(std::optional<::std::vector<::test_anonymous::TableData>> value) {
  storage_.table_data = std::move(value);
  return *this;
}

::test_anonymous::Expression::Expression(Expression&& other) noexcept : Expression(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_anonymous::Expression& ::test_anonymous::Expression::operator=(Expression&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_anonymous::Expression::Expression(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_anonymous::Expression::Expression(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_anonymous::Expression::Tag test_anonymous::Expression::Which() const {
  return Expression::IndexToTag(storage_->index()).value();
}

size_t test_anonymous::Expression::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_anonymous::Expression::Tag tag) {
  switch (tag) {
    case ::test_anonymous::Expression::Tag::kValue:
      return 1;
    case ::test_anonymous::Expression::Tag::kBinOp:
      return 2;
    case ::test_anonymous::Expression::Tag::kFunctionApplication:
      return 3;
    default: {
      return 0;
    }
  }
}

std::optional<::test_anonymous::Expression::Tag> test_anonymous::Expression::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_anonymous::Expression::Tag::kValue;
    case 2:
      return ::test_anonymous::Expression::Tag::kBinOp;
    case 3:
      return ::test_anonymous::Expression::Tag::kFunctionApplication;
    default:
      return ::test_anonymous::Expression::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_anonymous::Expression::Expression(const Expression& other) noexcept : Expression(other.CloneStorage_()) {}

::test_anonymous::Expression& test_anonymous::Expression::operator=(const Expression& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_anonymous::Expression::operator==(const Expression& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_anonymous::Expression::operator!=(const Expression& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_anonymous::Expression::Storage_> test_anonymous::Expression::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    case 3:
      return std::make_shared<Storage_>(
          std::in_place_index<3>,
          ::fidl::internal::NaturalClone(std::get<3>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_anonymous::Expression::IsUnknown() const {
  return Which() == ::test_anonymous::Expression::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_anonymous::Expression test_anonymous::Expression::WithValue(uint64_t val) {
  return Expression(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_anonymous::Expression::Storage_> test_anonymous::Expression::value() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_anonymous::Expression::Storage_> test_anonymous::Expression::value() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_anonymous::Expression& test_anonymous::Expression::value(uint64_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_anonymous::Expression test_anonymous::Expression::WithBinOp(::test_anonymous::OverrideTest val) {
  return Expression(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_anonymous::Expression::Storage_> test_anonymous::Expression::bin_op() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_anonymous::Expression::Storage_> test_anonymous::Expression::bin_op() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_anonymous::Expression& test_anonymous::Expression::bin_op(::test_anonymous::OverrideTest value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}
::test_anonymous::Expression test_anonymous::Expression::WithFunctionApplication(::test_anonymous::FunctionApplication val) {
  return Expression(std::make_shared<Storage_>(
      std::in_place_index_t<3>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<3, ::test_anonymous::Expression::Storage_> test_anonymous::Expression::function_application() const {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<3, ::test_anonymous::Expression::Storage_> test_anonymous::Expression::function_application() {
  return ::fidl::internal::UnionMemberView<3, Storage_>(storage_);
}

::test_anonymous::Expression& test_anonymous::Expression::function_application(::test_anonymous::FunctionApplication value) {
  storage_->emplace<3>(std::move(value));
  return *this;
}

::test_anonymous::UnionMember::UnionMember(UnionMember&& other) noexcept : UnionMember(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_anonymous::UnionMember& ::test_anonymous::UnionMember::operator=(UnionMember&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_anonymous::UnionMember::UnionMember(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_anonymous::UnionMember::UnionMember(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_anonymous::UnionMember::Tag test_anonymous::UnionMember::Which() const {
  return UnionMember::IndexToTag(storage_->index()).value();
}

size_t test_anonymous::UnionMember::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_anonymous::UnionMember::Tag tag) {
  switch (tag) {
    case ::test_anonymous::UnionMember::Tag::kUnionData:
      return 1;
    default: {
      return 0;
    }
  }
}

std::optional<::test_anonymous::UnionMember::Tag> test_anonymous::UnionMember::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_anonymous::UnionMember::Tag::kUnionData;
    default:
      return ::test_anonymous::UnionMember::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_anonymous::UnionMember::UnionMember(const UnionMember& other) noexcept : UnionMember(other.CloneStorage_()) {}

::test_anonymous::UnionMember& test_anonymous::UnionMember::operator=(const UnionMember& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_anonymous::UnionMember::operator==(const UnionMember& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_anonymous::UnionMember::operator!=(const UnionMember& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_anonymous::UnionMember::Storage_> test_anonymous::UnionMember::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_anonymous::UnionMember::IsUnknown() const {
  return Which() == ::test_anonymous::UnionMember::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_anonymous::UnionMember test_anonymous::UnionMember::WithUnionData(uint8_t val) {
  return UnionMember(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_anonymous::UnionMember::Storage_> test_anonymous::UnionMember::union_data() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_anonymous::UnionMember::Storage_> test_anonymous::UnionMember::union_data() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_anonymous::UnionMember& test_anonymous::UnionMember::union_data(uint8_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_anonymous::SomeProtocolSomeMethodResult::SomeProtocolSomeMethodResult(SomeProtocolSomeMethodResult&& other) noexcept : SomeProtocolSomeMethodResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_anonymous::SomeProtocolSomeMethodResult& ::test_anonymous::SomeProtocolSomeMethodResult::operator=(SomeProtocolSomeMethodResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_anonymous::SomeProtocolSomeMethodResult::SomeProtocolSomeMethodResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_anonymous::SomeProtocolSomeMethodResult::SomeProtocolSomeMethodResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_anonymous::SomeProtocolSomeMethodResult::Tag test_anonymous::SomeProtocolSomeMethodResult::Which() const {
  return SomeProtocolSomeMethodResult::IndexToTag(storage_->index()).value();
}

size_t test_anonymous::SomeProtocolSomeMethodResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_anonymous::SomeProtocolSomeMethodResult::Tag tag) {
  switch (tag) {
    case ::test_anonymous::SomeProtocolSomeMethodResult::Tag::kResponse:
      return 1;
    case ::test_anonymous::SomeProtocolSomeMethodResult::Tag::kErr:
      return 2;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_anonymous::SomeProtocolSomeMethodResult::Tag> test_anonymous::SomeProtocolSomeMethodResult::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_anonymous::SomeProtocolSomeMethodResult::Tag::kResponse;
    case 2:
      return ::test_anonymous::SomeProtocolSomeMethodResult::Tag::kErr;
    default:
      return std::nullopt;
  }
}

::test_anonymous::SomeProtocolSomeMethodResult::SomeProtocolSomeMethodResult(const SomeProtocolSomeMethodResult& other) noexcept : SomeProtocolSomeMethodResult(other.CloneStorage_()) {}

::test_anonymous::SomeProtocolSomeMethodResult& test_anonymous::SomeProtocolSomeMethodResult::operator=(const SomeProtocolSomeMethodResult& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_anonymous::SomeProtocolSomeMethodResult::operator==(const SomeProtocolSomeMethodResult& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_anonymous::SomeProtocolSomeMethodResult::operator!=(const SomeProtocolSomeMethodResult& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_anonymous::SomeProtocolSomeMethodResult::Storage_> test_anonymous::SomeProtocolSomeMethodResult::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage_>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_anonymous::SomeProtocolSomeMethodResult test_anonymous::SomeProtocolSomeMethodResult::WithResponse(::test_anonymous::SomeProtocolSomeMethodResponse val) {
  return SomeProtocolSomeMethodResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_anonymous::SomeProtocolSomeMethodResult::Storage_> test_anonymous::SomeProtocolSomeMethodResult::response() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_anonymous::SomeProtocolSomeMethodResult::Storage_> test_anonymous::SomeProtocolSomeMethodResult::response() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_anonymous::SomeProtocolSomeMethodResult& test_anonymous::SomeProtocolSomeMethodResult::response(::test_anonymous::SomeProtocolSomeMethodResponse value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}
::test_anonymous::SomeProtocolSomeMethodResult test_anonymous::SomeProtocolSomeMethodResult::WithErr(::test_anonymous::SomeProtocolSomeMethodError val) {
  return SomeProtocolSomeMethodResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<2, ::test_anonymous::SomeProtocolSomeMethodResult::Storage_> test_anonymous::SomeProtocolSomeMethodResult::err() const {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<2, ::test_anonymous::SomeProtocolSomeMethodResult::Storage_> test_anonymous::SomeProtocolSomeMethodResult::err() {
  return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
}

::test_anonymous::SomeProtocolSomeMethodResult& test_anonymous::SomeProtocolSomeMethodResult::err(::test_anonymous::SomeProtocolSomeMethodError value) {
  storage_->emplace<2>(std::move(value));
  return *this;
}

#pragma clang diagnostic pop
