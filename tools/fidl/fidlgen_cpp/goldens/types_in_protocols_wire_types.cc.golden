// WARNING: This file is machine generated by fidlgen.

  // fidl_experiment = output_index_json

  #include <fidl/test.typesinprotocols/cpp/wire_types.h>

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Bits>);
static_assert(sizeof(::test_typesinprotocols::wire::Bits) == sizeof(uint32_t));

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Bits* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  *position.As<::test_typesinprotocols::wire::Bits>() = *value;
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, ::fidl::internal::WireCodingConstraintEmpty, false>;

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
  ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Enum* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  *position.As<::test_typesinprotocols::wire::Enum>() = *value;
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
  ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, ::fidl::internal::WireCodingConstraintEmpty, false>;

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Struct* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Struct));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Struct>);
static_assert(offsetof(::test_typesinprotocols::wire::Struct, __reserved) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::Struct) == ::fidl::TypeTraits<::test_typesinprotocols::wire::Struct>::kPrimarySize);

#ifdef __Fuchsia__

    void ::test_typesinprotocols::wire::ResourceStruct::_CloseHandles() {

    }

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceStruct* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ResourceStruct));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ResourceStruct>);
static_assert(offsetof(::test_typesinprotocols::wire::ResourceStruct, __reserved) == 0);
static_assert(sizeof(::test_typesinprotocols::wire::ResourceStruct) == ::fidl::TypeTraits<::test_typesinprotocols::wire::ResourceStruct>::kPrimarySize);

#endif  // __Fuchsia__

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Basic* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Basic));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 16);
    internal::WireZeroPadding<uint64_t>(encoder, position + 32);
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint8, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint16, position + 2, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint32, position + 4, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->uint64, position + 8, recursion_depth);
    internal::WireCodingTraits<int8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int8, position + 16, recursion_depth);
    internal::WireCodingTraits<int16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int16, position + 18, recursion_depth);
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int32, position + 20, recursion_depth);
    internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->int64, position + 24, recursion_depth);
    internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->float32, position + 32, recursion_depth);
    internal::WireCodingTraits<double, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->float64, position + 40, recursion_depth);
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->string, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Encode(encoder, &value->opt_string, position + 64, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 2, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 4, recursion_depth);
    internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<int8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<int16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 18, recursion_depth);
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 20, recursion_depth);
    internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 24, recursion_depth);
    internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 32, recursion_depth);
    internal::WireCodingTraits<double, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 40, recursion_depth);
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
      decoder, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Decode(
      decoder, position + 64, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xff00);
  internal::WireCheckPadding<uint64_t>(decoder, position + 16, 0xff00);
  internal::WireCheckPadding<uint64_t>(decoder, position + 32, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Basic>);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint16) == 2);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint32) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint64) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int8) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int16) == 18);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int32) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, int64) == 24);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, float64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, string) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Basic, opt_string) == 64);
static_assert(sizeof(::test_typesinprotocols::wire::Basic) == ::fidl::TypeTraits<::test_typesinprotocols::wire::Basic>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Compound* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Compound));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 8);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->bits, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->enum_, position + 4, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->struct_, position + 8, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Table, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->table, position + 16, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Union, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->opt_struct, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->opt_union, position + 56, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 4, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Table, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::Union, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
      decoder, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
      decoder, position + 56, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffffffff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Compound>);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, enum_) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, struct_) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, table) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, union_) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_struct) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_union) == 56);
static_assert(sizeof(::test_typesinprotocols::wire::Compound) == ::fidl::TypeTraits<::test_typesinprotocols::wire::Compound>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayBasic* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ArrayBasic));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 32);
    internal::WireZeroPadding<uint64_t>(encoder, position + 80);
    internal::WireZeroPadding<uint64_t>(encoder, position + 112);
    internal::WireZeroPadding<uint64_t>(encoder, position + 176);
    internal::WireCodingTraits<::fidl::Array<uint8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint8, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<uint16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint16, position + 6, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<uint32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint32, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<uint64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_uint64, position + 40, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int8, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int16, position + 86, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int32, position + 96, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_int64, position + 120, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<float, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_float32, position + 160, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<double, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_float64, position + 184, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Encode(encoder, &value->array_string, position + 224, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Encode(encoder, &value->array_opt_string, position + 304, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::Array<uint8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<uint16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 6, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<uint32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<uint64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 40, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 86, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 96, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<int64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 120, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<float, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 160, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<double, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 184, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::Decode(
      decoder, position + 224, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Decode(
      decoder, position + 304, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xff0000000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 32, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 80, 0xff0000000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 112, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 176, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ArrayBasic>);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint16) == 6);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint32) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint64) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int8) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int16) == 86);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int64) == 120);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float32) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float64) == 184);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_string) == 224);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_opt_string) == 304);
static_assert(sizeof(::test_typesinprotocols::wire::ArrayBasic) == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayBasic>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayCompound* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ArrayCompound));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 40);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Bits, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_bits, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Enum, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_enum, position + 20, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Struct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_struct, position + 40, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Table, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_table, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Union, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->array_union, position + 128, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_opt_struct, position + 208, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->array_opt_union, position + 248, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Bits, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Enum, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 20, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Struct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 40, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Table, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::Union, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
      decoder, position + 128, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 208, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
      decoder, position + 248, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 40, 0xffffff0000000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ArrayCompound>);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_enum) == 20);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_struct) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_union) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_struct) == 208);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_union) == 248);
static_assert(sizeof(::test_typesinprotocols::wire::ArrayCompound) == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayCompound>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorBasic* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::VectorBasic));
  } else {
    internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint8, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<uint16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint16, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<uint32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint32, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<uint64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_uint64, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int8, position + 64, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int16, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int32, position + 96, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_int64, position + 112, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<float>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_float32, position + 128, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<double>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_float64, position + 144, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::Encode(encoder, &value->vector_string, position + 160, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<true>, false>, IsRecursive>::Encode(encoder, &value->vector_opt_string, position + 176, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<uint16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<uint32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<uint64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 64, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 96, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<int64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 112, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<float>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 128, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<double>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 144, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::Decode(
      decoder, position + 160, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<true>, false>, IsRecursive>::Decode(
      decoder, position + 176, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::VectorBasic>);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint16) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint32) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint64) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int8) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int16) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int32) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int64) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float32) == 128);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float64) == 144);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_string) == 160);
static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_opt_string) == 176);
static_assert(sizeof(::test_typesinprotocols::wire::VectorBasic) == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorBasic>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorCompound* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::VectorCompound));
  } else {
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Bits>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_bits, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Enum>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_enum, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_struct, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Table>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_table, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Encode(encoder, &value->vector_union, position + 64, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_opt_struct, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false>, IsRecursive>::Encode(encoder, &value->vector_opt_union, position + 96, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Bits>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Enum>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Table>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 48, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Decode(
      decoder, position + 64, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false>, IsRecursive>::Decode(
      decoder, position + 96, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::VectorCompound>);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_bits) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_enum) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_table) == 48);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_union) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_struct) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_union) == 96);
static_assert(sizeof(::test_typesinprotocols::wire::VectorCompound) == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorCompound>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorOptional* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::VectorOptional));
  } else {
    internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Encode(encoder, &value->opt_vector_uint8, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, true>, IsRecursive>::Encode(encoder, &value->opt_vector_string, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Encode(encoder, &value->opt_vector_struct, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Encode(encoder, &value->opt_vector_opt_struct, position + 48, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, true>, IsRecursive>::Decode(
      decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Decode(
      decoder, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Decode(
      decoder, position + 48, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::VectorOptional>);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_string) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_struct) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_opt_struct) == 48);
static_assert(sizeof(::test_typesinprotocols::wire::VectorOptional) == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorOptional>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayVectorNested* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::ArrayVectorNested));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 24);
    internal::WireCodingTraits<::fidl::Array<::fidl::Array<uint8_t, 5>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_array_uint8, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::VectorView<uint8_t>, 5>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->array_vector_uint8, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::Array<uint8_t, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_array_uint8, position + 112, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::VectorView<uint8_t>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, false>, IsRecursive>::Encode(encoder, &value->vector_vector_uint8, position + 128, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::Array<::fidl::Array<uint8_t, 5>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::VectorView<uint8_t>, 5>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 32, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::Array<uint8_t, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 112, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::VectorView<uint8_t>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, false>, IsRecursive>::Decode(
      decoder, position + 128, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffffffffff00);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ArrayVectorNested>);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_array_uint8) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_vector_uint8) == 32);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_array_uint8) == 112);
static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_vector_uint8) == 128);
static_assert(sizeof(::test_typesinprotocols::wire::ArrayVectorNested) == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested>::kPrimarySize);

#ifdef __Fuchsia__

    void ::test_typesinprotocols::wire::Resource::_CloseHandles() {
        handle.reset();
        vmo.reset();
        client_end.reset();
        server_end.reset();
        struct_._CloseHandles();
        table._CloseHandles();
        union_._CloseHandles();
        opt_handle.reset();
        opt_vmo.reset();
        opt_client_end.reset();
        opt_server_end.reset();
        if (opt_struct != nullptr) { opt_struct->_CloseHandles(); }
        if (opt_union.has_value()) { opt_union->_CloseHandles(); }
        for (auto& e_1 : array_handle) {
e_1.reset();
}

        for (auto& e_1 : array_vmo) {
e_1.reset();
}

        for (auto& e_1 : array_client_end) {
e_1.reset();
}

        for (auto& e_1 : array_server_end) {
e_1.reset();
}

        for (auto& e_1 : array_struct) {
e_1._CloseHandles();
}

        for (auto& e_1 : array_table) {
e_1._CloseHandles();
}

        for (auto& e_1 : array_union) {
e_1._CloseHandles();
}

        for (auto& e_1 : vector_handle) {
e_1.reset();
}

        for (auto& e_1 : vector_vmo) {
e_1.reset();
}

        for (auto& e_1 : vector_client_end) {
e_1.reset();
}

        for (auto& e_1 : vector_server_end) {
e_1.reset();
}

        for (auto& e_1 : vector_struct) {
e_1._CloseHandles();
}

        for (auto& e_1 : vector_table) {
e_1._CloseHandles();
}

        for (auto& e_1 : vector_union) {
e_1._CloseHandles();
}

    }

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Resource* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_typesinprotocols::wire::Resource));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 16);
    internal::WireZeroPadding<uint64_t>(encoder, position + 176);
    internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->handle, position + 0, recursion_depth);
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->vmo, position + 4, recursion_depth);
    internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->client_end, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->server_end, position + 12, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->struct_, position + 16, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->table, position + 24, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_, position + 40, recursion_depth);
    internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>, IsRecursive>::Encode(encoder, &value->opt_handle, position + 56, recursion_depth);
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>::Encode(encoder, &value->opt_vmo, position + 60, recursion_depth);
    internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->opt_client_end, position + 64, recursion_depth);
    internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->opt_server_end, position + 68, recursion_depth);
    internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->opt_struct, position + 72, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->opt_union, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::zx::handle, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->array_handle, position + 96, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Encode(encoder, &value->array_vmo, position + 116, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->array_client_end, position + 136, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Encode(encoder, &value->array_server_end, position + 156, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_struct, position + 176, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->array_table, position + 184, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->array_union, position + 264, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::zx::handle>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, false>, IsRecursive>::Encode(encoder, &value->vector_handle, position + 344, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Encode(encoder, &value->vector_vmo, position + 360, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Encode(encoder, &value->vector_client_end, position + 376, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Encode(encoder, &value->vector_server_end, position + 392, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_struct, position + 408, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Encode(encoder, &value->vector_table, position + 424, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Encode(encoder, &value->vector_union, position + 440, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Decode(
      decoder, position + 4, recursion_depth);
    internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
      decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
      decoder, position + 12, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 16, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 24, recursion_depth);
    internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
      decoder, position + 40, recursion_depth);
    internal::WireCodingTraits<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>, IsRecursive>::Decode(
      decoder, position + 56, recursion_depth);
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>::Decode(
      decoder, position + 60, recursion_depth);
    internal::WireCodingTraits<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
      decoder, position + 64, recursion_depth);
    internal::WireCodingTraits<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
      decoder, position + 68, recursion_depth);
    internal::WireCodingTraits<::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 72, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
      decoder, position + 80, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::zx::handle, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>::Decode(
      decoder, position + 96, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>::Decode(
      decoder, position + 116, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
      decoder, position + 136, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>::Decode(
      decoder, position + 156, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 176, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 184, recursion_depth);
    internal::WireCodingTraits<::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
      decoder, position + 264, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::zx::handle>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, false>, IsRecursive>::Decode(
      decoder, position + 344, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>::Decode(
      decoder, position + 360, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Decode(
      decoder, position + 376, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>::Decode(
      decoder, position + 392, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 408, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>::Decode(
      decoder, position + 424, recursion_depth);
    internal::WireCodingTraits<::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>::Decode(
      decoder, position + 440, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 16, 0xffffffffffffff00);
  internal::WireCheckPadding<uint64_t>(decoder, position + 176, 0xffffff0000000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Resource>);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, handle) == 0);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vmo) == 4);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, client_end) == 8);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, server_end) == 12);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, struct_) == 16);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, table) == 24);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, union_) == 40);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_handle) == 56);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_vmo) == 60);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_client_end) == 64);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_server_end) == 68);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_struct) == 72);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_union) == 80);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_handle) == 96);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_vmo) == 116);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_client_end) == 136);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_server_end) == 156);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_struct) == 176);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_table) == 184);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_union) == 264);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_handle) == 344);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_vmo) == 360);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_client_end) == 376);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_server_end) == 392);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_struct) == 408);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_table) == 424);
static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_union) == 440);
static_assert(sizeof(::test_typesinprotocols::wire::Resource) == ::fidl::TypeTraits<::test_typesinprotocols::wire::Resource>::kPrimarySize);

#endif  // __Fuchsia__

::test_typesinprotocols::wire::Union::Union() : ordinal_(::test_typesinprotocols::wire::Union::Ordinal::Invalid), envelope_{} {}
auto ::test_typesinprotocols::wire::Union::Which() const -> ::test_typesinprotocols::wire::Union::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_typesinprotocols::wire::Union::Ordinal::kB:
    return static_cast<::test_typesinprotocols::wire::Union::Tag>(ordinal_);
  default:
    return ::test_typesinprotocols::wire::Union::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_typesinprotocols::wire::Union::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Union) == sizeof(fidl_union_t));
  static_assert(offsetof(Union, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(Union, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::Union::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::Union::is_b() const { return ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::kB; }
    ::test_typesinprotocols::wire::Union test_typesinprotocols::wire::Union::WithB(bool val) {
      Union result;
      result.ordinal_ = ::test_typesinprotocols::wire::Union::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_typesinprotocols::wire::Union::b() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_typesinprotocols::wire::Union::b() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::Union::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Union>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Union* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::Union::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::Union::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::Union::Tag tag = *position.As<::test_typesinprotocols::wire::Union::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::Union::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::Union::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#ifdef __Fuchsia__

::test_typesinprotocols::wire::ResourceUnion::ResourceUnion() : ordinal_(::test_typesinprotocols::wire::ResourceUnion::Ordinal::Invalid), envelope_{} {}
auto ::test_typesinprotocols::wire::ResourceUnion::Which() const -> ::test_typesinprotocols::wire::ResourceUnion::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB:
    return static_cast<::test_typesinprotocols::wire::ResourceUnion::Tag>(ordinal_);
  default:
    return ::test_typesinprotocols::wire::ResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_typesinprotocols::wire::ResourceUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ResourceUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(ResourceUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ResourceUnion, envelope_) == offsetof(fidl_union_t, envelope));
}
::test_typesinprotocols::wire::ResourceUnion::~ResourceUnion() {
  switch (ordinal_) {
    case ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB:
      envelope_.As<bool>().clear_data();
      break;
    default:
      break;
  }
}

::test_typesinprotocols::wire::ResourceUnion::ResourceUnion(ResourceUnion&& other) {
  _Move(std::move(other));
}
::test_typesinprotocols::wire::ResourceUnion& test_typesinprotocols::wire::ResourceUnion::operator=(::test_typesinprotocols::wire::ResourceUnion&& other) {
  if (this != &other) {
    _Move(std::move(other));
  }
  return *this;
}

void ::test_typesinprotocols::wire::ResourceUnion::_Move(ResourceUnion&& other) {
  ordinal_ = other.ordinal_;
  switch (ordinal_) {
    case ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB:
      envelope_.As<bool>() = std::move(other.envelope_.As<bool>());
      break;
    default:
      break;
  }
}

void ::test_typesinprotocols::wire::ResourceUnion::_CloseHandles() {
  switch (ordinal_) {
  default:
    break;
  }
}

bool test_typesinprotocols::wire::ResourceUnion::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ResourceUnion::is_b() const { return ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB; }
    ::test_typesinprotocols::wire::ResourceUnion test_typesinprotocols::wire::ResourceUnion::WithB(bool val) {
      ResourceUnion result;
      result.ordinal_ = ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_typesinprotocols::wire::ResourceUnion::b() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_typesinprotocols::wire::ResourceUnion::b() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ResourceUnion::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ResourceUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ResourceUnion::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ResourceUnion::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ResourceUnion::Tag tag = *position.As<::test_typesinprotocols::wire::ResourceUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ResourceUnion::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ResourceUnion::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#endif  // __Fuchsia__

::test_typesinprotocols::wire::ProtocolErrorBasicResult::ProtocolErrorBasicResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag test_typesinprotocols::wire::ProtocolErrorBasicResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorBasicResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorBasicResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorBasicResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorBasicResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorBasicResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorBasicResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorBasicResult test_typesinprotocols::wire::ProtocolErrorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic> val) {
      ProtocolErrorBasicResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::Basic>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::Basic& test_typesinprotocols::wire::ProtocolErrorBasicResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Basic>().get_data();
  }
  const ::test_typesinprotocols::wire::Basic& test_typesinprotocols::wire::ProtocolErrorBasicResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Basic>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorBasicResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorBasicResult test_typesinprotocols::wire::ProtocolErrorBasicResult::WithErr(uint32_t val) {
      ProtocolErrorBasicResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorBasicResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorBasicResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorBasicResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorBasicResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::Basic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_typesinprotocols::wire::ProtocolErrorCompoundResult::ProtocolErrorCompoundResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag test_typesinprotocols::wire::ProtocolErrorCompoundResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorCompoundResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorCompoundResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorCompoundResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorCompoundResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorCompoundResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorCompoundResult test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound> val) {
      ProtocolErrorCompoundResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::Compound>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::Compound& test_typesinprotocols::wire::ProtocolErrorCompoundResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Compound>().get_data();
  }
  const ::test_typesinprotocols::wire::Compound& test_typesinprotocols::wire::ProtocolErrorCompoundResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Compound>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorCompoundResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorCompoundResult test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithErr(uint32_t val) {
      ProtocolErrorCompoundResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorCompoundResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorCompoundResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorCompoundResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorCompoundResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::Compound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::ProtocolErrorArrayBasicResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorArrayBasicResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorArrayBasicResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorArrayBasicResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic> val) {
      ProtocolErrorArrayBasicResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::ArrayBasic>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::ArrayBasic& test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayBasic>().get_data();
  }
  const ::test_typesinprotocols::wire::ArrayBasic& test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayBasic>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithErr(uint32_t val) {
      ProtocolErrorArrayBasicResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::ArrayBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::ProtocolErrorArrayCompoundResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorArrayCompoundResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorArrayCompoundResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorArrayCompoundResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound> val) {
      ProtocolErrorArrayCompoundResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::ArrayCompound>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::ArrayCompound& test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayCompound>().get_data();
  }
  const ::test_typesinprotocols::wire::ArrayCompound& test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayCompound>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithErr(uint32_t val) {
      ProtocolErrorArrayCompoundResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::ArrayCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::ProtocolErrorVectorBasicResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorVectorBasicResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorVectorBasicResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorVectorBasicResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic> val) {
      ProtocolErrorVectorBasicResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::VectorBasic>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::VectorBasic& test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorBasic>().get_data();
  }
  const ::test_typesinprotocols::wire::VectorBasic& test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorBasic>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithErr(uint32_t val) {
      ProtocolErrorVectorBasicResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::VectorBasic, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::ProtocolErrorVectorCompoundResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorVectorCompoundResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorVectorCompoundResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorVectorCompoundResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound> val) {
      ProtocolErrorVectorCompoundResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::VectorCompound>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::VectorCompound& test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorCompound>().get_data();
  }
  const ::test_typesinprotocols::wire::VectorCompound& test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorCompound>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithErr(uint32_t val) {
      ProtocolErrorVectorCompoundResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::VectorCompound, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::ProtocolErrorVectorOptionalResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorVectorOptionalResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorVectorOptionalResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorVectorOptionalResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional> val) {
      ProtocolErrorVectorOptionalResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::VectorOptional>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::VectorOptional& test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorOptional>().get_data();
  }
  const ::test_typesinprotocols::wire::VectorOptional& test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::VectorOptional>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithErr(uint32_t val) {
      ProtocolErrorVectorOptionalResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::VectorOptional, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::ProtocolErrorArrayVectorNestedResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorArrayVectorNestedResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorArrayVectorNestedResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorArrayVectorNestedResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested> val) {
      ProtocolErrorArrayVectorNestedResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::ArrayVectorNested>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::ArrayVectorNested& test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayVectorNested>().get_data();
  }
  const ::test_typesinprotocols::wire::ArrayVectorNested& test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::ArrayVectorNested>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithErr(uint32_t val) {
      ProtocolErrorArrayVectorNestedResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::ArrayVectorNested, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#ifdef __Fuchsia__

::test_typesinprotocols::wire::ProtocolErrorResourceResult::ProtocolErrorResourceResult() : ordinal_(::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::Invalid), envelope_{} {}
::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag test_typesinprotocols::wire::ProtocolErrorResourceResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag>(ordinal_);
}

void ::test_typesinprotocols::wire::ProtocolErrorResourceResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ProtocolErrorResourceResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ProtocolErrorResourceResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ProtocolErrorResourceResult, envelope_) == offsetof(fidl_union_t, envelope));
}
::test_typesinprotocols::wire::ProtocolErrorResourceResult::~ProtocolErrorResourceResult() {
  switch (ordinal_) {
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse:
      envelope_.As<::test_typesinprotocols::wire::Resource>().clear_data();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr:
      envelope_.As<uint32_t>().clear_data();
      break;
    default:
      break;
  }
}

::test_typesinprotocols::wire::ProtocolErrorResourceResult::ProtocolErrorResourceResult(ProtocolErrorResourceResult&& other) {
  _Move(std::move(other));
}
::test_typesinprotocols::wire::ProtocolErrorResourceResult& test_typesinprotocols::wire::ProtocolErrorResourceResult::operator=(::test_typesinprotocols::wire::ProtocolErrorResourceResult&& other) {
  if (this != &other) {
    _Move(std::move(other));
  }
  return *this;
}

void ::test_typesinprotocols::wire::ProtocolErrorResourceResult::_Move(ProtocolErrorResourceResult&& other) {
  ordinal_ = other.ordinal_;
  switch (ordinal_) {
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse:
      envelope_.As<::test_typesinprotocols::wire::Resource>() = std::move(other.envelope_.As<::test_typesinprotocols::wire::Resource>());
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr:
      envelope_.As<uint32_t>() = std::move(other.envelope_.As<uint32_t>());
      break;
    default:
      break;
  }
}

void ::test_typesinprotocols::wire::ProtocolErrorResourceResult::_CloseHandles() {
  switch (ordinal_) {
      case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse: {response()._CloseHandles();
        break;
      }
  default:
    break;
  }
}

bool test_typesinprotocols::wire::ProtocolErrorResourceResult::has_invalid_tag() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::Invalid; }

  bool test_typesinprotocols::wire::ProtocolErrorResourceResult::is_response() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse; }
    ::test_typesinprotocols::wire::ProtocolErrorResourceResult test_typesinprotocols::wire::ProtocolErrorResourceResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource> val) {
      ProtocolErrorResourceResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse;
      result.envelope_.As<::test_typesinprotocols::wire::Resource>().set_data(std::move(val));
      return result;
    }

  ::test_typesinprotocols::wire::Resource& test_typesinprotocols::wire::ProtocolErrorResourceResult::response() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Resource>().get_data();
  }
  const ::test_typesinprotocols::wire::Resource& test_typesinprotocols::wire::ProtocolErrorResourceResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kResponse);
    return envelope_.As<::test_typesinprotocols::wire::Resource>().get_data();
  }

  bool test_typesinprotocols::wire::ProtocolErrorResourceResult::is_err() const { return ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr; }
    ::test_typesinprotocols::wire::ProtocolErrorResourceResult test_typesinprotocols::wire::ProtocolErrorResourceResult::WithErr(uint32_t val) {
      ProtocolErrorResourceResult result;
      result.ordinal_ = ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_typesinprotocols::wire::ProtocolErrorResourceResult::err() {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_typesinprotocols::wire::ProtocolErrorResourceResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ProtocolErrorResourceResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorResourceResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag tag = *position.As<::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_typesinprotocols::wire::Resource, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#endif  // __Fuchsia__

bool ::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_typesinprotocols::wire::Table>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
  return max_ordinal;
}

::test_typesinprotocols::wire::Table::Table(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>(allocator)) {}

::test_typesinprotocols::wire::Table::Table(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_typesinprotocols::wire::Table::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>(allocator);
}
void test_typesinprotocols::wire::Table::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_typesinprotocols::wire::Table::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_typesinprotocols::wire::Table::HasUnknownData() const {
  if (max_ordinal_ > 0) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table> test_typesinprotocols::wire::Table::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>(arena);
}
::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table> test_typesinprotocols::wire::Table::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_typesinprotocols::wire::Table fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_typesinprotocols::wire::Table t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}

template class fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>>;
template class fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>;

::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Table, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Table* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Table, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Table, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Table, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::Table>);

#ifdef __Fuchsia__

bool ::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
  return max_ordinal;
}

::test_typesinprotocols::wire::ResourceTable::ResourceTable(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>(allocator)) {}

::test_typesinprotocols::wire::ResourceTable::ResourceTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_typesinprotocols::wire::ResourceTable::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>(allocator);
}
void test_typesinprotocols::wire::ResourceTable::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_typesinprotocols::wire::ResourceTable::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_typesinprotocols::wire::ResourceTable::HasUnknownData() const {
  if (max_ordinal_ > 0) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

void ::test_typesinprotocols::wire::ResourceTable::_CloseHandles() {
}

::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable> test_typesinprotocols::wire::ResourceTable::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>(arena);
}
::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable> test_typesinprotocols::wire::ResourceTable::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_typesinprotocols::wire::ResourceTable fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_typesinprotocols::wire::ResourceTable t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}

template class fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>>;
template class fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>;

::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceTable* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_typesinprotocols::wire::ResourceTable>);

#endif  // __Fuchsia__

  #pragma clang diagnostic pop

