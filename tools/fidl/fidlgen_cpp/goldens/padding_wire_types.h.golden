// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <fidl/test.padding/cpp/common_types.h>
#include <fidl/test.padding/cpp/markers.h>
#include <lib/fidl/cpp/wire/array.h>
#include <lib/fidl/cpp/wire/envelope.h>
#include <lib/fidl/cpp/wire/internal/framework_err.h>
#include <lib/fidl/cpp/wire/message.h>
#include <lib/fidl/cpp/wire/message_storage.h>
#include <lib/fidl/cpp/wire/object_view.h>
#include <lib/fidl/cpp/wire/string_view.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/fidl/cpp/wire/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_padding {

namespace wire {

struct Padding1ByteEnd;

struct Padding2ByteEnd;

struct Padding3ByteEnd;

struct Padding4ByteEnd;

struct Padding5ByteEnd;

struct Padding6ByteEnd;

struct Padding7ByteEnd;

struct Padding1ByteMiddle;

struct Padding2ByteMiddle;

struct Padding3ByteMiddle;

struct Padding4ByteMiddle;

struct Padding5ByteMiddle;

struct Padding6ByteMiddle;

struct Padding7ByteMiddle;

struct Padding4ByteAlignmentLength12;

struct Padding2ByteAlignmentLength6;

struct Padding1ByteEnd {
  uint16_t a = {};

  uint8_t b = {};
};

struct Padding1ByteMiddle {
  uint8_t a = {};

  uint16_t b = {};
};

struct Padding2ByteEnd {
  uint32_t a = {};

  uint16_t b = {};
};

struct Padding3ByteEnd {
  uint32_t a = {};

  uint8_t b = {};
};

struct Padding4ByteEnd {
  uint64_t a = {};

  uint32_t b = {};
};

struct Padding5ByteEnd {
  uint64_t a = {};

  uint16_t b = {};

  uint8_t c = {};
};

struct Padding6ByteEnd {
  uint64_t a = {};

  uint16_t b = {};
};

struct Padding7ByteEnd {
  uint64_t a = {};

  uint8_t b = {};
};

struct Padding2ByteMiddle {
  uint16_t a = {};

  uint32_t b = {};
};

struct Padding3ByteMiddle {
  uint8_t a = {};

  uint32_t b = {};
};

struct Padding4ByteMiddle {
  uint32_t a = {};

  uint64_t b = {};
};

struct Padding5ByteMiddle {
  uint16_t a = {};

  uint8_t b = {};

  uint64_t c = {};
};

struct Padding6ByteMiddle {
  uint16_t a = {};

  uint64_t b = {};
};

struct Padding7ByteMiddle {
  uint8_t a = {};

  uint64_t b = {};
};

struct Padding4ByteAlignmentLength12 {
  uint32_t a = {};

  uint8_t b = {};

  uint16_t c = {};

  uint16_t d = {};
};

struct Padding2ByteAlignmentLength6 {
  uint8_t a = {};

  uint16_t b = {};

  uint8_t c = {};
};

}  // namespace wire
}  // namespace test_padding
namespace fidl {

template <>
struct TypeTraits<::test_padding::wire::Padding1ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding1ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding1ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding1ByteEnd> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding1ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding2ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding2ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding2ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding2ByteEnd> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding3ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding3ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding3ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding3ByteEnd> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding3ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding4ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding4ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding4ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding4ByteEnd> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding5ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding5ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding5ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding5ByteEnd> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding5ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding6ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding6ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding6ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding6ByteEnd> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding6ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding7ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding7ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding7ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding7ByteEnd> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding7ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding1ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding1ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding1ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding1ByteMiddle> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding1ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding2ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding2ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding2ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding2ByteMiddle> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding3ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding3ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding3ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding3ByteMiddle> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding3ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding4ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding4ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding4ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding4ByteMiddle> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding5ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding5ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding5ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding5ByteMiddle> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding5ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding6ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding6ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding6ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding6ByteMiddle> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding6ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding7ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding7ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding7ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding7ByteMiddle> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding7ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding4ByteAlignmentLength12> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding4ByteAlignmentLength12> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding4ByteAlignmentLength12> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding4ByteAlignmentLength12> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 12;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteAlignmentLength12* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_padding::wire::Padding2ByteAlignmentLength6> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 6;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding2ByteAlignmentLength6> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding2ByteAlignmentLength6> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding2ByteAlignmentLength6> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 6;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteAlignmentLength6* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#pragma clang diagnostic pop

}  // namespace fidl
