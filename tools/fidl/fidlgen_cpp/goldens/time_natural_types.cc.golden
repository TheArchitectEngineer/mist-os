// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.time/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

::test_time::AllInstants::AllInstants(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_time::AllInstants::AllInstants(::fidl::basic_time<ZX_CLOCK_MONOTONIC> monotonic, ::fidl::basic_time<ZX_CLOCK_BOOT> boot, ::fidl::basic_ticks<ZX_CLOCK_MONOTONIC> monotonic_ticks, ::fidl::basic_ticks<ZX_CLOCK_BOOT> boot_ticks) noexcept
    : storage_({.monotonic = std::move(monotonic),
                .boot = std::move(boot),
                .monotonic_ticks = std::move(monotonic_ticks),
                .boot_ticks = std::move(boot_ticks)}) {}

::test_time::AllInstants::AllInstants(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : AllInstants(Storage_{
                                                                                                        .monotonic = {},
                                                                                                        .boot = {},
                                                                                                        .monotonic_ticks = {},
                                                                                                        .boot_ticks = {},
                                                                                                    }) {}
::test_time::AllInstants::AllInstants(const ::test_time::AllInstants& other) noexcept : ::test_time::AllInstants(other.CloneStorage_()) {}

::test_time::AllInstants& test_time::AllInstants::operator=(const ::test_time::AllInstants& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_time::AllInstants::operator==(const AllInstants& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_time::AllInstants, 32>::Equal(this, &other);
}

bool test_time::AllInstants::operator!=(const AllInstants& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_time::AllInstants, 32>::Equal(this, &other);
}

::test_time::AllInstants::Storage_ test_time::AllInstants::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.monotonic),
      ::fidl::internal::NaturalClone(storage_.boot),
      ::fidl::internal::NaturalClone(storage_.monotonic_ticks),
      ::fidl::internal::NaturalClone(storage_.boot_ticks)};
}
::fidl::basic_time<ZX_CLOCK_MONOTONIC>
test_time::AllInstants::monotonic() const {
  return storage_.monotonic;
}

::fidl::basic_time<ZX_CLOCK_MONOTONIC>& ::test_time::AllInstants::monotonic() {
  return storage_.monotonic;
}

::test_time::AllInstants& ::test_time::AllInstants::monotonic(::fidl::basic_time<ZX_CLOCK_MONOTONIC> value) {
  storage_.monotonic = std::move(value);
  return *this;
}
::fidl::basic_time<ZX_CLOCK_BOOT>
test_time::AllInstants::boot() const {
  return storage_.boot;
}

::fidl::basic_time<ZX_CLOCK_BOOT>& ::test_time::AllInstants::boot() {
  return storage_.boot;
}

::test_time::AllInstants& ::test_time::AllInstants::boot(::fidl::basic_time<ZX_CLOCK_BOOT> value) {
  storage_.boot = std::move(value);
  return *this;
}
::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>
test_time::AllInstants::monotonic_ticks() const {
  return storage_.monotonic_ticks;
}

::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>& ::test_time::AllInstants::monotonic_ticks() {
  return storage_.monotonic_ticks;
}

::test_time::AllInstants& ::test_time::AllInstants::monotonic_ticks(::fidl::basic_ticks<ZX_CLOCK_MONOTONIC> value) {
  storage_.monotonic_ticks = std::move(value);
  return *this;
}
::fidl::basic_ticks<ZX_CLOCK_BOOT>
test_time::AllInstants::boot_ticks() const {
  return storage_.boot_ticks;
}

::fidl::basic_ticks<ZX_CLOCK_BOOT>& ::test_time::AllInstants::boot_ticks() {
  return storage_.boot_ticks;
}

::test_time::AllInstants& ::test_time::AllInstants::boot_ticks(::fidl::basic_ticks<ZX_CLOCK_BOOT> value) {
  storage_.boot_ticks = std::move(value);
  return *this;
}

::test_time::ComplexInstants::ComplexInstants(::test_time::ComplexInstants::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_time::ComplexInstants::ComplexInstants(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ComplexInstants(Storage_{}) {}

::test_time::ComplexInstants::ComplexInstants(const ::test_time::ComplexInstants& other) noexcept : ComplexInstants(other.CloneStorage_()) {}

::test_time::ComplexInstants& ::test_time::ComplexInstants::operator=(const ::test_time::ComplexInstants& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_time::ComplexInstants::operator==(const ComplexInstants& other) const noexcept {
  return ::fidl::internal::NaturalTableCodingTraits<::test_time::ComplexInstants>::Equal(this, &other);
}
bool test_time::ComplexInstants::operator!=(const ComplexInstants& other) const noexcept {
  return !::fidl::internal::NaturalTableCodingTraits<::test_time::ComplexInstants>::Equal(this, &other);
}

::test_time::ComplexInstants::Storage_ test_time::ComplexInstants::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.monotonic),
      ::fidl::internal::NaturalClone(storage_.boot),
      ::fidl::internal::NaturalClone(storage_.monotonic_ticks),
      ::fidl::internal::NaturalClone(storage_.boot_ticks)};
}

bool test_time::ComplexInstants::IsEmpty() const {
  return !(storage_.monotonic.has_value() || storage_.boot.has_value() || storage_.monotonic_ticks.has_value() || storage_.boot_ticks.has_value());
}
const std::optional<::std::array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>>& test_time::ComplexInstants::monotonic() const {
  return storage_.monotonic;
}

::std::optional<::std::array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>>& test_time::ComplexInstants::monotonic() {
  return storage_.monotonic;
}

::test_time::ComplexInstants& test_time::ComplexInstants::monotonic(std::optional<::std::array<::fidl::basic_time<ZX_CLOCK_MONOTONIC>, 10>> value) {
  storage_.monotonic = std::move(value);
  return *this;
}
const std::optional<::std::vector<::fidl::basic_time<ZX_CLOCK_BOOT>>>& test_time::ComplexInstants::boot() const {
  return storage_.boot;
}

::std::optional<::std::vector<::fidl::basic_time<ZX_CLOCK_BOOT>>>& test_time::ComplexInstants::boot() {
  return storage_.boot;
}

::test_time::ComplexInstants& test_time::ComplexInstants::boot(std::optional<::std::vector<::fidl::basic_time<ZX_CLOCK_BOOT>>> value) {
  storage_.boot = std::move(value);
  return *this;
}
const std::optional<::std::array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>>& test_time::ComplexInstants::monotonic_ticks() const {
  return storage_.monotonic_ticks;
}

::std::optional<::std::array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>>& test_time::ComplexInstants::monotonic_ticks() {
  return storage_.monotonic_ticks;
}

::test_time::ComplexInstants& test_time::ComplexInstants::monotonic_ticks(std::optional<::std::array<::fidl::basic_ticks<ZX_CLOCK_MONOTONIC>, 10>> value) {
  storage_.monotonic_ticks = std::move(value);
  return *this;
}
const std::optional<::std::array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>>& test_time::ComplexInstants::boot_ticks() const {
  return storage_.boot_ticks;
}

::std::optional<::std::array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>>& test_time::ComplexInstants::boot_ticks() {
  return storage_.boot_ticks;
}

::test_time::ComplexInstants& test_time::ComplexInstants::boot_ticks(std::optional<::std::array<::fidl::basic_ticks<ZX_CLOCK_BOOT>, 10>> value) {
  storage_.boot_ticks = std::move(value);
  return *this;
}

#pragma clang diagnostic pop
