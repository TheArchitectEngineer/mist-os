// WARNING: This file is machine generated by fidlgen.

  // fidl_experiment = output_index_json

  #include <fidl/test.protocollayoutssamelibrary/cpp/wire_types.h>

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

::test_protocollayoutssamelibrary::wire::UnionPayload::UnionPayload() : ordinal_(::test_protocollayoutssamelibrary::wire::UnionPayload::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::UnionPayload::Tag test_protocollayoutssamelibrary::wire::UnionPayload::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::UnionPayload::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::UnionPayload::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionPayload) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionPayload, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionPayload, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::UnionPayload::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::UnionPayload::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::UnionPayload::is_b() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::UnionPayload::Ordinal::kB; }
    ::test_protocollayoutssamelibrary::wire::UnionPayload test_protocollayoutssamelibrary::wire::UnionPayload::WithB(bool val) {
      UnionPayload result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::UnionPayload::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_protocollayoutssamelibrary::wire::UnionPayload::b() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::UnionPayload::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_protocollayoutssamelibrary::wire::UnionPayload::b() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::UnionPayload::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::UnionPayload>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::UnionPayload* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::UnionPayload::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::UnionPayload::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::UnionPayload::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::UnionPayload::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::UnionPayload::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::UnionPayload::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::ComposedProtocolTwoWayAnonComposedRequest() : ordinal_(::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ComposedProtocolTwoWayAnonComposedRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(ComposedProtocolTwoWayAnonComposedRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ComposedProtocolTwoWayAnonComposedRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::is_b() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Ordinal::kB; }
    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::WithB(bool val) {
      ComposedProtocolTwoWayAnonComposedRequest result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::b() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::b() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::ComposedProtocolTwoWayAnonComposedWithErrorResponse() : ordinal_(::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ComposedProtocolTwoWayAnonComposedWithErrorResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(ComposedProtocolTwoWayAnonComposedWithErrorResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ComposedProtocolTwoWayAnonComposedWithErrorResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::is_b() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Ordinal::kB; }
    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::WithB(bool val) {
      ComposedProtocolTwoWayAnonComposedWithErrorResponse result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::b() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::b() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::ComposedProtocolTwoWayAnonComposedWithErrorResult() : ordinal_(::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ComposedProtocolTwoWayAnonComposedWithErrorResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ComposedProtocolTwoWayAnonComposedWithErrorResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ComposedProtocolTwoWayAnonComposedWithErrorResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::is_response() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kResponse; }
    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse> val) {
      ComposedProtocolTwoWayAnonComposedWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kResponse;
      result.envelope_.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse>().set_data(std::move(val));
      return result;
    }

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::response() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse>().get_data();
  }
  const ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse>().get_data();
  }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::is_err() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kErr; }
    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::WithErr(uint32_t val) {
      ComposedProtocolTwoWayAnonComposedWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::err() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::ComposedProtocolOnAnonComposedRequest() : ordinal_(::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ComposedProtocolOnAnonComposedRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(ComposedProtocolOnAnonComposedRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ComposedProtocolOnAnonComposedRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::is_b() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Ordinal::kB; }
    ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::WithB(bool val) {
      ComposedProtocolOnAnonComposedRequest result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::b() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::b() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::ComposedProtocolTwoWayNamedComposedWithErrorResult() : ordinal_(::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ComposedProtocolTwoWayNamedComposedWithErrorResult) == sizeof(fidl_union_t));
  static_assert(offsetof(ComposedProtocolTwoWayNamedComposedWithErrorResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ComposedProtocolTwoWayNamedComposedWithErrorResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::is_response() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kResponse; }
    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::UnionPayload> val) {
      ComposedProtocolTwoWayNamedComposedWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kResponse;
      result.envelope_.As<::test_protocollayoutssamelibrary::wire::UnionPayload>().set_data(std::move(val));
      return result;
    }

  ::test_protocollayoutssamelibrary::wire::UnionPayload& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::response() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::UnionPayload>().get_data();
  }
  const ::test_protocollayoutssamelibrary::wire::UnionPayload& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::UnionPayload>().get_data();
  }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::is_err() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kErr; }
    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::WithErr(uint32_t val) {
      ComposedProtocolTwoWayNamedComposedWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::err() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::MainProtocolTwoWayLocalWithErrorResult() : ordinal_(::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolTwoWayLocalWithErrorResult) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolTwoWayLocalWithErrorResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolTwoWayLocalWithErrorResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::is_response() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse; }
    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::UnionPayload> val) {
      MainProtocolTwoWayLocalWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse;
      result.envelope_.As<::test_protocollayoutssamelibrary::wire::UnionPayload>().set_data(std::move(val));
      return result;
    }

  ::test_protocollayoutssamelibrary::wire::UnionPayload& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::response() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::UnionPayload>().get_data();
  }
  const ::test_protocollayoutssamelibrary::wire::UnionPayload& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::UnionPayload>().get_data();
  }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::is_err() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr; }
    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::WithErr(uint32_t val) {
      MainProtocolTwoWayLocalWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::err() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocollayoutssamelibrary::wire::UnionPayload, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::MainProtocolTwoWayAnonRequest() : ordinal_(::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal::Invalid), envelope_{} {}
auto ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Which() const -> ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal::kB:
    return static_cast<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag>(ordinal_);
  default:
    return ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolTwoWayAnonRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolTwoWayAnonRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolTwoWayAnonRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::is_b() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal::kB; }
    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::WithB(bool val) {
      MainProtocolTwoWayAnonRequest result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::b() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::b() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::MainProtocolTwoWayAnonWithErrorResponse() : ordinal_(::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal::Invalid), envelope_{} {}
auto ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Which() const -> ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal::kB:
    return static_cast<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag>(ordinal_);
  default:
    return ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolTwoWayAnonWithErrorResponse) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolTwoWayAnonWithErrorResponse, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolTwoWayAnonWithErrorResponse, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::is_b() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal::kB; }
    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::WithB(bool val) {
      MainProtocolTwoWayAnonWithErrorResponse result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::b() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::b() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::MainProtocolTwoWayAnonWithErrorResult() : ordinal_(::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid), envelope_{} {}
::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag>(ordinal_);
}

void ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolTwoWayAnonWithErrorResult) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolTwoWayAnonWithErrorResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolTwoWayAnonWithErrorResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::is_response() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse; }
    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse> val) {
      MainProtocolTwoWayAnonWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse;
      result.envelope_.As<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse>().set_data(std::move(val));
      return result;
    }

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::response() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse>().get_data();
  }
  const ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::response() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse>().get_data();
  }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::is_err() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr; }
    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::WithErr(uint32_t val) {
      MainProtocolTwoWayAnonWithErrorResult result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::err() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::err() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case 2: // ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>();
      break;
    case ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::MainProtocolOnAnonRequest() : ordinal_(::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal::Invalid), envelope_{} {}
auto ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Which() const -> ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal::kB:
    return static_cast<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag>(ordinal_);
  default:
    return ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolOnAnonRequest) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolOnAnonRequest, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolOnAnonRequest, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::has_invalid_tag() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal::Invalid; }

  bool test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::is_b() const { return ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal::kB; }
    ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::WithB(bool val) {
      MainProtocolOnAnonRequest result;
      result.ordinal_ = ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal::kB;
      result.envelope_.As<bool>().set_data(std::move(val));
      return result;
    }

  bool& test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::b() {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }
  const bool& test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::b() const {
    ZX_ASSERT(ordinal_ == ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal::kB);
    return envelope_.As<bool>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag tag = *position.As<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

bool ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!a_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_protocollayoutssamelibrary::wire::TablePayload::TablePayload(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>(allocator)) {}

::test_protocollayoutssamelibrary::wire::TablePayload::TablePayload(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_protocollayoutssamelibrary::wire::TablePayload::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>(allocator);
}
void test_protocollayoutssamelibrary::wire::TablePayload::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_protocollayoutssamelibrary::wire::TablePayload::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_protocollayoutssamelibrary::wire::TablePayload::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  uint16_t& test_protocollayoutssamelibrary::wire::TablePayload::a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }

  bool test_protocollayoutssamelibrary::wire::TablePayload::has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.has_data();
  }

  ::test_protocollayoutssamelibrary::wire::TablePayload& test_protocollayoutssamelibrary::wire::TablePayload::clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_protocollayoutssamelibrary::wire::TablePayload& test_protocollayoutssamelibrary::wire::TablePayload::set_a(uint16_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->a_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload> test_protocollayoutssamelibrary::wire::TablePayload::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>(arena);
}
::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload> test_protocollayoutssamelibrary::wire::TablePayload::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_protocollayoutssamelibrary::wire::TablePayload fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_protocollayoutssamelibrary::wire::TablePayload t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, BuilderImpl>::has_a() const {
    return table_.has_a();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, BuilderImpl>::clear_a() {
    table_.clear_a();
  }

  template<typename BuilderImpl>
  uint16_t& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, BuilderImpl>::a() const {
    return table_.a();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, BuilderImpl>::a(uint16_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->a_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;
template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::TablePayload* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::TablePayload>);

bool ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!a_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::ComposedProtocolOneWayAnonComposedRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>(allocator)) {}

::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::ComposedProtocolOneWayAnonComposedRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>(allocator);
}
void test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  uint16_t& test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.has_data();
  }

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest& test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest& test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::set_a(uint16_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->a_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, BuilderImpl>::has_a() const {
    return table_.has_a();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, BuilderImpl>::clear_a() {
    table_.clear_a();
  }

  template<typename BuilderImpl>
  uint16_t& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, BuilderImpl>::a() const {
    return table_.a();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, BuilderImpl>::a(uint16_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->a_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>);

bool ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!a_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::ComposedProtocolTwoWayAnonComposedResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>(allocator)) {}

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::ComposedProtocolTwoWayAnonComposedResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>(allocator);
}
void test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  uint16_t& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.has_data();
  }

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::set_a(uint16_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->a_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, BuilderImpl>::has_a() const {
    return table_.has_a();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, BuilderImpl>::clear_a() {
    table_.clear_a();
  }

  template<typename BuilderImpl>
  uint16_t& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, BuilderImpl>::a() const {
    return table_.a();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, BuilderImpl>::a(uint16_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->a_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>);

bool ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!a_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::ComposedProtocolTwoWayAnonComposedWithErrorRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>(allocator)) {}

::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::ComposedProtocolTwoWayAnonComposedWithErrorRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>(allocator);
}
void test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  uint16_t& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }

  bool test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.has_data();
  }

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest& test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::set_a(uint16_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->a_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, BuilderImpl>::has_a() const {
    return table_.has_a();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, BuilderImpl>::clear_a() {
    table_.clear_a();
  }

  template<typename BuilderImpl>
  uint16_t& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, BuilderImpl>::a() const {
    return table_.a();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, BuilderImpl>::a(uint16_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->a_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>);

bool ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!a_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>(allocator)) {}

::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::MainProtocolOneWayAnonRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>(allocator);
}
void test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  uint16_t& test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }

  bool test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.has_data();
  }

  ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest& test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest& test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::set_a(uint16_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->a_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, BuilderImpl>::has_a() const {
    return table_.has_a();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, BuilderImpl>::clear_a() {
    table_.clear_a();
  }

  template<typename BuilderImpl>
  uint16_t& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, BuilderImpl>::a() const {
    return table_.a();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, BuilderImpl>::a(uint16_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->a_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>);

bool ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!a_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>(allocator)) {}

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::MainProtocolTwoWayAnonResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>(allocator);
}
void test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  uint16_t& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.has_data();
  }

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::set_a(uint16_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->a_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>(arena);
}
::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, BuilderImpl>::has_a() const {
    return table_.has_a();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, BuilderImpl>::clear_a() {
    table_.clear_a();
  }

  template<typename BuilderImpl>
  uint16_t& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, BuilderImpl>::a() const {
    return table_.a();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, BuilderImpl>::a(uint16_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->a_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;
template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>);

bool ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>::HasUnknownData() const {
  return false;
}

uint64_t fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
      if (!a_.has_data()) {
        max_ordinal = 1;
      }
  return max_ordinal;
}

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(::fidl::AnyArena& allocator)
: frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>(allocator)) {}

::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::MainProtocolTwoWayAnonWithErrorRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame)
: frame_ptr_(std::move(frame)) {}

void test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>(allocator);
}
void test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::HasUnknownData() const {
  if (max_ordinal_ > 1) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

  uint16_t& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }

  bool test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::has_a() const {
    return max_ordinal_ >= 1 && frame_ptr_->a_.has_data();
  }

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
    return *this;
  }

    ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest& test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::set_a(uint16_t elem) {
      ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
      frame_ptr_->a_.set_data(std::move(elem));
      max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
      return *this;
    }

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>(arena);
}
::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>(std::move(frame));
}

template<typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame)
: table_(std::move(frame)) {}

template<typename BuilderImpl>
::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
  template<typename BuilderImpl>
  bool fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl>::has_a() const {
    return table_.has_a();
  }

  template<typename BuilderImpl>
  void fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl>::clear_a() {
    table_.clear_a();
  }

  template<typename BuilderImpl>
  uint16_t& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl>::a() const {
    return table_.a();
  }
    template<typename BuilderImpl>
    BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl>::a(uint16_t elem) {
      ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
      table_.frame_ptr_->a_.set_data(std::move(elem));
      table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
      return *static_cast<BuilderImpl*>(this);
    }

template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;
template class fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;

::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>::WireTableBuilder(::fidl::AnyArena& arena)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>(arena)),
  arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>* frame)
: Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
    Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {

    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
      ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {

    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch(i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>);

  #pragma clang diagnostic pop

