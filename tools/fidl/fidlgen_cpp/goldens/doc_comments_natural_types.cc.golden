// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.doccomments/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

void fidl::internal::NaturalCodingTraits<::test_doccomments::MyStrictBits, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_doccomments::MyStrictBits* value, size_t offset, size_t recursion_depth) {
  if (unlikely(static_cast<uint32_t>(*value) & ~3ull)) {
    encoder->SetError(::fidl::internal::kCodingErrorUnknownBitSetInBitsValue);
  }
  *encoder->template GetPtr<::test_doccomments::MyStrictBits>(offset) = *value;
}
void fidl::internal::NaturalCodingTraits<::test_doccomments::MyStrictBits, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_doccomments::MyStrictBits* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_doccomments::MyStrictBits>(offset);
  if (unlikely(static_cast<uint32_t>(*value) & ~3ull)) {
    decoder->SetError(::fidl::internal::kCodingErrorUnknownBitSetInBitsValue);
  }
}

void fidl::internal::NaturalCodingTraits<::test_doccomments::MyFlexibleBits, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_doccomments::MyFlexibleBits* value, size_t offset, size_t recursion_depth) {
  *encoder->template GetPtr<::test_doccomments::MyFlexibleBits>(offset) = *value;
}
void fidl::internal::NaturalCodingTraits<::test_doccomments::MyFlexibleBits, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_doccomments::MyFlexibleBits* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_doccomments::MyFlexibleBits>(offset);
}

void fidl::internal::NaturalCodingTraits<::test_doccomments::MyStrictEnum, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_doccomments::MyStrictEnum* value, size_t offset, size_t recursion_depth) {
  switch (*value) {
    case ::test_doccomments::MyStrictEnum::kFoo:
    case ::test_doccomments::MyStrictEnum::kBar:
      break;
    default:
      encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
      return;
  }
  *encoder->template GetPtr<::test_doccomments::MyStrictEnum>(offset) = *value;
}

void fidl::internal::NaturalCodingTraits<::test_doccomments::MyStrictEnum, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_doccomments::MyStrictEnum* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_doccomments::MyStrictEnum>(offset);
  switch (*value) {
    case ::test_doccomments::MyStrictEnum::kFoo:
    case ::test_doccomments::MyStrictEnum::kBar:
      break;
    default:
      decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
      return;
  }
}

void fidl::internal::NaturalCodingTraits<::test_doccomments::MyFlexibleEnum, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
    fidl::internal::NaturalEncoder* encoder, ::test_doccomments::MyFlexibleEnum* value, size_t offset, size_t recursion_depth) {
  *encoder->template GetPtr<::test_doccomments::MyFlexibleEnum>(offset) = *value;
}

void fidl::internal::NaturalCodingTraits<::test_doccomments::MyFlexibleEnum, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
    fidl::internal::NaturalDecoder* decoder, ::test_doccomments::MyFlexibleEnum* value, size_t offset, size_t recursion_depth) {
  *value = *decoder->template GetPtr<::test_doccomments::MyFlexibleEnum>(offset);
}

::test_doccomments::Struct::Struct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
::test_doccomments::Struct::Struct(int32_t field) noexcept
    : storage_({.field = std::move(field)}) {}

::test_doccomments::Struct::Struct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Struct(Storage_{
                                                                                                     .field = {},
                                                                                                 }) {}
::test_doccomments::Struct::Struct(const ::test_doccomments::Struct& other) noexcept : ::test_doccomments::Struct(other.CloneStorage_()) {}

::test_doccomments::Struct& test_doccomments::Struct::operator=(const ::test_doccomments::Struct& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_doccomments::Struct::operator==(const Struct& other) const noexcept {
  return ::fidl::internal::NaturalStructCodingTraits<::test_doccomments::Struct, 4>::Equal(this, &other);
}

bool test_doccomments::Struct::operator!=(const Struct& other) const noexcept {
  return !::fidl::internal::NaturalStructCodingTraits<::test_doccomments::Struct, 4>::Equal(this, &other);
}

::test_doccomments::Struct::Storage_ test_doccomments::Struct::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.field)};
}
int32_t
test_doccomments::Struct::field() const {
  return storage_.field;
}

int32_t& ::test_doccomments::Struct::field() {
  return storage_.field;
}

::test_doccomments::Struct& ::test_doccomments::Struct::field(int32_t value) {
  storage_.field = std::move(value);
  return *this;
}

::test_doccomments::Table::Table(::test_doccomments::Table::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_doccomments::Table::Table(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Table(Storage_{}) {}

::test_doccomments::Table::Table(const ::test_doccomments::Table& other) noexcept : Table(other.CloneStorage_()) {}

::test_doccomments::Table& ::test_doccomments::Table::operator=(const ::test_doccomments::Table& other) noexcept {
  storage_ = other.CloneStorage_();
  return *this;
}

bool test_doccomments::Table::operator==(const Table& other) const noexcept {
  return ::fidl::internal::NaturalTableCodingTraits<::test_doccomments::Table>::Equal(this, &other);
}
bool test_doccomments::Table::operator!=(const Table& other) const noexcept {
  return !::fidl::internal::NaturalTableCodingTraits<::test_doccomments::Table>::Equal(this, &other);
}

::test_doccomments::Table::Storage_ test_doccomments::Table::CloneStorage_() const {
  return Storage_{
      ::fidl::internal::NaturalClone(storage_.field)};
}

bool test_doccomments::Table::IsEmpty() const {
  return !(storage_.field.has_value());
}
const std::optional<int32_t>& test_doccomments::Table::field() const {
  return storage_.field;
}

::std::optional<int32_t>& test_doccomments::Table::field() {
  return storage_.field;
}

::test_doccomments::Table& test_doccomments::Table::field(std::optional<int32_t> value) {
  storage_.field = std::move(value);
  return *this;
}

::test_doccomments::StrictUnion::StrictUnion(StrictUnion&& other) noexcept : StrictUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_doccomments::StrictUnion& ::test_doccomments::StrictUnion::operator=(StrictUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_doccomments::StrictUnion::StrictUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_doccomments::StrictUnion::StrictUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_doccomments::StrictUnion::Tag test_doccomments::StrictUnion::Which() const {
  return StrictUnion::IndexToTag(storage_->index()).value();
}

size_t test_doccomments::StrictUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_doccomments::StrictUnion::Tag tag) {
  switch (tag) {
    case ::test_doccomments::StrictUnion::Tag::kField:
      return 1;
    default: {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_doccomments::StrictUnion::Tag> test_doccomments::StrictUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_doccomments::StrictUnion::Tag::kField;
    default:
      return std::nullopt;
  }
}

::test_doccomments::StrictUnion::StrictUnion(const StrictUnion& other) noexcept : StrictUnion(other.CloneStorage_()) {}

::test_doccomments::StrictUnion& test_doccomments::StrictUnion::operator=(const StrictUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_doccomments::StrictUnion::operator==(const StrictUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_doccomments::StrictUnion::operator!=(const StrictUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_doccomments::StrictUnion::Storage_> test_doccomments::StrictUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
::test_doccomments::StrictUnion test_doccomments::StrictUnion::WithField(int32_t val) {
  return StrictUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_doccomments::StrictUnion::Storage_> test_doccomments::StrictUnion::field() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_doccomments::StrictUnion::Storage_> test_doccomments::StrictUnion::field() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_doccomments::StrictUnion& test_doccomments::StrictUnion::field(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

::test_doccomments::FlexibleUnion::FlexibleUnion(FlexibleUnion&& other) noexcept : FlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_doccomments::FlexibleUnion& ::test_doccomments::FlexibleUnion::operator=(FlexibleUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_doccomments::FlexibleUnion::FlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
    : storage_(std::make_shared<Storage_>()) {}

::test_doccomments::FlexibleUnion::FlexibleUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_doccomments::FlexibleUnion::Tag test_doccomments::FlexibleUnion::Which() const {
  return FlexibleUnion::IndexToTag(storage_->index()).value();
}

size_t test_doccomments::FlexibleUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_doccomments::FlexibleUnion::Tag tag) {
  switch (tag) {
    case ::test_doccomments::FlexibleUnion::Tag::kField:
      return 1;
    default: {
      return 0;
    }
  }
}

std::optional<::test_doccomments::FlexibleUnion::Tag> test_doccomments::FlexibleUnion::IndexToTag(size_t index) {
  switch (index) {
    case 1:
      return ::test_doccomments::FlexibleUnion::Tag::kField;
    default:
      return ::test_doccomments::FlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

::test_doccomments::FlexibleUnion::FlexibleUnion(const FlexibleUnion& other) noexcept : FlexibleUnion(other.CloneStorage_()) {}

::test_doccomments::FlexibleUnion& test_doccomments::FlexibleUnion::operator=(const FlexibleUnion& other) noexcept {
  if (this != &other) {
    storage_ = other.CloneStorage_();
  }
  return *this;
}

bool test_doccomments::FlexibleUnion::operator==(const FlexibleUnion& other) const noexcept {
  return *storage_ == *other.storage_;
}
bool test_doccomments::FlexibleUnion::operator!=(const FlexibleUnion& other) const noexcept {
  return *storage_ != *other.storage_;
}

std::shared_ptr<::test_doccomments::FlexibleUnion::Storage_> test_doccomments::FlexibleUnion::CloneStorage_() const {
  const Storage_& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage_>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage_>();
  }
}
bool test_doccomments::FlexibleUnion::IsUnknown() const {
  return Which() == ::test_doccomments::FlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}
::test_doccomments::FlexibleUnion test_doccomments::FlexibleUnion::WithField(int32_t val) {
  return FlexibleUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
}

const ::fidl::internal::UnionMemberView<1, ::test_doccomments::FlexibleUnion::Storage_> test_doccomments::FlexibleUnion::field() const {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::fidl::internal::UnionMemberView<1, ::test_doccomments::FlexibleUnion::Storage_> test_doccomments::FlexibleUnion::field() {
  return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
}

::test_doccomments::FlexibleUnion& test_doccomments::FlexibleUnion::field(int32_t value) {
  storage_->emplace<1>(std::move(value));
  return *this;
}

#pragma clang diagnostic pop
