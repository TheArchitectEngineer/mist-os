// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.anonymous/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

static_assert(std::is_standard_layout_v<::test_anonymous::wire::Flags>);
static_assert(sizeof(::test_anonymous::wire::Flags) == sizeof(uint16_t));

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::Flags, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::Flags* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  *position.As<::test_anonymous::wire::Flags>() = *value;
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::Flags, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Flags, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Flags, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_anonymous::wire::BitsMember>);
static_assert(sizeof(::test_anonymous::wire::BitsMember) == sizeof(uint32_t));

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::BitsMember, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::BitsMember* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  *position.As<::test_anonymous::wire::BitsMember>() = *value;
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::BitsMember, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::BitsMember, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::BitsMember, ::fidl::internal::WireCodingConstraintEmpty, false>;

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::Op, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::Op* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  *position.As<::test_anonymous::wire::Op>() = *value;
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::Op, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Op, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Op, ::fidl::internal::WireCodingConstraintEmpty, false>;

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodError, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::SomeProtocolSomeMethodError* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  *position.As<::test_anonymous::wire::SomeProtocolSomeMethodError>() = *value;
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodError, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodError, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodError, ::fidl::internal::WireCodingConstraintEmpty, false>;

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::OverrideTest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::OverrideTest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_anonymous::wire::OverrideTest));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireCodingTraits<::test_anonymous::wire::Op, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->op, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_anonymous::wire::Expression>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->left, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_anonymous::wire::Expression>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->right, position + 24, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::OverrideTest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_anonymous::wire::Op, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_anonymous::wire::Expression>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<::fidl::WireOptional<::test_anonymous::wire::Expression>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 24, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::OverrideTest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::OverrideTest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_anonymous::wire::OverrideTest>);
static_assert(offsetof(::test_anonymous::wire::OverrideTest, op) == 0);
static_assert(offsetof(::test_anonymous::wire::OverrideTest, left) == 8);
static_assert(offsetof(::test_anonymous::wire::OverrideTest, right) == 24);
static_assert(sizeof(::test_anonymous::wire::OverrideTest) == ::fidl::TypeTraits<::test_anonymous::wire::OverrideTest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::TableData, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::TableData* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_anonymous::wire::TableData));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->data, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::TableData, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::TableData, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::TableData, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_anonymous::wire::TableData>);
static_assert(offsetof(::test_anonymous::wire::TableData, data) == 0);
static_assert(sizeof(::test_anonymous::wire::TableData) == ::fidl::TypeTraits<::test_anonymous::wire::TableData>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::SomeProtocolSomeMethodRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_anonymous::wire::SomeProtocolSomeMethodRequest));
  } else {
    internal::WireCodingTraits<::test_anonymous::wire::UnionMember, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->union_member, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_anonymous::wire::TableMember, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->table_member, position + 16, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_anonymous::wire::UnionMember, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_anonymous::wire::TableMember, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 16, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_anonymous::wire::SomeProtocolSomeMethodRequest>);
static_assert(offsetof(::test_anonymous::wire::SomeProtocolSomeMethodRequest, union_member) == 0);
static_assert(offsetof(::test_anonymous::wire::SomeProtocolSomeMethodRequest, table_member) == 16);
static_assert(sizeof(::test_anonymous::wire::SomeProtocolSomeMethodRequest) == ::fidl::TypeTraits<::test_anonymous::wire::SomeProtocolSomeMethodRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::SomeProtocolSomeMethodResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_anonymous::wire::SomeProtocolSomeMethodResponse));
  } else {
    internal::WireCodingTraits<::test_anonymous::wire::BitsMember, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->bits_member, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_anonymous::wire::BitsMember, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_anonymous::wire::SomeProtocolSomeMethodResponse>);
static_assert(offsetof(::test_anonymous::wire::SomeProtocolSomeMethodResponse, bits_member) == 0);
static_assert(sizeof(::test_anonymous::wire::SomeProtocolSomeMethodResponse) == ::fidl::TypeTraits<::test_anonymous::wire::SomeProtocolSomeMethodResponse>::kPrimarySize);

::test_anonymous::wire::Expression::Expression() : ordinal_(::test_anonymous::wire::Expression::Ordinal::Invalid), envelope_{} {}
auto ::test_anonymous::wire::Expression::Which() const -> ::test_anonymous::wire::Expression::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
    case ::test_anonymous::wire::Expression::Ordinal::kValue:
    case ::test_anonymous::wire::Expression::Ordinal::kBinOp:
    case ::test_anonymous::wire::Expression::Ordinal::kFunctionApplication:
      return static_cast<::test_anonymous::wire::Expression::Tag>(ordinal_);
    default:
      return ::test_anonymous::wire::Expression::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_anonymous::wire::Expression::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Expression) == sizeof(fidl_union_t));
  static_assert(offsetof(Expression, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(Expression, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_anonymous::wire::Expression::has_invalid_tag() const { return ordinal_ == ::test_anonymous::wire::Expression::Ordinal::Invalid; }

bool test_anonymous::wire::Expression::is_value() const { return ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kValue; }
::test_anonymous::wire::Expression test_anonymous::wire::Expression::WithValue(::fidl::ObjectView<uint64_t> val) {
  Expression result;
  result.ordinal_ = ::test_anonymous::wire::Expression::Ordinal::kValue;
  result.envelope_.As<uint64_t>().set_data(std::move(val));
  return result;
}

uint64_t& test_anonymous::wire::Expression::value() {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kValue);
  return envelope_.As<uint64_t>().get_data();
}
const uint64_t& test_anonymous::wire::Expression::value() const {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kValue);
  return envelope_.As<uint64_t>().get_data();
}

bool test_anonymous::wire::Expression::is_bin_op() const { return ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kBinOp; }
::test_anonymous::wire::Expression test_anonymous::wire::Expression::WithBinOp(::fidl::ObjectView<::test_anonymous::wire::OverrideTest> val) {
  Expression result;
  result.ordinal_ = ::test_anonymous::wire::Expression::Ordinal::kBinOp;
  result.envelope_.As<::test_anonymous::wire::OverrideTest>().set_data(std::move(val));
  return result;
}

::test_anonymous::wire::OverrideTest& test_anonymous::wire::Expression::bin_op() {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kBinOp);
  return envelope_.As<::test_anonymous::wire::OverrideTest>().get_data();
}
const ::test_anonymous::wire::OverrideTest& test_anonymous::wire::Expression::bin_op() const {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kBinOp);
  return envelope_.As<::test_anonymous::wire::OverrideTest>().get_data();
}

bool test_anonymous::wire::Expression::is_function_application() const { return ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kFunctionApplication; }
::test_anonymous::wire::Expression test_anonymous::wire::Expression::WithFunctionApplication(::fidl::ObjectView<::test_anonymous::wire::FunctionApplication> val) {
  Expression result;
  result.ordinal_ = ::test_anonymous::wire::Expression::Ordinal::kFunctionApplication;
  result.envelope_.As<::test_anonymous::wire::FunctionApplication>().set_data(std::move(val));
  return result;
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::Expression::function_application() {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kFunctionApplication);
  return envelope_.As<::test_anonymous::wire::FunctionApplication>().get_data();
}
const ::test_anonymous::wire::FunctionApplication& test_anonymous::wire::Expression::function_application() const {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::Expression::Ordinal::kFunctionApplication);
  return envelope_.As<::test_anonymous::wire::FunctionApplication>().get_data();
}

static_assert(std::is_standard_layout_v<::test_anonymous::wire::Expression>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::Expression, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::Expression* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_anonymous::wire::Expression::Tag::kValue
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_anonymous::wire::Expression::Tag::kBinOp
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::OverrideTest, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3:  // ::test_anonymous::wire::Expression::Tag::kFunctionApplication
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::FunctionApplication, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_anonymous::wire::Expression::Tag::kValue
      encode_fn = ::fidl::internal::MakeEncodeFn<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_anonymous::wire::Expression::Tag::kBinOp
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_anonymous::wire::OverrideTest, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3:  // ::test_anonymous::wire::Expression::Tag::kFunctionApplication
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_anonymous::wire::FunctionApplication, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::Expression, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_anonymous::wire::Expression::Tag tag = *position.As<::test_anonymous::wire::Expression::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_anonymous::wire::Expression::Tag::kValue:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_anonymous::wire::Expression::Tag::kBinOp:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::OverrideTest, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_anonymous::wire::Expression::Tag::kFunctionApplication:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::FunctionApplication, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_anonymous::wire::Expression::Tag::kValue:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_anonymous::wire::Expression::Tag::kBinOp:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_anonymous::wire::OverrideTest, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_anonymous::wire::Expression::Tag::kFunctionApplication:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_anonymous::wire::FunctionApplication, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Expression, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Expression, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Expression, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Expression, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_anonymous::wire::UnionMember::UnionMember() : ordinal_(::test_anonymous::wire::UnionMember::Ordinal::Invalid), envelope_{} {}
auto ::test_anonymous::wire::UnionMember::Which() const -> ::test_anonymous::wire::UnionMember::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
    case ::test_anonymous::wire::UnionMember::Ordinal::kUnionData:
      return static_cast<::test_anonymous::wire::UnionMember::Tag>(ordinal_);
    default:
      return ::test_anonymous::wire::UnionMember::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_anonymous::wire::UnionMember::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionMember) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionMember, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionMember, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_anonymous::wire::UnionMember::has_invalid_tag() const { return ordinal_ == ::test_anonymous::wire::UnionMember::Ordinal::Invalid; }

bool test_anonymous::wire::UnionMember::is_union_data() const { return ordinal_ == ::test_anonymous::wire::UnionMember::Ordinal::kUnionData; }
::test_anonymous::wire::UnionMember test_anonymous::wire::UnionMember::WithUnionData(uint8_t val) {
  UnionMember result;
  result.ordinal_ = ::test_anonymous::wire::UnionMember::Ordinal::kUnionData;
  result.envelope_.As<uint8_t>().set_data(std::move(val));
  return result;
}

uint8_t& test_anonymous::wire::UnionMember::union_data() {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::UnionMember::Ordinal::kUnionData);
  return envelope_.As<uint8_t>().get_data();
}
const uint8_t& test_anonymous::wire::UnionMember::union_data() const {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::UnionMember::Ordinal::kUnionData);
  return envelope_.As<uint8_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_anonymous::wire::UnionMember>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::UnionMember, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::UnionMember* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 2:  // ::test_anonymous::wire::UnionMember::Tag::kUnionData
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 2:  // ::test_anonymous::wire::UnionMember::Tag::kUnionData
      encode_fn = ::fidl::internal::MakeEncodeFn<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::UnionMember, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_anonymous::wire::UnionMember::Tag tag = *position.As<::test_anonymous::wire::UnionMember::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_anonymous::wire::UnionMember::Tag::kUnionData:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_anonymous::wire::UnionMember::Tag::kUnionData:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::UnionMember, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::UnionMember, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::UnionMember, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::UnionMember, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_anonymous::wire::SomeProtocolSomeMethodResult::SomeProtocolSomeMethodResult() : ordinal_(::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::Invalid), envelope_{} {}
::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag test_anonymous::wire::SomeProtocolSomeMethodResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag>(ordinal_);
}

void ::test_anonymous::wire::SomeProtocolSomeMethodResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(SomeProtocolSomeMethodResult) == sizeof(fidl_union_t));
  static_assert(offsetof(SomeProtocolSomeMethodResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(SomeProtocolSomeMethodResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_anonymous::wire::SomeProtocolSomeMethodResult::has_invalid_tag() const { return ordinal_ == ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::Invalid; }

bool test_anonymous::wire::SomeProtocolSomeMethodResult::is_response() const { return ordinal_ == ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kResponse; }
::test_anonymous::wire::SomeProtocolSomeMethodResult test_anonymous::wire::SomeProtocolSomeMethodResult::WithResponse(::test_anonymous::wire::SomeProtocolSomeMethodResponse val) {
  SomeProtocolSomeMethodResult result;
  result.ordinal_ = ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kResponse;
  result.envelope_.As<::test_anonymous::wire::SomeProtocolSomeMethodResponse>().set_data(std::move(val));
  return result;
}

::test_anonymous::wire::SomeProtocolSomeMethodResponse& test_anonymous::wire::SomeProtocolSomeMethodResult::response() {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kResponse);
  return envelope_.As<::test_anonymous::wire::SomeProtocolSomeMethodResponse>().get_data();
}
const ::test_anonymous::wire::SomeProtocolSomeMethodResponse& test_anonymous::wire::SomeProtocolSomeMethodResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kResponse);
  return envelope_.As<::test_anonymous::wire::SomeProtocolSomeMethodResponse>().get_data();
}

bool test_anonymous::wire::SomeProtocolSomeMethodResult::is_err() const { return ordinal_ == ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kErr; }
::test_anonymous::wire::SomeProtocolSomeMethodResult test_anonymous::wire::SomeProtocolSomeMethodResult::WithErr(::test_anonymous::wire::SomeProtocolSomeMethodError val) {
  SomeProtocolSomeMethodResult result;
  result.ordinal_ = ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kErr;
  result.envelope_.As<::test_anonymous::wire::SomeProtocolSomeMethodError>().set_data(std::move(val));
  return result;
}

::test_anonymous::wire::SomeProtocolSomeMethodError& test_anonymous::wire::SomeProtocolSomeMethodResult::err() {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kErr);
  return envelope_.As<::test_anonymous::wire::SomeProtocolSomeMethodError>().get_data();
}
const ::test_anonymous::wire::SomeProtocolSomeMethodError& test_anonymous::wire::SomeProtocolSomeMethodResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_anonymous::wire::SomeProtocolSomeMethodResult::Ordinal::kErr);
  return envelope_.As<::test_anonymous::wire::SomeProtocolSomeMethodError>().get_data();
}

static_assert(std::is_standard_layout_v<::test_anonymous::wire::SomeProtocolSomeMethodResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::SomeProtocolSomeMethodResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodError, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_anonymous::wire::SomeProtocolSomeMethodResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_anonymous::wire::SomeProtocolSomeMethodError, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag tag = *position.As<::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodError, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_anonymous::wire::SomeProtocolSomeMethodResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_anonymous::wire::SomeProtocolSomeMethodResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_anonymous::wire::SomeProtocolSomeMethodError, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::SomeProtocolSomeMethodResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

bool ::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>::HasUnknownData() const {
  if (!reserved_1_.IsZeroEnvelope()) {
    return true;
  }
  return false;
}

uint64_t fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
  if (!func_.has_data()) {
    max_ordinal = 1;
  }
  if (!reserved_1_.IsZeroEnvelope()) {
    max_ordinal = 1;
  }
  if (!args_.has_data()) {
    max_ordinal = 3;
  }
  if (!flags_.has_data()) {
    max_ordinal = 4;
  }
  return max_ordinal;
}

::test_anonymous::wire::FunctionApplication::FunctionApplication(::fidl::AnyArena& allocator)
    : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>>(allocator)) {}

::test_anonymous::wire::FunctionApplication::FunctionApplication(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>>&& frame)
    : frame_ptr_(std::move(frame)) {}

void test_anonymous::wire::FunctionApplication::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>>(allocator);
}
void test_anonymous::wire::FunctionApplication::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_anonymous::wire::FunctionApplication::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_anonymous::wire::FunctionApplication::HasUnknownData() const {
  if (max_ordinal_ > 4) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

::fidl::StringView& test_anonymous::wire::FunctionApplication::func() const {
  ZX_ASSERT(has_func());
  return frame_ptr_->func_.get_data();
}

bool test_anonymous::wire::FunctionApplication::has_func() const {
  return max_ordinal_ >= 1 && frame_ptr_->func_.has_data();
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::clear_func() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->func_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::set_func(::fidl::ObjectView<::fidl::StringView> elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->func_.set_data(elem);
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
  return *this;
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::set_func(std::nullptr_t) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->func_.set_data(nullptr);
  return *this;
}

::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>& test_anonymous::wire::FunctionApplication::args() const {
  ZX_ASSERT(has_args());
  return frame_ptr_->args_.get_data();
}

bool test_anonymous::wire::FunctionApplication::has_args() const {
  return max_ordinal_ >= 3 && frame_ptr_->args_.has_data();
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::clear_args() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->args_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::set_args(::fidl::ObjectView<::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>> elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->args_.set_data(elem);
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(3));
  return *this;
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::set_args(std::nullptr_t) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->args_.set_data(nullptr);
  return *this;
}

::test_anonymous::wire::Flags& test_anonymous::wire::FunctionApplication::flags() const {
  ZX_ASSERT(has_flags());
  return frame_ptr_->flags_.get_data();
}

bool test_anonymous::wire::FunctionApplication::has_flags() const {
  return max_ordinal_ >= 4 && frame_ptr_->flags_.has_data();
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::clear_flags() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->flags_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_anonymous::wire::FunctionApplication& test_anonymous::wire::FunctionApplication::set_flags(::test_anonymous::wire::Flags elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->flags_.set_data(std::move(elem));
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(4));
  return *this;
}

::fidl::WireTableBuilder<::test_anonymous::wire::FunctionApplication> test_anonymous::wire::FunctionApplication::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_anonymous::wire::FunctionApplication>(arena);
}
::fidl::WireTableExternalBuilder<::test_anonymous::wire::FunctionApplication> test_anonymous::wire::FunctionApplication::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_anonymous::wire::FunctionApplication>(std::move(frame));
}

template <typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>>&& frame)
    : table_(std::move(frame)) {}

template <typename BuilderImpl>
::test_anonymous::wire::FunctionApplication fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_anonymous::wire::FunctionApplication t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::has_func() const {
  return table_.has_func();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::clear_func() {
  table_.clear_func();
}

template <typename BuilderImpl>
::fidl::StringView& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::func() const {
  return table_.func();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::func(Wrapper_Ignore_Me_<::fidl::ObjectView<::fidl::StringView>> elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
  table_.frame_ptr_->func_.set_data(elem.value);
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(1));
  return *static_cast<BuilderImpl*>(this);
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::has_args() const {
  return table_.has_args();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::clear_args() {
  table_.clear_args();
}

template <typename BuilderImpl>
::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::args() const {
  return table_.args();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::args(Wrapper_Ignore_Me_<::fidl::ObjectView<::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>>> elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
  table_.frame_ptr_->args_.set_data(elem.value);
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(3));
  return *static_cast<BuilderImpl*>(this);
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::has_flags() const {
  return table_.has_flags();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::clear_flags() {
  table_.clear_flags();
}

template <typename BuilderImpl>
::test_anonymous::wire::Flags& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::flags() const {
  return table_.flags();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, BuilderImpl>::flags(::test_anonymous::wire::Flags elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  table_.frame_ptr_->flags_.set_data(std::move(elem));
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(4));
  return *static_cast<BuilderImpl*>(this);
}

template class fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, ::fidl::WireTableBuilder<::test_anonymous::wire::FunctionApplication>>;
template class fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::FunctionApplication, ::fidl::WireTableExternalBuilder<::test_anonymous::wire::FunctionApplication>>;

::fidl::WireTableBuilder<::test_anonymous::wire::FunctionApplication>::WireTableBuilder(::fidl::AnyArena& arena)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>>(arena)),
      arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_anonymous::wire::FunctionApplication>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>* frame)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::FunctionApplication>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::FunctionApplication, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::FunctionApplication* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {
    size_t encode_inline_size = 0;
    switch (i) {
      case 0:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 100>, IsRecursive>::kInlineSize;
        break;
      case 2:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false, 5>, IsRecursive>::kInlineSize;
        break;
      case 3:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Flags, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 0:
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 100>, IsRecursive>();
        break;
      case 2:
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false, 5>, IsRecursive>();
        break;
      case 3:
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_anonymous::wire::Flags, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::FunctionApplication, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {
    size_t decode_inline_size = 0;
    switch (i) {
      case 0:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 100>, IsRecursive>::kInlineSize;
        break;
      case 2:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false, 5>, IsRecursive>::kInlineSize;
        break;
      case 3:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::test_anonymous::wire::Flags, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch (i) {
      case 0:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 100>, IsRecursive>();
        break;
      case 2:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::WireOptional<::test_anonymous::wire::Expression>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false, 5>, IsRecursive>();
        break;
      case 3:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_anonymous::wire::Flags, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::FunctionApplication, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::FunctionApplication, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_anonymous::wire::FunctionApplication>);

bool ::fidl::WireTableFrame<::test_anonymous::wire::TableMember>::HasUnknownData() const {
  if (!reserved_0_.IsZeroEnvelope()) {
    return true;
  }
  return false;
}

uint64_t fidl::WireTableFrame<::test_anonymous::wire::TableMember>::ComputeMaxOrdinal() const {
  uint64_t max_ordinal = 0;
  if (!reserved_0_.IsZeroEnvelope()) {
    max_ordinal = 0;
  }
  if (!table_data_.has_data()) {
    max_ordinal = 2;
  }
  return max_ordinal;
}

::test_anonymous::wire::TableMember::TableMember(::fidl::AnyArena& allocator)
    : frame_ptr_(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>>(allocator)) {}

::test_anonymous::wire::TableMember::TableMember(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>>&& frame)
    : frame_ptr_(std::move(frame)) {}

void test_anonymous::wire::TableMember::Allocate(::fidl::AnyArena& allocator) {
  max_ordinal_ = 0;
  frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>>(allocator);
}
void test_anonymous::wire::TableMember::Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>>&& frame_ptr) {
  max_ordinal_ = 0;
  frame_ptr_ = std::move(frame_ptr);
}

bool ::test_anonymous::wire::TableMember::IsEmpty() const { return max_ordinal_ == 0; }

bool ::test_anonymous::wire::TableMember::HasUnknownData() const {
  if (max_ordinal_ > 2) {
    return true;
  }
  if (frame_ptr_ == nullptr) {
    return false;
  }
  return frame_ptr_->HasUnknownData();
}

::fidl::VectorView<::test_anonymous::wire::TableData>& test_anonymous::wire::TableMember::table_data() const {
  ZX_ASSERT(has_table_data());
  return frame_ptr_->table_data_.get_data();
}

bool test_anonymous::wire::TableMember::has_table_data() const {
  return max_ordinal_ >= 2 && frame_ptr_->table_data_.has_data();
}

::test_anonymous::wire::TableMember& test_anonymous::wire::TableMember::clear_table_data() {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->table_data_.clear_data();
  max_ordinal_ = frame_ptr_->ComputeMaxOrdinal();
  return *this;
}

::test_anonymous::wire::TableMember& test_anonymous::wire::TableMember::set_table_data(::fidl::ObjectView<::fidl::VectorView<::test_anonymous::wire::TableData>> elem) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->table_data_.set_data(elem);
  max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(2));
  return *this;
}

::test_anonymous::wire::TableMember& test_anonymous::wire::TableMember::set_table_data(std::nullptr_t) {
  ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
  frame_ptr_->table_data_.set_data(nullptr);
  return *this;
}

::fidl::WireTableBuilder<::test_anonymous::wire::TableMember> test_anonymous::wire::TableMember::Builder(::fidl::AnyArena& arena) {
  return ::fidl::WireTableBuilder<::test_anonymous::wire::TableMember>(arena);
}
::fidl::WireTableExternalBuilder<::test_anonymous::wire::TableMember> test_anonymous::wire::TableMember::ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>> frame) {
  return ::fidl::WireTableExternalBuilder<::test_anonymous::wire::TableMember>(std::move(frame));
}

template <typename BuilderImpl>
fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, BuilderImpl>::WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>>&& frame)
    : table_(std::move(frame)) {}

template <typename BuilderImpl>
::test_anonymous::wire::TableMember fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, BuilderImpl>::Build() {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ::test_anonymous::wire::TableMember t = std::move(table_);
  // Poison this builder to prevent accidental reuse.
  table_.frame_ptr_ = nullptr;
  return t;
}
template <typename BuilderImpl>
bool fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, BuilderImpl>::has_table_data() const {
  return table_.has_table_data();
}

template <typename BuilderImpl>
void fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, BuilderImpl>::clear_table_data() {
  table_.clear_table_data();
}

template <typename BuilderImpl>
::fidl::VectorView<::test_anonymous::wire::TableData>& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, BuilderImpl>::table_data() const {
  return table_.table_data();
}
template <typename BuilderImpl>
BuilderImpl& fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, BuilderImpl>::table_data(Wrapper_Ignore_Me_<::fidl::ObjectView<::fidl::VectorView<::test_anonymous::wire::TableData>>> elem) {
  ZX_DEBUG_ASSERT(table_.frame_ptr_ != nullptr);
  ZX_DEBUG_ASSERT(elem.value.get() != nullptr);
  table_.frame_ptr_->table_data_.set_data(elem.value);
  table_.max_ordinal_ = std::max(table_.max_ordinal_, static_cast<uint64_t>(2));
  return *static_cast<BuilderImpl*>(this);
}

template class fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, ::fidl::WireTableBuilder<::test_anonymous::wire::TableMember>>;
template class fidl::internal::WireTableBaseBuilder<::test_anonymous::wire::TableMember, ::fidl::WireTableExternalBuilder<::test_anonymous::wire::TableMember>>;

::fidl::WireTableBuilder<::test_anonymous::wire::TableMember>::WireTableBuilder(::fidl::AnyArena& arena)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>>(arena)),
      arena_(arena) {}

::fidl::WireTableExternalBuilder<::test_anonymous::wire::TableMember>::WireTableExternalBuilder(::fidl::WireTableFrame<::test_anonymous::wire::TableMember>* frame)
    : Base(::fidl::ObjectView<::fidl::WireTableFrame<::test_anonymous::wire::TableMember>>::FromExternal(frame)) {}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::TableMember, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_anonymous::wire::TableMember* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit ==
      Base::PrepareForBodyEncode(encoder, value, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = reinterpret_cast<fidl_vector_t*>(value);
  fidl_envelope_t* envelopes = static_cast<fidl_envelope_t*>(vec->data);
  for (size_t i = 0; i < vec->count; i++) {
    size_t encode_inline_size = 0;
    switch (i) {
      case 1:
        encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::test_anonymous::wire::TableData>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>::kInlineSize;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn = nullptr;
    switch (i) {
      case 1:
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::test_anonymous::wire::TableData>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>();
        break;
    }
    WirePosition envelope_position = vector_position + i * sizeof(fidl_envelope_t);
    WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &envelopes[i], envelope_position, inner_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_anonymous::wire::TableMember, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 2);
  if (!inner_depth.IsValid()) {
    return;
  }

  ::fidl::internal::WirePosition vector_position;
  if (Base::PreworkResult::kEarlyExit == Base::DecodePrework(decoder, position, &vector_position)) {
    return;
  }

  fidl_vector_t* vec = position.As<fidl_vector_t>();
  for (size_t i = 0; i < vec->count; i++) {
    size_t decode_inline_size = 0;
    switch (i) {
      case 1:
        decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::test_anonymous::wire::TableData>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>::kInlineSize;
        break;
    }
    DecodeFn<IsRecursive> decode_fn = nullptr;
    switch (i) {
      case 1:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::test_anonymous::wire::TableData>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>();
        break;
    }
    ::fidl::internal::WireDecodeOptionalEnvelope(decode_inline_size, decode_fn, decoder, vector_position + i * sizeof(fidl_envelope_t), inner_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::TableMember, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_anonymous::wire::TableMember, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_anonymous::wire::TableMember>);

#pragma clang diagnostic pop
