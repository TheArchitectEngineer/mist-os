// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.bindingsdenylist/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest));
  } else {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest, a) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, b) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest));
  } else {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest, a) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, b) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest));
  } else {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest, a) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, b) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest));
  } else {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest, a) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, b) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest));
  } else {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest, a) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>);
static_assert(offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, b) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary));
  } else {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>);
static_assert(offsetof(::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary, a) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary));
  } else {
    internal::WireCodingTraits<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->member_only_appears_in_importing_library, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>);
static_assert(offsetof(::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary, member_only_appears_in_importing_library) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary) == ::fidl::TypeTraits<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>::kPrimarySize);

::test_bindingsdenylist::wire::OnlyLlcpp::OnlyLlcpp() : ordinal_(::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::Invalid), envelope_{} {}
::test_bindingsdenylist::wire::OnlyLlcpp::Tag test_bindingsdenylist::wire::OnlyLlcpp::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_bindingsdenylist::wire::OnlyLlcpp::Tag>(ordinal_);
}

void ::test_bindingsdenylist::wire::OnlyLlcpp::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(OnlyLlcpp) == sizeof(fidl_union_t));
  static_assert(offsetof(OnlyLlcpp, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(OnlyLlcpp, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_bindingsdenylist::wire::OnlyLlcpp::has_invalid_tag() const { return ordinal_ == ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::Invalid; }

bool test_bindingsdenylist::wire::OnlyLlcpp::is_x() const { return ordinal_ == ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX; }
::test_bindingsdenylist::wire::OnlyLlcpp test_bindingsdenylist::wire::OnlyLlcpp::WithX(uint32_t val) {
  OnlyLlcpp result;
  result.ordinal_ = ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_bindingsdenylist::wire::OnlyLlcpp::x() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_bindingsdenylist::wire::OnlyLlcpp::x() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::OnlyLlcpp>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyLlcpp, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::OnlyLlcpp* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::OnlyLlcpp::Tag::kX
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::OnlyLlcpp::Tag::kX
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyLlcpp, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_bindingsdenylist::wire::OnlyLlcpp::Tag tag = *position.As<::test_bindingsdenylist::wire::OnlyLlcpp::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_bindingsdenylist::wire::OnlyLlcpp::Tag::kX:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_bindingsdenylist::wire::OnlyLlcpp::Tag::kX:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyLlcpp, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyLlcpp, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyLlcpp, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::OnlyLlcpp, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::DenyEachBindingOnlyDenyDartResult() : ordinal_(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::Invalid), envelope_{} {}
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag>(ordinal_);
}

void ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(DenyEachBindingOnlyDenyDartResult) == sizeof(fidl_union_t));
  static_assert(offsetof(DenyEachBindingOnlyDenyDartResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(DenyEachBindingOnlyDenyDartResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::has_invalid_tag() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::Invalid; }

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::is_response() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kResponse; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::WithResponse(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse val) {
  DenyEachBindingOnlyDenyDartResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kResponse;
  result.envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>().set_data(std::move(val));
  return result;
}

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::response() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>().get_data();
}
const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>().get_data();
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::is_err() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kErr; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::WithErr(uint32_t val) {
  DenyEachBindingOnlyDenyDartResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::err() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag tag = *position.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::DenyEachBindingOnlyDenyGoResult() : ordinal_(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::Invalid), envelope_{} {}
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag>(ordinal_);
}

void ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(DenyEachBindingOnlyDenyGoResult) == sizeof(fidl_union_t));
  static_assert(offsetof(DenyEachBindingOnlyDenyGoResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(DenyEachBindingOnlyDenyGoResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::has_invalid_tag() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::Invalid; }

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::is_response() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kResponse; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::WithResponse(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse val) {
  DenyEachBindingOnlyDenyGoResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kResponse;
  result.envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>().set_data(std::move(val));
  return result;
}

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::response() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>().get_data();
}
const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>().get_data();
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::is_err() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kErr; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::WithErr(uint32_t val) {
  DenyEachBindingOnlyDenyGoResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::err() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag tag = *position.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::DenyEachBindingOnlyDenyPythonResult() : ordinal_(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::Invalid), envelope_{} {}
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag>(ordinal_);
}

void ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(DenyEachBindingOnlyDenyPythonResult) == sizeof(fidl_union_t));
  static_assert(offsetof(DenyEachBindingOnlyDenyPythonResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(DenyEachBindingOnlyDenyPythonResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::has_invalid_tag() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::Invalid; }

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::is_response() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kResponse; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::WithResponse(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse val) {
  DenyEachBindingOnlyDenyPythonResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kResponse;
  result.envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse>().set_data(std::move(val));
  return result;
}

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::response() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse>().get_data();
}
const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse>().get_data();
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::is_err() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kErr; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::WithErr(uint32_t val) {
  DenyEachBindingOnlyDenyPythonResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::err() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag tag = *position.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyPythonResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::DenyEachBindingOnlyDenyRustResult() : ordinal_(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::Invalid), envelope_{} {}
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag>(ordinal_);
}

void ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(DenyEachBindingOnlyDenyRustResult) == sizeof(fidl_union_t));
  static_assert(offsetof(DenyEachBindingOnlyDenyRustResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(DenyEachBindingOnlyDenyRustResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::has_invalid_tag() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::Invalid; }

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::is_response() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kResponse; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::WithResponse(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse val) {
  DenyEachBindingOnlyDenyRustResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kResponse;
  result.envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>().set_data(std::move(val));
  return result;
}

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::response() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>().get_data();
}
const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>().get_data();
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::is_err() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kErr; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::WithErr(uint32_t val) {
  DenyEachBindingOnlyDenyRustResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::err() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag tag = *position.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::DenyEachBindingOnlyDenySyzkallerResult() : ordinal_(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::Invalid), envelope_{} {}
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag>(ordinal_);
}

void ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(DenyEachBindingOnlyDenySyzkallerResult) == sizeof(fidl_union_t));
  static_assert(offsetof(DenyEachBindingOnlyDenySyzkallerResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(DenyEachBindingOnlyDenySyzkallerResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::has_invalid_tag() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::Invalid; }

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::is_response() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::WithResponse(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse val) {
  DenyEachBindingOnlyDenySyzkallerResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse;
  result.envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>().set_data(std::move(val));
  return result;
}

::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::response() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>().get_data();
}
const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse& test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse);
  return envelope_.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>().get_data();
}

bool test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::is_err() const { return ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr; }
::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::WithErr(uint32_t val) {
  DenyEachBindingOnlyDenySyzkallerResult result;
  result.ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::err() {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag tag = *position.As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#pragma clang diagnostic pop
