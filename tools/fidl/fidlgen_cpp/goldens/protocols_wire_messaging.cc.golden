// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json
#ifdef __Fuchsia__

#include <fidl/test.protocols/cpp/wire_messaging.h>

#include <memory>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal = 5413654872775949227lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_NoRequestNoResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal = 1631193469798418024lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal = 9037369643591427517lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ret) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal = 7326057319832554103lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_WithRequestNoResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, arg) == 0);

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal = 2877322062572412767lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, arg) == 0);

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal = 6417226585456833969lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, arg) == 0);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ret) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal = 5397663296507358806lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_OnEmptyResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, header) == 0);

  [[maybe_unused]]
  constexpr uint64_t kWithAndWithoutRequestResponse_OnWithResponse_Ordinal = 5811598563493228968lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithAndWithoutRequestResponse_OnWithResponse_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, body) == sizeof(fidl_message_header_t));}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(result) {}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
    }
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(result) {}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(result) {}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(result) {}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
    }
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(result) {}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(result) {}

  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request_object{  };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestNoResponse(::fidl::StringView arg) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request_object{ arg };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
    return ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestNoResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}

  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
          return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

::fidl::internal::WireEventDispatcher<::test_protocols::WithAndWithoutRequestResponse>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::WithAndWithoutRequestResponse> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::WithAndWithoutRequestResponse> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocols::WithAndWithoutRequestResponse>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
          event_handler()->OnEmptyResponse();
        }
        return ::fidl::Status::Ok();
      }
      case ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->OnWithResponse(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }
void fidl::WireAsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {}
void fidl::WireAsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* event) {}

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::entries_[] = {
    { ::test_protocols::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->NoRequestNoResponse(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->NoRequestEmptyResponse(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->NoRequestWithResponse(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->WithRequestNoResponse(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->WithRequestEmptyResponse(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>*>(interface)->WithRequestWithResponse(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::entries_end_ =
    &entries_[6];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::TryDispatch(
    ::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::Dispatch(::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>::Handler fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::WithAndWithoutRequestResponse> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _response{  };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _response{  };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>& fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _response{ ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _response{ ret };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _response{  };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _response{  };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>& fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _response{ ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::Reply(::fidl::StringView ret) {
  return MakeReply(ret);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::MakeReply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _response{ ret };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestNoResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireResponse(::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse base) : ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::WireResponse(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse{ .ret = std::move(ret)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::TransactionalResponse(::fidl::StringView ret)
    : body(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(ret)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::TransactionalRequest(::fidl::StringView arg)
    : body(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest { arg } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestNoResponse_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::TransactionalRequest(::fidl::StringView arg)
    : body(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest { arg } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::TransactionalRequest(::fidl::StringView arg)
    : body(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest { arg } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireResponse(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse base) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::WireResponse(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse{ .ret = std::move(ret)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::TransactionalResponse(::fidl::StringView ret)
    : body(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(ret)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::TransactionalEvent(::fidl::StringView ret)
    : body{ ret } {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal, ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
        return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
        return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
        return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestNoResponse(::fidl::StringView arg) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
        return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestNoResponse(::fidl::StringView arg) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
        return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
        return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestEmptyResponse(::fidl::StringView arg) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
        return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
        return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>::WithRequestWithResponse(::fidl::StringView arg) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
        return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(
          ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> _response{ };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>::OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> _response{ret };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal = 268248568430741139lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_ResponseAsStruct_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 6930994461233198567lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal = 5491891352371277635lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_ErrorAsEnum_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kWithErrorSyntax_HandleInResult_Ordinal = 1371676333068455103lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithErrorSyntax_HandleInResult_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, body) == sizeof(fidl_message_header_t));}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ResponseAsStruct>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(result) {}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(result) {}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsEnum>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(result) {}

::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::HandleInResult>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithErrorSyntax::HandleInResult>(result) {}

  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::HandleInResult> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
    return ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::HandleInResult>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::HandleInResult> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::HandleInResult>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}

  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
          return ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

::fidl::internal::WireEventDispatcher<::test_protocols::WithErrorSyntax>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::WithErrorSyntax>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::WithErrorSyntax> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::WithErrorSyntax> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::entries_[] = {
    { ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ResponseAsStruct>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->ResponseAsStruct(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->ErrorAsPrimitive(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->ErrorAsEnum(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::HandleInResult>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)->HandleInResult(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::entries_end_ =
    &entries_[4];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::TryDispatch(
    ::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::Dispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::WithErrorSyntax>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::WithErrorSyntax>::Handler fidl::WireServer<::test_protocols::WithErrorSyntax>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::WithErrorSyntax> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult WithErrorSyntaxResponseAsStructResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> _response{ WithErrorSyntaxResponseAsStructResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplySuccess(int64_t a, int64_t b, int64_t c) {
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse _response = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse {
  .a = std::move(a),
  .b = std::move(b),
  .c = std::move(c),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult WithErrorSyntaxResponseAsStructResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> _response{ WithErrorSyntaxResponseAsStructResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>& fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplySuccess(int64_t a, int64_t b, int64_t c) {
    ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse _response = ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse {
  .a = std::move(a),
  .b = std::move(b),
  .c = std::move(c),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Reply(::fit::result<uint32_t> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult WithErrorSyntaxErrorAsPrimitiveResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _response{ WithErrorSyntaxErrorAsPrimitiveResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Reply(::fit::result<uint32_t> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult WithErrorSyntaxErrorAsPrimitiveResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _response{ WithErrorSyntaxErrorAsPrimitiveResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithResponse({}));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(::fit::result<::test_protocols::wire::ErrorEnum> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult WithErrorSyntaxErrorAsEnumResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> _response{ WithErrorSyntaxErrorAsEnumResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplyError(::test_protocols::wire::ErrorEnum error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(::fit::result<::test_protocols::wire::ErrorEnum> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult WithErrorSyntaxErrorAsEnumResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> _response{ WithErrorSyntaxErrorAsEnumResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>& fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse({}));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplyError(::test_protocols::wire::ErrorEnum error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult WithErrorSyntaxHandleInResultResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult> _response{ std::move(WithErrorSyntaxHandleInResultResult) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplySuccess(::zx::handle&& h) {
    ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse _response = ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse {
  .h = std::move(h),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::Reply(::fit::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult WithErrorSyntaxHandleInResultResult) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult> _response{ std::move(WithErrorSyntaxHandleInResultResult) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>& fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplySuccess(::zx::handle&& h) {
    ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse _response = ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse {
  .h = std::move(h),
};
return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(std::move(*&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t error) {
    return MakeReply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(std::move(error)));
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>::WireResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult WithErrorSyntaxResponseAsStructResult) : ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult(WithErrorSyntaxResponseAsStructResult){}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>::TransactionalResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult WithErrorSyntaxResponseAsStructResult)
    : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>(WithErrorSyntaxResponseAsStructResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult WithErrorSyntaxErrorAsPrimitiveResult) : ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult(WithErrorSyntaxErrorAsPrimitiveResult){}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::TransactionalResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult WithErrorSyntaxErrorAsPrimitiveResult)
    : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(WithErrorSyntaxErrorAsPrimitiveResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult WithErrorSyntaxErrorAsEnumResult) : ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult(WithErrorSyntaxErrorAsEnumResult){}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>::TransactionalResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult WithErrorSyntaxErrorAsEnumResult)
    : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>(WithErrorSyntaxErrorAsEnumResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal, ::test_protocols::kWithErrorSyntax_HandleInResult_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>::WireResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResult WithErrorSyntaxHandleInResultResult) : ::test_protocols::wire::WithErrorSyntaxHandleInResultResult(std::move(WithErrorSyntaxHandleInResultResult)){}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>::TransactionalResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResult WithErrorSyntaxHandleInResultResult)
    : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>(std::move(WithErrorSyntaxHandleInResultResult))) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal, ::test_protocols::kWithErrorSyntax_HandleInResult_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal, ::test_protocols::kWithErrorSyntax_HandleInResult_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
        return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
        return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
        return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
        return ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax>::HandleInResult() {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>(
          ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kChannelProtocol_MethodA_Ordinal = 3155008840945527714lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kChannelProtocol_MethodA_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::ChannelProtocolMethodARequest)
        == ::fidl::TypeTraits<::test_protocols::wire::ChannelProtocolMethodARequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest, a) == 0);
          static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodARequest, b) == 8);

  [[maybe_unused]]
  constexpr uint64_t kChannelProtocol_EventA_Ordinal = 2220452875311597006lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kChannelProtocol_EventA_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kChannelProtocol_MethodB_Ordinal = 8903004957800778182lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kChannelProtocol_MethodB_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::ChannelProtocolMethodBRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::ChannelProtocolMethodBRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest, a) == 0);
          static_assert(offsetof(::test_protocols::wire::ChannelProtocolMethodBRequest, b) == 8);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, result) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kChannelProtocol_TakeHandle_Ordinal = 591935489944717925lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kChannelProtocol_TakeHandle_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::ChannelProtocolTakeHandleRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::ChannelProtocolTakeHandleRequest, h) == 0);

  [[maybe_unused]]
  constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal = 7411742788430590287lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kChannelProtocol_MutateSocket_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::ChannelProtocolMutateSocketRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::ChannelProtocolMutateSocketRequest, a) == 0);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, b) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, body) == sizeof(fidl_message_header_t));}  // namespace test_protocols

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodA>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodA>(result) {}

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MethodB>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodB>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MethodB>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>::WireUnownedResult(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* response)
        : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MethodB>(result) {}

::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
}

::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::TakeHandle>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
    }
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::TakeHandle>(result) {}

::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MutateSocket>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>::WireUnownedResult(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* response)
        : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ChannelProtocol::MutateSocket>(result) {}

  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request_object{ a, b };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MethodB> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
    return ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MethodB>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::TakeHandle> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
    return ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::TakeHandle>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MutateSocket> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
    return ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MutateSocket>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodA>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MethodB> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodB>();
  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
  return ::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MethodB>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::TakeHandle> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::TakeHandle>();
  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::TakeHandle>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MutateSocket> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ChannelProtocol::MutateSocket>();
  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MutateSocket>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}

  ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
          return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
          return ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
          return ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

::fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::ChannelProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::ChannelProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocols::kChannelProtocol_EventA_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::ChannelProtocol::EventA>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventA(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }
void fidl::WireAsyncEventHandler<::test_protocols::ChannelProtocol>::EventA(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* event) {}

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::entries_[] = {
    { ::test_protocols::kChannelProtocol_MethodA_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::ChannelProtocolMethodARequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodA>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->MethodA(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kChannelProtocol_MethodB_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::ChannelProtocolMethodBRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodB>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->MethodB(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::ChannelProtocolTakeHandleRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::TakeHandle>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->TakeHandle(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::ChannelProtocolMutateSocketRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MutateSocket>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)->MutateSocket(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::entries_end_ =
    &entries_[4];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::Dispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::ChannelProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::ChannelProtocol>::Handler fidl::WireServer<::test_protocols::ChannelProtocol>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::ChannelProtocol> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  return MakeReply(result);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::MakeReply(int64_t result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB> _response{ result };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  return MakeReply(result);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MethodB>::MakeReply(int64_t result) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB> _response{ result };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::MethodB>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB>& fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle> _response{  };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  return MakeReply();
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle>::MakeReply() {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle> _response{  };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::TakeHandle>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>& fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  return MakeReply(std::move(b));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::MakeReply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket> _response{ std::move(b) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  return MakeReply(std::move(b));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket>::MakeReply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket> _response{ std::move(b) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::MutateSocket>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>& fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodA_Ordinal, ::test_protocols::kChannelProtocol_MethodA_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>::TransactionalRequest(int64_t a, int64_t b)
    : body(::test_protocols::wire::ChannelProtocolMethodARequest { a, b } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodA_Ordinal, ::test_protocols::kChannelProtocol_MethodA_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>::TransactionalEvent(int64_t a, int64_t b)
    : body{ a, b } {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_EventA_Ordinal, ::test_protocols::kChannelProtocol_EventA_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_EventA_Ordinal, ::test_protocols::kChannelProtocol_EventA_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal, ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>::TransactionalRequest(int64_t a, int64_t b)
    : body(::test_protocols::wire::ChannelProtocolMethodBRequest { a, b } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal, ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>::WireResponse(::test_protocols::wire::ChannelProtocolMethodBResponse base) : ::test_protocols::wire::ChannelProtocolMethodBResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>::WireResponse(int64_t result) : ::test_protocols::wire::ChannelProtocolMethodBResponse{ .result = std::move(result)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>::TransactionalResponse(int64_t result)
    : body(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>(result)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal, ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal, ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_TakeHandle_Ordinal, ::test_protocols::kChannelProtocol_TakeHandle_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>::TransactionalRequest(::zx::handle&& h)
    : body(::test_protocols::wire::ChannelProtocolTakeHandleRequest { std::move(h) } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_TakeHandle_Ordinal, ::test_protocols::kChannelProtocol_TakeHandle_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_TakeHandle_Ordinal, ::test_protocols::kChannelProtocol_TakeHandle_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal, ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>::TransactionalRequest(::zx::socket&& a)
    : body(::test_protocols::wire::ChannelProtocolMutateSocketRequest { std::move(a) } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal, ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>::WireResponse(::test_protocols::wire::ChannelProtocolMutateSocketResponse base) : ::test_protocols::wire::ChannelProtocolMutateSocketResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>::WireResponse(::zx::socket&& b) : ::test_protocols::wire::ChannelProtocolMutateSocketResponse{ .b = std::move(b)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>::TransactionalResponse(::zx::socket&& b)
    : body(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>(std::move(b))) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal, ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal, ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
        return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
        return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>
      fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
        return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
        return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>
      fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
        return ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
        return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>
      fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
        return ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
        return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>(
          ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::EventA>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::ChannelProtocol::EventA>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> _response{a, b };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kDiscoverableProtocol_Method_Ordinal = 3455873048082739435lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kDiscoverableProtocol_Method_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;}  // namespace test_protocols

::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::DiscoverableProtocol::Method>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::DiscoverableProtocol::Method>(result) {}

  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol>::Method() {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request_object{  };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::DiscoverableProtocol>::Method() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::DiscoverableProtocol::Method>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

::fidl::internal::WireEventDispatcher<::test_protocols::DiscoverableProtocol>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::DiscoverableProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::DiscoverableProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::DiscoverableProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::entries_[] = {
    { ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::DiscoverableProtocol::Method>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::DiscoverableProtocol>*>(interface)->Method(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::entries_end_ =
    &entries_[1];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::DiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::DiscoverableProtocol>::Handler fidl::WireServer<::test_protocols::DiscoverableProtocol>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

  ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kDiscoverableProtocol_Method_Ordinal, ::test_protocols::kDiscoverableProtocol_Method_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_protocols::DiscoverableProtocol>::Method() {
        ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
        return ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>(
          ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::DiscoverableProtocol>::Method() {
        ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
        return ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>(
          ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

::fidl::internal::WireEventDispatcher<::test_protocols::AnotherDiscoverableProtocol>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::AnotherDiscoverableProtocol>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::AnotherDiscoverableProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::AnotherDiscoverableProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::AnotherDiscoverableProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::AnotherDiscoverableProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::entries_[] = {
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::entries_end_ =
    &entries_[0];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::Dispatch(::fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::AnotherDiscoverableProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>::Handler fidl::WireServer<::test_protocols::AnotherDiscoverableProtocol>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::AnotherDiscoverableProtocol> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

::fidl::internal::WireEventDispatcher<::test_protocols::PlatformServer>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::PlatformServer>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::PlatformServer>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::PlatformServer> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::PlatformServer> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::PlatformServer> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::PlatformServer>::entries_[] = {
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::PlatformServer>::entries_end_ =
    &entries_[0];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::PlatformServer>::TryDispatch(
    ::fidl::WireServer<::test_protocols::PlatformServer>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::PlatformServer>::Dispatch(::fidl::WireServer<::test_protocols::PlatformServer>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::PlatformServer>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::PlatformServer>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::PlatformServer>::Handler fidl::WireServer<::test_protocols::PlatformServer>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::PlatformServer> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kHandleRightsProtocol_NoResponseMethod_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, h) == 0);

  [[maybe_unused]]
  constexpr uint64_t kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kHandleRightsProtocol_ResponseMethod_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, h) == 0);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, h) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kHandleRightsProtocol_AnEvent_Ordinal = 476727631355490611lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kHandleRightsProtocol_AnEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, body) == sizeof(fidl_message_header_t));}  // namespace test_protocols

::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::NoResponseMethod>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(result) {}

::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::ResponseMethod>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireUnownedResult(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* response)
        : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(result) {}

  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&& h) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request_object{ std::move(h) };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
    return ::fidl::internal::WireThenable<::test_protocols::HandleRightsProtocol::ResponseMethod>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::NoResponseMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::HandleRightsProtocol::ResponseMethod>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}

  ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
          return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

::fidl::internal::WireEventDispatcher<::test_protocols::HandleRightsProtocol>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::HandleRightsProtocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::HandleRightsProtocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::HandleRightsProtocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_protocols::HandleRightsProtocol>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->AnEvent(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }
void fidl::WireAsyncEventHandler<::test_protocols::HandleRightsProtocol>::AnEvent(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>* event) {}

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::entries_[] = {
    { ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::NoResponseMethod>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(interface)->NoResponseMethod(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::ResponseMethod>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(interface)->ResponseMethod(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::entries_end_ =
    &entries_[2];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::TryDispatch(
    ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::HandleRightsProtocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::HandleRightsProtocol>::Handler fidl::WireServer<::test_protocols::HandleRightsProtocol>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::HandleRightsProtocol> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

void
fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::Reply(::zx::socket&& h) {
  return MakeReply(std::move(h));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::MakeReply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> _response{ std::move(h) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::Reply(::zx::socket&& h) {
  return MakeReply(std::move(h));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod>::MakeReply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> _response{ std::move(h) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>& fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

  ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_NoResponseMethod_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>::TransactionalRequest(::zx::socket&& h)
    : body(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest { std::move(h) } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_NoResponseMethod_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>::TransactionalRequest(::zx::socket&& h)
    : body(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest { std::move(h) } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireResponse(::test_protocols::wire::HandleRightsProtocolResponseMethodResponse base) : ::test_protocols::wire::HandleRightsProtocolResponseMethodResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>::WireResponse(::zx::socket&& h) : ::test_protocols::wire::HandleRightsProtocolResponseMethodResponse{ .h = std::move(h)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>::TransactionalResponse(::zx::socket&& h)
    : body(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>(std::move(h))) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal, ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>::TransactionalEvent(::zx::socket&& h)
    : body{ std::move(h) } {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal, ::test_protocols::kHandleRightsProtocol_AnEvent_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal, ::test_protocols::kHandleRightsProtocol_AnEvent_DynamicFlags);
  }
    void ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&& h) {
        ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
        return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(
          ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&& h) {
        ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
        return ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(
          ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
      fidl::internal::WireSyncClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
        ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
        return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(
          ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
        ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
        return ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(
          ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> _response{std::move(h) };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kWithProtocolEnds_ClientEnds_Ordinal = 5870448041025163330lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithProtocolEnds_ClientEnds_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::WithProtocolEndsClientEndsRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::WithProtocolEndsClientEndsRequest, in) == 0);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, out) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kWithProtocolEnds_ServerEnds_Ordinal = 8115535094437022259lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithProtocolEnds_ServerEnds_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::WithProtocolEndsServerEndsRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::WithProtocolEndsServerEndsRequest, in) == 0);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, out) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kWithProtocolEnds_StructContainingEnds_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, in) == 0);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, out) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, body) == sizeof(fidl_message_header_t));}  // namespace test_protocols

::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ClientEnds>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ClientEnds>(result) {}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ServerEnds>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::ServerEnds>(result) {}

::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::StructContainingEnds>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireUnownedResult(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* response)
        : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(result) {}

  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ClientEnds> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
    return ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ClientEnds>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ServerEnds> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
    return ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ServerEnds>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
    return ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::StructContainingEnds>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ClientEnds> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ClientEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ServerEnds> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ServerEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
  return ::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::StructContainingEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}

  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
          return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
          return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
          return ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

::fidl::internal::WireEventDispatcher<::test_protocols::WithProtocolEnds>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::WithProtocolEnds>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::WithProtocolEnds> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::WithProtocolEnds> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::entries_[] = {
    { ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::WithProtocolEndsClientEndsRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ClientEnds>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(interface)->ClientEnds(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::WithProtocolEndsServerEndsRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ServerEnds>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(interface)->ServerEnds(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::StructContainingEnds>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(interface)->StructContainingEnds(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::entries_end_ =
    &entries_[3];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::TryDispatch(
    ::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::Dispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::WithProtocolEnds>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::WithProtocolEnds>::Handler fidl::WireServer<::test_protocols::WithProtocolEnds>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::WithProtocolEnds> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::MakeReply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds> _response{ std::move(out) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::MakeReply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds> _response{ std::move(out) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>& fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::MakeReply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds> _response{ std::move(out) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::MakeReply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds> _response{ std::move(out) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>& fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::Reply(::test_protocols::wire::ProtocolEnds&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::MakeReply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> _response{ std::move(out) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::Reply(::test_protocols::wire::ProtocolEnds&& out) {
  return MakeReply(std::move(out));
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds>::MakeReply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> _response{ std::move(out) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>& fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>::TransactionalRequest(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in)
    : body(::test_protocols::wire::WithProtocolEndsClientEndsRequest { std::move(in) } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>::WireResponse(::test_protocols::wire::WithProtocolEndsClientEndsResponse base) : ::test_protocols::wire::WithProtocolEndsClientEndsResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>::WireResponse(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) : ::test_protocols::wire::WithProtocolEndsClientEndsResponse{ .out = std::move(out)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>::TransactionalResponse(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out)
    : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>(std::move(out))) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>::TransactionalRequest(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in)
    : body(::test_protocols::wire::WithProtocolEndsServerEndsRequest { std::move(in) } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>::WireResponse(::test_protocols::wire::WithProtocolEndsServerEndsResponse base) : ::test_protocols::wire::WithProtocolEndsServerEndsResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>::WireResponse(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) : ::test_protocols::wire::WithProtocolEndsServerEndsResponse{ .out = std::move(out)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>::TransactionalResponse(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out)
    : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>(std::move(out))) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal, ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal, ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>::TransactionalRequest(::test_protocols::wire::ProtocolEnds&& in)
    : body(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest { std::move(in) } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal, ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireResponse(::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse base) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>::WireResponse(::test_protocols::wire::ProtocolEnds&& out) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse{ .out = std::move(out)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>::TransactionalResponse(::test_protocols::wire::ProtocolEnds&& out)
    : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>(std::move(out))) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal, ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal, ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
        return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>(
          ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithProtocolEnds>::ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
        return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>(
          ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
        return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>(
          ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithProtocolEnds>::ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
        return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>(
          ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
      fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
        return ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(
          ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithProtocolEnds>::StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
        ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
        return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(
          ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kManyParameters_Fifteen_Ordinal = 6423043252952467815lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kManyParameters_Fifteen_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::ManyParametersFifteenRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::ManyParametersFifteenRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p1) == 0);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p2) == 1);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p3) == 2);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p4) == 3);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p5) == 4);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p6) == 5);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p7) == 6);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p8) == 7);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p9) == 8);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p10) == 9);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p11) == 10);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p12) == 11);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p13) == 12);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p14) == 13);
          static_assert(offsetof(::test_protocols::wire::ManyParametersFifteenRequest, p15) == 14);}  // namespace test_protocols

::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::ManyParameters::Fifteen>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::ManyParameters::Fifteen>(result) {}

  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request_object{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::ManyParameters::Fifteen>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

::fidl::internal::WireEventDispatcher<::test_protocols::ManyParameters>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::ManyParameters>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::ManyParameters> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::ManyParameters> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::entries_[] = {
    { ::test_protocols::kManyParameters_Fifteen_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::ManyParametersFifteenRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::ManyParameters::Fifteen>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::ManyParameters>*>(interface)->Fifteen(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::entries_end_ =
    &entries_[1];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::TryDispatch(
    ::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::Dispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::ManyParameters>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::ManyParameters>::Handler fidl::WireServer<::test_protocols::ManyParameters>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::ManyParameters> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

  ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kManyParameters_Fifteen_Ordinal, ::test_protocols::kManyParameters_Fifteen_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>::TransactionalRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15)
    : body(::test_protocols::wire::ManyParametersFifteenRequest { p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kManyParameters_Fifteen_Ordinal, ::test_protocols::kManyParameters_Fifteen_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
        return ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>(
          ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
        ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
        return ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>(
          ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

  namespace test_protocols {

  [[maybe_unused]]
  constexpr uint64_t kMethodWithUnion_UnionMethod_Ordinal = 4124874338266649112lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kMethodWithUnion_UnionMethod_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_protocols::wire::MethodWithUnionUnionMethodRequest)
        == ::fidl::TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest>::kPrimarySize);
          static_assert(offsetof(::test_protocols::wire::MethodWithUnionUnionMethodRequest, u) == 0);
      static_assert(sizeof(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, u) == 0);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, body) == sizeof(fidl_message_header_t));}  // namespace test_protocols

::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client,
    ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(result) {}

    ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>::WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_protocols::MethodWithUnion::UnionMethod>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>::WireUnownedResult(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* response)
        : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_protocols::MethodWithUnion::UnionMethod>(result) {}

  ::fidl::internal::WireThenable<::test_protocols::MethodWithUnion::UnionMethod> fidl::internal::WireWeakAsyncClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
    ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
    return ::fidl::internal::WireThenable<::test_protocols::MethodWithUnion::UnionMethod>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::internal::WireBufferThenable<::test_protocols::MethodWithUnion::UnionMethod> fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_protocols::MethodWithUnion::UnionMethod>();
  ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
  return ::fidl::internal::WireBufferThenable<::test_protocols::MethodWithUnion::UnionMethod>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}

  ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>
  fidl::internal::WireWeakSyncClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
          return ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>(::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

::fidl::internal::WireEventDispatcher<::test_protocols::MethodWithUnion>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_protocols::MethodWithUnion>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_protocols::MethodWithUnion> event_storage;
      fidl::internal::WireEventDispatcher<::test_protocols::MethodWithUnion> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::entries_[] = {
    { ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_protocols::wire::MethodWithUnionUnionMethodRequest>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_protocols::MethodWithUnion::UnionMethod>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_protocols::MethodWithUnion>*>(interface)->UnionMethod(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::entries_end_ =
    &entries_[1];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::TryDispatch(
    ::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::Dispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_protocols::MethodWithUnion>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_protocols::MethodWithUnion>::Handler fidl::WireServer<::test_protocols::MethodWithUnion>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_protocols::MethodWithUnion> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

void
fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::Reply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  return MakeReply(u);
}

void
fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::MakeReply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod> _response{ u };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::Reply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  return MakeReply(u);
}

void
fidl::internal::WireBufferCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod>::MakeReply(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) {
  ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod> _response{ u };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_protocols::MethodWithUnion::UnionMethod>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>& fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

  ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal, ::test_protocols::kMethodWithUnion_UnionMethod_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>::TransactionalRequest(::test_protocols::wire::TheUnion u)
    : body(::test_protocols::wire::MethodWithUnionUnionMethodRequest { u } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal, ::test_protocols::kMethodWithUnion_UnionMethod_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>::WireResponse(::test_protocols::wire::MethodWithUnionUnionMethodResponse base) : ::test_protocols::wire::MethodWithUnionUnionMethodResponse(std::move(base)) {}
    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>::WireResponse(::fidl::WireOptional<::test_protocols::wire::TheUnion> u) : ::test_protocols::wire::MethodWithUnionUnionMethodResponse{ .u = std::move(u)}{}

    ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>::TransactionalResponse(::fidl::WireOptional<::test_protocols::wire::TheUnion> u)
    : body(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>(u)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal, ::test_protocols::kMethodWithUnion_UnionMethod_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal, ::test_protocols::kMethodWithUnion_UnionMethod_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>
      fidl::internal::WireSyncClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
        ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
        return ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>(
          ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>
      fidl::internal::WireSyncBufferClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(::test_protocols::wire::TheUnion u) {
        ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
        return ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>(
          ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

#pragma clang diagnostic pop

#endif  // __Fuchsia__

