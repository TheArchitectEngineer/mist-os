// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <fidl/test.bits/cpp/common_types.h>

#if defined(__cpp_lib_format) && __cplusplus >= 202002L && defined(__Fuchsia__)
#include <format>

template <>
struct std::formatter<::test_bits::MyBits> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_bits::MyBits& value, std::format_context& ctx) const {
    auto out = ctx.out();
    out = std::format_to(out, "test_bits::MyBits(");
    bool first = true;
    if (value & ::test_bits::MyBits::kMyFirstBit) {
      if (!first) *out++ = '|';
      first = false;
      out = std::format_to(out, "kMyFirstBit");
    }
    if (value & ::test_bits::MyBits::kMyOtherBit) {
      if (!first) *out++ = '|';
      first = false;
      out = std::format_to(out, "kMyOtherBit");
    }
    if (value & ::test_bits::MyBits::kMask_) {
      if (!first) *out++ = '|';
      first = false;
      out = std::format_to(out, "kMask_");
    }
    *out++ = ')';
    return out;
  }
};
template <>
struct std::formatter<::test_bits::StrictBits> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_bits::StrictBits& value, std::format_context& ctx) const {
    auto out = ctx.out();
    out = std::format_to(out, "test_bits::StrictBits(");
    bool first = true;
    if (value & ::test_bits::StrictBits::kSmallest) {
      if (!first) *out++ = '|';
      first = false;
      out = std::format_to(out, "kSmallest");
    }
    if (value & ::test_bits::StrictBits::kBiggest) {
      if (!first) *out++ = '|';
      first = false;
      out = std::format_to(out, "kBiggest");
    }
    *out++ = ')';
    return out;
  }
};
template <>
struct std::formatter<::test_bits::FlexibleBits> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_bits::FlexibleBits& value, std::format_context& ctx) const {
    auto out = ctx.out();
    out = std::format_to(out, "test_bits::FlexibleBits(");
    bool first = true;
    if (value & ::test_bits::FlexibleBits::kSmallest) {
      if (!first) *out++ = '|';
      first = false;
      out = std::format_to(out, "kSmallest");
    }
    if (value & ::test_bits::FlexibleBits::kBiggest) {
      if (!first) *out++ = '|';
      first = false;
      out = std::format_to(out, "kBiggest");
    }
    if (value.has_unknown_bits()) {
      if (!first) *out++ = '|';
      out = std::format_to(out, "{}", static_cast<uint64_t>(value.unknown_bits()));
    }
    *out++ = ')';
    return out;
  }
};
template <>
struct std::formatter<::test_bits::EmptyBits> {
  constexpr auto parse(auto& ctx) { return ctx.begin(); }
  auto format(const ::test_bits::EmptyBits& value, std::format_context& ctx) const {
    auto out = ctx.out();
    out = std::format_to(out, "test_bits::EmptyBits(");
    bool first = true;
    if (value.has_unknown_bits()) {
      if (!first) *out++ = '|';
      out = std::format_to(out, "{}", static_cast<uint32_t>(value.unknown_bits()));
    }
    *out++ = ')';
    return out;
  }
};

#endif
