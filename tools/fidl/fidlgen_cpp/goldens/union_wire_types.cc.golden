// WARNING: This file is machine generated by fidlgen.

  // fidl_experiment = output_index_json

  #include <fidl/test.union/cpp/wire_types.h>

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::Pizza* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::Pizza));
  } else {
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false, 16>, false>, IsRecursive>::Encode(encoder, &value->toppings, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false, 16>, false>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::Pizza>);
static_assert(offsetof(::test_union::wire::Pizza, toppings) == 0);
static_assert(sizeof(::test_union::wire::Pizza) == ::fidl::TypeTraits<::test_union::wire::Pizza>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::Pasta* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::Pasta));
  } else {
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 16>, IsRecursive>::Encode(encoder, &value->sauce, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false, 16>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::Pasta>);
static_assert(offsetof(::test_union::wire::Pasta, sauce) == 0);
static_assert(sizeof(::test_union::wire::Pasta) == ::fidl::TypeTraits<::test_union::wire::Pasta>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::NullableUnionStruct* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::NullableUnionStruct));
  } else {
    internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->the_union, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::NullableUnionStruct, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::NullableUnionStruct>);
static_assert(offsetof(::test_union::wire::NullableUnionStruct, the_union) == 0);
static_assert(sizeof(::test_union::wire::NullableUnionStruct) == ::fidl::TypeTraits<::test_union::wire::NullableUnionStruct>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::Empty* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::Empty));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::Empty>);
static_assert(offsetof(::test_union::wire::Empty, __reserved) == 0);
static_assert(sizeof(::test_union::wire::Empty) == ::fidl::TypeTraits<::test_union::wire::Empty>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse));
  } else {
    internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->xu, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>);
static_assert(offsetof(::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, xu) == 0);
static_assert(sizeof(::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse) == ::fidl::TypeTraits<::test_union::wire::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse));
  } else {
    internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->xu, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>);
static_assert(offsetof(::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, xu) == 0);
static_assert(sizeof(::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse) == ::fidl::TypeTraits<::test_union::wire::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::StructWithNullableUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::StructWithNullableUnion));
  } else {
    internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::OlderSimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->x1, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::WireOptional<::test_union::wire::OlderSimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::StructWithNullableUnion>);
static_assert(offsetof(::test_union::wire::StructWithNullableUnion, x1) == 0);
static_assert(sizeof(::test_union::wire::StructWithNullableUnion) == ::fidl::TypeTraits<::test_union::wire::StructWithNullableUnion>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::UnionSandwich* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_union::wire::UnionSandwich));
  } else {
    internal::WireZeroPadding<uint64_t>(encoder, position + 0);
    internal::WireZeroPadding<uint64_t>(encoder, position + 24);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->u, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 24, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
      decoder, position + 8, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position + 24, recursion_depth);
  }
  internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
  internal::WireCheckPadding<uint64_t>(decoder, position + 24, 0xffffffff00000000);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionSandwich, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_union::wire::UnionSandwich>);
static_assert(offsetof(::test_union::wire::UnionSandwich, a) == 0);
static_assert(offsetof(::test_union::wire::UnionSandwich, u) == 8);
static_assert(offsetof(::test_union::wire::UnionSandwich, b) == 24);
static_assert(sizeof(::test_union::wire::UnionSandwich) == ::fidl::TypeTraits<::test_union::wire::UnionSandwich>::kPrimarySize);

::test_union::wire::PizzaOrPasta::PizzaOrPasta() : ordinal_(::test_union::wire::PizzaOrPasta::Ordinal::Invalid), envelope_{} {}
::test_union::wire::PizzaOrPasta::Tag test_union::wire::PizzaOrPasta::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::PizzaOrPasta::Tag>(ordinal_);
}

void ::test_union::wire::PizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(PizzaOrPasta) == sizeof(fidl_union_t));
  static_assert(offsetof(PizzaOrPasta, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(PizzaOrPasta, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::PizzaOrPasta::has_invalid_tag() const { return ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::Invalid; }

  bool test_union::wire::PizzaOrPasta::is_pizza() const { return ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPizza; }
    ::test_union::wire::PizzaOrPasta test_union::wire::PizzaOrPasta::WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
      PizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::PizzaOrPasta::Ordinal::kPizza;
      result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pizza& test_union::wire::PizzaOrPasta::pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& test_union::wire::PizzaOrPasta::pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool test_union::wire::PizzaOrPasta::is_pasta() const { return ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPasta; }
    ::test_union::wire::PizzaOrPasta test_union::wire::PizzaOrPasta::WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
      PizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::PizzaOrPasta::Ordinal::kPasta;
      result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pasta& test_union::wire::PizzaOrPasta::pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& test_union::wire::PizzaOrPasta::pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::PizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::PizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::PizzaOrPasta* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::PizzaOrPasta::Tag::kPizza
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::PizzaOrPasta::Tag::kPasta
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::PizzaOrPasta::Tag::kPizza
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::PizzaOrPasta::Tag::kPasta
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::PizzaOrPasta::Tag tag = *position.As<::test_union::wire::PizzaOrPasta::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::PizzaOrPasta::Tag::kPizza:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::PizzaOrPasta::Tag::kPasta:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::PizzaOrPasta::Tag::kPizza:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::PizzaOrPasta::Tag::kPasta:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::PizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::ExplicitPizzaOrPasta::ExplicitPizzaOrPasta() : ordinal_(::test_union::wire::ExplicitPizzaOrPasta::Ordinal::Invalid), envelope_{} {}
::test_union::wire::ExplicitPizzaOrPasta::Tag test_union::wire::ExplicitPizzaOrPasta::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::ExplicitPizzaOrPasta::Tag>(ordinal_);
}

void ::test_union::wire::ExplicitPizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ExplicitPizzaOrPasta) == sizeof(fidl_union_t));
  static_assert(offsetof(ExplicitPizzaOrPasta, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ExplicitPizzaOrPasta, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::ExplicitPizzaOrPasta::has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::Invalid; }

  bool test_union::wire::ExplicitPizzaOrPasta::is_pizza() const { return ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza; }
    ::test_union::wire::ExplicitPizzaOrPasta test_union::wire::ExplicitPizzaOrPasta::WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
      ExplicitPizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza;
      result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pizza& test_union::wire::ExplicitPizzaOrPasta::pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& test_union::wire::ExplicitPizzaOrPasta::pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool test_union::wire::ExplicitPizzaOrPasta::is_pasta() const { return ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta; }
    ::test_union::wire::ExplicitPizzaOrPasta test_union::wire::ExplicitPizzaOrPasta::WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
      ExplicitPizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta;
      result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pasta& test_union::wire::ExplicitPizzaOrPasta::pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& test_union::wire::ExplicitPizzaOrPasta::pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitPizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::ExplicitPizzaOrPasta* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 4: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 4: // ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::ExplicitPizzaOrPasta::Tag tag = *position.As<::test_union::wire::ExplicitPizzaOrPasta::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPizza:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::ExplicitPizzaOrPasta::Tag::kPasta:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::FlexiblePizzaOrPasta::FlexiblePizzaOrPasta() : ordinal_(::test_union::wire::FlexiblePizzaOrPasta::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::FlexiblePizzaOrPasta::Which() const -> ::test_union::wire::FlexiblePizzaOrPasta::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza:
  case ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta:
    return static_cast<::test_union::wire::FlexiblePizzaOrPasta::Tag>(ordinal_);
  default:
    return ::test_union::wire::FlexiblePizzaOrPasta::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::FlexiblePizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(FlexiblePizzaOrPasta) == sizeof(fidl_union_t));
  static_assert(offsetof(FlexiblePizzaOrPasta, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(FlexiblePizzaOrPasta, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::FlexiblePizzaOrPasta::has_invalid_tag() const { return ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::Invalid; }

  bool test_union::wire::FlexiblePizzaOrPasta::is_pizza() const { return ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza; }
    ::test_union::wire::FlexiblePizzaOrPasta test_union::wire::FlexiblePizzaOrPasta::WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
      FlexiblePizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza;
      result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pizza& test_union::wire::FlexiblePizzaOrPasta::pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& test_union::wire::FlexiblePizzaOrPasta::pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool test_union::wire::FlexiblePizzaOrPasta::is_pasta() const { return ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta; }
    ::test_union::wire::FlexiblePizzaOrPasta test_union::wire::FlexiblePizzaOrPasta::WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
      FlexiblePizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta;
      result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pasta& test_union::wire::FlexiblePizzaOrPasta::pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& test_union::wire::FlexiblePizzaOrPasta::pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::FlexiblePizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::FlexiblePizzaOrPasta* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::FlexiblePizzaOrPasta::Tag tag = *position.As<::test_union::wire::FlexiblePizzaOrPasta::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPizza:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::FlexiblePizzaOrPasta::Tag::kPasta:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexiblePizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::StrictPizzaOrPasta::StrictPizzaOrPasta() : ordinal_(::test_union::wire::StrictPizzaOrPasta::Ordinal::Invalid), envelope_{} {}
::test_union::wire::StrictPizzaOrPasta::Tag test_union::wire::StrictPizzaOrPasta::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::StrictPizzaOrPasta::Tag>(ordinal_);
}

void ::test_union::wire::StrictPizzaOrPasta::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(StrictPizzaOrPasta) == sizeof(fidl_union_t));
  static_assert(offsetof(StrictPizzaOrPasta, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(StrictPizzaOrPasta, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::StrictPizzaOrPasta::has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::Invalid; }

  bool test_union::wire::StrictPizzaOrPasta::is_pizza() const { return ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza; }
    ::test_union::wire::StrictPizzaOrPasta test_union::wire::StrictPizzaOrPasta::WithPizza(::fidl::ObjectView<::test_union::wire::Pizza> val) {
      StrictPizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza;
      result.envelope_.As<::test_union::wire::Pizza>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pizza& test_union::wire::StrictPizzaOrPasta::pizza() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }
  const ::test_union::wire::Pizza& test_union::wire::StrictPizzaOrPasta::pizza() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::test_union::wire::Pizza>().get_data();
  }

  bool test_union::wire::StrictPizzaOrPasta::is_pasta() const { return ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta; }
    ::test_union::wire::StrictPizzaOrPasta test_union::wire::StrictPizzaOrPasta::WithPasta(::fidl::ObjectView<::test_union::wire::Pasta> val) {
      StrictPizzaOrPasta result;
      result.ordinal_ = ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta;
      result.envelope_.As<::test_union::wire::Pasta>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Pasta& test_union::wire::StrictPizzaOrPasta::pasta() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }
  const ::test_union::wire::Pasta& test_union::wire::StrictPizzaOrPasta::pasta() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::test_union::wire::Pasta>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::StrictPizzaOrPasta>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::StrictPizzaOrPasta* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::StrictPizzaOrPasta::Tag tag = *position.As<::test_union::wire::StrictPizzaOrPasta::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::StrictPizzaOrPasta::Tag::kPizza:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pizza, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::StrictPizzaOrPasta::Tag::kPasta:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Pasta, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictPizzaOrPasta, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::Union::Union() : ordinal_(::test_union::wire::Union::Ordinal::Invalid), envelope_{} {}
::test_union::wire::Union::Tag test_union::wire::Union::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::Union::Tag>(ordinal_);
}

void ::test_union::wire::Union::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(Union) == sizeof(fidl_union_t));
  static_assert(offsetof(Union, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(Union, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::Union::has_invalid_tag() const { return ordinal_ == ::test_union::wire::Union::Ordinal::Invalid; }

  bool test_union::wire::Union::is_primitive() const { return ordinal_ == ::test_union::wire::Union::Ordinal::kPrimitive; }
    ::test_union::wire::Union test_union::wire::Union::WithPrimitive(int32_t val) {
      Union result;
      result.ordinal_ = ::test_union::wire::Union::Ordinal::kPrimitive;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::Union::primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::Union::primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_union::wire::Union::is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::Union::Ordinal::kStringNeedsConstructor; }
    ::test_union::wire::Union test_union::wire::Union::WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
      Union result;
      result.ordinal_ = ::test_union::wire::Union::Ordinal::kStringNeedsConstructor;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::Union::string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::Union::string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool test_union::wire::Union::is_vector_string_also_needs_constructor() const { return ordinal_ == ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor; }
    ::test_union::wire::Union test_union::wire::Union::WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
      Union result;
      result.ordinal_ = ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor;
      result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
      return result;
    }

  ::fidl::VectorView<::fidl::StringView>& test_union::wire::Union::vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& test_union::wire::Union::vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::Union::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::Union>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Union, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::Union* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::Union::Tag::kPrimitive
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::Union::Tag::kStringNeedsConstructor
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::Union::Tag::kPrimitive
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::Union::Tag::kStringNeedsConstructor
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case 3: // ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::Union, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::Union::Tag tag = *position.As<::test_union::wire::Union::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::Union::Tag::kPrimitive:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::Union::Tag::kStringNeedsConstructor:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::Union::Tag::kPrimitive:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::Union::Tag::kStringNeedsConstructor:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case ::test_union::wire::Union::Tag::kVectorStringAlsoNeedsConstructor:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::Union, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::FlexibleUnion::FlexibleUnion() : ordinal_(::test_union::wire::FlexibleUnion::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::FlexibleUnion::Which() const -> ::test_union::wire::FlexibleUnion::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive:
  case ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor:
  case ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor:
    return static_cast<::test_union::wire::FlexibleUnion::Tag>(ordinal_);
  default:
    return ::test_union::wire::FlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::FlexibleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(FlexibleUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(FlexibleUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(FlexibleUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::FlexibleUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::Invalid; }

  bool test_union::wire::FlexibleUnion::is_primitive() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive; }
    ::test_union::wire::FlexibleUnion test_union::wire::FlexibleUnion::WithPrimitive(int32_t val) {
      FlexibleUnion result;
      result.ordinal_ = ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::FlexibleUnion::primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::FlexibleUnion::primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_union::wire::FlexibleUnion::is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor; }
    ::test_union::wire::FlexibleUnion test_union::wire::FlexibleUnion::WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
      FlexibleUnion result;
      result.ordinal_ = ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::FlexibleUnion::string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::FlexibleUnion::string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool test_union::wire::FlexibleUnion::is_vector_string_also_needs_constructor() const { return ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor; }
    ::test_union::wire::FlexibleUnion test_union::wire::FlexibleUnion::WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
      FlexibleUnion result;
      result.ordinal_ = ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor;
      result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
      return result;
    }

  ::fidl::VectorView<::fidl::StringView>& test_union::wire::FlexibleUnion::vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& test_union::wire::FlexibleUnion::vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::FlexibleUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::FlexibleUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::FlexibleUnion::Tag::kPrimitive
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::FlexibleUnion::Tag::kPrimitive
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case 3: // ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::FlexibleUnion::Tag tag = *position.As<::test_union::wire::FlexibleUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::FlexibleUnion::Tag::kPrimitive:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::FlexibleUnion::Tag::kPrimitive:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::FlexibleUnion::Tag::kStringNeedsConstructor:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case ::test_union::wire::FlexibleUnion::Tag::kVectorStringAlsoNeedsConstructor:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::StrictUnion::StrictUnion() : ordinal_(::test_union::wire::StrictUnion::Ordinal::Invalid), envelope_{} {}
::test_union::wire::StrictUnion::Tag test_union::wire::StrictUnion::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::StrictUnion::Tag>(ordinal_);
}

void ::test_union::wire::StrictUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(StrictUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(StrictUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(StrictUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::StrictUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::Invalid; }

  bool test_union::wire::StrictUnion::is_primitive() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kPrimitive; }
    ::test_union::wire::StrictUnion test_union::wire::StrictUnion::WithPrimitive(int32_t val) {
      StrictUnion result;
      result.ordinal_ = ::test_union::wire::StrictUnion::Ordinal::kPrimitive;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::StrictUnion::primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::StrictUnion::primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_union::wire::StrictUnion::is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor; }
    ::test_union::wire::StrictUnion test_union::wire::StrictUnion::WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
      StrictUnion result;
      result.ordinal_ = ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::StrictUnion::string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::StrictUnion::string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool test_union::wire::StrictUnion::is_vector_string_also_needs_constructor() const { return ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor; }
    ::test_union::wire::StrictUnion test_union::wire::StrictUnion::WithVectorStringAlsoNeedsConstructor(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
      StrictUnion result;
      result.ordinal_ = ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor;
      result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
      return result;
    }

  ::fidl::VectorView<::fidl::StringView>& test_union::wire::StrictUnion::vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& test_union::wire::StrictUnion::vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictUnion::Ordinal::kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::StrictUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::StrictUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictUnion::Tag::kPrimitive
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictUnion::Tag::kPrimitive
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case 3: // ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::StrictUnion::Tag tag = *position.As<::test_union::wire::StrictUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::StrictUnion::Tag::kPrimitive:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::StrictUnion::Tag::kPrimitive:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::StrictUnion::Tag::kStringNeedsConstructor:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case ::test_union::wire::StrictUnion::Tag::kVectorStringAlsoNeedsConstructor:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::FieldCollision::FieldCollision() : ordinal_(::test_union::wire::FieldCollision::Ordinal::Invalid), envelope_{} {}
::test_union::wire::FieldCollision::Tag test_union::wire::FieldCollision::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::FieldCollision::Tag>(ordinal_);
}

void ::test_union::wire::FieldCollision::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(FieldCollision) == sizeof(fidl_union_t));
  static_assert(offsetof(FieldCollision, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(FieldCollision, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::FieldCollision::has_invalid_tag() const { return ordinal_ == ::test_union::wire::FieldCollision::Ordinal::Invalid; }

  bool test_union::wire::FieldCollision::is_field_collision_tag() const { return ordinal_ == ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag; }
    ::test_union::wire::FieldCollision test_union::wire::FieldCollision::WithFieldCollisionTag(int32_t val) {
      FieldCollision result;
      result.ordinal_ = ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::FieldCollision::field_collision_tag() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::FieldCollision::field_collision_tag() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::FieldCollision>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::FieldCollision* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::FieldCollision::Tag tag = *position.As<::test_union::wire::FieldCollision::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::FieldCollision::Tag::kFieldCollisionTag:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FieldCollision, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::ExplicitUnion::ExplicitUnion() : ordinal_(::test_union::wire::ExplicitUnion::Ordinal::Invalid), envelope_{} {}
::test_union::wire::ExplicitUnion::Tag test_union::wire::ExplicitUnion::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::ExplicitUnion::Tag>(ordinal_);
}

void ::test_union::wire::ExplicitUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ExplicitUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(ExplicitUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ExplicitUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::ExplicitUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::Invalid; }

  bool test_union::wire::ExplicitUnion::is_primitive() const { return ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive; }
    ::test_union::wire::ExplicitUnion test_union::wire::ExplicitUnion::WithPrimitive(int32_t val) {
      ExplicitUnion result;
      result.ordinal_ = ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::ExplicitUnion::primitive() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::ExplicitUnion::primitive() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_union::wire::ExplicitUnion::is_string_needs_constructor() const { return ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor; }
    ::test_union::wire::ExplicitUnion test_union::wire::ExplicitUnion::WithStringNeedsConstructor(::fidl::ObjectView<::fidl::StringView> val) {
      ExplicitUnion result;
      result.ordinal_ = ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::ExplicitUnion::string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::ExplicitUnion::string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::ExplicitUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitUnion::Tag::kPrimitive
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitUnion::Tag::kPrimitive
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::ExplicitUnion::Tag tag = *position.As<::test_union::wire::ExplicitUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::ExplicitUnion::Tag::kPrimitive:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::ExplicitUnion::Tag::kPrimitive:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::ExplicitUnion::Tag::kStringNeedsConstructor:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::ReverseOrdinalUnion::ReverseOrdinalUnion() : ordinal_(::test_union::wire::ReverseOrdinalUnion::Ordinal::Invalid), envelope_{} {}
::test_union::wire::ReverseOrdinalUnion::Tag test_union::wire::ReverseOrdinalUnion::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::ReverseOrdinalUnion::Tag>(ordinal_);
}

void ::test_union::wire::ReverseOrdinalUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ReverseOrdinalUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(ReverseOrdinalUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ReverseOrdinalUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::ReverseOrdinalUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::Invalid; }

  bool test_union::wire::ReverseOrdinalUnion::is_first() const { return ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst; }
    ::test_union::wire::ReverseOrdinalUnion test_union::wire::ReverseOrdinalUnion::WithFirst(uint32_t val) {
      ReverseOrdinalUnion result;
      result.ordinal_ = ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_union::wire::ReverseOrdinalUnion::first() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_union::wire::ReverseOrdinalUnion::first() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst);
    return envelope_.As<uint32_t>().get_data();
  }

  bool test_union::wire::ReverseOrdinalUnion::is_second() const { return ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond; }
    ::test_union::wire::ReverseOrdinalUnion test_union::wire::ReverseOrdinalUnion::WithSecond(uint32_t val) {
      ReverseOrdinalUnion result;
      result.ordinal_ = ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond;
      result.envelope_.As<uint32_t>().set_data(std::move(val));
      return result;
    }

  uint32_t& test_union::wire::ReverseOrdinalUnion::second() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& test_union::wire::ReverseOrdinalUnion::second() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond);
    return envelope_.As<uint32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::ReverseOrdinalUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::ReverseOrdinalUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::ReverseOrdinalUnion::Tag tag = *position.As<::test_union::wire::ReverseOrdinalUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::ReverseOrdinalUnion::Tag::kFirst:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::ReverseOrdinalUnion::Tag::kSecond:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ReverseOrdinalUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::FlexibleFoo::FlexibleFoo() : ordinal_(::test_union::wire::FlexibleFoo::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::FlexibleFoo::Which() const -> ::test_union::wire::FlexibleFoo::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::FlexibleFoo::Ordinal::kS:
  case ::test_union::wire::FlexibleFoo::Ordinal::kI:
    return static_cast<::test_union::wire::FlexibleFoo::Tag>(ordinal_);
  default:
    return ::test_union::wire::FlexibleFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::FlexibleFoo::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(FlexibleFoo) == sizeof(fidl_union_t));
  static_assert(offsetof(FlexibleFoo, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(FlexibleFoo, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::FlexibleFoo::has_invalid_tag() const { return ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::Invalid; }

  bool test_union::wire::FlexibleFoo::is_s() const { return ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kS; }
    ::test_union::wire::FlexibleFoo test_union::wire::FlexibleFoo::WithS(::fidl::ObjectView<::fidl::StringView> val) {
      FlexibleFoo result;
      result.ordinal_ = ::test_union::wire::FlexibleFoo::Ordinal::kS;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::FlexibleFoo::s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::FlexibleFoo::s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool test_union::wire::FlexibleFoo::is_i() const { return ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kI; }
    ::test_union::wire::FlexibleFoo test_union::wire::FlexibleFoo::WithI(int32_t val) {
      FlexibleFoo result;
      result.ordinal_ = ::test_union::wire::FlexibleFoo::Ordinal::kI;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::FlexibleFoo::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::FlexibleFoo::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::FlexibleFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::FlexibleFoo>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::FlexibleFoo* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::FlexibleFoo::Tag::kS
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::FlexibleFoo::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::FlexibleFoo::Tag::kS
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case 2: // ::test_union::wire::FlexibleFoo::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::FlexibleFoo::Tag tag = *position.As<::test_union::wire::FlexibleFoo::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::FlexibleFoo::Tag::kS:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::FlexibleFoo::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::FlexibleFoo::Tag::kS:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case ::test_union::wire::FlexibleFoo::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::FlexibleFoo, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::StrictFoo::StrictFoo() : ordinal_(::test_union::wire::StrictFoo::Ordinal::Invalid), envelope_{} {}
::test_union::wire::StrictFoo::Tag test_union::wire::StrictFoo::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::StrictFoo::Tag>(ordinal_);
}

void ::test_union::wire::StrictFoo::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(StrictFoo) == sizeof(fidl_union_t));
  static_assert(offsetof(StrictFoo, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(StrictFoo, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::StrictFoo::has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictFoo::Ordinal::Invalid; }

  bool test_union::wire::StrictFoo::is_s() const { return ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kS; }
    ::test_union::wire::StrictFoo test_union::wire::StrictFoo::WithS(::fidl::ObjectView<::fidl::StringView> val) {
      StrictFoo result;
      result.ordinal_ = ::test_union::wire::StrictFoo::Ordinal::kS;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::StrictFoo::s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::StrictFoo::s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool test_union::wire::StrictFoo::is_i() const { return ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kI; }
    ::test_union::wire::StrictFoo test_union::wire::StrictFoo::WithI(int32_t val) {
      StrictFoo result;
      result.ordinal_ = ::test_union::wire::StrictFoo::Ordinal::kI;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::StrictFoo::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::StrictFoo::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::StrictFoo>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::StrictFoo* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictFoo::Tag::kS
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::StrictFoo::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictFoo::Tag::kS
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case 2: // ::test_union::wire::StrictFoo::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::StrictFoo::Tag tag = *position.As<::test_union::wire::StrictFoo::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::StrictFoo::Tag::kS:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::StrictFoo::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::StrictFoo::Tag::kS:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case ::test_union::wire::StrictFoo::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictFoo, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::ExplicitFoo::ExplicitFoo() : ordinal_(::test_union::wire::ExplicitFoo::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::ExplicitFoo::Which() const -> ::test_union::wire::ExplicitFoo::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::ExplicitFoo::Ordinal::kI:
  case ::test_union::wire::ExplicitFoo::Ordinal::kS:
    return static_cast<::test_union::wire::ExplicitFoo::Tag>(ordinal_);
  default:
    return ::test_union::wire::ExplicitFoo::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::ExplicitFoo::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ExplicitFoo) == sizeof(fidl_union_t));
  static_assert(offsetof(ExplicitFoo, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ExplicitFoo, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::ExplicitFoo::has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::Invalid; }

  bool test_union::wire::ExplicitFoo::is_i() const { return ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kI; }
    ::test_union::wire::ExplicitFoo test_union::wire::ExplicitFoo::WithI(int32_t val) {
      ExplicitFoo result;
      result.ordinal_ = ::test_union::wire::ExplicitFoo::Ordinal::kI;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::ExplicitFoo::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::ExplicitFoo::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_union::wire::ExplicitFoo::is_s() const { return ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kS; }
    ::test_union::wire::ExplicitFoo test_union::wire::ExplicitFoo::WithS(::fidl::ObjectView<::fidl::StringView> val) {
      ExplicitFoo result;
      result.ordinal_ = ::test_union::wire::ExplicitFoo::Ordinal::kS;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::ExplicitFoo::s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::ExplicitFoo::s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitFoo>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::ExplicitFoo* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitFoo::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::ExplicitFoo::Tag::kS
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitFoo::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::ExplicitFoo::Tag::kS
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::ExplicitFoo::Tag tag = *position.As<::test_union::wire::ExplicitFoo::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::ExplicitFoo::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::ExplicitFoo::Tag::kS:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::ExplicitFoo::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::ExplicitFoo::Tag::kS:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFoo, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::ExplicitStrictFoo::ExplicitStrictFoo() : ordinal_(::test_union::wire::ExplicitStrictFoo::Ordinal::Invalid), envelope_{} {}
::test_union::wire::ExplicitStrictFoo::Tag test_union::wire::ExplicitStrictFoo::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::ExplicitStrictFoo::Tag>(ordinal_);
}

void ::test_union::wire::ExplicitStrictFoo::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ExplicitStrictFoo) == sizeof(fidl_union_t));
  static_assert(offsetof(ExplicitStrictFoo, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ExplicitStrictFoo, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::ExplicitStrictFoo::has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::Invalid; }

  bool test_union::wire::ExplicitStrictFoo::is_i() const { return ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kI; }
    ::test_union::wire::ExplicitStrictFoo test_union::wire::ExplicitStrictFoo::WithI(int32_t val) {
      ExplicitStrictFoo result;
      result.ordinal_ = ::test_union::wire::ExplicitStrictFoo::Ordinal::kI;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::ExplicitStrictFoo::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::ExplicitStrictFoo::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_union::wire::ExplicitStrictFoo::is_s() const { return ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kS; }
    ::test_union::wire::ExplicitStrictFoo test_union::wire::ExplicitStrictFoo::WithS(::fidl::ObjectView<::fidl::StringView> val) {
      ExplicitStrictFoo result;
      result.ordinal_ = ::test_union::wire::ExplicitStrictFoo::Ordinal::kS;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::ExplicitStrictFoo::s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::ExplicitStrictFoo::s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitStrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitStrictFoo>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::ExplicitStrictFoo* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 2: // ::test_union::wire::ExplicitStrictFoo::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_union::wire::ExplicitStrictFoo::Tag::kS
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 2: // ::test_union::wire::ExplicitStrictFoo::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_union::wire::ExplicitStrictFoo::Tag::kS
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::ExplicitStrictFoo::Tag tag = *position.As<::test_union::wire::ExplicitStrictFoo::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::ExplicitStrictFoo::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::ExplicitStrictFoo::Tag::kS:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::ExplicitStrictFoo::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::ExplicitStrictFoo::Tag::kS:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitStrictFoo, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::OlderSimpleUnion::OlderSimpleUnion() : ordinal_(::test_union::wire::OlderSimpleUnion::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::OlderSimpleUnion::Which() const -> ::test_union::wire::OlderSimpleUnion::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::OlderSimpleUnion::Ordinal::kI:
  case ::test_union::wire::OlderSimpleUnion::Ordinal::kF:
    return static_cast<::test_union::wire::OlderSimpleUnion::Tag>(ordinal_);
  default:
    return ::test_union::wire::OlderSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::OlderSimpleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(OlderSimpleUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(OlderSimpleUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(OlderSimpleUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::OlderSimpleUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::Invalid; }

  bool test_union::wire::OlderSimpleUnion::is_i() const { return ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kI; }
    ::test_union::wire::OlderSimpleUnion test_union::wire::OlderSimpleUnion::WithI(::fidl::ObjectView<int64_t> val) {
      OlderSimpleUnion result;
      result.ordinal_ = ::test_union::wire::OlderSimpleUnion::Ordinal::kI;
      result.envelope_.As<int64_t>().set_data(std::move(val));
      return result;
    }

  int64_t& test_union::wire::OlderSimpleUnion::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& test_union::wire::OlderSimpleUnion::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool test_union::wire::OlderSimpleUnion::is_f() const { return ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kF; }
    ::test_union::wire::OlderSimpleUnion test_union::wire::OlderSimpleUnion::WithF(float val) {
      OlderSimpleUnion result;
      result.ordinal_ = ::test_union::wire::OlderSimpleUnion::Ordinal::kF;
      result.envelope_.As<float>().set_data(std::move(val));
      return result;
    }

  float& test_union::wire::OlderSimpleUnion::f() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& test_union::wire::OlderSimpleUnion::f() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::OlderSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::OlderSimpleUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::OlderSimpleUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::OlderSimpleUnion::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::OlderSimpleUnion::Tag::kF
      encode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::OlderSimpleUnion::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::OlderSimpleUnion::Tag::kF
      encode_fn = ::fidl::internal::MakeEncodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::OlderSimpleUnion::Tag tag = *position.As<::test_union::wire::OlderSimpleUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::OlderSimpleUnion::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::OlderSimpleUnion::Tag::kF:
      decode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::OlderSimpleUnion::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::OlderSimpleUnion::Tag::kF:
      decode_fn = ::fidl::internal::MakeDecodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::OlderSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::NewerSimpleUnion::NewerSimpleUnion() : ordinal_(::test_union::wire::NewerSimpleUnion::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::NewerSimpleUnion::Which() const -> ::test_union::wire::NewerSimpleUnion::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::NewerSimpleUnion::Ordinal::kI:
  case ::test_union::wire::NewerSimpleUnion::Ordinal::kS:
  case ::test_union::wire::NewerSimpleUnion::Ordinal::kV:
    return static_cast<::test_union::wire::NewerSimpleUnion::Tag>(ordinal_);
  default:
    return ::test_union::wire::NewerSimpleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::NewerSimpleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(NewerSimpleUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(NewerSimpleUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(NewerSimpleUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::NewerSimpleUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::Invalid; }

  bool test_union::wire::NewerSimpleUnion::is_i() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kI; }
    ::test_union::wire::NewerSimpleUnion test_union::wire::NewerSimpleUnion::WithI(::fidl::ObjectView<int64_t> val) {
      NewerSimpleUnion result;
      result.ordinal_ = ::test_union::wire::NewerSimpleUnion::Ordinal::kI;
      result.envelope_.As<int64_t>().set_data(std::move(val));
      return result;
    }

  int64_t& test_union::wire::NewerSimpleUnion::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& test_union::wire::NewerSimpleUnion::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool test_union::wire::NewerSimpleUnion::is_s() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kS; }
    ::test_union::wire::NewerSimpleUnion test_union::wire::NewerSimpleUnion::WithS(::fidl::ObjectView<::fidl::StringView> val) {
      NewerSimpleUnion result;
      result.ordinal_ = ::test_union::wire::NewerSimpleUnion::Ordinal::kS;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::NewerSimpleUnion::s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::NewerSimpleUnion::s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool test_union::wire::NewerSimpleUnion::is_v() const { return ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kV; }
    ::test_union::wire::NewerSimpleUnion test_union::wire::NewerSimpleUnion::WithV(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
      NewerSimpleUnion result;
      result.ordinal_ = ::test_union::wire::NewerSimpleUnion::Ordinal::kV;
      result.envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(std::move(val));
      return result;
    }

  ::fidl::VectorView<::fidl::StringView>& test_union::wire::NewerSimpleUnion::v() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& test_union::wire::NewerSimpleUnion::v() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::NewerSimpleUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::NewerSimpleUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::NewerSimpleUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::NewerSimpleUnion::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::NewerSimpleUnion::Tag::kS
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_union::wire::NewerSimpleUnion::Tag::kV
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::NewerSimpleUnion::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::NewerSimpleUnion::Tag::kS
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case 3: // ::test_union::wire::NewerSimpleUnion::Tag::kV
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::NewerSimpleUnion::Tag tag = *position.As<::test_union::wire::NewerSimpleUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::NewerSimpleUnion::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::NewerSimpleUnion::Tag::kS:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::NewerSimpleUnion::Tag::kV:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::NewerSimpleUnion::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::NewerSimpleUnion::Tag::kS:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    case ::test_union::wire::NewerSimpleUnion::Tag::kV:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::NewerSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::StrictSimpleUnion::StrictSimpleUnion() : ordinal_(::test_union::wire::StrictSimpleUnion::Ordinal::Invalid), envelope_{} {}
::test_union::wire::StrictSimpleUnion::Tag test_union::wire::StrictSimpleUnion::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::StrictSimpleUnion::Tag>(ordinal_);
}

void ::test_union::wire::StrictSimpleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(StrictSimpleUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(StrictSimpleUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(StrictSimpleUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::StrictSimpleUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::Invalid; }

  bool test_union::wire::StrictSimpleUnion::is_i() const { return ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kI; }
    ::test_union::wire::StrictSimpleUnion test_union::wire::StrictSimpleUnion::WithI(int32_t val) {
      StrictSimpleUnion result;
      result.ordinal_ = ::test_union::wire::StrictSimpleUnion::Ordinal::kI;
      result.envelope_.As<int32_t>().set_data(std::move(val));
      return result;
    }

  int32_t& test_union::wire::StrictSimpleUnion::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& test_union::wire::StrictSimpleUnion::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }

  bool test_union::wire::StrictSimpleUnion::is_f() const { return ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kF; }
    ::test_union::wire::StrictSimpleUnion test_union::wire::StrictSimpleUnion::WithF(float val) {
      StrictSimpleUnion result;
      result.ordinal_ = ::test_union::wire::StrictSimpleUnion::Ordinal::kF;
      result.envelope_.As<float>().set_data(std::move(val));
      return result;
    }

  float& test_union::wire::StrictSimpleUnion::f() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& test_union::wire::StrictSimpleUnion::f() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }

  bool test_union::wire::StrictSimpleUnion::is_s() const { return ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kS; }
    ::test_union::wire::StrictSimpleUnion test_union::wire::StrictSimpleUnion::WithS(::fidl::ObjectView<::fidl::StringView> val) {
      StrictSimpleUnion result;
      result.ordinal_ = ::test_union::wire::StrictSimpleUnion::Ordinal::kS;
      result.envelope_.As<::fidl::StringView>().set_data(std::move(val));
      return result;
    }

  ::fidl::StringView& test_union::wire::StrictSimpleUnion::s() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& test_union::wire::StrictSimpleUnion::s() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::StrictSimpleUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::StrictSimpleUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictSimpleUnion::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2: // ::test_union::wire::StrictSimpleUnion::Tag::kF
      encode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 3: // ::test_union::wire::StrictSimpleUnion::Tag::kS
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictSimpleUnion::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2: // ::test_union::wire::StrictSimpleUnion::Tag::kF
      encode_fn = ::fidl::internal::MakeEncodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 3: // ::test_union::wire::StrictSimpleUnion::Tag::kS
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::StrictSimpleUnion::Tag tag = *position.As<::test_union::wire::StrictSimpleUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::StrictSimpleUnion::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::StrictSimpleUnion::Tag::kF:
      decode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::StrictSimpleUnion::Tag::kS:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::StrictSimpleUnion::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::StrictSimpleUnion::Tag::kF:
      decode_fn = ::fidl::internal::MakeDecodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::StrictSimpleUnion::Tag::kS:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictSimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::UnionContainingEmptyStruct::UnionContainingEmptyStruct() : ordinal_(::test_union::wire::UnionContainingEmptyStruct::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::UnionContainingEmptyStruct::Which() const -> ::test_union::wire::UnionContainingEmptyStruct::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::UnionContainingEmptyStruct::Ordinal::kEmpty:
    return static_cast<::test_union::wire::UnionContainingEmptyStruct::Tag>(ordinal_);
  default:
    return ::test_union::wire::UnionContainingEmptyStruct::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::UnionContainingEmptyStruct::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionContainingEmptyStruct) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionContainingEmptyStruct, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionContainingEmptyStruct, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::UnionContainingEmptyStruct::has_invalid_tag() const { return ordinal_ == ::test_union::wire::UnionContainingEmptyStruct::Ordinal::Invalid; }

  bool test_union::wire::UnionContainingEmptyStruct::is_empty() const { return ordinal_ == ::test_union::wire::UnionContainingEmptyStruct::Ordinal::kEmpty; }
    ::test_union::wire::UnionContainingEmptyStruct test_union::wire::UnionContainingEmptyStruct::WithEmpty(::test_union::wire::Empty val) {
      UnionContainingEmptyStruct result;
      result.ordinal_ = ::test_union::wire::UnionContainingEmptyStruct::Ordinal::kEmpty;
      result.envelope_.As<::test_union::wire::Empty>().set_data(std::move(val));
      return result;
    }

  ::test_union::wire::Empty& test_union::wire::UnionContainingEmptyStruct::empty() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::UnionContainingEmptyStruct::Ordinal::kEmpty);
    return envelope_.As<::test_union::wire::Empty>().get_data();
  }
  const ::test_union::wire::Empty& test_union::wire::UnionContainingEmptyStruct::empty() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::UnionContainingEmptyStruct::Ordinal::kEmpty);
    return envelope_.As<::test_union::wire::Empty>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::UnionContainingEmptyStruct>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::UnionContainingEmptyStruct* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::UnionContainingEmptyStruct::Tag::kEmpty
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::UnionContainingEmptyStruct::Tag::kEmpty
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::UnionContainingEmptyStruct::Tag tag = *position.As<::test_union::wire::UnionContainingEmptyStruct::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::UnionContainingEmptyStruct::Tag::kEmpty:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::UnionContainingEmptyStruct::Tag::kEmpty:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_union::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionContainingEmptyStruct, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::StrictBoundedUnion::StrictBoundedUnion() : ordinal_(::test_union::wire::StrictBoundedUnion::Ordinal::Invalid), envelope_{} {}
::test_union::wire::StrictBoundedUnion::Tag test_union::wire::StrictBoundedUnion::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_union::wire::StrictBoundedUnion::Tag>(ordinal_);
}

void ::test_union::wire::StrictBoundedUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(StrictBoundedUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(StrictBoundedUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(StrictBoundedUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::StrictBoundedUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::StrictBoundedUnion::Ordinal::Invalid; }

  bool test_union::wire::StrictBoundedUnion::is_v() const { return ordinal_ == ::test_union::wire::StrictBoundedUnion::Ordinal::kV; }
    ::test_union::wire::StrictBoundedUnion test_union::wire::StrictBoundedUnion::WithV(::fidl::ObjectView<::fidl::VectorView<uint8_t>> val) {
      StrictBoundedUnion result;
      result.ordinal_ = ::test_union::wire::StrictBoundedUnion::Ordinal::kV;
      result.envelope_.As<::fidl::VectorView<uint8_t>>().set_data(std::move(val));
      return result;
    }

  ::fidl::VectorView<uint8_t>& test_union::wire::StrictBoundedUnion::v() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictBoundedUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<uint8_t>>().get_data();
  }
  const ::fidl::VectorView<uint8_t>& test_union::wire::StrictBoundedUnion::v() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::StrictBoundedUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<uint8_t>>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::StrictBoundedUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::StrictBoundedUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictBoundedUnion::Tag::kV
      encode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::StrictBoundedUnion::Tag::kV
      encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::StrictBoundedUnion::Tag tag = *position.As<::test_union::wire::StrictBoundedUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::StrictBoundedUnion::Tag::kV:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::StrictBoundedUnion::Tag::kV:
      decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false, 10>, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::StrictBoundedUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::ExplicitFlexibleUnion::ExplicitFlexibleUnion() : ordinal_(::test_union::wire::ExplicitFlexibleUnion::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::ExplicitFlexibleUnion::Which() const -> ::test_union::wire::ExplicitFlexibleUnion::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kI:
  case ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kF:
    return static_cast<::test_union::wire::ExplicitFlexibleUnion::Tag>(ordinal_);
  default:
    return ::test_union::wire::ExplicitFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::ExplicitFlexibleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(ExplicitFlexibleUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(ExplicitFlexibleUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(ExplicitFlexibleUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::ExplicitFlexibleUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::ExplicitFlexibleUnion::Ordinal::Invalid; }

  bool test_union::wire::ExplicitFlexibleUnion::is_i() const { return ordinal_ == ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kI; }
    ::test_union::wire::ExplicitFlexibleUnion test_union::wire::ExplicitFlexibleUnion::WithI(::fidl::ObjectView<int64_t> val) {
      ExplicitFlexibleUnion result;
      result.ordinal_ = ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kI;
      result.envelope_.As<int64_t>().set_data(std::move(val));
      return result;
    }

  int64_t& test_union::wire::ExplicitFlexibleUnion::i() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& test_union::wire::ExplicitFlexibleUnion::i() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool test_union::wire::ExplicitFlexibleUnion::is_f() const { return ordinal_ == ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kF; }
    ::test_union::wire::ExplicitFlexibleUnion test_union::wire::ExplicitFlexibleUnion::WithF(float val) {
      ExplicitFlexibleUnion result;
      result.ordinal_ = ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kF;
      result.envelope_.As<float>().set_data(std::move(val));
      return result;
    }

  float& test_union::wire::ExplicitFlexibleUnion::f() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& test_union::wire::ExplicitFlexibleUnion::f() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::ExplicitFlexibleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::ExplicitFlexibleUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::ExplicitFlexibleUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitFlexibleUnion::Tag::kI
      encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 4: // ::test_union::wire::ExplicitFlexibleUnion::Tag::kF
      encode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::ExplicitFlexibleUnion::Tag::kI
      encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 4: // ::test_union::wire::ExplicitFlexibleUnion::Tag::kF
      encode_fn = ::fidl::internal::MakeEncodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::ExplicitFlexibleUnion::Tag tag = *position.As<::test_union::wire::ExplicitFlexibleUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::ExplicitFlexibleUnion::Tag::kI:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_union::wire::ExplicitFlexibleUnion::Tag::kF:
      decode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::ExplicitFlexibleUnion::Tag::kI:
      decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_union::wire::ExplicitFlexibleUnion::Tag::kF:
      decode_fn = ::fidl::internal::MakeDecodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::ExplicitFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::UnionWithAttributes::UnionWithAttributes() : ordinal_(::test_union::wire::UnionWithAttributes::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::UnionWithAttributes::Which() const -> ::test_union::wire::UnionWithAttributes::Tag {
  ZX_ASSERT(!has_invalid_tag());
  switch (ordinal_) {
  case ::test_union::wire::UnionWithAttributes::Ordinal::kX:
    return static_cast<::test_union::wire::UnionWithAttributes::Tag>(ordinal_);
  default:
    return ::test_union::wire::UnionWithAttributes::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

void ::test_union::wire::UnionWithAttributes::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(UnionWithAttributes) == sizeof(fidl_union_t));
  static_assert(offsetof(UnionWithAttributes, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(UnionWithAttributes, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::UnionWithAttributes::has_invalid_tag() const { return ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::Invalid; }

  bool test_union::wire::UnionWithAttributes::is_x() const { return ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::kX; }
    ::test_union::wire::UnionWithAttributes test_union::wire::UnionWithAttributes::WithX(::fidl::ObjectView<int64_t> val) {
      UnionWithAttributes result;
      result.ordinal_ = ::test_union::wire::UnionWithAttributes::Ordinal::kX;
      result.envelope_.As<int64_t>().set_data(std::move(val));
      return result;
    }

  int64_t& test_union::wire::UnionWithAttributes::x() {
    ZX_ASSERT(ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::kX);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& test_union::wire::UnionWithAttributes::x() const {
    ZX_ASSERT(ordinal_ == ::test_union::wire::UnionWithAttributes::Ordinal::kX);
    return envelope_.As<int64_t>().get_data();
  }

static_assert(std::is_standard_layout_v<::test_union::wire::UnionWithAttributes>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::UnionWithAttributes* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1: // ::test_union::wire::UnionWithAttributes::Tag::kX
      encode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1: // ::test_union::wire::UnionWithAttributes::Tag::kX
      encode_fn = ::fidl::internal::MakeEncodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::UnionWithAttributes::Tag tag = *position.As<::test_union::wire::UnionWithAttributes::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_union::wire::UnionWithAttributes::Tag::kX:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    case ::test_union::wire::UnionWithAttributes::Tag::kX:
      decode_fn = ::fidl::internal::MakeDecodeFn<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::UnionWithAttributes, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_union::wire::EmptyFlexibleUnion::EmptyFlexibleUnion() : ordinal_(::test_union::wire::EmptyFlexibleUnion::Ordinal::Invalid), envelope_{} {}
auto ::test_union::wire::EmptyFlexibleUnion::Which() const -> ::test_union::wire::EmptyFlexibleUnion::Tag {
  ZX_ASSERT(!has_invalid_tag());
  return ::test_union::wire::EmptyFlexibleUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
}

void ::test_union::wire::EmptyFlexibleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(EmptyFlexibleUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(EmptyFlexibleUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(EmptyFlexibleUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_union::wire::EmptyFlexibleUnion::has_invalid_tag() const { return ordinal_ == ::test_union::wire::EmptyFlexibleUnion::Ordinal::Invalid; }

static_assert(std::is_standard_layout_v<::test_union::wire::EmptyFlexibleUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_union::wire::EmptyFlexibleUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);

}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {

  ::test_union::wire::EmptyFlexibleUnion::Tag tag = *position.As<::test_union::wire::EmptyFlexibleUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch(tag) {
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeFlexibleEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_union::wire::EmptyFlexibleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

  #pragma clang diagnostic pop

