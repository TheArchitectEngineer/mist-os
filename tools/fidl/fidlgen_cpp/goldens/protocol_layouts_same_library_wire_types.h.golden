// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <lib/fidl/cpp/wire/array.h>
#include <lib/fidl/cpp/wire/envelope.h>
#include <lib/fidl/cpp/wire/internal/framework_err.h>
#include <lib/fidl/cpp/wire/message.h>
#include <lib/fidl/cpp/wire/message_storage.h>
#include <lib/fidl/cpp/wire/object_view.h>
#include <lib/fidl/cpp/wire/string_view.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/fidl/cpp/wire/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.protocollayoutssamelibrary/cpp/common_types.h>
#include <fidl/test.protocollayoutssamelibrary/cpp/markers.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_protocollayoutssamelibrary {

namespace wire {

class TablePayload;

class ComposedProtocolOneWayAnonComposedRequest;

class ComposedProtocolTwoWayAnonComposedResponse;

class ComposedProtocolTwoWayAnonComposedWithErrorRequest;

class MainProtocolOneWayAnonRequest;

class MainProtocolTwoWayAnonResponse;

class MainProtocolTwoWayAnonWithErrorRequest;

class UnionPayload;

class ComposedProtocolTwoWayAnonComposedRequest;

class ComposedProtocolTwoWayAnonComposedWithErrorResponse;

class ComposedProtocolTwoWayAnonComposedWithErrorResult;

class ComposedProtocolOnAnonComposedRequest;

class ComposedProtocolTwoWayNamedComposedWithErrorResult;

class MainProtocolTwoWayLocalWithErrorResult;

class MainProtocolTwoWayAnonRequest;

class MainProtocolTwoWayAnonWithErrorResponse;

class MainProtocolTwoWayAnonWithErrorResult;

class MainProtocolOnAnonRequest;

}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayoutssamelibrary::wire::TablePayload;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;
};

namespace test_protocollayoutssamelibrary {
namespace wire {

class TablePayload {
 public:
  TablePayload() = default;
  TablePayload(const TablePayload& other) noexcept = default;
  TablePayload& operator=(const TablePayload& other) noexcept = default;
  TablePayload(TablePayload&& other) noexcept = default;
  TablePayload& operator=(TablePayload&& other) noexcept = default;

  ~TablePayload() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  TablePayload& set_a(uint16_t elem);

  TablePayload& clear_a();

  explicit TablePayload(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit TablePayload(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayoutssamelibrary::wire::TablePayload Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>>&& frame);

 private:
  ::test_protocollayoutssamelibrary::wire::TablePayload table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;

 public:
 private:
  friend class ::test_protocollayoutssamelibrary::wire::TablePayload;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::TablePayload>>;

 private:
  friend class ::test_protocollayoutssamelibrary::wire::TablePayload;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::TablePayload>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;
};

namespace test_protocollayoutssamelibrary {
namespace wire {

class ComposedProtocolOneWayAnonComposedRequest {
 public:
  ComposedProtocolOneWayAnonComposedRequest() = default;
  ComposedProtocolOneWayAnonComposedRequest(const ComposedProtocolOneWayAnonComposedRequest& other) noexcept = default;
  ComposedProtocolOneWayAnonComposedRequest& operator=(const ComposedProtocolOneWayAnonComposedRequest& other) noexcept = default;
  ComposedProtocolOneWayAnonComposedRequest(ComposedProtocolOneWayAnonComposedRequest&& other) noexcept = default;
  ComposedProtocolOneWayAnonComposedRequest& operator=(ComposedProtocolOneWayAnonComposedRequest&& other) noexcept = default;

  ~ComposedProtocolOneWayAnonComposedRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  ComposedProtocolOneWayAnonComposedRequest& set_a(uint16_t elem);

  ComposedProtocolOneWayAnonComposedRequest& clear_a();

  explicit ComposedProtocolOneWayAnonComposedRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit ComposedProtocolOneWayAnonComposedRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>&& frame);

 private:
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;

 public:
 private:
  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>>;

 private:
  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;
};

namespace test_protocollayoutssamelibrary {
namespace wire {

class ComposedProtocolTwoWayAnonComposedResponse {
 public:
  ComposedProtocolTwoWayAnonComposedResponse() = default;
  ComposedProtocolTwoWayAnonComposedResponse(const ComposedProtocolTwoWayAnonComposedResponse& other) noexcept = default;
  ComposedProtocolTwoWayAnonComposedResponse& operator=(const ComposedProtocolTwoWayAnonComposedResponse& other) noexcept = default;
  ComposedProtocolTwoWayAnonComposedResponse(ComposedProtocolTwoWayAnonComposedResponse&& other) noexcept = default;
  ComposedProtocolTwoWayAnonComposedResponse& operator=(ComposedProtocolTwoWayAnonComposedResponse&& other) noexcept = default;

  ~ComposedProtocolTwoWayAnonComposedResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  ComposedProtocolTwoWayAnonComposedResponse& set_a(uint16_t elem);

  ComposedProtocolTwoWayAnonComposedResponse& clear_a();

  explicit ComposedProtocolTwoWayAnonComposedResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit ComposedProtocolTwoWayAnonComposedResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>&& frame);

 private:
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;

 public:
 private:
  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>>;

 private:
  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;
};

namespace test_protocollayoutssamelibrary {
namespace wire {

class ComposedProtocolTwoWayAnonComposedWithErrorRequest {
 public:
  ComposedProtocolTwoWayAnonComposedWithErrorRequest() = default;
  ComposedProtocolTwoWayAnonComposedWithErrorRequest(const ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) noexcept = default;
  ComposedProtocolTwoWayAnonComposedWithErrorRequest& operator=(const ComposedProtocolTwoWayAnonComposedWithErrorRequest& other) noexcept = default;
  ComposedProtocolTwoWayAnonComposedWithErrorRequest(ComposedProtocolTwoWayAnonComposedWithErrorRequest&& other) noexcept = default;
  ComposedProtocolTwoWayAnonComposedWithErrorRequest& operator=(ComposedProtocolTwoWayAnonComposedWithErrorRequest&& other) noexcept = default;

  ~ComposedProtocolTwoWayAnonComposedWithErrorRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  ComposedProtocolTwoWayAnonComposedWithErrorRequest& set_a(uint16_t elem);

  ComposedProtocolTwoWayAnonComposedWithErrorRequest& clear_a();

  explicit ComposedProtocolTwoWayAnonComposedWithErrorRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit ComposedProtocolTwoWayAnonComposedWithErrorRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>&& frame);

 private:
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;

 public:
 private:
  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>>;

 private:
  friend class ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;
};

namespace test_protocollayoutssamelibrary {
namespace wire {

class MainProtocolOneWayAnonRequest {
 public:
  MainProtocolOneWayAnonRequest() = default;
  MainProtocolOneWayAnonRequest(const MainProtocolOneWayAnonRequest& other) noexcept = default;
  MainProtocolOneWayAnonRequest& operator=(const MainProtocolOneWayAnonRequest& other) noexcept = default;
  MainProtocolOneWayAnonRequest(MainProtocolOneWayAnonRequest&& other) noexcept = default;
  MainProtocolOneWayAnonRequest& operator=(MainProtocolOneWayAnonRequest&& other) noexcept = default;

  ~MainProtocolOneWayAnonRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  MainProtocolOneWayAnonRequest& set_a(uint16_t elem);

  MainProtocolOneWayAnonRequest& clear_a();

  explicit MainProtocolOneWayAnonRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit MainProtocolOneWayAnonRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>&& frame);

 private:
  ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;

 public:
 private:
  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>>;

 private:
  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;
};

namespace test_protocollayoutssamelibrary {
namespace wire {

class MainProtocolTwoWayAnonResponse {
 public:
  MainProtocolTwoWayAnonResponse() = default;
  MainProtocolTwoWayAnonResponse(const MainProtocolTwoWayAnonResponse& other) noexcept = default;
  MainProtocolTwoWayAnonResponse& operator=(const MainProtocolTwoWayAnonResponse& other) noexcept = default;
  MainProtocolTwoWayAnonResponse(MainProtocolTwoWayAnonResponse&& other) noexcept = default;
  MainProtocolTwoWayAnonResponse& operator=(MainProtocolTwoWayAnonResponse&& other) noexcept = default;

  ~MainProtocolTwoWayAnonResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  MainProtocolTwoWayAnonResponse& set_a(uint16_t elem);

  MainProtocolTwoWayAnonResponse& clear_a();

  explicit MainProtocolTwoWayAnonResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit MainProtocolTwoWayAnonResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>&& frame);

 private:
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;

 public:
 private:
  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>>;

 private:
  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;
};

namespace test_protocollayoutssamelibrary {
namespace wire {

class MainProtocolTwoWayAnonWithErrorRequest {
 public:
  MainProtocolTwoWayAnonWithErrorRequest() = default;
  MainProtocolTwoWayAnonWithErrorRequest(const MainProtocolTwoWayAnonWithErrorRequest& other) noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest& operator=(const MainProtocolTwoWayAnonWithErrorRequest& other) noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest(MainProtocolTwoWayAnonWithErrorRequest&& other) noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest& operator=(MainProtocolTwoWayAnonWithErrorRequest&& other) noexcept = default;

  ~MainProtocolTwoWayAnonWithErrorRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  MainProtocolTwoWayAnonWithErrorRequest& set_a(uint16_t elem);

  MainProtocolTwoWayAnonWithErrorRequest& clear_a();

  explicit MainProtocolTwoWayAnonWithErrorRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit MainProtocolTwoWayAnonWithErrorRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayoutssamelibrary

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame);

 private:
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;

 public:
 private:
  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>>;

 private:
  friend class ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest>* frame);
};
namespace test_protocollayoutssamelibrary {
namespace wire {

class UnionPayload {
 public:
  UnionPayload();

  UnionPayload(const UnionPayload&) = default;
  UnionPayload& operator=(const UnionPayload&) = default;
  UnionPayload(UnionPayload&&) = default;
  UnionPayload& operator=(UnionPayload&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  bool has_invalid_tag() const;

  bool is_b() const;

  static UnionPayload WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayoutssamelibrary::wire::UnionPayload::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::UnionPayload::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ComposedProtocolTwoWayAnonComposedRequest {
 public:
  ComposedProtocolTwoWayAnonComposedRequest();

  ComposedProtocolTwoWayAnonComposedRequest(const ComposedProtocolTwoWayAnonComposedRequest&) = default;
  ComposedProtocolTwoWayAnonComposedRequest& operator=(const ComposedProtocolTwoWayAnonComposedRequest&) = default;
  ComposedProtocolTwoWayAnonComposedRequest(ComposedProtocolTwoWayAnonComposedRequest&&) = default;
  ComposedProtocolTwoWayAnonComposedRequest& operator=(ComposedProtocolTwoWayAnonComposedRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  bool has_invalid_tag() const;

  bool is_b() const;

  static ComposedProtocolTwoWayAnonComposedRequest WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ComposedProtocolTwoWayAnonComposedWithErrorResponse {
 public:
  ComposedProtocolTwoWayAnonComposedWithErrorResponse();

  ComposedProtocolTwoWayAnonComposedWithErrorResponse(const ComposedProtocolTwoWayAnonComposedWithErrorResponse&) = default;
  ComposedProtocolTwoWayAnonComposedWithErrorResponse& operator=(const ComposedProtocolTwoWayAnonComposedWithErrorResponse&) = default;
  ComposedProtocolTwoWayAnonComposedWithErrorResponse(ComposedProtocolTwoWayAnonComposedWithErrorResponse&&) = default;
  ComposedProtocolTwoWayAnonComposedWithErrorResponse& operator=(ComposedProtocolTwoWayAnonComposedWithErrorResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  bool has_invalid_tag() const;

  bool is_b() const;

  static ComposedProtocolTwoWayAnonComposedWithErrorResponse WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ComposedProtocolTwoWayAnonComposedWithErrorResult {
 public:
  using Response = test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse;

  ComposedProtocolTwoWayAnonComposedWithErrorResult();

  ComposedProtocolTwoWayAnonComposedWithErrorResult(const ComposedProtocolTwoWayAnonComposedWithErrorResult&) = default;
  ComposedProtocolTwoWayAnonComposedWithErrorResult& operator=(const ComposedProtocolTwoWayAnonComposedWithErrorResult&) = default;
  ComposedProtocolTwoWayAnonComposedWithErrorResult(ComposedProtocolTwoWayAnonComposedWithErrorResult&&) = default;
  ComposedProtocolTwoWayAnonComposedWithErrorResult& operator=(ComposedProtocolTwoWayAnonComposedWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ComposedProtocolTwoWayAnonComposedWithErrorResult WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse> val);

  template <typename... Args>
  static ComposedProtocolTwoWayAnonComposedWithErrorResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse>(allocator,
                                                                                                                                         std::forward<Args>(args)...));
  }

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse& response();

  const ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse& response() const;

  bool is_err() const;

  static ComposedProtocolTwoWayAnonComposedWithErrorResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ComposedProtocolOnAnonComposedRequest {
 public:
  ComposedProtocolOnAnonComposedRequest();

  ComposedProtocolOnAnonComposedRequest(const ComposedProtocolOnAnonComposedRequest&) = default;
  ComposedProtocolOnAnonComposedRequest& operator=(const ComposedProtocolOnAnonComposedRequest&) = default;
  ComposedProtocolOnAnonComposedRequest(ComposedProtocolOnAnonComposedRequest&&) = default;
  ComposedProtocolOnAnonComposedRequest& operator=(ComposedProtocolOnAnonComposedRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
  };

  bool has_invalid_tag() const;

  bool is_b() const;

  static ComposedProtocolOnAnonComposedRequest WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ComposedProtocolTwoWayNamedComposedWithErrorResult {
 public:
  ComposedProtocolTwoWayNamedComposedWithErrorResult();

  ComposedProtocolTwoWayNamedComposedWithErrorResult(const ComposedProtocolTwoWayNamedComposedWithErrorResult&) = default;
  ComposedProtocolTwoWayNamedComposedWithErrorResult& operator=(const ComposedProtocolTwoWayNamedComposedWithErrorResult&) = default;
  ComposedProtocolTwoWayNamedComposedWithErrorResult(ComposedProtocolTwoWayNamedComposedWithErrorResult&&) = default;
  ComposedProtocolTwoWayNamedComposedWithErrorResult& operator=(ComposedProtocolTwoWayNamedComposedWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ComposedProtocolTwoWayNamedComposedWithErrorResult WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::UnionPayload> val);

  template <typename... Args>
  static ComposedProtocolTwoWayNamedComposedWithErrorResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::UnionPayload>(allocator,
                                                                                                  std::forward<Args>(args)...));
  }

  ::test_protocollayoutssamelibrary::wire::UnionPayload& response();

  const ::test_protocollayoutssamelibrary::wire::UnionPayload& response() const;

  bool is_err() const;

  static ComposedProtocolTwoWayNamedComposedWithErrorResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayLocalWithErrorResult {
 public:
  MainProtocolTwoWayLocalWithErrorResult();

  MainProtocolTwoWayLocalWithErrorResult(const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult(MainProtocolTwoWayLocalWithErrorResult&&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(MainProtocolTwoWayLocalWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static MainProtocolTwoWayLocalWithErrorResult WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::UnionPayload> val);

  template <typename... Args>
  static MainProtocolTwoWayLocalWithErrorResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::UnionPayload>(allocator,
                                                                                                  std::forward<Args>(args)...));
  }

  ::test_protocollayoutssamelibrary::wire::UnionPayload& response();

  const ::test_protocollayoutssamelibrary::wire::UnionPayload& response() const;

  bool is_err() const;

  static MainProtocolTwoWayLocalWithErrorResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayAnonRequest {
 public:
  MainProtocolTwoWayAnonRequest();

  MainProtocolTwoWayAnonRequest(const MainProtocolTwoWayAnonRequest&) = default;
  MainProtocolTwoWayAnonRequest& operator=(const MainProtocolTwoWayAnonRequest&) = default;
  MainProtocolTwoWayAnonRequest(MainProtocolTwoWayAnonRequest&&) = default;
  MainProtocolTwoWayAnonRequest& operator=(MainProtocolTwoWayAnonRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static MainProtocolTwoWayAnonRequest WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayAnonWithErrorResponse {
 public:
  MainProtocolTwoWayAnonWithErrorResponse();

  MainProtocolTwoWayAnonWithErrorResponse(const MainProtocolTwoWayAnonWithErrorResponse&) = default;
  MainProtocolTwoWayAnonWithErrorResponse& operator=(const MainProtocolTwoWayAnonWithErrorResponse&) = default;
  MainProtocolTwoWayAnonWithErrorResponse(MainProtocolTwoWayAnonWithErrorResponse&&) = default;
  MainProtocolTwoWayAnonWithErrorResponse& operator=(MainProtocolTwoWayAnonWithErrorResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static MainProtocolTwoWayAnonWithErrorResponse WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayAnonWithErrorResult {
 public:
  using Response = test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse;

  MainProtocolTwoWayAnonWithErrorResult();

  MainProtocolTwoWayAnonWithErrorResult(const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult(MainProtocolTwoWayAnonWithErrorResult&&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(MainProtocolTwoWayAnonWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static MainProtocolTwoWayAnonWithErrorResult WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse> val);

  template <typename... Args>
  static MainProtocolTwoWayAnonWithErrorResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse>(allocator,
                                                                                                                             std::forward<Args>(args)...));
  }

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse& response();

  const ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse& response() const;

  bool is_err() const;

  static MainProtocolTwoWayAnonWithErrorResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolOnAnonRequest {
 public:
  MainProtocolOnAnonRequest();

  MainProtocolOnAnonRequest(const MainProtocolOnAnonRequest&) = default;
  MainProtocolOnAnonRequest& operator=(const MainProtocolOnAnonRequest&) = default;
  MainProtocolOnAnonRequest(MainProtocolOnAnonRequest&&) = default;
  MainProtocolOnAnonRequest& operator=(MainProtocolOnAnonRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static MainProtocolOnAnonRequest WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

}  // namespace wire
}  // namespace test_protocollayoutssamelibrary
namespace fidl {

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::TablePayload> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::TablePayload> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::TablePayload> : public std::true_type {};
template <>
struct IsTable<::test_protocollayoutssamelibrary::wire::TablePayload> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::TablePayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::TablePayload* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> : public std::true_type {};
template <>
struct IsTable<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolOneWayAnonComposedRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> : public std::true_type {};
template <>
struct IsTable<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> : public std::true_type {};
template <>
struct IsTable<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> : public std::true_type {};
template <>
struct IsTable<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolOneWayAnonRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> : public std::true_type {};
template <>
struct IsTable<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};
template <>
struct IsTable<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::UnionPayload> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::UnionPayload> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::UnionPayload> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::UnionPayload> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::UnionPayload* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::UnionPayload, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayAnonComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolOnAnonComposedRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::ComposedProtocolTwoWayNamedComposedWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayoutssamelibrary::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#pragma clang diagnostic pop

}  // namespace fidl
