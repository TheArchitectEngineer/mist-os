// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.emptystruct/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_emptystruct::wire::Empty* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_emptystruct::wire::Empty));
  } else {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
  if (*position.As<uint8_t>() != 0) {
    decoder->SetError(kCodingErrorInvalidPaddingBytes);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::Empty, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_emptystruct::wire::Empty>);
static_assert(offsetof(::test_emptystruct::wire::Empty, __reserved) == 0);
static_assert(sizeof(::test_emptystruct::wire::Empty) == ::fidl::TypeTraits<::test_emptystruct::wire::Empty>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_emptystruct::wire::EmptyProtocolSendRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_emptystruct::wire::EmptyProtocolSendRequest));
  } else {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->e, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_emptystruct::wire::EmptyProtocolSendRequest>);
static_assert(offsetof(::test_emptystruct::wire::EmptyProtocolSendRequest, e) == 0);
static_assert(sizeof(::test_emptystruct::wire::EmptyProtocolSendRequest) == ::fidl::TypeTraits<::test_emptystruct::wire::EmptyProtocolSendRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_emptystruct::wire::EmptyProtocolReceiveRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_emptystruct::wire::EmptyProtocolReceiveRequest));
  } else {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->e, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_emptystruct::wire::EmptyProtocolReceiveRequest>);
static_assert(offsetof(::test_emptystruct::wire::EmptyProtocolReceiveRequest, e) == 0);
static_assert(sizeof(::test_emptystruct::wire::EmptyProtocolReceiveRequest) == ::fidl::TypeTraits<::test_emptystruct::wire::EmptyProtocolReceiveRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest));
  } else {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->e, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest>);
static_assert(offsetof(::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest, e) == 0);
static_assert(sizeof(::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest) == ::fidl::TypeTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse));
  } else {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->e, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::test_emptystruct::wire::Empty, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse>);
static_assert(offsetof(::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse, e) == 0);
static_assert(sizeof(::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse) == ::fidl::TypeTraits<::test_emptystruct::wire::EmptyProtocolSendAndReceiveResponse>::kPrimarySize);

#pragma clang diagnostic pop
