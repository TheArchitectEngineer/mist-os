// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.protocolpayloads/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::LocalStructPayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::LocalStructPayload* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolpayloads::wire::LocalStructPayload));
  } else {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::LocalStructPayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::LocalStructPayload, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::LocalStructPayload, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::LocalStructPayload>);
static_assert(offsetof(::test_protocolpayloads::wire::LocalStructPayload, a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::LocalStructPayload, b) == 4);
static_assert(sizeof(::test_protocolpayloads::wire::LocalStructPayload) == ::fidl::TypeTraits<::test_protocolpayloads::wire::LocalStructPayload>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest));
  } else {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest>);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, b) == 4);
static_assert(sizeof(::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest) == ::fidl::TypeTraits<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest));
  } else {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest>);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, b) == 4);
static_assert(sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest) == ::fidl::TypeTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse));
  } else {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse>);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse, a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse, b) == 4);
static_assert(sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse) == ::fidl::TypeTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest));
  } else {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest>);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest, a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest, b) == 4);
static_assert(sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest) == ::fidl::TypeTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse));
  } else {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, b) == 4);
static_assert(sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse) == ::fidl::TypeTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolOnAnonRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_protocolpayloads::wire::MainProtocolOnAnonRequest));
  } else {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolOnAnonRequest>);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonRequest, a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonRequest, b) == 4);
static_assert(sizeof(::test_protocolpayloads::wire::MainProtocolOnAnonRequest) == ::fidl::TypeTraits<::test_protocolpayloads::wire::MainProtocolOnAnonRequest>::kPrimarySize);

::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::MainProtocolTwoWayLocalWithErrorResult() : ordinal_(::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid), envelope_{} {}
::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag>(ordinal_);
}

void ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolTwoWayLocalWithErrorResult) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolTwoWayLocalWithErrorResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolTwoWayLocalWithErrorResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::has_invalid_tag() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid; }

bool test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::is_response() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse; }
::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload> val) {
  MainProtocolTwoWayLocalWithErrorResult result;
  result.ordinal_ = ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse;
  result.envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>().set_data(std::move(val));
  return result;
}

::test_protocolpayloads::wire::LocalStructPayload& test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::response() {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
  return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>().get_data();
}
const ::test_protocolpayloads::wire::LocalStructPayload& test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
  return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>().get_data();
}

bool test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::is_err() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr; }
::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::WithErr(uint32_t val) {
  MainProtocolTwoWayLocalWithErrorResult result;
  result.ordinal_ = ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::err() {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::LocalStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocolpayloads::wire::LocalStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag tag = *position.As<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::LocalStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocolpayloads::wire::LocalStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::MainProtocolTwoWayAnonWithErrorResult() : ordinal_(::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid), envelope_{} {}
::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag>(ordinal_);
}

void ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolTwoWayAnonWithErrorResult) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolTwoWayAnonWithErrorResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolTwoWayAnonWithErrorResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::has_invalid_tag() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid; }

bool test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::is_response() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse; }
::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithResponse(::fidl::ObjectView<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse> val) {
  MainProtocolTwoWayAnonWithErrorResult result;
  result.ordinal_ = ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse;
  result.envelope_.As<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>().set_data(std::move(val));
  return result;
}

::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse& test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::response() {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
  return envelope_.As<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>().get_data();
}
const ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse& test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
  return envelope_.As<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>().get_data();
}

bool test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::is_err() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr; }
::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::WithErr(uint32_t val) {
  MainProtocolTwoWayAnonWithErrorResult result;
  result.ordinal_ = ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::err() {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag tag = *position.As<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::MainProtocolTwoWayImportWithErrorResult() : ordinal_(::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::Invalid), envelope_{} {}
::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag>(ordinal_);
}

void ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(MainProtocolTwoWayImportWithErrorResult) == sizeof(fidl_union_t));
  static_assert(offsetof(MainProtocolTwoWayImportWithErrorResult, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(MainProtocolTwoWayImportWithErrorResult, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::has_invalid_tag() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::Invalid; }

bool test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::is_response() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse; }
::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithResponse(::test_protocolpayloads_imported::wire::ImportStructPayload val) {
  MainProtocolTwoWayImportWithErrorResult result;
  result.ordinal_ = ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse;
  result.envelope_.As<::test_protocolpayloads_imported::wire::ImportStructPayload>().set_data(std::move(val));
  return result;
}

::test_protocolpayloads_imported::wire::ImportStructPayload& test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::response() {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse);
  return envelope_.As<::test_protocolpayloads_imported::wire::ImportStructPayload>().get_data();
}
const ::test_protocolpayloads_imported::wire::ImportStructPayload& test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::response() const {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse);
  return envelope_.As<::test_protocolpayloads_imported::wire::ImportStructPayload>().get_data();
}

bool test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::is_err() const { return ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr; }
::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::WithErr(uint32_t val) {
  MainProtocolTwoWayImportWithErrorResult result;
  result.ordinal_ = ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr;
  result.envelope_.As<uint32_t>().set_data(std::move(val));
  return result;
}

uint32_t& test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::err() {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}
const uint32_t& test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::err() const {
  ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr);
  return envelope_.As<uint32_t>().get_data();
}

static_assert(std::is_standard_layout_v<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kResponse
      encode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocolpayloads_imported::wire::ImportStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kErr
      encode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kResponse
      encode_fn = ::fidl::internal::MakeEncodeFn<::test_protocolpayloads_imported::wire::ImportStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kErr
      encode_fn = ::fidl::internal::MakeEncodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag tag = *position.As<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kResponse:
      decode_inline_size = ::fidl::internal::WireCodingTraits<::test_protocolpayloads_imported::wire::ImportStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kErr:
      decode_inline_size = ::fidl::internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kResponse:
      decode_fn = ::fidl::internal::MakeDecodeFn<::test_protocolpayloads_imported::wire::ImportStructPayload, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag::kErr:
      decode_fn = ::fidl::internal::MakeDecodeFn<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#pragma clang diagnostic pop
