# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.anonymous"]
add_ir_path(_ir_path)


@dataclass
class OverrideTest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    op: int | None
    left: typing.Optional[Expression] | None
    right: typing.Optional[Expression] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "OverrideTest"
    __fidl_raw_type__ = "test.anonymous/OverrideTest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.anonymous", "test.anonymous/OverrideTest"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "op": None,
                "left": None,
                "right": None,
            }
        )


@dataclass
class SomeProtocolSomeMethodRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    union_member: UnionMember | None
    table_member: TableMember | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "SomeProtocolSomeMethodRequest"
    __fidl_raw_type__ = "test.anonymous/SomeProtocolSomeMethodRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.anonymous",
            "test.anonymous/SomeProtocolSomeMethodRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "union_member": None,
                "table_member": None,
            }
        )


@dataclass
class SomeProtocolSomeMethodResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    bits_member: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "SomeProtocolSomeMethodResponse"
    __fidl_raw_type__ = "test.anonymous/SomeProtocol_SomeMethod_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.anonymous",
            "test.anonymous/SomeProtocol_SomeMethod_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "bits_member": None,
            }
        )


@dataclass
class TableData:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    data: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "TableData"
    __fidl_raw_type__ = "test.anonymous/TableData"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.anonymous", "test.anonymous/TableData"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "data": None,
            }
        )


@dataclass
class FunctionApplication:
    func: str | None
    args: typing.Sequence[typing.Optional[Expression]] | None
    flags: int | None

    def __init__(
        self,
        func: str | None = None,
        args: typing.Sequence[typing.Optional[Expression]] | None = None,
        flags: int | None = None,
    ) -> None:
        self.func = func
        self.args = args
        self.flags = flags

    __fidl_kind__ = "table"
    __fidl_type__ = "FunctionApplication"
    __fidl_raw_type__ = "test.anonymous/FunctionApplication"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.anonymous", "test.anonymous/FunctionApplication"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class TableMember:
    table_data: typing.Sequence[TableData] | None

    def __init__(
        self,
        table_data: typing.Sequence[TableData] | None = None,
    ) -> None:
        self.table_data = table_data

    __fidl_kind__ = "table"
    __fidl_type__ = "TableMember"
    __fidl_raw_type__ = "test.anonymous/TableMember"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.anonymous", "test.anonymous/TableMember"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class Expression:
    _value: typing.Optional[int]
    _bin_op: typing.Optional[OverrideTest]
    _function_application: typing.Optional[FunctionApplication]

    __fidl_kind__ = "union"
    __fidl_type__ = "Expression"
    __fidl_raw_type__ = "test.anonymous/Expression"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.value != other.value:
            return False
        if self.bin_op != other.bin_op:
            return False
        if self.function_application != other.function_application:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.value:
            variant = f"value={self.value!r}"
        if self.bin_op:
            variant = f"bin_op={self.bin_op!r}"
        if self.function_application:
            variant = f"function_application={self.function_application!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        value: typing.Optional[int] = None,
        bin_op: typing.Optional[OverrideTest] = None,
        function_application: typing.Optional[FunctionApplication] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if value is not None:
            self._value = value
            variants.append("value")
            number_of_variants += 1
        if bin_op is not None:
            self._bin_op = bin_op
            variants.append("bin_op")
            number_of_variants += 1
        if function_application is not None:
            self._function_application = function_application
            variants.append("function_application")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def value(self) -> int | None:
        return getattr(self, "_value", None)

    @property
    def bin_op(self) -> OverrideTest | None:
        return getattr(self, "_bin_op", None)

    @property
    def function_application(self) -> FunctionApplication | None:
        return getattr(self, "_function_application", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.anonymous", "test.anonymous/Expression"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class SomeProtocolSomeMethodResult:
    _response: typing.Optional[SomeProtocolSomeMethodResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "SomeProtocolSomeMethodResult"
    __fidl_raw_type__ = "test.anonymous/SomeProtocol_SomeMethod_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[SomeProtocolSomeMethodResponse] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> SomeProtocolSomeMethodResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.anonymous",
            "test.anonymous/SomeProtocol_SomeMethod_Result",
        )

    def unwrap(self) -> SomeProtocolSomeMethodResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionMember:
    _union_data: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionMember"
    __fidl_raw_type__ = "test.anonymous/UnionMember"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.union_data != other.union_data:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.union_data:
            variant = f"union_data={self.union_data!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        union_data: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if union_data is not None:
            self._union_data = union_data
            variants.append("union_data")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def union_data(self) -> int | None:
        return getattr(self, "_union_data", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.anonymous", "test.anonymous/UnionMember"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


Op = enum.IntEnum(
    "Op",
    {
        "__fidl_kind__": "enum",
        "__fidl_type__": "Op",
        "__fidl_raw_type__": "test.anonymous/Op",
        "__strict__": False,
        "ADD": 1,
        "MUL": 2,
        "DIV": 3,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


SomeProtocolSomeMethodError = enum.IntEnum(
    "SomeProtocolSomeMethodError",
    {
        "__fidl_kind__": "enum",
        "__fidl_type__": "SomeProtocolSomeMethodError",
        "__fidl_raw_type__": "test.anonymous/SomeProtocol_SomeMethod_Error",
        "__strict__": False,
        "ERROR_ONE": 1,
        "ERROR_TWO": 2,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


BitsMember = enum.IntFlag(
    "BitsMember",
    {
        "__fidl_kind__": "bits",
        "__fidl_type__": "BitsMember",
        "__fidl_raw_type__": "test.anonymous/BitsMember",
        "__strict__": False,
        "BIT_ONE": 1,
        "BIT_TWO": 2,
        "make_default": classmethod(lambda cls: cls(value=0)),
    },
)


Flags = enum.IntFlag(
    "Flags",
    {
        "__fidl_kind__": "bits",
        "__fidl_type__": "Flags",
        "__fidl_raw_type__": "test.anonymous/Flags",
        "__strict__": False,
        "INLINE": 1,
        "make_default": classmethod(lambda cls: cls(value=0)),
    },
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class SomeProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.anonymous"
    method_map: typing.Dict[int, MethodInfo] = {
        2515914517457749720: MethodInfo(
            name="some_method",
            request_ident="test.anonymous/SomeProtocolSomeMethodRequest",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.anonymous/SomeProtocol_SomeMethod_Result",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_some_method: typing.TypeAlias = typing.Union[
        DomainError,
        SomeProtocolSomeMethodResponse,
    ]

    @abstractmethod
    def some_method(
        self,
        request: SomeProtocolSomeMethodRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_some_method]
        | _MethodResponse_some_method
    ):
        ...


class SomeProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.anonymous"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def some_method(
        self,
        *,
        union_member: UnionMember,
        table_member: TableMember,
    ) -> typing.Coroutine[typing.Any, typing.Any, SomeProtocolSomeMethodResult]:
        msg = SomeProtocolSomeMethodRequest(
            union_member,
            table_member,
        )
        return self._send_two_way_fidl_request(
            2515914517457749720,
            "test.anonymous",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.anonymous/SomeProtocol_SomeMethod_Result"
            ),
        )


class SomeProtocolEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.anonymous"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


SomeProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.anonymous/SomeProtocol"
)
