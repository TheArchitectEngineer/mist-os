# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl
from fidl._ir import get_fidl_ir_map

_ir_path = get_fidl_ir_map()["test.unionsandwich"]
add_ir_path(_ir_path)


@dataclass
class SandwichUnionSize12Alignment4:
    before: int
    union: UnionSize12Alignment4
    after: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "SandwichUnionSize12Alignment4"
    __fidl_raw_type__ = "test.unionsandwich/SandwichUnionSize12Alignment4"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/SandwichUnionSize12Alignment4",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "before": None,  # type: ignore[arg-type,unused-ignore]
                "union": None,  # type: ignore[arg-type,unused-ignore]
                "after": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class SandwichUnionSize24Alignment8:
    before: int
    union: UnionSize24Alignment8
    after: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "SandwichUnionSize24Alignment8"
    __fidl_raw_type__ = "test.unionsandwich/SandwichUnionSize24Alignment8"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/SandwichUnionSize24Alignment8",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "before": None,  # type: ignore[arg-type,unused-ignore]
                "union": None,  # type: ignore[arg-type,unused-ignore]
                "after": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class SandwichUnionSize36Alignment4:
    before: int
    union: UnionSize36Alignment4
    after: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "SandwichUnionSize36Alignment4"
    __fidl_raw_type__ = "test.unionsandwich/SandwichUnionSize36Alignment4"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/SandwichUnionSize36Alignment4",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "before": None,  # type: ignore[arg-type,unused-ignore]
                "union": None,  # type: ignore[arg-type,unused-ignore]
                "after": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class SandwichUnionSize8Alignment4:
    before: int
    union: UnionSize8Alignment4
    after: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "SandwichUnionSize8Alignment4"
    __fidl_raw_type__ = "test.unionsandwich/SandwichUnionSize8Alignment4"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/SandwichUnionSize8Alignment4",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "before": None,  # type: ignore[arg-type,unused-ignore]
                "union": None,  # type: ignore[arg-type,unused-ignore]
                "after": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class StructSize16Alignment8:
    f1: int
    f2: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructSize16Alignment8"
    __fidl_raw_type__ = "test.unionsandwich/StructSize16Alignment8"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/StructSize16Alignment8",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "f1": None,  # type: ignore[arg-type,unused-ignore]
                "f2": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


class UnionSize12Alignment4:
    _variant: typing.Optional[typing.Sequence[int]]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionSize12Alignment4"
    __fidl_raw_type__ = "test.unionsandwich/UnionSize12Alignment4"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.variant != other.variant:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.variant:
            variant = f"variant={self.variant!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        variant: typing.Optional[typing.Sequence[int]] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if variant is not None:
            self._variant = variant
            variants.append("variant")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def variant(self) -> typing.Sequence[int] | None:
        return getattr(self, "_variant", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/UnionSize12Alignment4",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionSize24Alignment8:
    _variant: typing.Optional[StructSize16Alignment8]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionSize24Alignment8"
    __fidl_raw_type__ = "test.unionsandwich/UnionSize24Alignment8"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.variant != other.variant:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.variant:
            variant = f"variant={self.variant!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        variant: typing.Optional[StructSize16Alignment8] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if variant is not None:
            self._variant = variant
            variants.append("variant")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def variant(self) -> StructSize16Alignment8 | None:
        return getattr(self, "_variant", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/UnionSize24Alignment8",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionSize36Alignment4:
    _variant: typing.Optional[typing.Sequence[int]]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionSize36Alignment4"
    __fidl_raw_type__ = "test.unionsandwich/UnionSize36Alignment4"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.variant != other.variant:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.variant:
            variant = f"variant={self.variant!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        variant: typing.Optional[typing.Sequence[int]] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if variant is not None:
            self._variant = variant
            variants.append("variant")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def variant(self) -> typing.Sequence[int] | None:
        return getattr(self, "_variant", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/UnionSize36Alignment4",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionSize8Alignment4:
    _variant: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionSize8Alignment4"
    __fidl_raw_type__ = "test.unionsandwich/UnionSize8Alignment4"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.variant != other.variant:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.variant:
            variant = f"variant={self.variant!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        variant: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if variant is not None:
            self._variant = variant
            variants.append("variant")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def variant(self) -> int | None:
        return getattr(self, "_variant", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unionsandwich",
            "test.unionsandwich/UnionSize8Alignment4",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())
