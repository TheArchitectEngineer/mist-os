# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl
from fidl._ir import get_fidl_ir_map

_ir_path = get_fidl_ir_map()["test.emptystruct"]
add_ir_path(_ir_path)


@dataclass
class Empty:
    __fidl_kind__ = "struct"
    __fidl_type__ = "Empty"
    __fidl_raw_type__ = "test.emptystruct/Empty"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.emptystruct", "test.emptystruct/Empty"
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class EmptyProtocolReceiveRequest:
    e: Empty

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolReceiveRequest"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolReceiveRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolReceiveRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class EmptyProtocolSendAndReceiveRequest:
    e: Empty

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolSendAndReceiveRequest"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolSendAndReceiveRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolSendAndReceiveRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class EmptyProtocolSendAndReceiveResponse:
    e: Empty

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolSendAndReceiveResponse"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolSendAndReceiveResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolSendAndReceiveResponse",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class EmptyProtocolSendRequest:
    e: Empty

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolSendRequest"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolSendRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolSendRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


from fidl._client import EventHandlerBase, FidlClient
from fidl._server import ServerBase
from fidl._fidl_common import (
    DomainError,
    FrameworkError,
    MethodInfo,
    FidlProtocolMarker,
    normalize_identifier,
)

from abc import abstractmethod, ABC


class EmptyProtocolServer(ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.emptystruct"
    method_map: typing.Dict[int, MethodInfo] = {
        1378773277029173000: MethodInfo(
            name="send",
            request_ident="test.emptystruct/EmptyProtocolSendRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        534401212734647530: MethodInfo(
            name="send_and_receive",
            request_ident="test.emptystruct/EmptyProtocolSendAndReceiveRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.emptystruct/EmptyProtocolSendAndReceiveResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_send: typing.TypeAlias = None

    @abstractmethod
    def send(
        self,
        request: EmptyProtocolSendRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_send]
        | _MethodResponse_send
    ):
        ...

    def receive(
        self,
        *,
        e: Empty,
    ) -> None:
        msg = EmptyProtocolReceiveRequest(
            e,
        )
        self._send_event(2301564782476583487, "test.emptystruct", msg)

    _MethodResponse_send_and_receive: typing.TypeAlias = (
        EmptyProtocolSendAndReceiveResponse
    )

    @abstractmethod
    def send_and_receive(
        self,
        request: EmptyProtocolSendAndReceiveRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_send_and_receive
        ]
        | _MethodResponse_send_and_receive
    ):
        ...


class EmptyProtocolClient(FidlClient):
    __fidl_kind__ = "client"
    library = "test.emptystruct"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def send(
        self,
        *,
        e: Empty,
    ) -> None:
        msg = EmptyProtocolSendRequest(
            e,
        )

        self._send_one_way_fidl_request(
            0,
            1378773277029173000,
            "test.emptystruct",
            msg,
        )

    def send_and_receive(
        self,
        *,
        e: Empty,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, EmptyProtocolSendAndReceiveResponse
    ]:
        msg = EmptyProtocolSendAndReceiveRequest(
            e,
        )
        return self._send_two_way_fidl_request(
            534401212734647530,
            "test.emptystruct",
            msg,
            normalize_identifier(
                "test.emptystruct/EmptyProtocolSendAndReceiveResponse"
            ),
        )


class EmptyProtocolEventHandler(EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.emptystruct"
    method_map: typing.Dict[int, MethodInfo] = {
        2301564782476583487: MethodInfo(
            name="receive",
            request_ident="test.emptystruct/EmptyProtocolReceiveRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def receive(
        self,
        request: EmptyProtocolReceiveRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


EmptyProtocolMarker = FidlProtocolMarker(
    "(nondiscoverable) test.emptystruct/EmptyProtocol"
)
