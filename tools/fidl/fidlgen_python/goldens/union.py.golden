# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.union"]
add_ir_path(_ir_path)


@dataclass
class Empty:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "Empty"
    __fidl_raw_type__ = "test.union/Empty"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/Empty")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class NullableUnionStruct:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    the_union: typing.Optional[Union] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "NullableUnionStruct"
    __fidl_raw_type__ = "test.union/NullableUnionStruct"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/NullableUnionStruct"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "the_union": None,
            }
        )


@dataclass
class Pasta:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    sauce: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "Pasta"
    __fidl_raw_type__ = "test.union/Pasta"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/Pasta")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "sauce": None,
            }
        )


@dataclass
class Pizza:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    toppings: typing.Sequence[str] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "Pizza"
    __fidl_raw_type__ = "test.union/Pizza"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/Pizza")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "toppings": None,
            }
        )


@dataclass
class StructWithNullableUnion:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    x1: typing.Optional[OlderSimpleUnion] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableUnion"
    __fidl_raw_type__ = "test.union/StructWithNullableUnion"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/StructWithNullableUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "x1": None,
            }
        )


@dataclass
class TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    xu: OlderSimpleUnion | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse"
    )
    __fidl_raw_type__ = "test.union/TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.union",
            "test.union/TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "xu": None,
            }
        )


@dataclass
class TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    xu: StrictBoundedUnion | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse"
    )
    __fidl_raw_type__ = "test.union/TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.union",
            "test.union/TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "xu": None,
            }
        )


@dataclass
class UnionSandwich:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    u: ExplicitFlexibleUnion | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnionSandwich"
    __fidl_raw_type__ = "test.union/UnionSandwich"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/UnionSandwich"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "u": None,
                "b": None,
            }
        )


class EmptyFlexibleUnion:
    __fidl_kind__ = "union"
    __fidl_type__ = "EmptyFlexibleUnion"
    __fidl_raw_type__ = "test.union/EmptyFlexibleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        return f"<'{self.__fidl_type__}' object({variant})>"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/EmptyFlexibleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class ExplicitFlexibleUnion:
    _i: typing.Optional[int]
    _f: typing.Optional[float]

    __fidl_kind__ = "union"
    __fidl_type__ = "ExplicitFlexibleUnion"
    __fidl_raw_type__ = "test.union/ExplicitFlexibleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.i != other.i:
            return False
        if self.f != other.f:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.i:
            variant = f"i={self.i!r}"
        if self.f:
            variant = f"f={self.f!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        i: typing.Optional[int] = None,
        f: typing.Optional[float] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if f is not None:
            self._f = f
            variants.append("f")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    @property
    def f(self) -> float | None:
        return getattr(self, "_f", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/ExplicitFlexibleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ExplicitFoo:
    _i: typing.Optional[int]
    _s: typing.Optional[str]

    __fidl_kind__ = "union"
    __fidl_type__ = "ExplicitFoo"
    __fidl_raw_type__ = "test.union/ExplicitFoo"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.i != other.i:
            return False
        if self.s != other.s:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.i:
            variant = f"i={self.i!r}"
        if self.s:
            variant = f"s={self.s!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        i: typing.Optional[int] = None,
        s: typing.Optional[str] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if s is not None:
            self._s = s
            variants.append("s")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    @property
    def s(self) -> str | None:
        return getattr(self, "_s", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/ExplicitFoo")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ExplicitPizzaOrPasta:
    _pizza: typing.Optional[Pizza]
    _pasta: typing.Optional[Pasta]

    __fidl_kind__ = "union"
    __fidl_type__ = "ExplicitPizzaOrPasta"
    __fidl_raw_type__ = "test.union/ExplicitPizzaOrPasta"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.pizza != other.pizza:
            return False
        if self.pasta != other.pasta:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.pizza:
            variant = f"pizza={self.pizza!r}"
        if self.pasta:
            variant = f"pasta={self.pasta!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        pizza: typing.Optional[Pizza] = None,
        pasta: typing.Optional[Pasta] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if pizza is not None:
            self._pizza = pizza
            variants.append("pizza")
            number_of_variants += 1
        if pasta is not None:
            self._pasta = pasta
            variants.append("pasta")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def pizza(self) -> Pizza | None:
        return getattr(self, "_pizza", None)

    @property
    def pasta(self) -> Pasta | None:
        return getattr(self, "_pasta", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/ExplicitPizzaOrPasta"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ExplicitStrictFoo:
    _i: typing.Optional[int]
    _s: typing.Optional[str]

    __fidl_kind__ = "union"
    __fidl_type__ = "ExplicitStrictFoo"
    __fidl_raw_type__ = "test.union/ExplicitStrictFoo"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.i != other.i:
            return False
        if self.s != other.s:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.i:
            variant = f"i={self.i!r}"
        if self.s:
            variant = f"s={self.s!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        i: typing.Optional[int] = None,
        s: typing.Optional[str] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if s is not None:
            self._s = s
            variants.append("s")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    @property
    def s(self) -> str | None:
        return getattr(self, "_s", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/ExplicitStrictFoo"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ExplicitUnion:
    _primitive: typing.Optional[int]
    _string_needs_constructor: typing.Optional[str]

    __fidl_kind__ = "union"
    __fidl_type__ = "ExplicitUnion"
    __fidl_raw_type__ = "test.union/ExplicitUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.primitive != other.primitive:
            return False
        if self.string_needs_constructor != other.string_needs_constructor:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.primitive:
            variant = f"primitive={self.primitive!r}"
        if self.string_needs_constructor:
            variant = (
                f"string_needs_constructor={self.string_needs_constructor!r}"
            )
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        primitive: typing.Optional[int] = None,
        string_needs_constructor: typing.Optional[str] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if primitive is not None:
            self._primitive = primitive
            variants.append("primitive")
            number_of_variants += 1
        if string_needs_constructor is not None:
            self._string_needs_constructor = string_needs_constructor
            variants.append("string_needs_constructor")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def primitive(self) -> int | None:
        return getattr(self, "_primitive", None)

    @property
    def string_needs_constructor(self) -> str | None:
        return getattr(self, "_string_needs_constructor", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/ExplicitUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class FieldCollision:
    _field_collision_tag: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "FieldCollision"
    __fidl_raw_type__ = "test.union/FieldCollision"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.field_collision_tag != other.field_collision_tag:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.field_collision_tag:
            variant = f"field_collision_tag={self.field_collision_tag!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        field_collision_tag: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if field_collision_tag is not None:
            self._field_collision_tag = field_collision_tag
            variants.append("field_collision_tag")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def field_collision_tag(self) -> int | None:
        return getattr(self, "_field_collision_tag", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/FieldCollision"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class FlexibleFoo:
    _s: typing.Optional[str]
    _i: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "FlexibleFoo"
    __fidl_raw_type__ = "test.union/FlexibleFoo"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.s != other.s:
            return False
        if self.i != other.i:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.s:
            variant = f"s={self.s!r}"
        if self.i:
            variant = f"i={self.i!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        s: typing.Optional[str] = None,
        i: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if s is not None:
            self._s = s
            variants.append("s")
            number_of_variants += 1
        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def s(self) -> str | None:
        return getattr(self, "_s", None)

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/FlexibleFoo")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class FlexiblePizzaOrPasta:
    _pizza: typing.Optional[Pizza]
    _pasta: typing.Optional[Pasta]

    __fidl_kind__ = "union"
    __fidl_type__ = "FlexiblePizzaOrPasta"
    __fidl_raw_type__ = "test.union/FlexiblePizzaOrPasta"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.pizza != other.pizza:
            return False
        if self.pasta != other.pasta:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.pizza:
            variant = f"pizza={self.pizza!r}"
        if self.pasta:
            variant = f"pasta={self.pasta!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        pizza: typing.Optional[Pizza] = None,
        pasta: typing.Optional[Pasta] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if pizza is not None:
            self._pizza = pizza
            variants.append("pizza")
            number_of_variants += 1
        if pasta is not None:
            self._pasta = pasta
            variants.append("pasta")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def pizza(self) -> Pizza | None:
        return getattr(self, "_pizza", None)

    @property
    def pasta(self) -> Pasta | None:
        return getattr(self, "_pasta", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/FlexiblePizzaOrPasta"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class FlexibleUnion:
    _primitive: typing.Optional[int]
    _string_needs_constructor: typing.Optional[str]
    _vector_string_also_needs_constructor: typing.Optional[typing.Sequence[str]]

    __fidl_kind__ = "union"
    __fidl_type__ = "FlexibleUnion"
    __fidl_raw_type__ = "test.union/FlexibleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.primitive != other.primitive:
            return False
        if self.string_needs_constructor != other.string_needs_constructor:
            return False
        if (
            self.vector_string_also_needs_constructor
            != other.vector_string_also_needs_constructor
        ):
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.primitive:
            variant = f"primitive={self.primitive!r}"
        if self.string_needs_constructor:
            variant = (
                f"string_needs_constructor={self.string_needs_constructor!r}"
            )
        if self.vector_string_also_needs_constructor:
            variant = f"vector_string_also_needs_constructor={self.vector_string_also_needs_constructor!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        primitive: typing.Optional[int] = None,
        string_needs_constructor: typing.Optional[str] = None,
        vector_string_also_needs_constructor: typing.Optional[
            typing.Sequence[str]
        ] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if primitive is not None:
            self._primitive = primitive
            variants.append("primitive")
            number_of_variants += 1
        if string_needs_constructor is not None:
            self._string_needs_constructor = string_needs_constructor
            variants.append("string_needs_constructor")
            number_of_variants += 1
        if vector_string_also_needs_constructor is not None:
            self._vector_string_also_needs_constructor = (
                vector_string_also_needs_constructor
            )
            variants.append("vector_string_also_needs_constructor")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def primitive(self) -> int | None:
        return getattr(self, "_primitive", None)

    @property
    def string_needs_constructor(self) -> str | None:
        return getattr(self, "_string_needs_constructor", None)

    @property
    def vector_string_also_needs_constructor(
        self,
    ) -> typing.Sequence[str] | None:
        return getattr(self, "_vector_string_also_needs_constructor", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/FlexibleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class NewerSimpleUnion:
    _i: typing.Optional[int]
    _s: typing.Optional[str]
    _v: typing.Optional[typing.Sequence[str]]

    __fidl_kind__ = "union"
    __fidl_type__ = "NewerSimpleUnion"
    __fidl_raw_type__ = "test.union/NewerSimpleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.i != other.i:
            return False
        if self.s != other.s:
            return False
        if self.v != other.v:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.i:
            variant = f"i={self.i!r}"
        if self.s:
            variant = f"s={self.s!r}"
        if self.v:
            variant = f"v={self.v!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        i: typing.Optional[int] = None,
        s: typing.Optional[str] = None,
        v: typing.Optional[typing.Sequence[str]] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if s is not None:
            self._s = s
            variants.append("s")
            number_of_variants += 1
        if v is not None:
            self._v = v
            variants.append("v")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    @property
    def s(self) -> str | None:
        return getattr(self, "_s", None)

    @property
    def v(self) -> typing.Sequence[str] | None:
        return getattr(self, "_v", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/NewerSimpleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OlderSimpleUnion:
    _i: typing.Optional[int]
    _f: typing.Optional[float]

    __fidl_kind__ = "union"
    __fidl_type__ = "OlderSimpleUnion"
    __fidl_raw_type__ = "test.union/OlderSimpleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.i != other.i:
            return False
        if self.f != other.f:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.i:
            variant = f"i={self.i!r}"
        if self.f:
            variant = f"f={self.f!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        i: typing.Optional[int] = None,
        f: typing.Optional[float] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if f is not None:
            self._f = f
            variants.append("f")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    @property
    def f(self) -> float | None:
        return getattr(self, "_f", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/OlderSimpleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class PizzaOrPasta:
    _pizza: typing.Optional[Pizza]
    _pasta: typing.Optional[Pasta]

    __fidl_kind__ = "union"
    __fidl_type__ = "PizzaOrPasta"
    __fidl_raw_type__ = "test.union/PizzaOrPasta"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.pizza != other.pizza:
            return False
        if self.pasta != other.pasta:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.pizza:
            variant = f"pizza={self.pizza!r}"
        if self.pasta:
            variant = f"pasta={self.pasta!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        pizza: typing.Optional[Pizza] = None,
        pasta: typing.Optional[Pasta] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if pizza is not None:
            self._pizza = pizza
            variants.append("pizza")
            number_of_variants += 1
        if pasta is not None:
            self._pasta = pasta
            variants.append("pasta")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def pizza(self) -> Pizza | None:
        return getattr(self, "_pizza", None)

    @property
    def pasta(self) -> Pasta | None:
        return getattr(self, "_pasta", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/PizzaOrPasta")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ReverseOrdinalUnion:
    _first: typing.Optional[int]
    _second: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "ReverseOrdinalUnion"
    __fidl_raw_type__ = "test.union/ReverseOrdinalUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.first != other.first:
            return False
        if self.second != other.second:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.first:
            variant = f"first={self.first!r}"
        if self.second:
            variant = f"second={self.second!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        first: typing.Optional[int] = None,
        second: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if first is not None:
            self._first = first
            variants.append("first")
            number_of_variants += 1
        if second is not None:
            self._second = second
            variants.append("second")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def first(self) -> int | None:
        return getattr(self, "_first", None)

    @property
    def second(self) -> int | None:
        return getattr(self, "_second", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/ReverseOrdinalUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class StrictBoundedUnion:
    _v: typing.Optional[typing.Sequence[int]]

    __fidl_kind__ = "union"
    __fidl_type__ = "StrictBoundedUnion"
    __fidl_raw_type__ = "test.union/StrictBoundedUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.v != other.v:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.v:
            variant = f"v={self.v!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        v: typing.Optional[typing.Sequence[int]] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if v is not None:
            self._v = v
            variants.append("v")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def v(self) -> typing.Sequence[int] | None:
        return getattr(self, "_v", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/StrictBoundedUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class StrictFoo:
    _s: typing.Optional[str]
    _i: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "StrictFoo"
    __fidl_raw_type__ = "test.union/StrictFoo"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.s != other.s:
            return False
        if self.i != other.i:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.s:
            variant = f"s={self.s!r}"
        if self.i:
            variant = f"i={self.i!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        s: typing.Optional[str] = None,
        i: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if s is not None:
            self._s = s
            variants.append("s")
            number_of_variants += 1
        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def s(self) -> str | None:
        return getattr(self, "_s", None)

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/StrictFoo")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class StrictPizzaOrPasta:
    _pizza: typing.Optional[Pizza]
    _pasta: typing.Optional[Pasta]

    __fidl_kind__ = "union"
    __fidl_type__ = "StrictPizzaOrPasta"
    __fidl_raw_type__ = "test.union/StrictPizzaOrPasta"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.pizza != other.pizza:
            return False
        if self.pasta != other.pasta:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.pizza:
            variant = f"pizza={self.pizza!r}"
        if self.pasta:
            variant = f"pasta={self.pasta!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        pizza: typing.Optional[Pizza] = None,
        pasta: typing.Optional[Pasta] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if pizza is not None:
            self._pizza = pizza
            variants.append("pizza")
            number_of_variants += 1
        if pasta is not None:
            self._pasta = pasta
            variants.append("pasta")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def pizza(self) -> Pizza | None:
        return getattr(self, "_pizza", None)

    @property
    def pasta(self) -> Pasta | None:
        return getattr(self, "_pasta", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/StrictPizzaOrPasta"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class StrictSimpleUnion:
    _i: typing.Optional[int]
    _f: typing.Optional[float]
    _s: typing.Optional[str]

    __fidl_kind__ = "union"
    __fidl_type__ = "StrictSimpleUnion"
    __fidl_raw_type__ = "test.union/StrictSimpleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.i != other.i:
            return False
        if self.f != other.f:
            return False
        if self.s != other.s:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.i:
            variant = f"i={self.i!r}"
        if self.f:
            variant = f"f={self.f!r}"
        if self.s:
            variant = f"s={self.s!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        i: typing.Optional[int] = None,
        f: typing.Optional[float] = None,
        s: typing.Optional[str] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if i is not None:
            self._i = i
            variants.append("i")
            number_of_variants += 1
        if f is not None:
            self._f = f
            variants.append("f")
            number_of_variants += 1
        if s is not None:
            self._s = s
            variants.append("s")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def i(self) -> int | None:
        return getattr(self, "_i", None)

    @property
    def f(self) -> float | None:
        return getattr(self, "_f", None)

    @property
    def s(self) -> str | None:
        return getattr(self, "_s", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/StrictSimpleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class StrictUnion:
    _primitive: typing.Optional[int]
    _string_needs_constructor: typing.Optional[str]
    _vector_string_also_needs_constructor: typing.Optional[typing.Sequence[str]]

    __fidl_kind__ = "union"
    __fidl_type__ = "StrictUnion"
    __fidl_raw_type__ = "test.union/StrictUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.primitive != other.primitive:
            return False
        if self.string_needs_constructor != other.string_needs_constructor:
            return False
        if (
            self.vector_string_also_needs_constructor
            != other.vector_string_also_needs_constructor
        ):
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.primitive:
            variant = f"primitive={self.primitive!r}"
        if self.string_needs_constructor:
            variant = (
                f"string_needs_constructor={self.string_needs_constructor!r}"
            )
        if self.vector_string_also_needs_constructor:
            variant = f"vector_string_also_needs_constructor={self.vector_string_also_needs_constructor!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        primitive: typing.Optional[int] = None,
        string_needs_constructor: typing.Optional[str] = None,
        vector_string_also_needs_constructor: typing.Optional[
            typing.Sequence[str]
        ] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if primitive is not None:
            self._primitive = primitive
            variants.append("primitive")
            number_of_variants += 1
        if string_needs_constructor is not None:
            self._string_needs_constructor = string_needs_constructor
            variants.append("string_needs_constructor")
            number_of_variants += 1
        if vector_string_also_needs_constructor is not None:
            self._vector_string_also_needs_constructor = (
                vector_string_also_needs_constructor
            )
            variants.append("vector_string_also_needs_constructor")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def primitive(self) -> int | None:
        return getattr(self, "_primitive", None)

    @property
    def string_needs_constructor(self) -> str | None:
        return getattr(self, "_string_needs_constructor", None)

    @property
    def vector_string_also_needs_constructor(
        self,
    ) -> typing.Sequence[str] | None:
        return getattr(self, "_vector_string_also_needs_constructor", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/StrictUnion")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class Union:
    _primitive: typing.Optional[int]
    _string_needs_constructor: typing.Optional[str]
    _vector_string_also_needs_constructor: typing.Optional[typing.Sequence[str]]

    __fidl_kind__ = "union"
    __fidl_type__ = "Union"
    __fidl_raw_type__ = "test.union/Union"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.primitive != other.primitive:
            return False
        if self.string_needs_constructor != other.string_needs_constructor:
            return False
        if (
            self.vector_string_also_needs_constructor
            != other.vector_string_also_needs_constructor
        ):
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.primitive:
            variant = f"primitive={self.primitive!r}"
        if self.string_needs_constructor:
            variant = (
                f"string_needs_constructor={self.string_needs_constructor!r}"
            )
        if self.vector_string_also_needs_constructor:
            variant = f"vector_string_also_needs_constructor={self.vector_string_also_needs_constructor!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        primitive: typing.Optional[int] = None,
        string_needs_constructor: typing.Optional[str] = None,
        vector_string_also_needs_constructor: typing.Optional[
            typing.Sequence[str]
        ] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if primitive is not None:
            self._primitive = primitive
            variants.append("primitive")
            number_of_variants += 1
        if string_needs_constructor is not None:
            self._string_needs_constructor = string_needs_constructor
            variants.append("string_needs_constructor")
            number_of_variants += 1
        if vector_string_also_needs_constructor is not None:
            self._vector_string_also_needs_constructor = (
                vector_string_also_needs_constructor
            )
            variants.append("vector_string_also_needs_constructor")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def primitive(self) -> int | None:
        return getattr(self, "_primitive", None)

    @property
    def string_needs_constructor(self) -> str | None:
        return getattr(self, "_string_needs_constructor", None)

    @property
    def vector_string_also_needs_constructor(
        self,
    ) -> typing.Sequence[str] | None:
        return getattr(self, "_vector_string_also_needs_constructor", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(self, "test.union", "test.union/Union")

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionContainingEmptyStruct:
    _empty: typing.Optional[Empty]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionContainingEmptyStruct"
    __fidl_raw_type__ = "test.union/UnionContainingEmptyStruct"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.empty != other.empty:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.empty:
            variant = f"empty={self.empty!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        empty: typing.Optional[Empty] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if empty is not None:
            self._empty = empty
            variants.append("empty")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def empty(self) -> Empty | None:
        return getattr(self, "_empty", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/UnionContainingEmptyStruct"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionWithAttributes:
    _x: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionWithAttributes"
    __fidl_raw_type__ = "test.union/UnionWithAttributes"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.x != other.x:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.x:
            variant = f"x={self.x!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        x: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if x is not None:
            self._x = x
            variants.append("x")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def x(self) -> int | None:
        return getattr(self, "_x", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.union", "test.union/UnionWithAttributes"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class TestProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.union"
    method_map: typing.Dict[int, MethodInfo] = {
        6628358876445129155: MethodInfo(
            name="strict_union_hence_response_may_be_stack_allocated",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.union/TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse",
        ),
        7588545459451501794: MethodInfo(
            name="flexible_union_hence_response_must_be_heap_allocated",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.union/TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_strict_union_hence_response_may_be_stack_allocated: typing.TypeAlias = (
        TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
    )

    @abstractmethod
    def strict_union_hence_response_may_be_stack_allocated(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any,
            typing.Any,
            _MethodResponse_strict_union_hence_response_may_be_stack_allocated,
        ]
        | _MethodResponse_strict_union_hence_response_may_be_stack_allocated
    ):
        ...

    _MethodResponse_flexible_union_hence_response_must_be_heap_allocated: typing.TypeAlias = (
        TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
    )

    @abstractmethod
    def flexible_union_hence_response_must_be_heap_allocated(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any,
            typing.Any,
            _MethodResponse_flexible_union_hence_response_must_be_heap_allocated,
        ]
        | _MethodResponse_flexible_union_hence_response_must_be_heap_allocated
    ):
        ...


class TestProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.union"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def strict_union_hence_response_may_be_stack_allocated(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            6628358876445129155,
            "test.union",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.union/TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse"
            ),
        )

    def flexible_union_hence_response_must_be_heap_allocated(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7588545459451501794,
            "test.union",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.union/TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse"
            ),
        )


class TestProtocolEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.union"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


TestProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.union/TestProtocol"
)
