# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.protocols"]
add_ir_path(_ir_path)


@dataclass
class ChannelProtocolEventARequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolEventARequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolEventARequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolEventARequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
            }
        )


@dataclass
class ChannelProtocolMethodARequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMethodARequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMethodARequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMethodARequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
            }
        )


@dataclass
class ChannelProtocolMethodBRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMethodBRequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMethodBRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMethodBRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
            }
        )


@dataclass
class ChannelProtocolMethodBResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    result: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMethodBResponse"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMethodBResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMethodBResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "result": None,
            }
        )


@dataclass
class ChannelProtocolMutateSocketRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMutateSocketRequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMutateSocketRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMutateSocketRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
            }
        )


@dataclass
class ChannelProtocolMutateSocketResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMutateSocketResponse"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMutateSocketResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMutateSocketResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "b": None,
            }
        )


@dataclass
class ChannelProtocolTakeHandleRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolTakeHandleRequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolTakeHandleRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolTakeHandleRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolAnEventRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolAnEventRequest"
    __fidl_raw_type__ = "test.protocols/HandleRightsProtocolAnEventRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolAnEventRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolNoResponseMethodRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolNoResponseMethodRequest"
    __fidl_raw_type__ = (
        "test.protocols/HandleRightsProtocolNoResponseMethodRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolNoResponseMethodRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolResponseMethodRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolResponseMethodRequest"
    __fidl_raw_type__ = (
        "test.protocols/HandleRightsProtocolResponseMethodRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolResponseMethodRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolResponseMethodResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolResponseMethodResponse"
    __fidl_raw_type__ = (
        "test.protocols/HandleRightsProtocolResponseMethodResponse"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolResponseMethodResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class ManyParametersFifteenRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    p1: bool | None
    p2: bool | None
    p3: bool | None
    p4: bool | None
    p5: bool | None
    p6: bool | None
    p7: bool | None
    p8: bool | None
    p9: bool | None
    p10: bool | None
    p11: bool | None
    p12: bool | None
    p13: bool | None
    p14: bool | None
    p15: bool | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ManyParametersFifteenRequest"
    __fidl_raw_type__ = "test.protocols/ManyParametersFifteenRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ManyParametersFifteenRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "p1": None,
                "p2": None,
                "p3": None,
                "p4": None,
                "p5": None,
                "p6": None,
                "p7": None,
                "p8": None,
                "p9": None,
                "p10": None,
                "p11": None,
                "p12": None,
                "p13": None,
                "p14": None,
                "p15": None,
            }
        )


@dataclass
class MethodWithUnionUnionMethodRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    u: TheUnion | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "MethodWithUnionUnionMethodRequest"
    __fidl_raw_type__ = "test.protocols/MethodWithUnionUnionMethodRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/MethodWithUnionUnionMethodRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "u": None,
            }
        )


@dataclass
class MethodWithUnionUnionMethodResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    u: typing.Optional[TheUnion] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "MethodWithUnionUnionMethodResponse"
    __fidl_raw_type__ = "test.protocols/MethodWithUnionUnionMethodResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/MethodWithUnionUnionMethodResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "u": None,
            }
        )


@dataclass
class ProtocolEnds:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    client: int | None
    server: int | None
    client_opt: typing.Optional[int] | None
    server_opt: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ProtocolEnds"
    __fidl_raw_type__ = "test.protocols/ProtocolEnds"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.protocols", "test.protocols/ProtocolEnds"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "client": None,
                "server": None,
                "client_opt": None,
                "server_opt": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseNoRequestWithResponseResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    ret: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithAndWithoutRequestResponseNoRequestWithResponseResponse"
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseNoRequestWithResponseResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseNoRequestWithResponseResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "ret": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseOnWithResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    ret: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithAndWithoutRequestResponseOnWithResponseRequest"
    __fidl_raw_type__ = (
        "test.protocols/WithAndWithoutRequestResponseOnWithResponseRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseOnWithResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "ret": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    arg: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "WithAndWithoutRequestResponseWithRequestEmptyResponseRequest"
    )
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestEmptyResponseRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestEmptyResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "arg": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestNoResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    arg: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithAndWithoutRequestResponseWithRequestNoResponseRequest"
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestNoResponseRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestNoResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "arg": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestWithResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    arg: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "WithAndWithoutRequestResponseWithRequestWithResponseRequest"
    )
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "arg": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestWithResponseResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    ret: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "WithAndWithoutRequestResponseWithRequestWithResponseResponse"
    )
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "ret": None,
            }
        )


@dataclass
class WithErrorSyntaxErrorAsEnumResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxErrorAsEnumResponse"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ErrorAsEnum_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsEnum_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class WithErrorSyntaxErrorAsPrimitiveResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxErrorAsPrimitiveResponse"
    __fidl_raw_type__ = (
        "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class WithErrorSyntaxHandleInResultResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxHandleInResultResponse"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_HandleInResult_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_HandleInResult_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class WithErrorSyntaxResponseAsStructResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None
    c: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxResponseAsStructResponse"
    __fidl_raw_type__ = (
        "test.protocols/WithErrorSyntax_ResponseAsStruct_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ResponseAsStruct_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
                "c": None,
            }
        )


@dataclass
class WithProtocolEndsClientEndsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    in_: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsClientEndsRequest"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsClientEndsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsClientEndsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "in_": None,
            }
        )


@dataclass
class WithProtocolEndsClientEndsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    out: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsClientEndsResponse"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsClientEndsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsClientEndsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "out": None,
            }
        )


@dataclass
class WithProtocolEndsServerEndsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    in_: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsServerEndsRequest"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsServerEndsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsServerEndsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "in_": None,
            }
        )


@dataclass
class WithProtocolEndsServerEndsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    out: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsServerEndsResponse"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsServerEndsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsServerEndsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "out": None,
            }
        )


@dataclass
class WithProtocolEndsStructContainingEndsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    in_: ProtocolEnds | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsStructContainingEndsRequest"
    __fidl_raw_type__ = (
        "test.protocols/WithProtocolEndsStructContainingEndsRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsStructContainingEndsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "in_": None,
            }
        )


@dataclass
class WithProtocolEndsStructContainingEndsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    out: ProtocolEnds | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsStructContainingEndsResponse"
    __fidl_raw_type__ = (
        "test.protocols/WithProtocolEndsStructContainingEndsResponse"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsStructContainingEndsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "out": None,
            }
        )


class TheUnion:
    _v: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "TheUnion"
    __fidl_raw_type__ = "test.protocols/TheUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.v != other.v:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.v:
            variant = f"v={self.v!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        v: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if v is not None:
            self._v = v
            variants.append("v")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def v(self) -> int | None:
        return getattr(self, "_v", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.protocols", "test.protocols/TheUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxErrorAsEnumResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxErrorAsEnumResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ErrorAsEnum_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsEnum_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxErrorAsPrimitiveResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxErrorAsPrimitiveResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxHandleInResultResult:
    _response: typing.Optional[WithErrorSyntaxHandleInResultResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxHandleInResultResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_HandleInResult_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[WithErrorSyntaxHandleInResultResponse] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> WithErrorSyntaxHandleInResultResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_HandleInResult_Result",
        )

    def unwrap(self) -> WithErrorSyntaxHandleInResultResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxResponseAsStructResult:
    _response: typing.Optional[WithErrorSyntaxResponseAsStructResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxResponseAsStructResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ResponseAsStruct_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            WithErrorSyntaxResponseAsStructResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> WithErrorSyntaxResponseAsStructResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ResponseAsStruct_Result",
        )

    def unwrap(self) -> WithErrorSyntaxResponseAsStructResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


ErrorEnum = enum.IntEnum(
    "ErrorEnum",
    {
        "__fidl_kind__": "enum",
        "__fidl_type__": "ErrorEnum",
        "__fidl_raw_type__": "test.protocols/ErrorEnum",
        "__strict__": True,
        "ERR_FOO": 1,
        "ERR_BAR": 2,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class AnotherDiscoverableProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class AnotherDiscoverableProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class AnotherDiscoverableProtocolEventHandler(
    fidl._client.EventHandlerBase, ABC
):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


AnotherDiscoverableProtocolMarker = fidl._library.ProtocolMarker(
    "fake.library.FakeProtocol"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class ChannelProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        3155008840945527714: MethodInfo(
            name="method_a",
            request_ident="test.protocols/ChannelProtocolMethodARequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        8903004957800778182: MethodInfo(
            name="method_b",
            request_ident="test.protocols/ChannelProtocolMethodBRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/ChannelProtocolMethodBResponse",
        ),
        591935489944717925: MethodInfo(
            name="take_handle",
            request_ident="test.protocols/ChannelProtocolTakeHandleRequest",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        7411742788430590287: MethodInfo(
            name="mutate_socket",
            request_ident="test.protocols/ChannelProtocolMutateSocketRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/ChannelProtocolMutateSocketResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_method_a: typing.TypeAlias = None

    @abstractmethod
    def method_a(
        self,
        request: ChannelProtocolMethodARequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_method_a]
        | _MethodResponse_method_a
    ):
        ...

    def event_a(
        self,
        *,
        a: int,
        b: int,
    ) -> None:
        msg = ChannelProtocolEventARequest(
            a,
            b,
        )
        self._send_event(2220452875311597006, "test.protocols", msg)

    _MethodResponse_method_b: typing.TypeAlias = ChannelProtocolMethodBResponse

    @abstractmethod
    def method_b(
        self,
        request: ChannelProtocolMethodBRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_method_b]
        | _MethodResponse_method_b
    ):
        ...

    _MethodResponse_take_handle: typing.TypeAlias = None

    @abstractmethod
    def take_handle(
        self,
        request: ChannelProtocolTakeHandleRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_take_handle]
        | _MethodResponse_take_handle
    ):
        ...

    _MethodResponse_mutate_socket: typing.TypeAlias = (
        ChannelProtocolMutateSocketResponse
    )

    @abstractmethod
    def mutate_socket(
        self,
        request: ChannelProtocolMutateSocketRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_mutate_socket]
        | _MethodResponse_mutate_socket
    ):
        ...


class ChannelProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def method_a(
        self,
        *,
        a: int,
        b: int,
    ) -> None:
        msg = ChannelProtocolMethodARequest(
            a,
            b,
        )

        self._send_one_way_fidl_request(
            0,
            3155008840945527714,
            "test.protocols",
            msg,
        )

    def method_b(
        self,
        *,
        a: int,
        b: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, ChannelProtocolMethodBResponse
    ]:
        msg = ChannelProtocolMethodBRequest(
            a,
            b,
        )
        return self._send_two_way_fidl_request(
            8903004957800778182,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/ChannelProtocolMethodBResponse"
            ),
        )

    def take_handle(
        self,
        *,
        h: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = ChannelProtocolTakeHandleRequest(
            h,
        )
        return self._send_two_way_fidl_request(
            591935489944717925,
            "test.protocols",
            msg,
            "",
        )

    def mutate_socket(
        self,
        *,
        a: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, ChannelProtocolMutateSocketResponse
    ]:
        msg = ChannelProtocolMutateSocketRequest(
            a,
        )
        return self._send_two_way_fidl_request(
            7411742788430590287,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/ChannelProtocolMutateSocketResponse"
            ),
        )


class ChannelProtocolEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        2220452875311597006: MethodInfo(
            name="event_a",
            request_ident="test.protocols/ChannelProtocolEventARequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def event_a(
        self,
        request: ChannelProtocolEventARequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


ChannelProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/ChannelProtocol"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class DiscoverableProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        3455873048082739435: MethodInfo(
            name="method",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_method: typing.TypeAlias = None

    @abstractmethod
    def method(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_method]
        | _MethodResponse_method
    ):
        ...


class DiscoverableProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def method(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            3455873048082739435,
            "test.protocols",
            msg,
        )


class DiscoverableProtocolEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


DiscoverableProtocolMarker = fidl._library.ProtocolMarker(
    "test.protocols.DiscoverableProtocol"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class HandleRightsProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        1155044649514904573: MethodInfo(
            name="no_response_method",
            request_ident="test.protocols/HandleRightsProtocolNoResponseMethodRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        5956276128041940295: MethodInfo(
            name="response_method",
            request_ident="test.protocols/HandleRightsProtocolResponseMethodRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/HandleRightsProtocolResponseMethodResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_no_response_method: typing.TypeAlias = None

    @abstractmethod
    def no_response_method(
        self,
        request: HandleRightsProtocolNoResponseMethodRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_no_response_method
        ]
        | _MethodResponse_no_response_method
    ):
        ...

    _MethodResponse_response_method: typing.TypeAlias = (
        HandleRightsProtocolResponseMethodResponse
    )

    @abstractmethod
    def response_method(
        self,
        request: HandleRightsProtocolResponseMethodRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_response_method
        ]
        | _MethodResponse_response_method
    ):
        ...

    def an_event(
        self,
        *,
        h: int,
    ) -> None:
        msg = HandleRightsProtocolAnEventRequest(
            h,
        )
        self._send_event(476727631355490611, "test.protocols", msg)


class HandleRightsProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def no_response_method(
        self,
        *,
        h: int,
    ) -> None:
        msg = HandleRightsProtocolNoResponseMethodRequest(
            h,
        )

        self._send_one_way_fidl_request(
            0,
            1155044649514904573,
            "test.protocols",
            msg,
        )

    def response_method(
        self,
        *,
        h: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, HandleRightsProtocolResponseMethodResponse
    ]:
        msg = HandleRightsProtocolResponseMethodRequest(
            h,
        )
        return self._send_two_way_fidl_request(
            5956276128041940295,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/HandleRightsProtocolResponseMethodResponse"
            ),
        )


class HandleRightsProtocolEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        476727631355490611: MethodInfo(
            name="an_event",
            request_ident="test.protocols/HandleRightsProtocolAnEventRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def an_event(
        self,
        request: HandleRightsProtocolAnEventRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


HandleRightsProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/HandleRightsProtocol"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class ManyParametersServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        6423043252952467815: MethodInfo(
            name="fifteen",
            request_ident="test.protocols/ManyParametersFifteenRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_fifteen: typing.TypeAlias = None

    @abstractmethod
    def fifteen(
        self,
        request: ManyParametersFifteenRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_fifteen]
        | _MethodResponse_fifteen
    ):
        ...


class ManyParametersClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def fifteen(
        self,
        *,
        p1: bool,
        p2: bool,
        p3: bool,
        p4: bool,
        p5: bool,
        p6: bool,
        p7: bool,
        p8: bool,
        p9: bool,
        p10: bool,
        p11: bool,
        p12: bool,
        p13: bool,
        p14: bool,
        p15: bool,
    ) -> None:
        msg = ManyParametersFifteenRequest(
            p1,
            p2,
            p3,
            p4,
            p5,
            p6,
            p7,
            p8,
            p9,
            p10,
            p11,
            p12,
            p13,
            p14,
            p15,
        )

        self._send_one_way_fidl_request(
            0,
            6423043252952467815,
            "test.protocols",
            msg,
        )


class ManyParametersEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


ManyParametersMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/ManyParameters"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class MethodWithUnionServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        4124874338266649112: MethodInfo(
            name="union_method",
            request_ident="test.protocols/MethodWithUnionUnionMethodRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/MethodWithUnionUnionMethodResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_union_method: typing.TypeAlias = (
        MethodWithUnionUnionMethodResponse
    )

    @abstractmethod
    def union_method(
        self,
        request: MethodWithUnionUnionMethodRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_union_method]
        | _MethodResponse_union_method
    ):
        ...


class MethodWithUnionClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def union_method(
        self,
        *,
        u: TheUnion,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, MethodWithUnionUnionMethodResponse
    ]:
        msg = MethodWithUnionUnionMethodRequest(
            u,
        )
        return self._send_two_way_fidl_request(
            4124874338266649112,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/MethodWithUnionUnionMethodResponse"
            ),
        )


class MethodWithUnionEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


MethodWithUnionMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/MethodWithUnion"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class PlatformServerServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class PlatformServerClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class PlatformServerEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


PlatformServerMarker = fidl._library.ProtocolMarker(
    "test.protocols.PlatformServer"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class WithAndWithoutRequestResponseServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        5413654872775949227: MethodInfo(
            name="no_request_no_response",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        1631193469798418024: MethodInfo(
            name="no_request_empty_response",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        9037369643591427517: MethodInfo(
            name="no_request_with_response",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/WithAndWithoutRequestResponseNoRequestWithResponseResponse",
        ),
        7326057319832554103: MethodInfo(
            name="with_request_no_response",
            request_ident="test.protocols/WithAndWithoutRequestResponseWithRequestNoResponseRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        2877322062572412767: MethodInfo(
            name="with_request_empty_response",
            request_ident="test.protocols/WithAndWithoutRequestResponseWithRequestEmptyResponseRequest",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        6417226585456833969: MethodInfo(
            name="with_request_with_response",
            request_ident="test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_no_request_no_response: typing.TypeAlias = None

    @abstractmethod
    def no_request_no_response(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_no_request_no_response
        ]
        | _MethodResponse_no_request_no_response
    ):
        ...

    _MethodResponse_no_request_empty_response: typing.TypeAlias = None

    @abstractmethod
    def no_request_empty_response(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_no_request_empty_response
        ]
        | _MethodResponse_no_request_empty_response
    ):
        ...

    _MethodResponse_no_request_with_response: typing.TypeAlias = (
        WithAndWithoutRequestResponseNoRequestWithResponseResponse
    )

    @abstractmethod
    def no_request_with_response(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_no_request_with_response
        ]
        | _MethodResponse_no_request_with_response
    ):
        ...

    _MethodResponse_with_request_no_response: typing.TypeAlias = None

    @abstractmethod
    def with_request_no_response(
        self,
        request: WithAndWithoutRequestResponseWithRequestNoResponseRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_with_request_no_response
        ]
        | _MethodResponse_with_request_no_response
    ):
        ...

    _MethodResponse_with_request_empty_response: typing.TypeAlias = None

    @abstractmethod
    def with_request_empty_response(
        self,
        request: WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_with_request_empty_response
        ]
        | _MethodResponse_with_request_empty_response
    ):
        ...

    _MethodResponse_with_request_with_response: typing.TypeAlias = (
        WithAndWithoutRequestResponseWithRequestWithResponseResponse
    )

    @abstractmethod
    def with_request_with_response(
        self,
        request: WithAndWithoutRequestResponseWithRequestWithResponseRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_with_request_with_response
        ]
        | _MethodResponse_with_request_with_response
    ):
        ...

    def on_empty_response(
        self,
    ) -> None:
        msg = None
        self._send_event(5397663296507358806, "test.protocols", msg)

    def on_with_response(
        self,
        *,
        ret: str,
    ) -> None:
        msg = WithAndWithoutRequestResponseOnWithResponseRequest(
            ret,
        )
        self._send_event(5811598563493228968, "test.protocols", msg)


class WithAndWithoutRequestResponseClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def no_request_no_response(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            5413654872775949227,
            "test.protocols",
            msg,
        )

    def no_request_empty_response(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = None
        return self._send_two_way_fidl_request(
            1631193469798418024,
            "test.protocols",
            msg,
            "",
        )

    def no_request_with_response(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        WithAndWithoutRequestResponseNoRequestWithResponseResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            9037369643591427517,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithAndWithoutRequestResponseNoRequestWithResponseResponse"
            ),
        )

    def with_request_no_response(
        self,
        *,
        arg: str,
    ) -> None:
        msg = WithAndWithoutRequestResponseWithRequestNoResponseRequest(
            arg,
        )

        self._send_one_way_fidl_request(
            0,
            7326057319832554103,
            "test.protocols",
            msg,
        )

    def with_request_empty_response(
        self,
        *,
        arg: str,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
            arg,
        )
        return self._send_two_way_fidl_request(
            2877322062572412767,
            "test.protocols",
            msg,
            "",
        )

    def with_request_with_response(
        self,
        *,
        arg: str,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        WithAndWithoutRequestResponseWithRequestWithResponseResponse,
    ]:
        msg = WithAndWithoutRequestResponseWithRequestWithResponseRequest(
            arg,
        )
        return self._send_two_way_fidl_request(
            6417226585456833969,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseResponse"
            ),
        )


class WithAndWithoutRequestResponseEventHandler(
    fidl._client.EventHandlerBase, ABC
):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        5397663296507358806: MethodInfo(
            name="on_empty_response",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        5811598563493228968: MethodInfo(
            name="on_with_response",
            request_ident="test.protocols/WithAndWithoutRequestResponseOnWithResponseRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def on_empty_response(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def on_with_response(
        self,
        request: WithAndWithoutRequestResponseOnWithResponseRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


WithAndWithoutRequestResponseMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/WithAndWithoutRequestResponse"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class WithErrorSyntaxServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        268248568430741139: MethodInfo(
            name="response_as_struct",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.protocols/WithErrorSyntax_ResponseAsStruct_Result",
        ),
        6930994461233198567: MethodInfo(
            name="error_as_primitive",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="test.protocols/WithErrorSyntax_ErrorAsPrimitive_Result",
        ),
        5491891352371277635: MethodInfo(
            name="error_as_enum",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="test.protocols/WithErrorSyntax_ErrorAsEnum_Result",
        ),
        1371676333068455103: MethodInfo(
            name="handle_in_result",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.protocols/WithErrorSyntax_HandleInResult_Result",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_response_as_struct: typing.TypeAlias = typing.Union[
        DomainError,
        WithErrorSyntaxResponseAsStructResponse,
    ]

    @abstractmethod
    def response_as_struct(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_response_as_struct
        ]
        | _MethodResponse_response_as_struct
    ):
        ...

    _MethodResponse_error_as_primitive: typing.TypeAlias = typing.Union[
        DomainError,
        None,
    ]

    @abstractmethod
    def error_as_primitive(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_error_as_primitive
        ]
        | _MethodResponse_error_as_primitive
    ):
        ...

    _MethodResponse_error_as_enum: typing.TypeAlias = typing.Union[
        DomainError,
        None,
    ]

    @abstractmethod
    def error_as_enum(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_error_as_enum]
        | _MethodResponse_error_as_enum
    ):
        ...

    _MethodResponse_handle_in_result: typing.TypeAlias = typing.Union[
        DomainError,
        WithErrorSyntaxHandleInResultResponse,
    ]

    @abstractmethod
    def handle_in_result(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_handle_in_result
        ]
        | _MethodResponse_handle_in_result
    ):
        ...


class WithErrorSyntaxClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def response_as_struct(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, WithErrorSyntaxResponseAsStructResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            268248568430741139,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithErrorSyntax_ResponseAsStruct_Result"
            ),
        )

    def error_as_primitive(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, WithErrorSyntaxErrorAsPrimitiveResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            6930994461233198567,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Result"
            ),
        )

    def error_as_enum(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, WithErrorSyntaxErrorAsEnumResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            5491891352371277635,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithErrorSyntax_ErrorAsEnum_Result"
            ),
        )

    def handle_in_result(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, WithErrorSyntaxHandleInResultResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            1371676333068455103,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithErrorSyntax_HandleInResult_Result"
            ),
        )


class WithErrorSyntaxEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


WithErrorSyntaxMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/WithErrorSyntax"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class WithProtocolEndsServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {
        5870448041025163330: MethodInfo(
            name="client_ends",
            request_ident="test.protocols/WithProtocolEndsClientEndsRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/WithProtocolEndsClientEndsResponse",
        ),
        8115535094437022259: MethodInfo(
            name="server_ends",
            request_ident="test.protocols/WithProtocolEndsServerEndsRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/WithProtocolEndsServerEndsResponse",
        ),
        4076866772260025813: MethodInfo(
            name="struct_containing_ends",
            request_ident="test.protocols/WithProtocolEndsStructContainingEndsRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.protocols/WithProtocolEndsStructContainingEndsResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_client_ends: typing.TypeAlias = (
        WithProtocolEndsClientEndsResponse
    )

    @abstractmethod
    def client_ends(
        self,
        request: WithProtocolEndsClientEndsRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_client_ends]
        | _MethodResponse_client_ends
    ):
        ...

    _MethodResponse_server_ends: typing.TypeAlias = (
        WithProtocolEndsServerEndsResponse
    )

    @abstractmethod
    def server_ends(
        self,
        request: WithProtocolEndsServerEndsRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_server_ends]
        | _MethodResponse_server_ends
    ):
        ...

    _MethodResponse_struct_containing_ends: typing.TypeAlias = (
        WithProtocolEndsStructContainingEndsResponse
    )

    @abstractmethod
    def struct_containing_ends(
        self,
        request: WithProtocolEndsStructContainingEndsRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_struct_containing_ends
        ]
        | _MethodResponse_struct_containing_ends
    ):
        ...


class WithProtocolEndsClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def client_ends(
        self,
        *,
        in_: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, WithProtocolEndsClientEndsResponse
    ]:
        msg = WithProtocolEndsClientEndsRequest(
            in_,
        )
        return self._send_two_way_fidl_request(
            5870448041025163330,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithProtocolEndsClientEndsResponse"
            ),
        )

    def server_ends(
        self,
        *,
        in_: typing.Optional[int],
    ) -> typing.Coroutine[
        typing.Any, typing.Any, WithProtocolEndsServerEndsResponse
    ]:
        msg = WithProtocolEndsServerEndsRequest(
            in_,
        )
        return self._send_two_way_fidl_request(
            8115535094437022259,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithProtocolEndsServerEndsResponse"
            ),
        )

    def struct_containing_ends(
        self,
        *,
        in_: ProtocolEnds,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, WithProtocolEndsStructContainingEndsResponse
    ]:
        msg = WithProtocolEndsStructContainingEndsRequest(
            in_,
        )
        return self._send_two_way_fidl_request(
            4076866772260025813,
            "test.protocols",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.protocols/WithProtocolEndsStructContainingEndsResponse"
            ),
        )


class WithProtocolEndsEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


WithProtocolEndsMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/WithProtocolEnds"
)
