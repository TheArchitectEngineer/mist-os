# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.unknowninteractions"]
add_ir_path(_ir_path)


@dataclass
class UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolStrictEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsClosedProtocolStrictEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolStrictEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolStrictTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayFieldsResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayFieldsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayFieldsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsProtocolStrictTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolFlexibleEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsAjarProtocolFlexibleEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsAjarProtocolStrictEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayTableResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayTableResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = (
        "UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsClosedProtocolStrictEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayTableResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayTableResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolFlexibleEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolStrictEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolStrictEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolStrictTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayTableResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayTableResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolStrictTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayTableErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolFlexibleEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventUnionRequest"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventUnionRequest"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventUnionRequest"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventUnionRequest"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictEventUnionRequest"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayUnionResponse"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayUnionResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayFieldsResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
    ]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
        ] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayTableResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayTableResponse
    ]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayTableResponse
        ] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayTableResponse | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolFlexibleTwoWayTableResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
    ]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
        ] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayUnionResponse | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolFlexibleTwoWayUnionResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayResult:
    _response: typing.Optional[None]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayFieldsErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolStrictTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayTableErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolStrictTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolStrictTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayUnionErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayUnionErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolStrictTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class UnknownInteractionsAjarProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, MethodInfo] = {
        956561744635167883: MethodInfo(
            name="strict_one_way",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        2483093178939638607: MethodInfo(
            name="flexible_one_way",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        364341676962177080: MethodInfo(
            name="strict_two_way",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        1821674633227946298: MethodInfo(
            name="strict_two_way_fields",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse",
        ),
        5870221221557233361: MethodInfo(
            name="strict_two_way_union",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse",
        ),
        8038805778859962068: MethodInfo(
            name="strict_two_way_table",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayTableResponse",
        ),
        6577335136969723910: MethodInfo(
            name="strict_two_way_err",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result",
        ),
        595881957484758745: MethodInfo(
            name="strict_two_way_fields_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result",
        ),
        3224530777258896533: MethodInfo(
            name="strict_two_way_union_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result",
        ),
        3515589146717969463: MethodInfo(
            name="strict_two_way_table_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_strict_one_way: typing.TypeAlias = None

    @abstractmethod
    def strict_one_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_one_way]
        | _MethodResponse_strict_one_way
    ):
        ...

    _MethodResponse_flexible_one_way: typing.TypeAlias = None

    @abstractmethod
    def flexible_one_way(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_one_way
        ]
        | _MethodResponse_flexible_one_way
    ):
        ...

    _MethodResponse_strict_two_way: typing.TypeAlias = None

    @abstractmethod
    def strict_two_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_two_way]
        | _MethodResponse_strict_two_way
    ):
        ...

    _MethodResponse_strict_two_way_fields: typing.TypeAlias = (
        UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
    )

    @abstractmethod
    def strict_two_way_fields(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields
        ]
        | _MethodResponse_strict_two_way_fields
    ):
        ...

    _MethodResponse_strict_two_way_union: typing.TypeAlias = (
        UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
    )

    @abstractmethod
    def strict_two_way_union(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_union
        ]
        | _MethodResponse_strict_two_way_union
    ):
        ...

    _MethodResponse_strict_two_way_table: typing.TypeAlias = (
        UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
    )

    @abstractmethod
    def strict_two_way_table(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_table
        ]
        | _MethodResponse_strict_two_way_table
    ):
        ...

    _MethodResponse_strict_two_way_err: typing.TypeAlias = typing.Union[
        DomainError,
        None,
    ]

    @abstractmethod
    def strict_two_way_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_err
        ]
        | _MethodResponse_strict_two_way_err
    ):
        ...

    _MethodResponse_strict_two_way_fields_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
    ]

    @abstractmethod
    def strict_two_way_fields_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields_err
        ]
        | _MethodResponse_strict_two_way_fields_err
    ):
        ...

    _MethodResponse_strict_two_way_union_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ]

    @abstractmethod
    def strict_two_way_union_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_union_err
        ]
        | _MethodResponse_strict_two_way_union_err
    ):
        ...

    _MethodResponse_strict_two_way_table_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse,
    ]

    @abstractmethod
    def strict_two_way_table_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_table_err
        ]
        | _MethodResponse_strict_two_way_table_err
    ):
        ...

    def strict_event(
        self,
    ) -> None:
        msg = None
        self._send_event(6927291151663612592, "test.unknowninteractions", msg)

    def strict_event_fields(
        self,
        *,
        some_field: int,
    ) -> None:
        msg = UnknownInteractionsAjarProtocolStrictEventFieldsRequest(
            some_field,
        )
        self._send_event(5838220329633564521, "test.unknowninteractions", msg)

    def strict_event_union(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsAjarProtocolStrictEventUnionRequest(
            some_field,
        )
        self._send_event(6303151946645602671, "test.unknowninteractions", msg)

    def strict_event_table(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsAjarProtocolStrictEventTableRequest(
            some_field,
        )
        self._send_event(659277224687564957, "test.unknowninteractions", msg)

    def flexible_event(
        self,
    ) -> None:
        msg = None
        self._send_event(1281760452005010931, "test.unknowninteractions", msg)

    def flexible_event_fields(
        self,
        *,
        some_field: int,
    ) -> None:
        msg = UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest(
            some_field,
        )
        self._send_event(4298964238728681570, "test.unknowninteractions", msg)

    def flexible_event_union(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsAjarProtocolFlexibleEventUnionRequest(
            some_field,
        )
        self._send_event(8950943792372972717, "test.unknowninteractions", msg)

    def flexible_event_table(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsAjarProtocolFlexibleEventTableRequest(
            some_field,
        )
        self._send_event(705539350563403440, "test.unknowninteractions", msg)


class UnknownInteractionsAjarProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.unknowninteractions"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def strict_one_way(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            956561744635167883,
            "test.unknowninteractions",
            msg,
        )

    def flexible_one_way(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            2483093178939638607,
            "test.unknowninteractions",
            msg,
        )

    def strict_two_way(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = None
        return self._send_two_way_fidl_request(
            364341676962177080,
            "test.unknowninteractions",
            msg,
            "",
        )

    def strict_two_way_fields(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            1821674633227946298,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse"
            ),
        )

    def strict_two_way_union(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            5870221221557233361,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse"
            ),
        )

    def strict_two_way_table(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsAjarProtocolStrictTwoWayTableResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            8038805778859962068,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayTableResponse"
            ),
        )

    def strict_two_way_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsAjarProtocolStrictTwoWayErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            6577335136969723910,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result"
            ),
        )

    def strict_two_way_fields_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            595881957484758745,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result"
            ),
        )

    def strict_two_way_union_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            3224530777258896533,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result"
            ),
        )

    def strict_two_way_table_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            3515589146717969463,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result"
            ),
        )


class UnknownInteractionsAjarProtocolEventHandler(
    fidl._client.EventHandlerBase, ABC
):
    __fidl_kind__ = "event_handler"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, MethodInfo] = {
        6927291151663612592: MethodInfo(
            name="strict_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        5838220329633564521: MethodInfo(
            name="strict_event_fields",
            request_ident="test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventFieldsRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        6303151946645602671: MethodInfo(
            name="strict_event_union",
            request_ident="test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventUnionRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        659277224687564957: MethodInfo(
            name="strict_event_table",
            request_ident="test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventTableRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        1281760452005010931: MethodInfo(
            name="flexible_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        4298964238728681570: MethodInfo(
            name="flexible_event_fields",
            request_ident="test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        8950943792372972717: MethodInfo(
            name="flexible_event_union",
            request_ident="test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventUnionRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        705539350563403440: MethodInfo(
            name="flexible_event_table",
            request_ident="test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventTableRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def strict_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_fields(
        self,
        request: UnknownInteractionsAjarProtocolStrictEventFieldsRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_union(
        self,
        request: UnknownInteractionsAjarProtocolStrictEventUnionRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_table(
        self,
        request: UnknownInteractionsAjarProtocolStrictEventTableRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event_fields(
        self,
        request: UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event_union(
        self,
        request: UnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event_table(
        self,
        request: UnknownInteractionsAjarProtocolFlexibleEventTableRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


UnknownInteractionsAjarProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.unknowninteractions/UnknownInteractionsAjarProtocol"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class UnknownInteractionsClosedProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, MethodInfo] = {
        401526495318825508: MethodInfo(
            name="strict_one_way",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        6834828562275693047: MethodInfo(
            name="strict_two_way",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        1379139029283639891: MethodInfo(
            name="strict_two_way_fields",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse",
        ),
        7544414847426850727: MethodInfo(
            name="strict_two_way_union",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse",
        ),
        7947328131967870853: MethodInfo(
            name="strict_two_way_table",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayTableResponse",
        ),
        5738532966428790074: MethodInfo(
            name="strict_two_way_err",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result",
        ),
        802395819586836733: MethodInfo(
            name="strict_two_way_fields_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result",
        ),
        925029359463709824: MethodInfo(
            name="strict_two_way_union_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result",
        ),
        1260407702860823440: MethodInfo(
            name="strict_two_way_table_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_strict_one_way: typing.TypeAlias = None

    @abstractmethod
    def strict_one_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_one_way]
        | _MethodResponse_strict_one_way
    ):
        ...

    _MethodResponse_strict_two_way: typing.TypeAlias = None

    @abstractmethod
    def strict_two_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_two_way]
        | _MethodResponse_strict_two_way
    ):
        ...

    _MethodResponse_strict_two_way_fields: typing.TypeAlias = (
        UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
    )

    @abstractmethod
    def strict_two_way_fields(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields
        ]
        | _MethodResponse_strict_two_way_fields
    ):
        ...

    _MethodResponse_strict_two_way_union: typing.TypeAlias = (
        UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
    )

    @abstractmethod
    def strict_two_way_union(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_union
        ]
        | _MethodResponse_strict_two_way_union
    ):
        ...

    _MethodResponse_strict_two_way_table: typing.TypeAlias = (
        UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
    )

    @abstractmethod
    def strict_two_way_table(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_table
        ]
        | _MethodResponse_strict_two_way_table
    ):
        ...

    _MethodResponse_strict_two_way_err: typing.TypeAlias = typing.Union[
        DomainError,
        None,
    ]

    @abstractmethod
    def strict_two_way_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_err
        ]
        | _MethodResponse_strict_two_way_err
    ):
        ...

    _MethodResponse_strict_two_way_fields_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    ]

    @abstractmethod
    def strict_two_way_fields_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields_err
        ]
        | _MethodResponse_strict_two_way_fields_err
    ):
        ...

    _MethodResponse_strict_two_way_union_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ]

    @abstractmethod
    def strict_two_way_union_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_union_err
        ]
        | _MethodResponse_strict_two_way_union_err
    ):
        ...

    _MethodResponse_strict_two_way_table_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse,
    ]

    @abstractmethod
    def strict_two_way_table_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_table_err
        ]
        | _MethodResponse_strict_two_way_table_err
    ):
        ...

    def strict_event(
        self,
    ) -> None:
        msg = None
        self._send_event(760799297757210939, "test.unknowninteractions", msg)

    def strict_event_fields(
        self,
        *,
        some_field: int,
    ) -> None:
        msg = UnknownInteractionsClosedProtocolStrictEventFieldsRequest(
            some_field,
        )
        self._send_event(6736355582617074292, "test.unknowninteractions", msg)

    def strict_event_union(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsClosedProtocolStrictEventUnionRequest(
            some_field,
        )
        self._send_event(4288682345454280036, "test.unknowninteractions", msg)

    def strict_event_table(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsClosedProtocolStrictEventTableRequest(
            some_field,
        )
        self._send_event(2871682464255309246, "test.unknowninteractions", msg)


class UnknownInteractionsClosedProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.unknowninteractions"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def strict_one_way(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            401526495318825508,
            "test.unknowninteractions",
            msg,
        )

    def strict_two_way(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = None
        return self._send_two_way_fidl_request(
            6834828562275693047,
            "test.unknowninteractions",
            msg,
            "",
        )

    def strict_two_way_fields(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            1379139029283639891,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse"
            ),
        )

    def strict_two_way_union(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7544414847426850727,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse"
            ),
        )

    def strict_two_way_table(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsClosedProtocolStrictTwoWayTableResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7947328131967870853,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayTableResponse"
            ),
        )

    def strict_two_way_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsClosedProtocolStrictTwoWayErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            5738532966428790074,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result"
            ),
        )

    def strict_two_way_fields_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            802395819586836733,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result"
            ),
        )

    def strict_two_way_union_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            925029359463709824,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result"
            ),
        )

    def strict_two_way_table_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            1260407702860823440,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result"
            ),
        )


class UnknownInteractionsClosedProtocolEventHandler(
    fidl._client.EventHandlerBase, ABC
):
    __fidl_kind__ = "event_handler"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, MethodInfo] = {
        760799297757210939: MethodInfo(
            name="strict_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        6736355582617074292: MethodInfo(
            name="strict_event_fields",
            request_ident="test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventFieldsRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        4288682345454280036: MethodInfo(
            name="strict_event_union",
            request_ident="test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventUnionRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        2871682464255309246: MethodInfo(
            name="strict_event_table",
            request_ident="test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventTableRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def strict_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_fields(
        self,
        request: UnknownInteractionsClosedProtocolStrictEventFieldsRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_union(
        self,
        request: UnknownInteractionsClosedProtocolStrictEventUnionRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_table(
        self,
        request: UnknownInteractionsClosedProtocolStrictEventTableRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


UnknownInteractionsClosedProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.unknowninteractions/UnknownInteractionsClosedProtocol"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class UnknownInteractionsProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, MethodInfo] = {
        5652707722400962470: MethodInfo(
            name="strict_one_way",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        583422011583300678: MethodInfo(
            name="flexible_one_way",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        8308184097687583042: MethodInfo(
            name="strict_two_way",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        3697260130745060067: MethodInfo(
            name="strict_two_way_fields",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayFieldsResponse",
        ),
        2455165891480464557: MethodInfo(
            name="strict_two_way_union",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayUnionResponse",
        ),
        8389853739594228663: MethodInfo(
            name="strict_two_way_table",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayTableResponse",
        ),
        7862264614495172967: MethodInfo(
            name="strict_two_way_err",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Result",
        ),
        2414673307948662059: MethodInfo(
            name="strict_two_way_fields_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result",
        ),
        4988571416540160202: MethodInfo(
            name="strict_two_way_union_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result",
        ),
        5487292735562672344: MethodInfo(
            name="strict_two_way_table_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Result",
        ),
        334879577560091516: MethodInfo(
            name="flexible_two_way",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Result",
        ),
        4257018954691721778: MethodInfo(
            name="flexible_two_way_fields",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Result",
        ),
        4913460516188409782: MethodInfo(
            name="flexible_two_way_union",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result",
        ),
        9171907422498283911: MethodInfo(
            name="flexible_two_way_table",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Result",
        ),
        6999736795697216519: MethodInfo(
            name="flexible_two_way_err",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Result",
        ),
        1093132337162001157: MethodInfo(
            name="flexible_two_way_fields_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result",
        ),
        2410151523245950935: MethodInfo(
            name="flexible_two_way_union_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result",
        ),
        7893309626427980786: MethodInfo(
            name="flexible_two_way_table_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_strict_one_way: typing.TypeAlias = None

    @abstractmethod
    def strict_one_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_one_way]
        | _MethodResponse_strict_one_way
    ):
        ...

    _MethodResponse_flexible_one_way: typing.TypeAlias = None

    @abstractmethod
    def flexible_one_way(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_one_way
        ]
        | _MethodResponse_flexible_one_way
    ):
        ...

    _MethodResponse_strict_two_way: typing.TypeAlias = None

    @abstractmethod
    def strict_two_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_two_way]
        | _MethodResponse_strict_two_way
    ):
        ...

    _MethodResponse_strict_two_way_fields: typing.TypeAlias = (
        UnknownInteractionsProtocolStrictTwoWayFieldsResponse
    )

    @abstractmethod
    def strict_two_way_fields(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields
        ]
        | _MethodResponse_strict_two_way_fields
    ):
        ...

    _MethodResponse_strict_two_way_union: typing.TypeAlias = (
        UnknownInteractionsProtocolStrictTwoWayUnionResponse
    )

    @abstractmethod
    def strict_two_way_union(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_union
        ]
        | _MethodResponse_strict_two_way_union
    ):
        ...

    _MethodResponse_strict_two_way_table: typing.TypeAlias = (
        UnknownInteractionsProtocolStrictTwoWayTableResponse
    )

    @abstractmethod
    def strict_two_way_table(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_table
        ]
        | _MethodResponse_strict_two_way_table
    ):
        ...

    _MethodResponse_strict_two_way_err: typing.TypeAlias = typing.Union[
        DomainError,
        None,
    ]

    @abstractmethod
    def strict_two_way_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_err
        ]
        | _MethodResponse_strict_two_way_err
    ):
        ...

    _MethodResponse_strict_two_way_fields_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
    ]

    @abstractmethod
    def strict_two_way_fields_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields_err
        ]
        | _MethodResponse_strict_two_way_fields_err
    ):
        ...

    _MethodResponse_strict_two_way_union_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
    ]

    @abstractmethod
    def strict_two_way_union_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_union_err
        ]
        | _MethodResponse_strict_two_way_union_err
    ):
        ...

    _MethodResponse_strict_two_way_table_err: typing.TypeAlias = typing.Union[
        DomainError,
        UnknownInteractionsProtocolStrictTwoWayTableErrResponse,
    ]

    @abstractmethod
    def strict_two_way_table_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_table_err
        ]
        | _MethodResponse_strict_two_way_table_err
    ):
        ...

    _MethodResponse_flexible_two_way: typing.TypeAlias = typing.Union[
        FrameworkError,
        None,
    ]

    @abstractmethod
    def flexible_two_way(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way
        ]
        | _MethodResponse_flexible_two_way
    ):
        ...

    _MethodResponse_flexible_two_way_fields: typing.TypeAlias = typing.Union[
        FrameworkError,
        UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
    ]

    @abstractmethod
    def flexible_two_way_fields(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_fields
        ]
        | _MethodResponse_flexible_two_way_fields
    ):
        ...

    _MethodResponse_flexible_two_way_union: typing.TypeAlias = typing.Union[
        FrameworkError,
        UnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
    ]

    @abstractmethod
    def flexible_two_way_union(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_union
        ]
        | _MethodResponse_flexible_two_way_union
    ):
        ...

    _MethodResponse_flexible_two_way_table: typing.TypeAlias = typing.Union[
        FrameworkError,
        UnknownInteractionsProtocolFlexibleTwoWayTableResponse,
    ]

    @abstractmethod
    def flexible_two_way_table(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_table
        ]
        | _MethodResponse_flexible_two_way_table
    ):
        ...

    _MethodResponse_flexible_two_way_err: typing.TypeAlias = typing.Union[
        FrameworkError,
        DomainError,
        None,
    ]

    @abstractmethod
    def flexible_two_way_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_err
        ]
        | _MethodResponse_flexible_two_way_err
    ):
        ...

    _MethodResponse_flexible_two_way_fields_err: typing.TypeAlias = (
        typing.Union[
            FrameworkError,
            DomainError,
            UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
        ]
    )

    @abstractmethod
    def flexible_two_way_fields_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_fields_err
        ]
        | _MethodResponse_flexible_two_way_fields_err
    ):
        ...

    _MethodResponse_flexible_two_way_union_err: typing.TypeAlias = typing.Union[
        FrameworkError,
        DomainError,
        UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    ]

    @abstractmethod
    def flexible_two_way_union_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_union_err
        ]
        | _MethodResponse_flexible_two_way_union_err
    ):
        ...

    _MethodResponse_flexible_two_way_table_err: typing.TypeAlias = typing.Union[
        FrameworkError,
        DomainError,
        UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse,
    ]

    @abstractmethod
    def flexible_two_way_table_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_table_err
        ]
        | _MethodResponse_flexible_two_way_table_err
    ):
        ...

    def strict_event(
        self,
    ) -> None:
        msg = None
        self._send_event(685715276307386305, "test.unknowninteractions", msg)

    def strict_event_fields(
        self,
        *,
        some_field: int,
    ) -> None:
        msg = UnknownInteractionsProtocolStrictEventFieldsRequest(
            some_field,
        )
        self._send_event(8896208255987935026, "test.unknowninteractions", msg)

    def strict_event_union(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsProtocolStrictEventUnionRequest(
            some_field,
        )
        self._send_event(3919175221694221274, "test.unknowninteractions", msg)

    def strict_event_table(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsProtocolStrictEventTableRequest(
            some_field,
        )
        self._send_event(2711448698318579984, "test.unknowninteractions", msg)

    def flexible_event(
        self,
    ) -> None:
        msg = None
        self._send_event(7042257263728687206, "test.unknowninteractions", msg)

    def flexible_event_fields(
        self,
        *,
        some_field: int,
    ) -> None:
        msg = UnknownInteractionsProtocolFlexibleEventFieldsRequest(
            some_field,
        )
        self._send_event(3613822014516746241, "test.unknowninteractions", msg)

    def flexible_event_union(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsProtocolFlexibleEventUnionRequest(
            some_field,
        )
        self._send_event(2499446536152409191, "test.unknowninteractions", msg)

    def flexible_event_table(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = UnknownInteractionsProtocolFlexibleEventTableRequest(
            some_field,
        )
        self._send_event(5724881371349617120, "test.unknowninteractions", msg)


class UnknownInteractionsProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.unknowninteractions"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def strict_one_way(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            5652707722400962470,
            "test.unknowninteractions",
            msg,
        )

    def flexible_one_way(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            583422011583300678,
            "test.unknowninteractions",
            msg,
        )

    def strict_two_way(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = None
        return self._send_two_way_fidl_request(
            8308184097687583042,
            "test.unknowninteractions",
            msg,
            "",
        )

    def strict_two_way_fields(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolStrictTwoWayFieldsResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            3697260130745060067,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayFieldsResponse"
            ),
        )

    def strict_two_way_union(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolStrictTwoWayUnionResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            2455165891480464557,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayUnionResponse"
            ),
        )

    def strict_two_way_table(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolStrictTwoWayTableResponse,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            8389853739594228663,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayTableResponse"
            ),
        )

    def strict_two_way_err(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, UnknownInteractionsProtocolStrictTwoWayErrResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7862264614495172967,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Result"
            ),
        )

    def strict_two_way_fields_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolStrictTwoWayFieldsErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            2414673307948662059,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result"
            ),
        )

    def strict_two_way_union_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolStrictTwoWayUnionErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            4988571416540160202,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result"
            ),
        )

    def strict_two_way_table_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolStrictTwoWayTableErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            5487292735562672344,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Result"
            ),
        )

    def flexible_two_way(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, UnknownInteractionsProtocolFlexibleTwoWayResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            334879577560091516,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Result"
            ),
        )

    def flexible_two_way_fields(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolFlexibleTwoWayFieldsResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            4257018954691721778,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Result"
            ),
        )

    def flexible_two_way_union(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolFlexibleTwoWayUnionResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            4913460516188409782,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result"
            ),
        )

    def flexible_two_way_table(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolFlexibleTwoWayTableResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            9171907422498283911,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Result"
            ),
        )

    def flexible_two_way_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolFlexibleTwoWayErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            6999736795697216519,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Result"
            ),
        )

    def flexible_two_way_fields_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            1093132337162001157,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result"
            ),
        )

    def flexible_two_way_union_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            2410151523245950935,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result"
            ),
        )

    def flexible_two_way_table_err(
        self,
    ) -> typing.Coroutine[
        typing.Any,
        typing.Any,
        UnknownInteractionsProtocolFlexibleTwoWayTableErrResult,
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7893309626427980786,
            "test.unknowninteractions",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result"
            ),
        )


class UnknownInteractionsProtocolEventHandler(
    fidl._client.EventHandlerBase, ABC
):
    __fidl_kind__ = "event_handler"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, MethodInfo] = {
        685715276307386305: MethodInfo(
            name="strict_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        8896208255987935026: MethodInfo(
            name="strict_event_fields",
            request_ident="test.unknowninteractions/UnknownInteractionsProtocolStrictEventFieldsRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        3919175221694221274: MethodInfo(
            name="strict_event_union",
            request_ident="test.unknowninteractions/UnknownInteractionsProtocolStrictEventUnionRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        2711448698318579984: MethodInfo(
            name="strict_event_table",
            request_ident="test.unknowninteractions/UnknownInteractionsProtocolStrictEventTableRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        7042257263728687206: MethodInfo(
            name="flexible_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        3613822014516746241: MethodInfo(
            name="flexible_event_fields",
            request_ident="test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventFieldsRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        2499446536152409191: MethodInfo(
            name="flexible_event_union",
            request_ident="test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventUnionRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        5724881371349617120: MethodInfo(
            name="flexible_event_table",
            request_ident="test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventTableRequest",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def strict_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_fields(
        self,
        request: UnknownInteractionsProtocolStrictEventFieldsRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_union(
        self,
        request: UnknownInteractionsProtocolStrictEventUnionRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def strict_event_table(
        self,
        request: UnknownInteractionsProtocolStrictEventTableRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event_fields(
        self,
        request: UnknownInteractionsProtocolFlexibleEventFieldsRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event_union(
        self,
        request: UnknownInteractionsProtocolFlexibleEventUnionRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event_table(
        self,
        request: UnknownInteractionsProtocolFlexibleEventTableRequest,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


UnknownInteractionsProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.unknowninteractions/UnknownInteractionsProtocol"
)
