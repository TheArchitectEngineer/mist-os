# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl
from fidl._ir import get_fidl_ir_map

_ir_path = get_fidl_ir_map()["test.experimentalmaybefromalias"]
add_ir_path(_ir_path)


@dataclass
class Testing:
    u1: int
    u2: typing.Sequence[int]
    u3: typing.Sequence[int]
    u4: typing.Sequence[typing.Sequence[int]]
    u5: typing.Sequence[typing.Sequence[int]]
    u6: typing.Sequence[typing.Sequence[int]]
    u7: typing.Sequence[typing.Sequence[int]]
    v1: typing.Optional[typing.Sequence[int]]
    v2: typing.Sequence[typing.Optional[typing.Sequence[int]]]
    v3: typing.Sequence[typing.Optional[typing.Sequence[int]]]
    a1: typing.Sequence[int]
    a2: typing.Sequence[typing.Sequence[int]]
    a3: typing.Sequence[typing.Sequence[int]]
    r1: typing.Optional[int]
    r2: typing.Sequence[typing.Optional[int]]
    r3: typing.Sequence[typing.Optional[int]]
    b1: typing.Sequence[int]
    b2: typing.Sequence[typing.Sequence[int]]
    b3: typing.Sequence[typing.Sequence[int]]
    s1: str
    s2: typing.Sequence[str]
    s3: typing.Sequence[str]
    vv1: typing.Sequence[int]
    vv2: typing.Sequence[typing.Sequence[int]]
    vv3: typing.Sequence[typing.Sequence[int]]
    aa1: typing.Sequence[int]
    aa2: typing.Sequence[typing.Sequence[int]]
    aa3: typing.Sequence[typing.Sequence[int]]

    __fidl_kind__ = "struct"
    __fidl_type__ = "Testing"
    __fidl_raw_type__ = "test.experimentalmaybefromalias/Testing"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.experimentalmaybefromalias",
            "test.experimentalmaybefromalias/Testing",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "u1": None,  # type: ignore[arg-type,unused-ignore]
                "u2": None,  # type: ignore[arg-type,unused-ignore]
                "u3": None,  # type: ignore[arg-type,unused-ignore]
                "u4": None,  # type: ignore[arg-type,unused-ignore]
                "u5": None,  # type: ignore[arg-type,unused-ignore]
                "u6": None,  # type: ignore[arg-type,unused-ignore]
                "u7": None,  # type: ignore[arg-type,unused-ignore]
                "v1": None,  # type: ignore[arg-type,unused-ignore]
                "v2": None,  # type: ignore[arg-type,unused-ignore]
                "v3": None,  # type: ignore[arg-type,unused-ignore]
                "a1": None,  # type: ignore[arg-type,unused-ignore]
                "a2": None,  # type: ignore[arg-type,unused-ignore]
                "a3": None,  # type: ignore[arg-type,unused-ignore]
                "r1": None,  # type: ignore[arg-type,unused-ignore]
                "r2": None,  # type: ignore[arg-type,unused-ignore]
                "r3": None,  # type: ignore[arg-type,unused-ignore]
                "b1": None,  # type: ignore[arg-type,unused-ignore]
                "b2": None,  # type: ignore[arg-type,unused-ignore]
                "b3": None,  # type: ignore[arg-type,unused-ignore]
                "s1": None,  # type: ignore[arg-type,unused-ignore]
                "s2": None,  # type: ignore[arg-type,unused-ignore]
                "s3": None,  # type: ignore[arg-type,unused-ignore]
                "vv1": None,  # type: ignore[arg-type,unused-ignore]
                "vv2": None,  # type: ignore[arg-type,unused-ignore]
                "vv3": None,  # type: ignore[arg-type,unused-ignore]
                "aa1": None,  # type: ignore[arg-type,unused-ignore]
                "aa2": None,  # type: ignore[arg-type,unused-ignore]
                "aa3": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


# Generated aliases
AliasOfArray = typing.Sequence[int]
AliasOfArrayContainingAliasOfArray = typing.Sequence[int]
AliasOfBytes = typing.Sequence[int]
AliasOfRequest = typing.Optional[int]
AliasOfString = str
AliasOfVectorContainingAliasOfVector = typing.Sequence[int]
U64 = int
Vector = typing.Optional[typing.Sequence[int]]


from fidl._client import EventHandlerBase, FidlClient
from fidl._server import ServerBase
from fidl._fidl_common import (
    DomainError,
    FrameworkError,
    MethodInfo,
    FidlProtocolMarker,
    normalize_identifier,
)

from abc import abstractmethod, ABC


class MyProtocolServer(ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.experimentalmaybefromalias"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class MyProtocolClient(FidlClient):
    __fidl_kind__ = "client"
    library = "test.experimentalmaybefromalias"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class MyProtocolEventHandler(EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.experimentalmaybefromalias"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


MyProtocolMarker = FidlProtocolMarker(
    "(nondiscoverable) test.experimentalmaybefromalias/MyProtocol"
)
