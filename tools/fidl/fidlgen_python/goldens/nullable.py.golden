# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.nullable"]
add_ir_path(_ir_path)


@dataclass
class Int32Wrapper:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "Int32Wrapper"
    __fidl_raw_type__ = "test.nullable/Int32Wrapper"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/Int32Wrapper"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


@dataclass
class SimpleProtocolAddRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "SimpleProtocolAddRequest"
    __fidl_raw_type__ = "test.nullable/SimpleProtocolAddRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/SimpleProtocolAddRequest"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
            }
        )


@dataclass
class SimpleProtocolAddResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    sum_: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "SimpleProtocolAddResponse"
    __fidl_raw_type__ = "test.nullable/SimpleProtocolAddResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/SimpleProtocolAddResponse"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "sum_": None,
            }
        )


@dataclass
class StructWithNullableHandle:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableHandle"
    __fidl_raw_type__ = "test.nullable/StructWithNullableHandle"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/StructWithNullableHandle"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


@dataclass
class StructWithNullableProtocol:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableProtocol"
    __fidl_raw_type__ = "test.nullable/StructWithNullableProtocol"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/StructWithNullableProtocol"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


@dataclass
class StructWithNullableRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableRequest"
    __fidl_raw_type__ = "test.nullable/StructWithNullableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/StructWithNullableRequest"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


@dataclass
class StructWithNullableString:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: typing.Optional[str] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableString"
    __fidl_raw_type__ = "test.nullable/StructWithNullableString"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/StructWithNullableString"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


@dataclass
class StructWithNullableStruct:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: typing.Optional[Int32Wrapper] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableStruct"
    __fidl_raw_type__ = "test.nullable/StructWithNullableStruct"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/StructWithNullableStruct"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


@dataclass
class StructWithNullableUnion:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: typing.Optional[SimpleUnion] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableUnion"
    __fidl_raw_type__ = "test.nullable/StructWithNullableUnion"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/StructWithNullableUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


@dataclass
class StructWithNullableVector:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    val: typing.Optional[typing.Sequence[int]] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "StructWithNullableVector"
    __fidl_raw_type__ = "test.nullable/StructWithNullableVector"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/StructWithNullableVector"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "val": None,
            }
        )


class SimpleUnion:
    _a: typing.Optional[int]
    _b: typing.Optional[float]

    __fidl_kind__ = "union"
    __fidl_type__ = "SimpleUnion"
    __fidl_raw_type__ = "test.nullable/SimpleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.a != other.a:
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.a:
            variant = f"a={self.a!r}"
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        a: typing.Optional[int] = None,
        b: typing.Optional[float] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if a is not None:
            self._a = a
            variants.append("a")
            number_of_variants += 1
        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def a(self) -> int | None:
        return getattr(self, "_a", None)

    @property
    def b(self) -> float | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.nullable", "test.nullable/SimpleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class SimpleProtocolServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.nullable"
    method_map: typing.Dict[int, MethodInfo] = {
        9142761280038437494: MethodInfo(
            name="add",
            request_ident="test.nullable/SimpleProtocolAddRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.nullable/SimpleProtocolAddResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_add: typing.TypeAlias = SimpleProtocolAddResponse

    @abstractmethod
    def add(
        self,
        request: SimpleProtocolAddRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_add]
        | _MethodResponse_add
    ):
        ...


class SimpleProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.nullable"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def add(
        self,
        *,
        a: int,
        b: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, SimpleProtocolAddResponse]:
        msg = SimpleProtocolAddRequest(
            a,
            b,
        )
        return self._send_two_way_fidl_request(
            9142761280038437494,
            "test.nullable",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.nullable/SimpleProtocolAddResponse"
            ),
        )


class SimpleProtocolEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.nullable"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


SimpleProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.nullable/SimpleProtocol"
)
