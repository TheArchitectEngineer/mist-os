# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.inheritance"]
add_ir_path(_ir_path)


@dataclass
class SuperFooRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    s: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "SuperFooRequest"
    __fidl_raw_type__ = "test.inheritance/SuperFooRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.inheritance", "test.inheritance/SuperFooRequest"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "s": None,
            }
        )


@dataclass
class SuperFooResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    y: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "SuperFooResponse"
    __fidl_raw_type__ = "test.inheritance/SuperFooResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.inheritance", "test.inheritance/SuperFooResponse"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "y": None,
            }
        )


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class SubServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.inheritance"
    method_map: typing.Dict[int, MethodInfo] = {
        7540745593380780216: MethodInfo(
            name="foo",
            request_ident="test.inheritance/SuperFooRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.inheritance/SuperFooResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_foo: typing.TypeAlias = SuperFooResponse

    @abstractmethod
    def foo(
        self,
        request: SuperFooRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_foo]
        | _MethodResponse_foo
    ):
        ...


class SubClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.inheritance"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def foo(
        self,
        *,
        s: str,
    ) -> typing.Coroutine[typing.Any, typing.Any, SuperFooResponse]:
        msg = SuperFooRequest(
            s,
        )
        return self._send_two_way_fidl_request(
            7540745593380780216,
            "test.inheritance",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.inheritance/SuperFooResponse"
            ),
        )


class SubEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.inheritance"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


SubMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.inheritance/sub"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class SuperServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.inheritance"
    method_map: typing.Dict[int, MethodInfo] = {
        7540745593380780216: MethodInfo(
            name="foo",
            request_ident="test.inheritance/SuperFooRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="test.inheritance/SuperFooResponse",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_foo: typing.TypeAlias = SuperFooResponse

    @abstractmethod
    def foo(
        self,
        request: SuperFooRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_foo]
        | _MethodResponse_foo
    ):
        ...


class SuperClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.inheritance"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def foo(
        self,
        *,
        s: str,
    ) -> typing.Coroutine[typing.Any, typing.Any, SuperFooResponse]:
        msg = SuperFooRequest(
            s,
        )
        return self._send_two_way_fidl_request(
            7540745593380780216,
            "test.inheritance",
            msg,
            fidl._fidl_common.normalize_identifier(
                "test.inheritance/SuperFooResponse"
            ),
        )


class SuperEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.inheritance"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


SuperMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.inheritance/super"
)
