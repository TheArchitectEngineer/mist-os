# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl
from fidl._ir import get_fidl_ir_map

_ir_path = get_fidl_ir_map()["test.bindingsdenylist"]
add_ir_path(_ir_path)


@dataclass
class DenyEachBindingOnlyDenyCppRequest:
    a: bool

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyCppRequest"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBindingOnlyDenyCppRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBindingOnlyDenyCppRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenyDartRequest:
    a: bool

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyDartRequest"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBindingOnlyDenyDartRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBindingOnlyDenyDartRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenyGoRequest:
    a: bool

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyGoRequest"
    __fidl_raw_type__ = "test.bindingsdenylist/DenyEachBindingOnlyDenyGoRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBindingOnlyDenyGoRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenyRustRequest:
    a: bool

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyRustRequest"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBindingOnlyDenyRustRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBindingOnlyDenyRustRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenySyzkallerRequest:
    a: bool

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenySyzkallerRequest"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBindingOnlyDenySyzkallerRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBindingOnlyDenySyzkallerRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenyCppResponse:
    b: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyCppResponse"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyCpp_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyCpp_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "b": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenyDartResponse:
    b: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyDartResponse"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyDart_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyDart_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "b": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenyGoResponse:
    b: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyGoResponse"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyGo_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyGo_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "b": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenyRustResponse:
    b: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenyRustResponse"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyRust_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyRust_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "b": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class DenyEachBindingOnlyDenySyzkallerResponse:
    b: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "DenyEachBindingOnlyDenySyzkallerResponse"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenySyzkaller_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenySyzkaller_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "b": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class MemberOnlyAppearsInImportingLibrary:
    a: bool

    __fidl_kind__ = "struct"
    __fidl_type__ = "MemberOnlyAppearsInImportingLibrary"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/MemberOnlyAppearsInImportingLibrary"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/MemberOnlyAppearsInImportingLibrary",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class OnlyAppearsInImportingLibrary:
    member_only_appears_in_importing_library: MemberOnlyAppearsInImportingLibrary

    __fidl_kind__ = "struct"
    __fidl_type__ = "OnlyAppearsInImportingLibrary"
    __fidl_raw_type__ = "test.bindingsdenylist/OnlyAppearsInImportingLibrary"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/OnlyAppearsInImportingLibrary",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "member_only_appears_in_importing_library": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class OnlyPython:
    __fidl_kind__ = "table"
    __fidl_type__ = "OnlyPython"
    __fidl_raw_type__ = "test.bindingsdenylist/OnlyPython"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.bindingsdenylist", "test.bindingsdenylist/OnlyPython"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class DenyEachBindingOnlyDenyCppResult:
    _response: typing.Optional[DenyEachBindingOnlyDenyCppResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "DenyEachBindingOnlyDenyCppResult"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyCpp_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[DenyEachBindingOnlyDenyCppResponse] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> DenyEachBindingOnlyDenyCppResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyCpp_Result",
        )

    def unwrap(self) -> DenyEachBindingOnlyDenyCppResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class DenyEachBindingOnlyDenyDartResult:
    _response: typing.Optional[DenyEachBindingOnlyDenyDartResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "DenyEachBindingOnlyDenyDartResult"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyDart_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[DenyEachBindingOnlyDenyDartResponse] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> DenyEachBindingOnlyDenyDartResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyDart_Result",
        )

    def unwrap(self) -> DenyEachBindingOnlyDenyDartResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class DenyEachBindingOnlyDenyGoResult:
    _response: typing.Optional[DenyEachBindingOnlyDenyGoResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "DenyEachBindingOnlyDenyGoResult"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyGo_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[DenyEachBindingOnlyDenyGoResponse] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> DenyEachBindingOnlyDenyGoResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyGo_Result",
        )

    def unwrap(self) -> DenyEachBindingOnlyDenyGoResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class DenyEachBindingOnlyDenyRustResult:
    _response: typing.Optional[DenyEachBindingOnlyDenyRustResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "DenyEachBindingOnlyDenyRustResult"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenyRust_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[DenyEachBindingOnlyDenyRustResponse] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> DenyEachBindingOnlyDenyRustResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenyRust_Result",
        )

    def unwrap(self) -> DenyEachBindingOnlyDenyRustResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class DenyEachBindingOnlyDenySyzkallerResult:
    _response: typing.Optional[DenyEachBindingOnlyDenySyzkallerResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "DenyEachBindingOnlyDenySyzkallerResult"
    __fidl_raw_type__ = (
        "test.bindingsdenylist/DenyEachBinding_OnlyDenySyzkaller_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            DenyEachBindingOnlyDenySyzkallerResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> DenyEachBindingOnlyDenySyzkallerResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.bindingsdenylist",
            "test.bindingsdenylist/DenyEachBinding_OnlyDenySyzkaller_Result",
        )

    def unwrap(self) -> DenyEachBindingOnlyDenySyzkallerResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


# Generated constants
ALL_BINDINGS: int = 0


from fidl._client import EventHandlerBase, FidlClient
from fidl._server import ServerBase
from fidl._fidl_common import (
    DomainError,
    FrameworkError,
    MethodInfo,
    FidlProtocolMarker,
    normalize_identifier,
)

from abc import abstractmethod, ABC


class AllowedServer(ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.bindingsdenylist"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class AllowedClient(FidlClient):
    __fidl_kind__ = "client"
    library = "test.bindingsdenylist"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class AllowedEventHandler(EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.bindingsdenylist"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


AllowedMarker = FidlProtocolMarker(
    "(nondiscoverable) test.bindingsdenylist/Allowed"
)


from fidl._client import EventHandlerBase, FidlClient
from fidl._server import ServerBase
from fidl._fidl_common import (
    DomainError,
    FrameworkError,
    MethodInfo,
    FidlProtocolMarker,
    normalize_identifier,
)

from abc import abstractmethod, ABC


class DenyEachBindingServer(ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.bindingsdenylist"
    method_map: typing.Dict[int, MethodInfo] = {
        2957648440141224850: MethodInfo(
            name="only_deny_cpp",
            request_ident="test.bindingsdenylist/DenyEachBindingOnlyDenyCppRequest",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.bindingsdenylist/DenyEachBinding_OnlyDenyCpp_Result",
        ),
        8446571910689294295: MethodInfo(
            name="only_deny_dart",
            request_ident="test.bindingsdenylist/DenyEachBindingOnlyDenyDartRequest",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.bindingsdenylist/DenyEachBinding_OnlyDenyDart_Result",
        ),
        7311125300308839833: MethodInfo(
            name="only_deny_go",
            request_ident="test.bindingsdenylist/DenyEachBindingOnlyDenyGoRequest",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.bindingsdenylist/DenyEachBinding_OnlyDenyGo_Result",
        ),
        3719805222870932662: MethodInfo(
            name="only_deny_rust",
            request_ident="test.bindingsdenylist/DenyEachBindingOnlyDenyRustRequest",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.bindingsdenylist/DenyEachBinding_OnlyDenyRust_Result",
        ),
        2319043834522757514: MethodInfo(
            name="only_deny_syzkaller",
            request_ident="test.bindingsdenylist/DenyEachBindingOnlyDenySyzkallerRequest",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="test.bindingsdenylist/DenyEachBinding_OnlyDenySyzkaller_Result",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_only_deny_cpp: typing.TypeAlias = typing.Union[
        DomainError,
        DenyEachBindingOnlyDenyCppResponse,
    ]

    @abstractmethod
    def only_deny_cpp(
        self,
        request: DenyEachBindingOnlyDenyCppRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_only_deny_cpp]
        | _MethodResponse_only_deny_cpp
    ):
        ...

    _MethodResponse_only_deny_dart: typing.TypeAlias = typing.Union[
        DomainError,
        DenyEachBindingOnlyDenyDartResponse,
    ]

    @abstractmethod
    def only_deny_dart(
        self,
        request: DenyEachBindingOnlyDenyDartRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_only_deny_dart]
        | _MethodResponse_only_deny_dart
    ):
        ...

    _MethodResponse_only_deny_go: typing.TypeAlias = typing.Union[
        DomainError,
        DenyEachBindingOnlyDenyGoResponse,
    ]

    @abstractmethod
    def only_deny_go(
        self,
        request: DenyEachBindingOnlyDenyGoRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_only_deny_go]
        | _MethodResponse_only_deny_go
    ):
        ...

    _MethodResponse_only_deny_rust: typing.TypeAlias = typing.Union[
        DomainError,
        DenyEachBindingOnlyDenyRustResponse,
    ]

    @abstractmethod
    def only_deny_rust(
        self,
        request: DenyEachBindingOnlyDenyRustRequest,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_only_deny_rust]
        | _MethodResponse_only_deny_rust
    ):
        ...

    _MethodResponse_only_deny_syzkaller: typing.TypeAlias = typing.Union[
        DomainError,
        DenyEachBindingOnlyDenySyzkallerResponse,
    ]

    @abstractmethod
    def only_deny_syzkaller(
        self,
        request: DenyEachBindingOnlyDenySyzkallerRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_only_deny_syzkaller
        ]
        | _MethodResponse_only_deny_syzkaller
    ):
        ...


class DenyEachBindingClient(FidlClient):
    __fidl_kind__ = "client"
    library = "test.bindingsdenylist"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def only_deny_cpp(
        self,
        *,
        a: bool,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, DenyEachBindingOnlyDenyCppResult
    ]:
        msg = DenyEachBindingOnlyDenyCppRequest(
            a,
        )
        return self._send_two_way_fidl_request(
            2957648440141224850,
            "test.bindingsdenylist",
            msg,
            normalize_identifier(
                "test.bindingsdenylist/DenyEachBinding_OnlyDenyCpp_Result"
            ),
        )

    def only_deny_dart(
        self,
        *,
        a: bool,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, DenyEachBindingOnlyDenyDartResult
    ]:
        msg = DenyEachBindingOnlyDenyDartRequest(
            a,
        )
        return self._send_two_way_fidl_request(
            8446571910689294295,
            "test.bindingsdenylist",
            msg,
            normalize_identifier(
                "test.bindingsdenylist/DenyEachBinding_OnlyDenyDart_Result"
            ),
        )

    def only_deny_go(
        self,
        *,
        a: bool,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, DenyEachBindingOnlyDenyGoResult
    ]:
        msg = DenyEachBindingOnlyDenyGoRequest(
            a,
        )
        return self._send_two_way_fidl_request(
            7311125300308839833,
            "test.bindingsdenylist",
            msg,
            normalize_identifier(
                "test.bindingsdenylist/DenyEachBinding_OnlyDenyGo_Result"
            ),
        )

    def only_deny_rust(
        self,
        *,
        a: bool,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, DenyEachBindingOnlyDenyRustResult
    ]:
        msg = DenyEachBindingOnlyDenyRustRequest(
            a,
        )
        return self._send_two_way_fidl_request(
            3719805222870932662,
            "test.bindingsdenylist",
            msg,
            normalize_identifier(
                "test.bindingsdenylist/DenyEachBinding_OnlyDenyRust_Result"
            ),
        )

    def only_deny_syzkaller(
        self,
        *,
        a: bool,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, DenyEachBindingOnlyDenySyzkallerResult
    ]:
        msg = DenyEachBindingOnlyDenySyzkallerRequest(
            a,
        )
        return self._send_two_way_fidl_request(
            2319043834522757514,
            "test.bindingsdenylist",
            msg,
            normalize_identifier(
                "test.bindingsdenylist/DenyEachBinding_OnlyDenySyzkaller_Result"
            ),
        )


class DenyEachBindingEventHandler(EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.bindingsdenylist"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


DenyEachBindingMarker = FidlProtocolMarker(
    "(nondiscoverable) test.bindingsdenylist/DenyEachBinding"
)


from fidl._client import EventHandlerBase, FidlClient
from fidl._server import ServerBase
from fidl._fidl_common import (
    DomainError,
    FrameworkError,
    MethodInfo,
    FidlProtocolMarker,
    normalize_identifier,
)

from abc import abstractmethod, ABC


class ImportsSameNameContextServer(ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "test.bindingsdenylist"
    method_map: typing.Dict[int, MethodInfo] = {
        475191379775102607: MethodInfo(
            name="unattributed",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        2914965219653596920: MethodInfo(
            name="always_appears_in_importing_library",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_unattributed: typing.TypeAlias = None

    @abstractmethod
    def unattributed(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_unattributed]
        | _MethodResponse_unattributed
    ):
        ...

    _MethodResponse_always_appears_in_importing_library: typing.TypeAlias = None

    @abstractmethod
    def always_appears_in_importing_library(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any,
            typing.Any,
            _MethodResponse_always_appears_in_importing_library,
        ]
        | _MethodResponse_always_appears_in_importing_library
    ):
        ...


class ImportsSameNameContextClient(FidlClient):
    __fidl_kind__ = "client"
    library = "test.bindingsdenylist"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def unattributed(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            475191379775102607,
            "test.bindingsdenylist",
            msg,
        )

    def always_appears_in_importing_library(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            2914965219653596920,
            "test.bindingsdenylist",
            msg,
        )


class ImportsSameNameContextEventHandler(EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "test.bindingsdenylist"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        import fidl._construct

        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


ImportsSameNameContextMarker = FidlProtocolMarker(
    "(nondiscoverable) test.bindingsdenylist/ImportsSameNameContext"
)
