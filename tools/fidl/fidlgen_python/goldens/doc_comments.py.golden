# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.doccomments"]
add_ir_path(_ir_path)


@dataclass
class Struct:
    """
    struct comment #1

    struct comment #3
    """

    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    """
    struct member comment #1

    struct member comment #3
    """
    field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "Struct"
    __fidl_raw_type__ = "test.doccomments/Struct"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.doccomments", "test.doccomments/Struct"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "field": None,
            }
        )


@dataclass
class Table:
    """
    table comment #1

    table comment #3
    """

    """
    table field comment #1

    table field comment #3
    """
    field: int | None

    def __init__(
        self,
        field: int | None = None,
    ) -> None:
        self.field = field

    __fidl_kind__ = "table"
    __fidl_type__ = "Table"
    __fidl_raw_type__ = "test.doccomments/Table"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.doccomments", "test.doccomments/Table"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class FlexibleUnion:
    """
    flexible union comment #1

    flexible union comment #3
    """

    """
    union member comment #1

    union member comment #3
    """
    _field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "FlexibleUnion"
    __fidl_raw_type__ = "test.doccomments/FlexibleUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.field != other.field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.field:
            variant = f"field={self.field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if field is not None:
            self._field = field
            variants.append("field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def field(self) -> int | None:
        return getattr(self, "_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.doccomments", "test.doccomments/FlexibleUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class StrictUnion:
    """
    strict union comment #1

    strict union comment #3
    """

    """
    union member comment #1

    union member comment #3
    """
    _field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "StrictUnion"
    __fidl_raw_type__ = "test.doccomments/StrictUnion"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.field != other.field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.field:
            variant = f"field={self.field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if field is not None:
            self._field = field
            variants.append("field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def field(self) -> int | None:
        return getattr(self, "_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.doccomments", "test.doccomments/StrictUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


MyFlexibleEnum = enum.IntEnum(
    "MyFlexibleEnum",
    {
        "__doc__": """
        flexible enum comment #1.

        flexible enum comment #2.""",
        "__fidl_kind__": "enum",
        "__fidl_type__": "MyFlexibleEnum",
        "__fidl_raw_type__": "test.doccomments/MyFlexibleEnum",
        "__strict__": False,
        "FOO": 1,
        "BAR": 2,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


MyStrictEnum = enum.IntEnum(
    "MyStrictEnum",
    {
        "__doc__": """
        strict enum comment #1.

        strict enum comment #2.""",
        "__fidl_kind__": "enum",
        "__fidl_type__": "MyStrictEnum",
        "__fidl_raw_type__": "test.doccomments/MyStrictEnum",
        "__strict__": True,
        "FOO": 1,
        "BAR": 2,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


MyFlexibleBits = enum.IntFlag(
    "MyFlexibleBits",
    {
        "__doc__": """
        flexible bits comment #1

        flexible bits comment #2
        """,
        "__fidl_kind__": "bits",
        "__fidl_type__": "MyFlexibleBits",
        "__fidl_raw_type__": "test.doccomments/MyFlexibleBits",
        "__strict__": False,
        "MY_FIRST_BIT": 1,
        "MY_OTHER_BIT": 2,
        "make_default": classmethod(lambda cls: cls(value=0)),
    },
)


MyStrictBits = enum.IntFlag(
    "MyStrictBits",
    {
        "__doc__": """
        strict bits comment #1

        strict bits comment #2
        """,
        "__fidl_kind__": "bits",
        "__fidl_type__": "MyStrictBits",
        "__fidl_raw_type__": "test.doccomments/MyStrictBits",
        "__strict__": True,
        "MY_FIRST_BIT": 1,
        "MY_OTHER_BIT": 2,
        "make_default": classmethod(lambda cls: cls(value=0)),
    },
)


# Generated constants
C: int = 4


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class InterfaceServer(fidl._server.ServerBase, ABC):
    """
    interface comment #1

    interface comment #3
    """

    __fidl_kind__ = "server"
    library = "test.doccomments"
    method_map: typing.Dict[int, MethodInfo] = {
        5017051197196532121: MethodInfo(
            name="method",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_method: typing.TypeAlias = None

    @abstractmethod
    def method(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_method]
        | _MethodResponse_method
    ):
        ...

    def on_event(
        self,
    ) -> None:
        msg = None
        self._send_event(28780186509098736, "test.doccomments", msg)


class InterfaceClient(fidl._client.FidlClient):
    """
    interface comment #1

    interface comment #3
    """

    __fidl_kind__ = "client"
    library = "test.doccomments"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def method(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            5017051197196532121,
            "test.doccomments",
            msg,
        )


class InterfaceEventHandler(fidl._client.EventHandlerBase, ABC):
    """
    interface comment #1

    interface comment #3
    """

    __fidl_kind__ = "event_handler"
    library = "test.doccomments"
    method_map: typing.Dict[int, MethodInfo] = {
        28780186509098736: MethodInfo(
            name="on_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def on_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


InterfaceMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.doccomments/Interface"
)
