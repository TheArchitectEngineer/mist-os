// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug, Default)]
pub struct EmptyTable {}

impl EmptyTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for EmptyTable {
    type Encoded = WireEmptyTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for EmptyTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEmptyTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for EmptyTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEmptyTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireEmptyTable<'de>> for EmptyTable {
    #[inline]
    fn from_wire(wire: WireEmptyTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

impl<'de> ::fidl_next::FromWireRef<WireEmptyTable<'de>> for EmptyTable {
    #[inline]
    fn from_wire_ref(wire: &WireEmptyTable<'de>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`EmptyTable`].
#[repr(C)]
pub struct WireEmptyTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireEmptyTable<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireEmptyTable<'static> {
    type Decoded<'de> = WireEmptyTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEmptyTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireEmptyTable<'de> {}

impl<'de> ::core::fmt::Debug for WireEmptyTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("EmptyTable").finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct ExtensionTable {}

impl ExtensionTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for ExtensionTable {
    type Encoded = WireExtensionTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ExtensionTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExtensionTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ExtensionTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExtensionTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireExtensionTable<'de>> for ExtensionTable {
    #[inline]
    fn from_wire(wire: WireExtensionTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

impl<'de> ::fidl_next::FromWireRef<WireExtensionTable<'de>> for ExtensionTable {
    #[inline]
    fn from_wire_ref(wire: &WireExtensionTable<'de>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ExtensionTable`].
#[repr(C)]
pub struct WireExtensionTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireExtensionTable<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireExtensionTable<'static> {
    type Decoded<'de> = WireExtensionTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExtensionTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireExtensionTable<'de> {}

impl<'de> ::core::fmt::Debug for WireExtensionTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ExtensionTable").finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct NewerSimpleTable {
    pub x: Option<i64>,

    pub y: Option<i64>,

    pub z: Option<i64>,
}

impl NewerSimpleTable {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        if self.y.is_some() {
            return 5;
        }

        if self.z.is_some() {
            return 6;
        }

        0
    }
}

impl ::fidl_next::Encodable for NewerSimpleTable {
    type Encoded = WireNewerSimpleTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for NewerSimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireNewerSimpleTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                6 => {
                    if let Some(z) = self.z.take() {
                        ::fidl_next::WireEnvelope::encode_value(z, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                5 => {
                    if let Some(y) = self.y.take() {
                        ::fidl_next::WireEnvelope::encode_value(y, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(x) = self.x.take() {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for NewerSimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireNewerSimpleTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                6 => {
                    if let Some(z) = &self.z {
                        ::fidl_next::WireEnvelope::encode_value(z, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                5 => {
                    if let Some(y) = &self.y {
                        ::fidl_next::WireEnvelope::encode_value(y, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(x) = &self.x {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireNewerSimpleTable<'de>> for NewerSimpleTable {
    #[inline]
    fn from_wire(wire: WireNewerSimpleTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let x = wire.table.get(1);

        let y = wire.table.get(5);

        let z = wire.table.get(6);

        Self {
            x: x.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            y: y.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            z: z.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireNewerSimpleTable<'de>> for NewerSimpleTable {
    #[inline]
    fn from_wire_ref(wire: &WireNewerSimpleTable<'de>) -> Self {
        Self {
            x: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            y: wire.table.get(5).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            z: wire.table.get(6).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`NewerSimpleTable`].
#[repr(C)]
pub struct WireNewerSimpleTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireNewerSimpleTable<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(5)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(6)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });
    }
}

unsafe impl ::fidl_next::Wire for WireNewerSimpleTable<'static> {
    type Decoded<'de> = WireNewerSimpleTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireNewerSimpleTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                5 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                6 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireNewerSimpleTable<'de> {
    pub fn x(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn y(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(5)?.deref_unchecked()) }
    }

    pub fn z(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(6)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireNewerSimpleTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("NewerSimpleTable")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct OlderSimpleTable {
    pub x: Option<i64>,
}

impl OlderSimpleTable {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for OlderSimpleTable {
    type Encoded = WireOlderSimpleTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OlderSimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOlderSimpleTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(x) = self.x.take() {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OlderSimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOlderSimpleTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(x) = &self.x {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireOlderSimpleTable<'de>> for OlderSimpleTable {
    #[inline]
    fn from_wire(wire: WireOlderSimpleTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let x = wire.table.get(1);

        Self {
            x: x.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireOlderSimpleTable<'de>> for OlderSimpleTable {
    #[inline]
    fn from_wire_ref(wire: &WireOlderSimpleTable<'de>) -> Self {
        Self {
            x: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`OlderSimpleTable`].
#[repr(C)]
pub struct WireOlderSimpleTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireOlderSimpleTable<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });
    }
}

unsafe impl ::fidl_next::Wire for WireOlderSimpleTable<'static> {
    type Decoded<'de> = WireOlderSimpleTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOlderSimpleTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireOlderSimpleTable<'de> {
    pub fn x(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireOlderSimpleTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OlderSimpleTable").field("x", &self.x()).finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct ReverseOrdinalTable {
    pub z: Option<i64>,

    pub y: Option<i64>,

    pub x: Option<i64>,
}

impl ReverseOrdinalTable {
    fn __max_ordinal(&self) -> usize {
        if self.z.is_some() {
            return 1;
        }

        if self.y.is_some() {
            return 2;
        }

        if self.x.is_some() {
            return 3;
        }

        0
    }
}

impl ::fidl_next::Encodable for ReverseOrdinalTable {
    type Encoded = WireReverseOrdinalTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ReverseOrdinalTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireReverseOrdinalTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                3 => {
                    if let Some(x) = self.x.take() {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                2 => {
                    if let Some(y) = self.y.take() {
                        ::fidl_next::WireEnvelope::encode_value(y, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(z) = self.z.take() {
                        ::fidl_next::WireEnvelope::encode_value(z, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ReverseOrdinalTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireReverseOrdinalTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                3 => {
                    if let Some(x) = &self.x {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                2 => {
                    if let Some(y) = &self.y {
                        ::fidl_next::WireEnvelope::encode_value(y, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(z) = &self.z {
                        ::fidl_next::WireEnvelope::encode_value(z, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireReverseOrdinalTable<'de>> for ReverseOrdinalTable {
    #[inline]
    fn from_wire(wire: WireReverseOrdinalTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let z = wire.table.get(1);

        let y = wire.table.get(2);

        let x = wire.table.get(3);

        Self {
            z: z.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            y: y.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            x: x.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireReverseOrdinalTable<'de>> for ReverseOrdinalTable {
    #[inline]
    fn from_wire_ref(wire: &WireReverseOrdinalTable<'de>) -> Self {
        Self {
            z: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            y: wire.table.get(2).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            x: wire.table.get(3).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`ReverseOrdinalTable`].
#[repr(C)]
pub struct WireReverseOrdinalTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireReverseOrdinalTable<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(2)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(3)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });
    }
}

unsafe impl ::fidl_next::Wire for WireReverseOrdinalTable<'static> {
    type Decoded<'de> = WireReverseOrdinalTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireReverseOrdinalTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireReverseOrdinalTable<'de> {
    pub fn z(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn y(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn x(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireReverseOrdinalTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ReverseOrdinalTable")
            .field("z", &self.z())
            .field("y", &self.y())
            .field("x", &self.x())
            .finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SimpleTable {
    pub x: Option<i64>,

    pub y: Option<i64>,
}

impl SimpleTable {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        if self.y.is_some() {
            return 5;
        }

        0
    }
}

impl ::fidl_next::Encodable for SimpleTable {
    type Encoded = WireSimpleTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSimpleTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                5 => {
                    if let Some(y) = self.y.take() {
                        ::fidl_next::WireEnvelope::encode_value(y, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(x) = self.x.take() {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for SimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSimpleTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                5 => {
                    if let Some(y) = &self.y {
                        ::fidl_next::WireEnvelope::encode_value(y, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(x) = &self.x {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireSimpleTable<'de>> for SimpleTable {
    #[inline]
    fn from_wire(wire: WireSimpleTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let x = wire.table.get(1);

        let y = wire.table.get(5);

        Self {
            x: x.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            y: y.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireSimpleTable<'de>> for SimpleTable {
    #[inline]
    fn from_wire_ref(wire: &WireSimpleTable<'de>) -> Self {
        Self {
            x: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            y: wire.table.get(5).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`SimpleTable`].
#[repr(C)]
pub struct WireSimpleTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireSimpleTable<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(5)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });
    }
}

unsafe impl ::fidl_next::Wire for WireSimpleTable<'static> {
    type Decoded<'de> = WireSimpleTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSimpleTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                5 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireSimpleTable<'de> {
    pub fn x(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn y(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(5)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireSimpleTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("SimpleTable").field("x", &self.x()).field("y", &self.y()).finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct SixtyFourOrdinalTable {
    pub v1: Option<i64>,

    pub v2: Option<i64>,

    pub v3: Option<i64>,

    pub v4: Option<i64>,

    pub v5: Option<i64>,

    pub v6: Option<i64>,

    pub v7: Option<i64>,

    pub v8: Option<i64>,

    pub v9: Option<i64>,

    pub v10: Option<i64>,

    pub v11: Option<i64>,

    pub v12: Option<i64>,

    pub v13: Option<i64>,

    pub v14: Option<i64>,

    pub v15: Option<i64>,

    pub v16: Option<i64>,

    pub v17: Option<i64>,

    pub v18: Option<i64>,

    pub v19: Option<i64>,

    pub v20: Option<i64>,

    pub v21: Option<i64>,

    pub v22: Option<i64>,

    pub v23: Option<i64>,

    pub v24: Option<i64>,

    pub v25: Option<i64>,

    pub v26: Option<i64>,

    pub v27: Option<i64>,

    pub v28: Option<i64>,

    pub v29: Option<i64>,

    pub v30: Option<i64>,

    pub v31: Option<i64>,

    pub v32: Option<i64>,

    pub v33: Option<i64>,

    pub v34: Option<i64>,

    pub v35: Option<i64>,

    pub v36: Option<i64>,

    pub v37: Option<i64>,

    pub v38: Option<i64>,

    pub v39: Option<i64>,

    pub v40: Option<i64>,

    pub v41: Option<i64>,

    pub v42: Option<i64>,

    pub v43: Option<i64>,

    pub v44: Option<i64>,

    pub v45: Option<i64>,

    pub v46: Option<i64>,

    pub v47: Option<i64>,

    pub v48: Option<i64>,

    pub v49: Option<i64>,

    pub v50: Option<i64>,

    pub v51: Option<i64>,

    pub v52: Option<i64>,

    pub v53: Option<i64>,

    pub v54: Option<i64>,

    pub v55: Option<i64>,

    pub v56: Option<i64>,

    pub v57: Option<i64>,

    pub v58: Option<i64>,

    pub v59: Option<i64>,

    pub v60: Option<i64>,

    pub v61: Option<i64>,

    pub v62: Option<i64>,

    pub v63: Option<i64>,

    pub v64: Option<crate::ExtensionTable>,
}

impl SixtyFourOrdinalTable {
    fn __max_ordinal(&self) -> usize {
        if self.v1.is_some() {
            return 1;
        }

        if self.v2.is_some() {
            return 2;
        }

        if self.v3.is_some() {
            return 3;
        }

        if self.v4.is_some() {
            return 4;
        }

        if self.v5.is_some() {
            return 5;
        }

        if self.v6.is_some() {
            return 6;
        }

        if self.v7.is_some() {
            return 7;
        }

        if self.v8.is_some() {
            return 8;
        }

        if self.v9.is_some() {
            return 9;
        }

        if self.v10.is_some() {
            return 10;
        }

        if self.v11.is_some() {
            return 11;
        }

        if self.v12.is_some() {
            return 12;
        }

        if self.v13.is_some() {
            return 13;
        }

        if self.v14.is_some() {
            return 14;
        }

        if self.v15.is_some() {
            return 15;
        }

        if self.v16.is_some() {
            return 16;
        }

        if self.v17.is_some() {
            return 17;
        }

        if self.v18.is_some() {
            return 18;
        }

        if self.v19.is_some() {
            return 19;
        }

        if self.v20.is_some() {
            return 20;
        }

        if self.v21.is_some() {
            return 21;
        }

        if self.v22.is_some() {
            return 22;
        }

        if self.v23.is_some() {
            return 23;
        }

        if self.v24.is_some() {
            return 24;
        }

        if self.v25.is_some() {
            return 25;
        }

        if self.v26.is_some() {
            return 26;
        }

        if self.v27.is_some() {
            return 27;
        }

        if self.v28.is_some() {
            return 28;
        }

        if self.v29.is_some() {
            return 29;
        }

        if self.v30.is_some() {
            return 30;
        }

        if self.v31.is_some() {
            return 31;
        }

        if self.v32.is_some() {
            return 32;
        }

        if self.v33.is_some() {
            return 33;
        }

        if self.v34.is_some() {
            return 34;
        }

        if self.v35.is_some() {
            return 35;
        }

        if self.v36.is_some() {
            return 36;
        }

        if self.v37.is_some() {
            return 37;
        }

        if self.v38.is_some() {
            return 38;
        }

        if self.v39.is_some() {
            return 39;
        }

        if self.v40.is_some() {
            return 40;
        }

        if self.v41.is_some() {
            return 41;
        }

        if self.v42.is_some() {
            return 42;
        }

        if self.v43.is_some() {
            return 43;
        }

        if self.v44.is_some() {
            return 44;
        }

        if self.v45.is_some() {
            return 45;
        }

        if self.v46.is_some() {
            return 46;
        }

        if self.v47.is_some() {
            return 47;
        }

        if self.v48.is_some() {
            return 48;
        }

        if self.v49.is_some() {
            return 49;
        }

        if self.v50.is_some() {
            return 50;
        }

        if self.v51.is_some() {
            return 51;
        }

        if self.v52.is_some() {
            return 52;
        }

        if self.v53.is_some() {
            return 53;
        }

        if self.v54.is_some() {
            return 54;
        }

        if self.v55.is_some() {
            return 55;
        }

        if self.v56.is_some() {
            return 56;
        }

        if self.v57.is_some() {
            return 57;
        }

        if self.v58.is_some() {
            return 58;
        }

        if self.v59.is_some() {
            return 59;
        }

        if self.v60.is_some() {
            return 60;
        }

        if self.v61.is_some() {
            return 61;
        }

        if self.v62.is_some() {
            return 62;
        }

        if self.v63.is_some() {
            return 63;
        }

        if self.v64.is_some() {
            return 64;
        }

        0
    }
}

impl ::fidl_next::Encodable for SixtyFourOrdinalTable {
    type Encoded = WireSixtyFourOrdinalTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SixtyFourOrdinalTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSixtyFourOrdinalTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                64 => {
                    if let Some(v64) = self.v64.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v64,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                63 => {
                    if let Some(v63) = self.v63.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v63,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                62 => {
                    if let Some(v62) = self.v62.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v62,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                61 => {
                    if let Some(v61) = self.v61.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v61,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                60 => {
                    if let Some(v60) = self.v60.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v60,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                59 => {
                    if let Some(v59) = self.v59.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v59,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                58 => {
                    if let Some(v58) = self.v58.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v58,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                57 => {
                    if let Some(v57) = self.v57.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v57,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                56 => {
                    if let Some(v56) = self.v56.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v56,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                55 => {
                    if let Some(v55) = self.v55.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v55,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                54 => {
                    if let Some(v54) = self.v54.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v54,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                53 => {
                    if let Some(v53) = self.v53.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v53,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                52 => {
                    if let Some(v52) = self.v52.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v52,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                51 => {
                    if let Some(v51) = self.v51.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v51,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                50 => {
                    if let Some(v50) = self.v50.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v50,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                49 => {
                    if let Some(v49) = self.v49.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v49,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                48 => {
                    if let Some(v48) = self.v48.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v48,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                47 => {
                    if let Some(v47) = self.v47.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v47,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                46 => {
                    if let Some(v46) = self.v46.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v46,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                45 => {
                    if let Some(v45) = self.v45.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v45,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                44 => {
                    if let Some(v44) = self.v44.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v44,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                43 => {
                    if let Some(v43) = self.v43.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v43,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                42 => {
                    if let Some(v42) = self.v42.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v42,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                41 => {
                    if let Some(v41) = self.v41.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v41,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                40 => {
                    if let Some(v40) = self.v40.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v40,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                39 => {
                    if let Some(v39) = self.v39.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v39,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                38 => {
                    if let Some(v38) = self.v38.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v38,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                37 => {
                    if let Some(v37) = self.v37.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v37,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                36 => {
                    if let Some(v36) = self.v36.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v36,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                35 => {
                    if let Some(v35) = self.v35.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v35,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                34 => {
                    if let Some(v34) = self.v34.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v34,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                33 => {
                    if let Some(v33) = self.v33.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v33,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                32 => {
                    if let Some(v32) = self.v32.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v32,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                31 => {
                    if let Some(v31) = self.v31.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v31,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                30 => {
                    if let Some(v30) = self.v30.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v30,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                29 => {
                    if let Some(v29) = self.v29.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v29,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                28 => {
                    if let Some(v28) = self.v28.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v28,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                27 => {
                    if let Some(v27) = self.v27.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v27,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                26 => {
                    if let Some(v26) = self.v26.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v26,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                25 => {
                    if let Some(v25) = self.v25.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v25,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                24 => {
                    if let Some(v24) = self.v24.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v24,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                23 => {
                    if let Some(v23) = self.v23.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v23,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                22 => {
                    if let Some(v22) = self.v22.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v22,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                21 => {
                    if let Some(v21) = self.v21.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v21,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                20 => {
                    if let Some(v20) = self.v20.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v20,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                19 => {
                    if let Some(v19) = self.v19.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v19,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                18 => {
                    if let Some(v18) = self.v18.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v18,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                17 => {
                    if let Some(v17) = self.v17.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v17,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                16 => {
                    if let Some(v16) = self.v16.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v16,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                15 => {
                    if let Some(v15) = self.v15.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v15,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                14 => {
                    if let Some(v14) = self.v14.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v14,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                13 => {
                    if let Some(v13) = self.v13.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v13,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                12 => {
                    if let Some(v12) = self.v12.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v12,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                11 => {
                    if let Some(v11) = self.v11.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v11,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                10 => {
                    if let Some(v10) = self.v10.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v10,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                9 => {
                    if let Some(v9) = self.v9.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v9,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                8 => {
                    if let Some(v8) = self.v8.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v8,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                7 => {
                    if let Some(v7) = self.v7.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v7,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                6 => {
                    if let Some(v6) = self.v6.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v6,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                5 => {
                    if let Some(v5) = self.v5.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v5,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                4 => {
                    if let Some(v4) = self.v4.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v4,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(v3) = self.v3.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v3,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                2 => {
                    if let Some(v2) = self.v2.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v2,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(v1) = self.v1.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            v1,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for SixtyFourOrdinalTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSixtyFourOrdinalTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                64 => {
                    if let Some(v64) = &self.v64 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v64,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                63 => {
                    if let Some(v63) = &self.v63 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v63,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                62 => {
                    if let Some(v62) = &self.v62 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v62,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                61 => {
                    if let Some(v61) = &self.v61 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v61,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                60 => {
                    if let Some(v60) = &self.v60 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v60,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                59 => {
                    if let Some(v59) = &self.v59 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v59,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                58 => {
                    if let Some(v58) = &self.v58 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v58,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                57 => {
                    if let Some(v57) = &self.v57 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v57,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                56 => {
                    if let Some(v56) = &self.v56 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v56,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                55 => {
                    if let Some(v55) = &self.v55 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v55,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                54 => {
                    if let Some(v54) = &self.v54 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v54,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                53 => {
                    if let Some(v53) = &self.v53 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v53,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                52 => {
                    if let Some(v52) = &self.v52 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v52,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                51 => {
                    if let Some(v51) = &self.v51 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v51,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                50 => {
                    if let Some(v50) = &self.v50 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v50,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                49 => {
                    if let Some(v49) = &self.v49 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v49,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                48 => {
                    if let Some(v48) = &self.v48 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v48,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                47 => {
                    if let Some(v47) = &self.v47 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v47,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                46 => {
                    if let Some(v46) = &self.v46 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v46,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                45 => {
                    if let Some(v45) = &self.v45 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v45,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                44 => {
                    if let Some(v44) = &self.v44 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v44,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                43 => {
                    if let Some(v43) = &self.v43 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v43,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                42 => {
                    if let Some(v42) = &self.v42 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v42,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                41 => {
                    if let Some(v41) = &self.v41 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v41,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                40 => {
                    if let Some(v40) = &self.v40 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v40,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                39 => {
                    if let Some(v39) = &self.v39 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v39,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                38 => {
                    if let Some(v38) = &self.v38 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v38,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                37 => {
                    if let Some(v37) = &self.v37 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v37,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                36 => {
                    if let Some(v36) = &self.v36 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v36,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                35 => {
                    if let Some(v35) = &self.v35 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v35,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                34 => {
                    if let Some(v34) = &self.v34 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v34,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                33 => {
                    if let Some(v33) = &self.v33 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v33,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                32 => {
                    if let Some(v32) = &self.v32 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v32,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                31 => {
                    if let Some(v31) = &self.v31 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v31,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                30 => {
                    if let Some(v30) = &self.v30 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v30,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                29 => {
                    if let Some(v29) = &self.v29 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v29,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                28 => {
                    if let Some(v28) = &self.v28 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v28,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                27 => {
                    if let Some(v27) = &self.v27 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v27,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                26 => {
                    if let Some(v26) = &self.v26 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v26,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                25 => {
                    if let Some(v25) = &self.v25 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v25,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                24 => {
                    if let Some(v24) = &self.v24 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v24,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                23 => {
                    if let Some(v23) = &self.v23 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v23,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                22 => {
                    if let Some(v22) = &self.v22 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v22,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                21 => {
                    if let Some(v21) = &self.v21 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v21,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                20 => {
                    if let Some(v20) = &self.v20 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v20,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                19 => {
                    if let Some(v19) = &self.v19 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v19,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                18 => {
                    if let Some(v18) = &self.v18 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v18,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                17 => {
                    if let Some(v17) = &self.v17 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v17,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                16 => {
                    if let Some(v16) = &self.v16 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v16,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                15 => {
                    if let Some(v15) = &self.v15 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v15,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                14 => {
                    if let Some(v14) = &self.v14 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v14,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                13 => {
                    if let Some(v13) = &self.v13 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v13,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                12 => {
                    if let Some(v12) = &self.v12 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v12,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                11 => {
                    if let Some(v11) = &self.v11 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v11,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                10 => {
                    if let Some(v10) = &self.v10 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v10,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                9 => {
                    if let Some(v9) = &self.v9 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v9,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                8 => {
                    if let Some(v8) = &self.v8 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v8,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                7 => {
                    if let Some(v7) = &self.v7 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v7,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                6 => {
                    if let Some(v6) = &self.v6 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v6,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                5 => {
                    if let Some(v5) = &self.v5 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v5,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                4 => {
                    if let Some(v4) = &self.v4 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v4,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(v3) = &self.v3 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v3,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                2 => {
                    if let Some(v2) = &self.v2 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v2,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(v1) = &self.v1 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v1,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireSixtyFourOrdinalTable<'de>> for SixtyFourOrdinalTable {
    #[inline]
    fn from_wire(wire: WireSixtyFourOrdinalTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let v1 = wire.table.get(1);

        let v2 = wire.table.get(2);

        let v3 = wire.table.get(3);

        let v4 = wire.table.get(4);

        let v5 = wire.table.get(5);

        let v6 = wire.table.get(6);

        let v7 = wire.table.get(7);

        let v8 = wire.table.get(8);

        let v9 = wire.table.get(9);

        let v10 = wire.table.get(10);

        let v11 = wire.table.get(11);

        let v12 = wire.table.get(12);

        let v13 = wire.table.get(13);

        let v14 = wire.table.get(14);

        let v15 = wire.table.get(15);

        let v16 = wire.table.get(16);

        let v17 = wire.table.get(17);

        let v18 = wire.table.get(18);

        let v19 = wire.table.get(19);

        let v20 = wire.table.get(20);

        let v21 = wire.table.get(21);

        let v22 = wire.table.get(22);

        let v23 = wire.table.get(23);

        let v24 = wire.table.get(24);

        let v25 = wire.table.get(25);

        let v26 = wire.table.get(26);

        let v27 = wire.table.get(27);

        let v28 = wire.table.get(28);

        let v29 = wire.table.get(29);

        let v30 = wire.table.get(30);

        let v31 = wire.table.get(31);

        let v32 = wire.table.get(32);

        let v33 = wire.table.get(33);

        let v34 = wire.table.get(34);

        let v35 = wire.table.get(35);

        let v36 = wire.table.get(36);

        let v37 = wire.table.get(37);

        let v38 = wire.table.get(38);

        let v39 = wire.table.get(39);

        let v40 = wire.table.get(40);

        let v41 = wire.table.get(41);

        let v42 = wire.table.get(42);

        let v43 = wire.table.get(43);

        let v44 = wire.table.get(44);

        let v45 = wire.table.get(45);

        let v46 = wire.table.get(46);

        let v47 = wire.table.get(47);

        let v48 = wire.table.get(48);

        let v49 = wire.table.get(49);

        let v50 = wire.table.get(50);

        let v51 = wire.table.get(51);

        let v52 = wire.table.get(52);

        let v53 = wire.table.get(53);

        let v54 = wire.table.get(54);

        let v55 = wire.table.get(55);

        let v56 = wire.table.get(56);

        let v57 = wire.table.get(57);

        let v58 = wire.table.get(58);

        let v59 = wire.table.get(59);

        let v60 = wire.table.get(60);

        let v61 = wire.table.get(61);

        let v62 = wire.table.get(62);

        let v63 = wire.table.get(63);

        let v64 = wire.table.get(64);

        Self {
            v1: v1.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v2: v2.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v3: v3.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v4: v4.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v5: v5.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v6: v6.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v7: v7.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v8: v8.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v9: v9.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v10: v10.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v11: v11.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v12: v12.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v13: v13.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v14: v14.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v15: v15.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v16: v16.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v17: v17.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v18: v18.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v19: v19.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v20: v20.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v21: v21.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v22: v22.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v23: v23.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v24: v24.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v25: v25.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v26: v26.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v27: v27.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v28: v28.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v29: v29.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v30: v30.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v31: v31.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v32: v32.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v33: v33.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v34: v34.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v35: v35.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v36: v36.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v37: v37.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v38: v38.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v39: v39.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v40: v40.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v41: v41.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v42: v42.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v43: v43.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v44: v44.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v45: v45.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v46: v46.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v47: v47.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v48: v48.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v49: v49.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v50: v50.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v51: v51.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v52: v52.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v53: v53.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v54: v54.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v55: v55.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v56: v56.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v57: v57.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v58: v58.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v59: v59.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v60: v60.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v61: v61.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v62: v62.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v63: v63.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v64: v64.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<crate::WireExtensionTable<'de>>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireSixtyFourOrdinalTable<'de>> for SixtyFourOrdinalTable {
    #[inline]
    fn from_wire_ref(wire: &WireSixtyFourOrdinalTable<'de>) -> Self {
        Self {
            v1: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v2: wire.table.get(2).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v3: wire.table.get(3).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v4: wire.table.get(4).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v5: wire.table.get(5).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v6: wire.table.get(6).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v7: wire.table.get(7).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v8: wire.table.get(8).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v9: wire.table.get(9).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v10: wire.table.get(10).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v11: wire.table.get(11).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v12: wire.table.get(12).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v13: wire.table.get(13).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v14: wire.table.get(14).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v15: wire.table.get(15).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v16: wire.table.get(16).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v17: wire.table.get(17).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v18: wire.table.get(18).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v19: wire.table.get(19).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v20: wire.table.get(20).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v21: wire.table.get(21).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v22: wire.table.get(22).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v23: wire.table.get(23).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v24: wire.table.get(24).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v25: wire.table.get(25).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v26: wire.table.get(26).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v27: wire.table.get(27).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v28: wire.table.get(28).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v29: wire.table.get(29).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v30: wire.table.get(30).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v31: wire.table.get(31).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v32: wire.table.get(32).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v33: wire.table.get(33).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v34: wire.table.get(34).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v35: wire.table.get(35).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v36: wire.table.get(36).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v37: wire.table.get(37).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v38: wire.table.get(38).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v39: wire.table.get(39).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v40: wire.table.get(40).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v41: wire.table.get(41).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v42: wire.table.get(42).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v43: wire.table.get(43).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v44: wire.table.get(44).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v45: wire.table.get(45).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v46: wire.table.get(46).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v47: wire.table.get(47).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v48: wire.table.get(48).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v49: wire.table.get(49).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v50: wire.table.get(50).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v51: wire.table.get(51).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v52: wire.table.get(52).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v53: wire.table.get(53).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v54: wire.table.get(54).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v55: wire.table.get(55).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v56: wire.table.get(56).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v57: wire.table.get(57).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v58: wire.table.get(58).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v59: wire.table.get(59).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v60: wire.table.get(60).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v61: wire.table.get(61).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v62: wire.table.get(62).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v63: wire.table.get(63).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),

            v64: wire.table.get(64).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<crate::WireExtensionTable<'de>>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`SixtyFourOrdinalTable`].
#[repr(C)]
pub struct WireSixtyFourOrdinalTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireSixtyFourOrdinalTable<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(2)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(3)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(4)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(5)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(6)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(7)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(8)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(9)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(10)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(11)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(12)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(13)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(14)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(15)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(16)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(17)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(18)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(19)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(20)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(21)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(22)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(23)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(24)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(25)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(26)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(27)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(28)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(29)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(30)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(31)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(32)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(33)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(34)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(35)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(36)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(37)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(38)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(39)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(40)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(41)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(42)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(43)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(44)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(45)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(46)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(47)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(48)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(49)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(50)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(51)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(52)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(53)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(54)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(55)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(56)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(57)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(58)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(59)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(60)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(61)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(62)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(63)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });

        let _ = self
            .table
            .get(64)
            .map(|envelope| unsafe { envelope.read_unchecked::<crate::WireExtensionTable<'de>>() });
    }
}

unsafe impl ::fidl_next::Wire for WireSixtyFourOrdinalTable<'static> {
    type Decoded<'de> = WireSixtyFourOrdinalTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSixtyFourOrdinalTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                5 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                6 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                7 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                8 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                9 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                10 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                11 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                12 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                13 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                14 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                15 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                16 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                17 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                18 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                19 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                20 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                21 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                22 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                23 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                24 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                25 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                26 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                27 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                28 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                29 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                30 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                31 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                32 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                33 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                34 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                35 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                36 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                37 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                38 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                39 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                40 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                41 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                42 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                43 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                44 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                45 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                46 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                47 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                48 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                49 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                50 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                51 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                52 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                53 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                54 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                55 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                56 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                57 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                58 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                59 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                60 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                61 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                62 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                63 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                64 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, crate::WireExtensionTable<'static>>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireSixtyFourOrdinalTable<'de> {
    pub fn v1(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn v2(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn v3(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn v4(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }

    pub fn v5(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(5)?.deref_unchecked()) }
    }

    pub fn v6(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(6)?.deref_unchecked()) }
    }

    pub fn v7(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(7)?.deref_unchecked()) }
    }

    pub fn v8(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(8)?.deref_unchecked()) }
    }

    pub fn v9(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(9)?.deref_unchecked()) }
    }

    pub fn v10(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(10)?.deref_unchecked()) }
    }

    pub fn v11(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(11)?.deref_unchecked()) }
    }

    pub fn v12(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(12)?.deref_unchecked()) }
    }

    pub fn v13(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(13)?.deref_unchecked()) }
    }

    pub fn v14(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(14)?.deref_unchecked()) }
    }

    pub fn v15(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(15)?.deref_unchecked()) }
    }

    pub fn v16(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(16)?.deref_unchecked()) }
    }

    pub fn v17(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(17)?.deref_unchecked()) }
    }

    pub fn v18(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(18)?.deref_unchecked()) }
    }

    pub fn v19(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(19)?.deref_unchecked()) }
    }

    pub fn v20(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(20)?.deref_unchecked()) }
    }

    pub fn v21(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(21)?.deref_unchecked()) }
    }

    pub fn v22(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(22)?.deref_unchecked()) }
    }

    pub fn v23(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(23)?.deref_unchecked()) }
    }

    pub fn v24(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(24)?.deref_unchecked()) }
    }

    pub fn v25(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(25)?.deref_unchecked()) }
    }

    pub fn v26(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(26)?.deref_unchecked()) }
    }

    pub fn v27(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(27)?.deref_unchecked()) }
    }

    pub fn v28(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(28)?.deref_unchecked()) }
    }

    pub fn v29(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(29)?.deref_unchecked()) }
    }

    pub fn v30(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(30)?.deref_unchecked()) }
    }

    pub fn v31(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(31)?.deref_unchecked()) }
    }

    pub fn v32(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(32)?.deref_unchecked()) }
    }

    pub fn v33(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(33)?.deref_unchecked()) }
    }

    pub fn v34(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(34)?.deref_unchecked()) }
    }

    pub fn v35(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(35)?.deref_unchecked()) }
    }

    pub fn v36(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(36)?.deref_unchecked()) }
    }

    pub fn v37(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(37)?.deref_unchecked()) }
    }

    pub fn v38(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(38)?.deref_unchecked()) }
    }

    pub fn v39(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(39)?.deref_unchecked()) }
    }

    pub fn v40(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(40)?.deref_unchecked()) }
    }

    pub fn v41(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(41)?.deref_unchecked()) }
    }

    pub fn v42(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(42)?.deref_unchecked()) }
    }

    pub fn v43(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(43)?.deref_unchecked()) }
    }

    pub fn v44(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(44)?.deref_unchecked()) }
    }

    pub fn v45(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(45)?.deref_unchecked()) }
    }

    pub fn v46(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(46)?.deref_unchecked()) }
    }

    pub fn v47(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(47)?.deref_unchecked()) }
    }

    pub fn v48(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(48)?.deref_unchecked()) }
    }

    pub fn v49(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(49)?.deref_unchecked()) }
    }

    pub fn v50(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(50)?.deref_unchecked()) }
    }

    pub fn v51(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(51)?.deref_unchecked()) }
    }

    pub fn v52(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(52)?.deref_unchecked()) }
    }

    pub fn v53(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(53)?.deref_unchecked()) }
    }

    pub fn v54(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(54)?.deref_unchecked()) }
    }

    pub fn v55(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(55)?.deref_unchecked()) }
    }

    pub fn v56(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(56)?.deref_unchecked()) }
    }

    pub fn v57(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(57)?.deref_unchecked()) }
    }

    pub fn v58(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(58)?.deref_unchecked()) }
    }

    pub fn v59(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(59)?.deref_unchecked()) }
    }

    pub fn v60(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(60)?.deref_unchecked()) }
    }

    pub fn v61(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(61)?.deref_unchecked()) }
    }

    pub fn v62(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(62)?.deref_unchecked()) }
    }

    pub fn v63(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(63)?.deref_unchecked()) }
    }

    pub fn v64(&self) -> Option<&crate::WireExtensionTable<'de>> {
        unsafe { Some(self.table.get(64)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireSixtyFourOrdinalTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("SixtyFourOrdinalTable")
            .field("v1", &self.v1())
            .field("v2", &self.v2())
            .field("v3", &self.v3())
            .field("v4", &self.v4())
            .field("v5", &self.v5())
            .field("v6", &self.v6())
            .field("v7", &self.v7())
            .field("v8", &self.v8())
            .field("v9", &self.v9())
            .field("v10", &self.v10())
            .field("v11", &self.v11())
            .field("v12", &self.v12())
            .field("v13", &self.v13())
            .field("v14", &self.v14())
            .field("v15", &self.v15())
            .field("v16", &self.v16())
            .field("v17", &self.v17())
            .field("v18", &self.v18())
            .field("v19", &self.v19())
            .field("v20", &self.v20())
            .field("v21", &self.v21())
            .field("v22", &self.v22())
            .field("v23", &self.v23())
            .field("v24", &self.v24())
            .field("v25", &self.v25())
            .field("v26", &self.v26())
            .field("v27", &self.v27())
            .field("v28", &self.v28())
            .field("v29", &self.v29())
            .field("v30", &self.v30())
            .field("v31", &self.v31())
            .field("v32", &self.v32())
            .field("v33", &self.v33())
            .field("v34", &self.v34())
            .field("v35", &self.v35())
            .field("v36", &self.v36())
            .field("v37", &self.v37())
            .field("v38", &self.v38())
            .field("v39", &self.v39())
            .field("v40", &self.v40())
            .field("v41", &self.v41())
            .field("v42", &self.v42())
            .field("v43", &self.v43())
            .field("v44", &self.v44())
            .field("v45", &self.v45())
            .field("v46", &self.v46())
            .field("v47", &self.v47())
            .field("v48", &self.v48())
            .field("v49", &self.v49())
            .field("v50", &self.v50())
            .field("v51", &self.v51())
            .field("v52", &self.v52())
            .field("v53", &self.v53())
            .field("v54", &self.v54())
            .field("v55", &self.v55())
            .field("v56", &self.v56())
            .field("v57", &self.v57())
            .field("v58", &self.v58())
            .field("v59", &self.v59())
            .field("v60", &self.v60())
            .field("v61", &self.v61())
            .field("v62", &self.v62())
            .field("v63", &self.v63())
            .field("v64", &self.v64())
            .finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct TableWithAttributes {
    pub x: Option<i64>,
}

impl TableWithAttributes {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for TableWithAttributes {
    type Encoded = WireTableWithAttributes<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TableWithAttributes
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableWithAttributes { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(x) = self.x.take() {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for TableWithAttributes
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableWithAttributes { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(x) = &self.x {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireTableWithAttributes<'de>> for TableWithAttributes {
    #[inline]
    fn from_wire(wire: WireTableWithAttributes<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let x = wire.table.get(1);

        Self {
            x: x.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireTableWithAttributes<'de>> for TableWithAttributes {
    #[inline]
    fn from_wire_ref(wire: &WireTableWithAttributes<'de>) -> Self {
        Self {
            x: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI64>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`TableWithAttributes`].
#[repr(C)]
pub struct WireTableWithAttributes<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireTableWithAttributes<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI64>() });
    }
}

unsafe impl ::fidl_next::Wire for WireTableWithAttributes<'static> {
    type Decoded<'de> = WireTableWithAttributes<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableWithAttributes<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI64>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireTableWithAttributes<'de> {
    pub fn x(&self) -> Option<&::fidl_next::WireI64> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireTableWithAttributes<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("TableWithAttributes").field("x", &self.x()).finish()
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {}
