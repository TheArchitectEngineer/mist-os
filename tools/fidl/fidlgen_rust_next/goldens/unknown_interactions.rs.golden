// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption = ::fidl_next::WireBox<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the UnknownInteractionsAjarDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarDriverProtocol;

pub mod unknown_interactions_ajar_driver_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 200845620698173917;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 3790953144423004126;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 523076268125513549;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 902155904889801604;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 8952307689721713673;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3114064683372134045;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7057260423103547829;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 6490530264582540031;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 2319476129312263555;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 6883106306697493305;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult;
    }
}

/// A helper trait for the `UnknownInteractionsAjarDriverProtocol` client sender.
pub trait UnknownInteractionsAjarDriverProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsAjarDriverProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsAjarDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(200845620698173917, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(3790953144423004126, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(523076268125513549, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(902155904889801604, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8952307689721713673, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3114064683372134045, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7057260423103547829, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6490530264582540031, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2319476129312263555, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6883106306697493305, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsAjarDriverProtocol protocol.
///
/// See [`UnknownInteractionsAjarDriverProtocol`] for more details.
pub trait UnknownInteractionsAjarDriverProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsAjarDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarDriverProtocolClientHandler<___T>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsAjarDriverProtocol` server sender.
pub trait UnknownInteractionsAjarDriverProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> UnknownInteractionsAjarDriverProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the UnknownInteractionsAjarDriverProtocol protocol.
///
/// See [`UnknownInteractionsAjarDriverProtocol`] for more details.
pub trait UnknownInteractionsAjarDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_driver_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsAjarDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            200845620698173917 => {
                handler.strict_one_way(sender);
            }

            3790953144423004126 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            523076268125513549 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            902155904889801604 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            8952307689721713673 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            3114064683372134045 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            7057260423103547829 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            6490530264582540031 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            2319476129312263555 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            6883106306697493305 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult>
    for UnknownInteractionsAjarProtocolStrictTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayErrResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_ajar_protocol_strict_two_way_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_ajar_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventTableRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventTableRequest>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolStrictEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for Option<Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_ajar_protocol_flexible_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsAjarProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarProtocol;

pub mod unknown_interactions_ajar_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 956561744635167883;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 2483093178939638607;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 364341676962177080;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1821674633227946298;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 5870221221557233361;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8038805778859962068;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 6577335136969723910;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 595881957484758745;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3224530777258896533;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 3515589146717969463;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 6927291151663612592;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 5838220329633564521;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 6303151946645602671;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 659277224687564957;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::Method for FlexibleEvent {
        const ORDINAL: u64 = 1281760452005010931;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::Method for FlexibleEventFields {
        const ORDINAL: u64 = 4298964238728681570;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 8950943792372972717;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::Method for FlexibleEventTable {
        const ORDINAL: u64 = 705539350563403440;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest;
    }
}

/// A helper trait for the `UnknownInteractionsAjarProtocol` client sender.
pub trait UnknownInteractionsAjarProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsAjarProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(956561744635167883, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(2483093178939638607, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(364341676962177080, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1821674633227946298, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5870221221557233361, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8038805778859962068, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6577335136969723910, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(595881957484758745, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3224530777258896533, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3515589146717969463, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsAjarProtocol protocol.
///
/// See [`UnknownInteractionsAjarProtocol`] for more details.
pub trait UnknownInteractionsAjarProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventUnion,
        >,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventTable,
        >,
    );

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventFields,
        >,
    );

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventUnion,
        >,
    );

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventTable,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsAjarProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarProtocolClientHandler<___T>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6927291151663612592 => {
                handler.strict_event(sender);
            }

            5838220329633564521 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            6303151946645602671 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            659277224687564957 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            1281760452005010931 => {
                handler.flexible_event(sender);
            }

            4298964238728681570 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_fields(sender, buffer);
            }

            8950943792372972717 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_union(sender, buffer);
            }

            705539350563403440 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_table(sender, buffer);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsAjarProtocol` server sender.
pub trait UnknownInteractionsAjarProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest,
        >;

    fn strict_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest,
        >;

    fn strict_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest,
        >;

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest,
        >;

    fn flexible_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
        >;

    fn flexible_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest,
        >;
}

impl<___T> UnknownInteractionsAjarProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(6927291151663612592, &mut ())
    }

    fn strict_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest,
        >,
    {
        self.as_untyped().send_event(5838220329633564521, request)
    }

    fn strict_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest,
        >,
    {
        self.as_untyped().send_event(6303151946645602671, request)
    }

    fn strict_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest,
        >,
    {
        self.as_untyped().send_event(659277224687564957, request)
    }

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(1281760452005010931, &mut ())
    }

    fn flexible_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest,
        >,
    {
        self.as_untyped().send_event(4298964238728681570, request)
    }

    fn flexible_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
        >,
    {
        self.as_untyped().send_event(8950943792372972717, request)
    }

    fn flexible_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest,
        >,
    {
        self.as_untyped().send_event(705539350563403440, request)
    }
}

/// A server handler for the UnknownInteractionsAjarProtocol protocol.
///
/// See [`UnknownInteractionsAjarProtocol`] for more details.
pub trait UnknownInteractionsAjarProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayUnionErr>,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayTableErr>,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsAjarProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            956561744635167883 => {
                handler.strict_one_way(sender);
            }

            2483093178939638607 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            364341676962177080 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            1821674633227946298 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            5870221221557233361 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            8038805778859962068 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            6577335136969723910 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            595881957484758745 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            3224530777258896533 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            3515589146717969463 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
    ) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption = ::fidl_next::WireBox<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
                    raw: ::fidl_next::RawWireUnion::absent(),
                };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
                    raw: ::fidl_next::RawWireUnion::absent(),
                };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the UnknownInteractionsClosedDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedDriverProtocol;

pub mod unknown_interactions_closed_driver_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 9111839835597799810;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 2815690661228737027;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 5761316743698652038;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7235351480214368636;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 1839495150551777151;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 4350840352076287137;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 3933117456632607830;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4598950031783776653;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1456858375973362525;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult;
    }
}

/// A helper trait for the `UnknownInteractionsClosedDriverProtocol` client sender.
pub trait UnknownInteractionsClosedDriverProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsClosedDriverProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsClosedDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(9111839835597799810, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2815690661228737027, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5761316743698652038, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7235351480214368636, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1839495150551777151, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4350840352076287137, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3933117456632607830, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4598950031783776653, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1456858375973362525, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsClosedDriverProtocol protocol.
///
/// See [`UnknownInteractionsClosedDriverProtocol`] for more details.
pub trait UnknownInteractionsClosedDriverProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsClosedDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedDriverProtocolClientHandler<___T>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `UnknownInteractionsClosedDriverProtocol` server sender.
pub trait UnknownInteractionsClosedDriverProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> UnknownInteractionsClosedDriverProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the UnknownInteractionsClosedDriverProtocol protocol.
///
/// See [`UnknownInteractionsClosedDriverProtocol`] for more details.
pub trait UnknownInteractionsClosedDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsClosedDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            9111839835597799810 => {
                handler.strict_one_way(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2815690661228737027 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            5761316743698652038 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            7235351480214368636 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            1839495150551777151 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            4350840352076287137 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            3933117456632607830 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            4598950031783776653 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            1456858375973362525 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult>
    for UnknownInteractionsClosedProtocolStrictTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_closed_protocol_strict_two_way_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_closed_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_closed_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsClosedProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_closed_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsClosedProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventTableRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsClosedProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventTableRequest>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedProtocolStrictEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsClosedProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedProtocol;

pub mod unknown_interactions_closed_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 401526495318825508;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 6834828562275693047;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1379139029283639891;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7544414847426850727;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 7947328131967870853;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 5738532966428790074;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 802395819586836733;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 925029359463709824;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1260407702860823440;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 760799297757210939;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 6736355582617074292;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 4288682345454280036;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 2871682464255309246;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest;
    }
}

/// A helper trait for the `UnknownInteractionsClosedProtocol` client sender.
pub trait UnknownInteractionsClosedProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsClosedProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(401526495318825508, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6834828562275693047, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1379139029283639891, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7544414847426850727, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7947328131967870853, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5738532966428790074, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(802395819586836733, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(925029359463709824, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1260407702860823440, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsClosedProtocol protocol.
///
/// See [`UnknownInteractionsClosedProtocol`] for more details.
pub trait UnknownInteractionsClosedProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventUnion,
        >,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventTable,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsClosedProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedProtocolClientHandler<___T>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            760799297757210939 => {
                handler.strict_event(sender);
            }

            6736355582617074292 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            4288682345454280036 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            2871682464255309246 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `UnknownInteractionsClosedProtocol` server sender.
pub trait UnknownInteractionsClosedProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest,
        >;

    fn strict_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest,
        >;

    fn strict_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest,
        >;
}

impl<___T> UnknownInteractionsClosedProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(760799297757210939, &mut ())
    }

    fn strict_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest,
        >,
    {
        self.as_untyped().send_event(6736355582617074292, request)
    }

    fn strict_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest,
        >,
    {
        self.as_untyped().send_event(4288682345454280036, request)
    }

    fn strict_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest,
        >,
    {
        self.as_untyped().send_event(2871682464255309246, request)
    }
}

/// A server handler for the UnknownInteractionsClosedProtocol protocol.
///
/// See [`UnknownInteractionsClosedProtocol`] for more details.
pub trait UnknownInteractionsClosedProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsClosedProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            401526495318825508 => {
                handler.strict_one_way(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            6834828562275693047 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            1379139029283639891 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            7544414847426850727 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            7947328131967870853 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            5738532966428790074 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            802395819586836733 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            925029359463709824 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            1260407702860823440 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult>
    for UnknownInteractionsDriverProtocolStrictTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_driver_protocol_strict_two_way_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_driver_protocol_strict_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_driver_protocol_strict_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_fields_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_table_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_fields_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    Response(crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(
            &'union crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
        ),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_driver_protocol_flexible_two_way_table_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the UnknownInteractionsDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsDriverProtocol;

pub mod unknown_interactions_driver_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 6982839851953080288;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 1083620022582160398;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 1481114722667499972;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 6841797014773573215;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 1451514501977162287;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3330693085881435529;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 8222960355260037542;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 225387363174180470;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3066880266580913088;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 708169949929096689;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 2929398860738426482;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 8423663794424433896;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 8216450897182897849;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 1049265954148894210;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 5583489590753947170;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 6033174601748665003;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 6235121653537390575;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 940887795361350656;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult;
    }
}

/// A helper trait for the `UnknownInteractionsDriverProtocol` client sender.
pub trait UnknownInteractionsDriverProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsDriverProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(6982839851953080288, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(1083620022582160398, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1481114722667499972, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6841797014773573215, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1451514501977162287, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3330693085881435529, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8222960355260037542, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(225387363174180470, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3066880266580913088, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(708169949929096689, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2929398860738426482, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8423663794424433896, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8216450897182897849, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1049265954148894210, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5583489590753947170, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6033174601748665003, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6235121653537390575, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(940887795361350656, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsDriverProtocol protocol.
///
/// See [`UnknownInteractionsDriverProtocol`] for more details.
pub trait UnknownInteractionsDriverProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsDriverProtocolClientHandler<___T>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsDriverProtocol` server sender.
pub trait UnknownInteractionsDriverProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> UnknownInteractionsDriverProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the UnknownInteractionsDriverProtocol protocol.
///
/// See [`UnknownInteractionsDriverProtocol`] for more details.
pub trait UnknownInteractionsDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
    );

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::FlexibleTwoWay>,
    );

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
    );

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
    );

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
    );

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::FlexibleTwoWayErr>,
    );

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
    );

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
    );

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6982839851953080288 => {
                handler.strict_one_way(sender);
            }

            1083620022582160398 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1481114722667499972 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            6841797014773573215 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            1451514501977162287 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            3330693085881435529 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            8222960355260037542 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            225387363174180470 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            3066880266580913088 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            708169949929096689 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            2929398860738426482 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder);
            }

            8423663794424433896 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder);
            }

            8216450897182897849 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder);
            }

            1049265954148894210 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder);
            }

            5583489590753947170 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder);
            }

            6033174601748665003 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder);
            }

            6235121653537390575 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder);
            }

            940887795361350656 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayFieldsResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayErrResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolStrictTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayErrResult {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnknownInteractionsProtocolStrictTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayErrResult>
    for UnknownInteractionsProtocolStrictTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayErrResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_strict_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_strict_two_way_err_result::Ref::Response(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            2 => crate::unknown_interactions_protocol_strict_two_way_err_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnknownInteractionsProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_strict_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_fields_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_strict_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_union_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayTableErrResult {
    Response(crate::UnknownInteractionsProtocolStrictTwoWayTableErrResponse),

    Err(i32),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolStrictTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayTableErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableErrResult>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayTableErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_strict_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse),

        Err(&'union ::fidl_next::WireI32),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_table_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::unknown_interactions_protocol_strict_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            2 => crate::unknown_interactions_protocol_strict_two_way_table_err_result::Ref::Err(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleTwoWayResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnknownInteractionsProtocolFlexibleTwoWayResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayResult>
    for UnknownInteractionsProtocolFlexibleTwoWayResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    pub fn as_ref(&self) -> crate::unknown_interactions_protocol_flexible_two_way_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_flexible_two_way_result::Ref::Response(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            3 => crate::unknown_interactions_protocol_flexible_two_way_result::Ref::FrameworkErr(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnknownInteractionsProtocolFlexibleTwoWayResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_fields_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_fields_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_fields_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_protocol_flexible_two_way_fields_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>()
                },
            },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_protocol_flexible_two_way_union_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayTableResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayTableResponse),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayTableResponse,
            >(value, 1, encoder, raw)?,

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayTableResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayTableResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayTableResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableResult>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayTableResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayTableResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_table_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayTableResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_table_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_table_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_protocol_flexible_two_way_table_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse
                        >().fmt(f)
            },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayTableResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse,
            >(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse {}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayErrResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayErrResult>
    for UnknownInteractionsProtocolFlexibleTwoWayErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayErrResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref::Response(
                unsafe { self.raw.get().deref_unchecked() },
            ),

            2 => {
                crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref::Err(unsafe {
                    self.raw.get().deref_unchecked()
                })
            }

            3 => {
                crate::unknown_interactions_protocol_flexible_two_way_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() },
                )
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
{
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_fields_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_protocol_flexible_two_way_fields_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            3 => Self {
                raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireFrameworkError>() },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                ::fidl_next::WireFrameworkError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_union_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_protocol_flexible_two_way_union_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    Response(crate::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse),

    Err(i32),

    FrameworkErr(::fidl_next::FrameworkError),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleTwoWayTableErrResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::FrameworkErr(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                ::fidl_next::FrameworkError,
            >(value, 3, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayTableErrResult>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayTableErrResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResult
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FrameworkErr(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayTableErrResult>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableErrResult`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_two_way_table_err_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse),

        Err(&'union ::fidl_next::WireI32),

        FrameworkErr(&'union ::fidl_next::WireFrameworkError),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref::Response(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                2 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref::Err(
                    unsafe { self.raw.get().deref_unchecked() }
                ),

                3 => crate::unknown_interactions_protocol_flexible_two_way_table_err_result::Ref::FrameworkErr(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                _ => unsafe { ::core::hint::unreachable_unchecked() },

        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<
                            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
                        >().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireFrameworkError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireFrameworkError>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictEventFieldsRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolStrictEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventFieldsRequest>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventUnionRequest { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictEventUnionRequest> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventUnionRequest>
    for UnknownInteractionsProtocolStrictEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsProtocolStrictEventUnionRequest>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsProtocolStrictEventTableRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventTableRequest>
    for UnknownInteractionsProtocolStrictEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolStrictEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corersponding to [`UnknownInteractionsProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventUnionRequest {
    type Encoded = WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventUnionRequest { raw } = slot);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for Option<Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

pub mod unknown_interactions_protocol_flexible_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnknownInteractionsProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventTableRequest {
    type Encoded = WireUnknownInteractionsProtocolFlexibleEventTableRequest;
}

impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventTableRequest { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventTableRequest>
    for UnknownInteractionsProtocolFlexibleEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolFlexibleEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsProtocol;

pub mod unknown_interactions_protocol {

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 5652707722400962470;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 583422011583300678;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 8308184097687583042;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 3697260130745060067;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 2455165891480464557;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8389853739594228663;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7862264614495172967;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayErrResult;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 2414673307948662059;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4988571416540160202;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 5487292735562672344;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResult;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 334879577560091516;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayResult;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 4257018954691721778;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 4913460516188409782;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 9171907422498283911;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResult;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 6999736795697216519;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResult;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 1093132337162001157;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 2410151523245950935;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 7893309626427980786;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 685715276307386305;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 8896208255987935026;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 3919175221694221274;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 2711448698318579984;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventTableRequest;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::Method for FlexibleEvent {
        const ORDINAL: u64 = 7042257263728687206;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::Method for FlexibleEventFields {
        const ORDINAL: u64 = 3613822014516746241;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 2499446536152409191;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::Method for FlexibleEventTable {
        const ORDINAL: u64 = 5724881371349617120;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest;
    }
}

/// A helper trait for the `UnknownInteractionsProtocol` client sender.
pub trait UnknownInteractionsProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(5652707722400962470, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(583422011583300678, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8308184097687583042, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3697260130745060067, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2455165891480464557, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8389853739594228663, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7862264614495172967, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2414673307948662059, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4988571416540160202, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5487292735562672344, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(334879577560091516, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4257018954691721778, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4913460516188409782, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9171907422498283911, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6999736795697216519, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1093132337162001157, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2410151523245950935, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7893309626427980786, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsProtocol protocol.
///
/// See [`UnknownInteractionsProtocol`] for more details.
pub trait UnknownInteractionsProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<___T, unknown_interactions_protocol::StrictEventUnion>,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<___T, unknown_interactions_protocol::StrictEventTable>,
    );

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,
    );

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventFields,
        >,
    );

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventUnion,
        >,
    );

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventTable,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsProtocolClientHandler<___T>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolStrictEventTableRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            685715276307386305 => {
                handler.strict_event(sender);
            }

            8896208255987935026 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            3919175221694221274 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            2711448698318579984 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            7042257263728687206 => {
                handler.flexible_event(sender);
            }

            3613822014516746241 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_fields(sender, buffer);
            }

            2499446536152409191 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_union(sender, buffer);
            }

            5724881371349617120 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_table(sender, buffer);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsProtocol` server sender.
pub trait UnknownInteractionsProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest,
        >;

    fn strict_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolStrictEventUnionRequest,
        >;

    fn strict_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolStrictEventTableRequest,
        >;

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest,
        >;

    fn flexible_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest,
        >;

    fn flexible_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest,
        >;
}

impl<___T> UnknownInteractionsProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(685715276307386305, &mut ())
    }

    fn strict_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest,
        >,
    {
        self.as_untyped().send_event(8896208255987935026, request)
    }

    fn strict_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolStrictEventUnionRequest,
        >,
    {
        self.as_untyped().send_event(3919175221694221274, request)
    }

    fn strict_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolStrictEventTableRequest,
        >,
    {
        self.as_untyped().send_event(2711448698318579984, request)
    }

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(7042257263728687206, &mut ())
    }

    fn flexible_event_fields<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest,
        >,
    {
        self.as_untyped().send_event(3613822014516746241, request)
    }

    fn flexible_event_union<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest,
        >,
    {
        self.as_untyped().send_event(2499446536152409191, request)
    }

    fn flexible_event_table<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest,
        >,
    {
        self.as_untyped().send_event(5724881371349617120, request)
    }
}

/// A server handler for the UnknownInteractionsProtocol protocol.
///
/// See [`UnknownInteractionsProtocol`] for more details.
pub trait UnknownInteractionsProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayFieldsErr>,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayUnionErr>,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayTableErr>,
    );

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWay>,
    );

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayFields>,
    );

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayUnion>,
    );

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayTable>,
    );

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayErr>,
    );

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayFieldsErr>,
    );

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayUnionErr>,
    );

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayTableErr>,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5652707722400962470 => {
                handler.strict_one_way(sender);
            }

            583422011583300678 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8308184097687583042 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            3697260130745060067 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            2455165891480464557 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            8389853739594228663 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            7862264614495172967 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            2414673307948662059 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            4988571416540160202 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            5487292735562672344 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            334879577560091516 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder);
            }

            4257018954691721778 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder);
            }

            4913460516188409782 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder);
            }

            9171907422498283911 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder);
            }

            6999736795697216519 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder);
            }

            1093132337162001157 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder);
            }

            2410151523245950935 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder);
            }

            7893309626427980786 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// Commonly-used items that should usually be in scope, such as extension traits.
pub mod prelude {
    pub use super::{
        UnknownInteractionsAjarDriverProtocolClientSender,
        UnknownInteractionsAjarDriverProtocolServerSender,
        UnknownInteractionsAjarProtocolClientSender, UnknownInteractionsAjarProtocolServerSender,
        UnknownInteractionsClosedDriverProtocolClientSender,
        UnknownInteractionsClosedDriverProtocolServerSender,
        UnknownInteractionsClosedProtocolClientSender,
        UnknownInteractionsClosedProtocolServerSender,
        UnknownInteractionsDriverProtocolClientSender,
        UnknownInteractionsDriverProtocolServerSender, UnknownInteractionsProtocolClientSender,
        UnknownInteractionsProtocolServerSender,
    };
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsAjarDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsAjarDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsAjarDriverProtocol,
    >;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsAjarProtocol`
    /// protocol.
    pub type UnknownInteractionsAjarProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsAjarProtocol,
    >;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsClosedDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsClosedDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsClosedDriverProtocol,
    >;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsClosedProtocol`
    /// protocol.
    pub type UnknownInteractionsClosedProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsClosedProtocol,
    >;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsDriverProtocol,
    >;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsProtocol`
    /// protocol.
    pub type UnknownInteractionsProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsProtocol,
    >;
}
