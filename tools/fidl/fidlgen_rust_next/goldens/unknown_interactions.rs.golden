// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption = ::fidl_next::WireBox<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsAjarDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarDriverProtocol;

pub mod unknown_interactions_ajar_driver_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_ajar_driver_protocol, UnknownInteractionsAjarDriverProtocol,
            UnknownInteractionsAjarDriverProtocolClientHandler,
            UnknownInteractionsAjarDriverProtocolClientSender,
            UnknownInteractionsAjarDriverProtocolServerHandler,
            UnknownInteractionsAjarDriverProtocolServerSender,
        };

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 200845620698173917;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 3790953144423004126;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 523076268125513549;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 902155904889801604;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 8952307689721713673;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3114064683372134045;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7057260423103547829;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 6490530264582540031;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 2319476129312263555;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 6883106306697493305;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }
}

/// A helper trait for the `UnknownInteractionsAjarDriverProtocol` client sender.
pub trait UnknownInteractionsAjarDriverProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsAjarDriverProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsAjarDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(200845620698173917, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(3790953144423004126, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(523076268125513549, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(902155904889801604, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8952307689721713673, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3114064683372134045, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7057260423103547829, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6490530264582540031, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2319476129312263555, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6883106306697493305, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsAjarDriverProtocol protocol.
///
/// See [`UnknownInteractionsAjarDriverProtocol`] for more details.
pub trait UnknownInteractionsAjarDriverProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsAjarDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarDriverProtocolClientHandler<___T>,









            <unknown_interactions_ajar_driver_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,


{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
































                ordinal => handler.on_unknown_interaction(sender, ordinal),

        }
    }
}

/// A helper trait for the `UnknownInteractionsAjarDriverProtocol` server sender.
pub trait UnknownInteractionsAjarDriverProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> UnknownInteractionsAjarDriverProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the UnknownInteractionsAjarDriverProtocol protocol.
///
/// See [`UnknownInteractionsAjarDriverProtocol`] for more details.
pub trait UnknownInteractionsAjarDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_driver_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsAjarDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            200845620698173917 => {
                handler.strict_one_way(sender);
            }

            3790953144423004126 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            523076268125513549 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            902155904889801604 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            8952307689721713673 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            3114064683372134045 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            7057260423103547829 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            6490530264582540031 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            2319476129312263555 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            6883106306697493305 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsAjarProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventTableRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolStrictEventTableRequest>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolStrictEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolStrictEventTableRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolStrictEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for Option<Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_flexible_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsAjarProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarProtocol;

pub mod unknown_interactions_ajar_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_ajar_protocol, UnknownInteractionsAjarProtocol,
            UnknownInteractionsAjarProtocolClientHandler,
            UnknownInteractionsAjarProtocolClientSender,
            UnknownInteractionsAjarProtocolServerHandler,
            UnknownInteractionsAjarProtocolServerSender,
        };

        pub use crate::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;

        pub use crate::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;

        pub use crate::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictEventFieldsRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictEventTableRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictEventUnionRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 956561744635167883;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 2483093178939638607;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 364341676962177080;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1821674633227946298;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 5870221221557233361;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8038805778859962068;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 6577335136969723910;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 595881957484758745;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3224530777258896533;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 3515589146717969463;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 6927291151663612592;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 5838220329633564521;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 6303151946645602671;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 659277224687564957;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::Method for FlexibleEvent {
        const ORDINAL: u64 = 1281760452005010931;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::Method for FlexibleEventFields {
        const ORDINAL: u64 = 4298964238728681570;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 8950943792372972717;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::Method for FlexibleEventTable {
        const ORDINAL: u64 = 705539350563403440;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest;
    }
}

/// A helper trait for the `UnknownInteractionsAjarProtocol` client sender.
pub trait UnknownInteractionsAjarProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsAjarProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(956561744635167883, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(2483093178939638607, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(364341676962177080, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1821674633227946298, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5870221221557233361, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8038805778859962068, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6577335136969723910, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(595881957484758745, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3224530777258896533, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_ajar_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3515589146717969463, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsAjarProtocol protocol.
///
/// See [`UnknownInteractionsAjarProtocol`] for more details.
pub trait UnknownInteractionsAjarProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventUnion,
        >,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::StrictEventTable,
        >,
    );

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventFields,
        >,
    );

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventUnion,
        >,
    );

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_ajar_protocol::FlexibleEventTable,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsAjarProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsAjarProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarProtocolClientHandler<___T>,

    <unknown_interactions_ajar_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::FlexibleEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::FlexibleEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6927291151663612592 => {
                handler.strict_event(sender);
            }

            5838220329633564521 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            6303151946645602671 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            659277224687564957 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            1281760452005010931 => {
                handler.flexible_event(sender);
            }

            4298964238728681570 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_fields(sender, buffer);
            }

            8950943792372972717 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_union(sender, buffer);
            }

            705539350563403440 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_table(sender, buffer);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsAjarProtocol` server sender.
pub trait UnknownInteractionsAjarProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::StrictEventFields as ::fidl_next::Method>::Response,
                    >;

    fn strict_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::StrictEventUnion as ::fidl_next::Method>::Response,
                    >;

    fn strict_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::StrictEventTable as ::fidl_next::Method>::Response,
                    >;

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::FlexibleEventFields as ::fidl_next::Method>::Response,
                    >;

    fn flexible_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response,
                    >;

    fn flexible_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::FlexibleEventTable as ::fidl_next::Method>::Response,
                    >;
}

impl<___T> UnknownInteractionsAjarProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(6927291151663612592, &mut ())
    }








                fn strict_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::StrictEventFields as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(5838220329633564521, request)
    }








                fn strict_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::StrictEventUnion as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(6303151946645602671, request)
    }








                fn strict_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::StrictEventTable as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(659277224687564957, request)
    }

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(1281760452005010931, &mut ())
    }








                fn flexible_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::FlexibleEventFields as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(4298964238728681570, request)
    }








                fn flexible_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(8950943792372972717, request)
    }








                fn flexible_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_ajar_protocol::FlexibleEventTable as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(705539350563403440, request)
    }
}

/// A server handler for the UnknownInteractionsAjarProtocol protocol.
///
/// See [`UnknownInteractionsAjarProtocol`] for more details.
pub trait UnknownInteractionsAjarProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayUnionErr>,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayTableErr>,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsAjarProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsAjarProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsAjarProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            956561744635167883 => {
                handler.strict_one_way(sender);
            }

            2483093178939638607 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            364341676962177080 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            1821674633227946298 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            5870221221557233361 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            8038805778859962068 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            6577335136969723910 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            595881957484758745 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            3224530777258896533 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            3515589146717969463 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption = ::fidl_next::WireBox<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
                    raw: ::fidl_next::RawWireUnion::absent(),
                };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsClosedDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedDriverProtocol;

pub mod unknown_interactions_closed_driver_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_closed_driver_protocol, UnknownInteractionsClosedDriverProtocol,
            UnknownInteractionsClosedDriverProtocolClientHandler,
            UnknownInteractionsClosedDriverProtocolClientSender,
            UnknownInteractionsClosedDriverProtocolServerHandler,
            UnknownInteractionsClosedDriverProtocolServerSender,
        };

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 9111839835597799810;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 2815690661228737027;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 5761316743698652038;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7235351480214368636;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 1839495150551777151;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 4350840352076287137;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 3933117456632607830;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4598950031783776653;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1456858375973362525;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }
}

/// A helper trait for the `UnknownInteractionsClosedDriverProtocol` client sender.
pub trait UnknownInteractionsClosedDriverProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsClosedDriverProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsClosedDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(9111839835597799810, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2815690661228737027, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5761316743698652038, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7235351480214368636, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1839495150551777151, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4350840352076287137, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3933117456632607830, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4598950031783776653, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1456858375973362525, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsClosedDriverProtocol protocol.
///
/// See [`UnknownInteractionsClosedDriverProtocol`] for more details.
pub trait UnknownInteractionsClosedDriverProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsClosedDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedDriverProtocolClientHandler<___T>,







            <unknown_interactions_closed_driver_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,


{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {





























                ordinal => {

                    sender.close();
                }

        }
    }
}

/// A helper trait for the `UnknownInteractionsClosedDriverProtocol` server sender.
pub trait UnknownInteractionsClosedDriverProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> UnknownInteractionsClosedDriverProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the UnknownInteractionsClosedDriverProtocol protocol.
///
/// See [`UnknownInteractionsClosedDriverProtocol`] for more details.
pub trait UnknownInteractionsClosedDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsClosedDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            9111839835597799810 => {
                handler.strict_one_way(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2815690661228737027 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            5761316743698652038 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            7235351480214368636 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            1839495150551777151 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            4350840352076287137 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            3933117456632607830 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            4598950031783776653 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            1456858375973362525 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsClosedProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventTableRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsClosedProtocolStrictEventTableRequest>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsClosedProtocolStrictEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsClosedProtocolStrictEventTableRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsClosedProtocolStrictEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsClosedProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedProtocol;

pub mod unknown_interactions_closed_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_closed_protocol, UnknownInteractionsClosedProtocol,
            UnknownInteractionsClosedProtocolClientHandler,
            UnknownInteractionsClosedProtocolClientSender,
            UnknownInteractionsClosedProtocolServerHandler,
            UnknownInteractionsClosedProtocolServerSender,
        };

        pub use crate::UnknownInteractionsClosedProtocolStrictEventFieldsRequest;

        pub use crate::UnknownInteractionsClosedProtocolStrictEventTableRequest;

        pub use crate::UnknownInteractionsClosedProtocolStrictEventUnionRequest;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 401526495318825508;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 6834828562275693047;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1379139029283639891;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7544414847426850727;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 7947328131967870853;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 5738532966428790074;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 802395819586836733;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 925029359463709824;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1260407702860823440;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 760799297757210939;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 6736355582617074292;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 4288682345454280036;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 2871682464255309246;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest;
    }
}

/// A helper trait for the `UnknownInteractionsClosedProtocol` client sender.
pub trait UnknownInteractionsClosedProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsClosedProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(401526495318825508, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6834828562275693047, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1379139029283639891, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7544414847426850727, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7947328131967870853, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5738532966428790074, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(802395819586836733, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(925029359463709824, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1260407702860823440, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsClosedProtocol protocol.
///
/// See [`UnknownInteractionsClosedProtocol`] for more details.
pub trait UnknownInteractionsClosedProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventUnion,
        >,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsClosedProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_closed_protocol::StrictEventTable,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsClosedProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedProtocolClientHandler<___T>,

    <unknown_interactions_closed_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            760799297757210939 => {
                handler.strict_event(sender);
            }

            6736355582617074292 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            4288682345454280036 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            2871682464255309246 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `UnknownInteractionsClosedProtocol` server sender.
pub trait UnknownInteractionsClosedProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_closed_protocol::StrictEventFields as ::fidl_next::Method>::Response,
                    >;

    fn strict_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_closed_protocol::StrictEventUnion as ::fidl_next::Method>::Response,
                    >;

    fn strict_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_closed_protocol::StrictEventTable as ::fidl_next::Method>::Response,
                    >;
}

impl<___T> UnknownInteractionsClosedProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(760799297757210939, &mut ())
    }








                fn strict_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_closed_protocol::StrictEventFields as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(6736355582617074292, request)
    }








                fn strict_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_closed_protocol::StrictEventUnion as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(4288682345454280036, request)
    }








                fn strict_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_closed_protocol::StrictEventTable as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(2871682464255309246, request)
    }
}

/// A server handler for the UnknownInteractionsClosedProtocol protocol.
///
/// See [`UnknownInteractionsClosedProtocol`] for more details.
pub trait UnknownInteractionsClosedProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsClosedProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsClosedProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsClosedProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            401526495318825508 => {
                handler.strict_one_way(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            6834828562275693047 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            1379139029283639891 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            7544414847426850727 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            7947328131967870853 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            5738532966428790074 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            802395819586836733 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            925029359463709824 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            1260407702860823440 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsDriverProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsDriverProtocolFlexibleTwoWayResponse = ();

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayResponse`].
pub type WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse`].
pub type WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
{
    type EncodedOption =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::TakeFrom<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    > for Option<Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn take_from(
        from: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
    ) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsDriverProtocol;

pub mod unknown_interactions_driver_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_driver_protocol, UnknownInteractionsDriverProtocol,
            UnknownInteractionsDriverProtocolClientHandler,
            UnknownInteractionsDriverProtocolClientSender,
            UnknownInteractionsDriverProtocolServerHandler,
            UnknownInteractionsDriverProtocolServerSender,
        };

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 6982839851953080288;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 1083620022582160398;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 1481114722667499972;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 6841797014773573215;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 1451514501977162287;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3330693085881435529;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 8222960355260037542;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 225387363174180470;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3066880266580913088;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 708169949929096689;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 2929398860738426482;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
        >;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 8423663794424433896;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
        >;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 8216450897182897849;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
        >;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 1049265954148894210;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse,
        >;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 5583489590753947170;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 6033174601748665003;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 6235121653537390575;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 940887795361350656;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }
}

/// A helper trait for the `UnknownInteractionsDriverProtocol` client sender.
pub trait UnknownInteractionsDriverProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsDriverProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(6982839851953080288, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(1083620022582160398, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1481114722667499972, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6841797014773573215, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1451514501977162287, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3330693085881435529, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8222960355260037542, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(225387363174180470, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3066880266580913088, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(708169949929096689, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2929398860738426482, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8423663794424433896, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8216450897182897849, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1049265954148894210, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5583489590753947170, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6033174601748665003, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6235121653537390575, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(940887795361350656, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsDriverProtocol protocol.
///
/// See [`UnknownInteractionsDriverProtocol`] for more details.
pub trait UnknownInteractionsDriverProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsDriverProtocolClientHandler<___T>,









            <unknown_interactions_driver_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWay as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,


{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
























































                ordinal => handler.on_unknown_interaction(sender, ordinal),

        }
    }
}

/// A helper trait for the `UnknownInteractionsDriverProtocol` server sender.
pub trait UnknownInteractionsDriverProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> UnknownInteractionsDriverProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the UnknownInteractionsDriverProtocol protocol.
///
/// See [`UnknownInteractionsDriverProtocol`] for more details.
pub trait UnknownInteractionsDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
    );

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::FlexibleTwoWay>,
    );

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
    );

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
    );

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
    );

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::FlexibleTwoWayErr>,
    );

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
    );

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
    );

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsDriverProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsDriverProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6982839851953080288 => {
                handler.strict_one_way(sender);
            }

            1083620022582160398 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1481114722667499972 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            6841797014773573215 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            1451514501977162287 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            3330693085881435529 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            8222960355260037542 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            225387363174180470 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            3066880266580913088 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            708169949929096689 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            2929398860738426482 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder);
            }

            8423663794424433896 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder);
            }

            8216450897182897849 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder);
            }

            1049265954148894210 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder);
            }

            5583489590753947170 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder);
            }

            6033174601748665003 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder);
            }

            6235121653537390575 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder);
            }

            940887795361350656 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayFieldsResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_strict_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableResponse>
    for UnknownInteractionsProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolStrictTwoWayTableResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_strict_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsProtocolFlexibleTwoWayResponse = ();

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayResponse`].
pub type WireUnknownInteractionsProtocolFlexibleTwoWayResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_flexible_two_way_union_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsProtocolFlexibleTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayErrResponse`].
pub type WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
{
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for Option<Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>>
{
    #[inline]
    fn take_from(
        from: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictEventFieldsRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolStrictEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventFieldsRequest>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolStrictEventFieldsRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventUnionRequest { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolStrictEventUnionRequest> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolStrictEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventUnionRequest>
    for UnknownInteractionsProtocolStrictEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest>
    for Option<Box<UnknownInteractionsProtocolStrictEventUnionRequest>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_strict_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsProtocolStrictEventTableRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolStrictEventTableRequest>
    for UnknownInteractionsProtocolStrictEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolStrictEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolStrictEventTableRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolStrictEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleEventFieldsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolFlexibleEventFieldsRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventUnionRequest {
    type Encoded = WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventUnionRequest { raw } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest> {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
        match from.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for Option<Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_flexible_event_union_request {
    pub enum Ref<'union> {
        SomeField(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventTableRequest {
    type Encoded = WireUnknownInteractionsProtocolFlexibleEventTableRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &mut self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnknownInteractionsProtocolFlexibleEventTableRequest>
    for UnknownInteractionsProtocolFlexibleEventTableRequest
{
    #[inline]
    fn take_from(from: &WireUnknownInteractionsProtocolFlexibleEventTableRequest) -> Self {
        Self { some_field: from.some_field().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventTableRequest {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnknownInteractionsProtocolFlexibleEventTableRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventTableRequest
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireUnknownInteractionsProtocolFlexibleEventTableRequest {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventTableRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsProtocol;

pub mod unknown_interactions_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_protocol, UnknownInteractionsProtocol,
            UnknownInteractionsProtocolClientHandler, UnknownInteractionsProtocolClientSender,
            UnknownInteractionsProtocolServerHandler, UnknownInteractionsProtocolServerSender,
        };

        pub use crate::UnknownInteractionsProtocolFlexibleEventFieldsRequest;

        pub use crate::UnknownInteractionsProtocolFlexibleEventTableRequest;

        pub use crate::UnknownInteractionsProtocolFlexibleEventUnionRequest;

        pub use crate::UnknownInteractionsProtocolStrictEventFieldsRequest;

        pub use crate::UnknownInteractionsProtocolStrictEventTableRequest;

        pub use crate::UnknownInteractionsProtocolStrictEventUnionRequest;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 5652707722400962470;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 583422011583300678;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 8308184097687583042;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 3697260130745060067;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 2455165891480464557;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8389853739594228663;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7862264614495172967;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 2414673307948662059;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4988571416540160202;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 5487292735562672344;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 334879577560091516;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response =
            ::fidl_next::WireFlexible<crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse>;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 4257018954691721778;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
        >;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 4913460516188409782;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
        >;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 9171907422498283911;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse,
        >;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 6999736795697216519;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 1093132337162001157;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 2410151523245950935;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 7893309626427980786;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 685715276307386305;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 8896208255987935026;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 3919175221694221274;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 2711448698318579984;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventTableRequest;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::Method for FlexibleEvent {
        const ORDINAL: u64 = 7042257263728687206;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::Method for FlexibleEventFields {
        const ORDINAL: u64 = 3613822014516746241;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 2499446536152409191;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::Method for FlexibleEventTable {
        const ORDINAL: u64 = 5724881371349617120;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest;
    }
}

/// A helper trait for the `UnknownInteractionsProtocol` client sender.
pub trait UnknownInteractionsProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> UnknownInteractionsProtocolClientSender
    for ::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(5652707722400962470, &mut ())
    }

    fn flexible_one_way(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(583422011583300678, &mut ())
    }

    fn strict_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8308184097687583042, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3697260130745060067, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2455165891480464557, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8389853739594228663, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7862264614495172967, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2414673307948662059, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4988571416540160202, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn strict_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::StrictTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5487292735562672344, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWay,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(334879577560091516, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFields,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4257018954691721778, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnion,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(4913460516188409782, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTable,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9171907422498283911, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6999736795697216519, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_fields_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayFieldsErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1093132337162001157, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_union_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayUnionErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2410151523245950935, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_two_way_table_err(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            unknown_interactions_protocol::FlexibleTwoWayTableErr,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7893309626427980786, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the UnknownInteractionsProtocol protocol.
///
/// See [`UnknownInteractionsProtocol`] for more details.
pub trait UnknownInteractionsProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,
    );

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::StrictEventFields,
        >,
    );

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<___T, unknown_interactions_protocol::StrictEventUnion>,
    );

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<___T, unknown_interactions_protocol::StrictEventTable>,
    );

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,
    );

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventFields,
        >,
    );

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventUnion,
        >,
    );

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            unknown_interactions_protocol::FlexibleEventTable,
        >,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, UnknownInteractionsProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for UnknownInteractionsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsProtocolClientHandler<___T>,

    <unknown_interactions_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWay as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            685715276307386305 => {
                handler.strict_event(sender);
            }

            8896208255987935026 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_fields(sender, buffer);
            }

            3919175221694221274 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_union(sender, buffer);
            }

            2711448698318579984 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.strict_event_table(sender, buffer);
            }

            7042257263728687206 => {
                handler.flexible_event(sender);
            }

            3613822014516746241 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_fields(sender, buffer);
            }

            2499446536152409191 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_union(sender, buffer);
            }

            5724881371349617120 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.flexible_event_table(sender, buffer);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `UnknownInteractionsProtocol` server sender.
pub trait UnknownInteractionsProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn strict_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::StrictEventFields as ::fidl_next::Method>::Response,
                    >;

    fn strict_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::StrictEventUnion as ::fidl_next::Method>::Response,
                    >;

    fn strict_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::StrictEventTable as ::fidl_next::Method>::Response,
                    >;

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn flexible_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::FlexibleEventFields as ::fidl_next::Method>::Response,
                    >;

    fn flexible_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response,
                    >;

    fn flexible_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::FlexibleEventTable as ::fidl_next::Method>::Response,
                    >;
}

impl<___T> UnknownInteractionsProtocolServerSender
    for ::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(685715276307386305, &mut ())
    }








                fn strict_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::StrictEventFields as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(8896208255987935026, request)
    }








                fn strict_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::StrictEventUnion as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(3919175221694221274, request)
    }








                fn strict_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::StrictEventTable as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(2711448698318579984, request)
    }

    fn flexible_event(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(7042257263728687206, &mut ())
    }








                fn flexible_event_fields<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::FlexibleEventFields as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(3613822014516746241, request)
    }








                fn flexible_event_union<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(2499446536152409191, request)
    }








                fn flexible_event_table<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <unknown_interactions_protocol::FlexibleEventTable as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(5724881371349617120, request)
    }
}

/// A server handler for the UnknownInteractionsProtocol protocol.
///
/// See [`UnknownInteractionsProtocol`] for more details.
pub trait UnknownInteractionsProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,
    );

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,
    );

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWay>,
    );

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayFields>,
    );

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayUnion>,
    );

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayTable>,
    );

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayErr>,
    );

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayFieldsErr>,
    );

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayUnionErr>,
    );

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayTableErr>,
    );

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWay>,
    );

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayFields>,
    );

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayUnion>,
    );

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayTable>,
    );

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayErr>,
    );

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayFieldsErr>,
    );

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayUnionErr>,
    );

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayTableErr>,
    );

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, UnknownInteractionsProtocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for UnknownInteractionsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: UnknownInteractionsProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5652707722400962470 => {
                handler.strict_one_way(sender);
            }

            583422011583300678 => {
                handler.flexible_one_way(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8308184097687583042 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder);
            }

            3697260130745060067 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder);
            }

            2455165891480464557 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder);
            }

            8389853739594228663 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder);
            }

            7862264614495172967 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder);
            }

            2414673307948662059 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder);
            }

            4988571416540160202 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder);
            }

            5487292735562672344 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder);
            }

            334879577560091516 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder);
            }

            4257018954691721778 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder);
            }

            4913460516188409782 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder);
            }

            9171907422498283911 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder);
            }

            6999736795697216519 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder);
            }

            1093132337162001157 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder);
            }

            2410151523245950935 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder);
            }

            7893309626427980786 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsAjarDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsAjarDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsAjarDriverProtocol,
    >;

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::UnknownInteractionsAjarDriverProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::UnknownInteractionsAjarDriverProtocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest,
        ) -> Self {
            Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest,
        ) -> Self {
            match from.as_ref() {

                                        crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest,
        ) -> Self {
            Self {
                some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest> for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsAjarProtocol`
    /// protocol.
    pub type UnknownInteractionsAjarProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsAjarProtocol,
    >;

    impl ::fidl_next::TakeFrom<crate::UnknownInteractionsAjarProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::UnknownInteractionsAjarProtocol) -> Self {
            Self
        }
    }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsClosedDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsClosedDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsClosedDriverProtocol,
    >;

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::UnknownInteractionsClosedDriverProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::UnknownInteractionsClosedDriverProtocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest> for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsClosedProtocol`
    /// protocol.
    pub type UnknownInteractionsClosedProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsClosedProtocol,
    >;

    impl ::fidl_next::TakeFrom<crate::UnknownInteractionsClosedProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::UnknownInteractionsClosedProtocol) -> Self {
            Self
        }
    }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsDriverProtocol,
    >;

    #[cfg(feature = "driver")]
    impl ::fidl_next::TakeFrom<crate::UnknownInteractionsDriverProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::UnknownInteractionsDriverProtocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse,
        ) -> Self {
            Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse,
        ) -> Self {
            match from.as_ref() {

                                        crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse,
        ) -> Self {
            Self {
                some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
        ) -> Self {
            match from.as_ref() {

                                        crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableErrResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse,
        ) -> Self {
            Self {
                some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
        ) -> Self {
            Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
        ) -> Self {
            match from.as_ref() {

                                        crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse,
        ) -> Self {
            Self {
                some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse) -> Self {
                                Self {

                                        some_field: ::fidl_next::TakeFrom::take_from(&from.some_field),

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
                            #[inline]
                            fn take_from(from: &crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) -> Self {
                                match from.as_ref() {

                                        crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
                        #[inline]
                        fn take_from(from: &crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse) -> Self {
                            Self {

                                    some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                                __source_breaking: ::fidl::marker::SourceBreaking,
                            }
                        }
                    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest,
        ) -> Self {
            Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictEventUnionRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest
    {
        #[inline]
        fn take_from(from: &crate::WireUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
            match from.as_ref() {

                                        crate::unknown_interactions_protocol_strict_event_union_request::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
        }
    }

    impl
        ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest>
        for Option<
            Box<
                ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest,
            >,
        >
    {
        #[inline]
        fn take_from(
            from: &crate::WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest,
        ) -> Self {
            if let Some(inner) = from.as_ref() {
                Some(::fidl_next::TakeFrom::take_from(inner))
            } else {
                None
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolStrictEventTableRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest
    {
        #[inline]
        fn take_from(from: &crate::WireUnknownInteractionsProtocolStrictEventTableRequest) -> Self {
            Self {
                some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest,
        ) -> Self {
            Self { some_field: ::fidl_next::TakeFrom::take_from(&from.some_field) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest,
        ) -> Self {
            match from.as_ref() {

                                        crate::unknown_interactions_protocol_flexible_event_union_request::Ref::SomeField(value) =>
                                            Self::SomeField(::fidl_next::TakeFrom::take_from(value)),


                                        crate::unknown_interactions_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown_ordinal) =>
                                            Self::__SourceBreaking { unknown_ordinal },

                                }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest> for Option<Box<::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest>> {
                            #[inline]
                            fn take_from(from: &crate::WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
                                if let Some(inner) = from.as_ref() {
                                    Some(::fidl_next::TakeFrom::take_from(inner))
                                } else {
                                    None
                                }
                            }
                        }

    impl ::fidl_next::TakeFrom<crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest,
        ) -> Self {
            Self {
                some_field: from.some_field().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsProtocol`
    /// protocol.
    pub type UnknownInteractionsProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsProtocol,
    >;

    impl ::fidl_next::TakeFrom<crate::UnknownInteractionsProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::UnknownInteractionsProtocol) -> Self {
            Self
        }
    }
}
