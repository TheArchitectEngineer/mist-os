// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsMember: u32 {
        const BIT_ONE = 1;
        const BIT_TWO = 2;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for BitsMember {
    type Encoded = WireBitsMember;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for BitsMember
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsMember { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBitsMember> for BitsMember {
    fn from(wire: WireBitsMember) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBitsMember> for BitsMember {
    #[inline]
    fn take_from(from: &WireBitsMember) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`BitsMember`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsMember {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireBitsMember {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsMember
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<BitsMember> for WireBitsMember {
    fn from(natural: BitsMember) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Op {
    Add = 1,
    Mul = 2,
    Div = 3,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Op {
    type Encoded = WireOp;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Op
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOp { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::Add => 1,

            Self::Mul => 2,

            Self::Div => 3,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireOp> for Op {
    fn from(wire: WireOp) -> Self {
        match u32::from(wire.value) {
            1 => Self::Add,

            2 => Self::Mul,

            3 => Self::Div,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireOp> for Op {
    #[inline]
    fn take_from(from: &WireOp) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Op`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireOp {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireOp {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireOp {
    pub const ADD: WireOp = WireOp { value: ::fidl_next::WireU32(1) };

    pub const MUL: WireOp = WireOp { value: ::fidl_next::WireU32(2) };

    pub const DIV: WireOp = WireOp { value: ::fidl_next::WireU32(3) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOp
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Op> for WireOp {
    fn from(natural: Op) -> Self {
        match natural {
            Op::Add => WireOp::ADD,

            Op::Mul => WireOp::MUL,

            Op::Div => WireOp::DIV,

            Op::UnknownOrdinal_(value) => WireOp { value: ::fidl_next::WireU32::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
pub struct OverrideTest {
    pub op: crate::Op,

    pub left: Option<Box<crate::Expression>>,

    pub right: Option<Box<crate::Expression>>,
}

impl ::fidl_next::Encodable for OverrideTest {
    type Encoded = WireOverrideTest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OverrideTest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                op,
                left,
                right,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.op, encoder, op)?;

        ::fidl_next::Encode::encode(&mut self.left, encoder, left)?;

        ::fidl_next::Encode::encode(&mut self.right, encoder, right)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OverrideTest> {
    type EncodedOption = ::fidl_next::WireBox<WireOverrideTest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<OverrideTest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OverrideTest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOverrideTest> for OverrideTest {
    #[inline]
    fn take_from(from: &WireOverrideTest) -> Self {
        Self {
            op: ::fidl_next::TakeFrom::take_from(&from.op),

            left: ::fidl_next::TakeFrom::take_from(&from.left),

            right: ::fidl_next::TakeFrom::take_from(&from.right),
        }
    }
}

/// The wire type corresponding to [`OverrideTest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireOverrideTest {
    pub op: crate::WireOp,

    pub left: crate::WireOptionalExpression,

    pub right: crate::WireOptionalExpression,
}

unsafe impl ::fidl_next::ZeroPadding for WireOverrideTest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(4).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOverrideTest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut op,
                mut left,
                mut right,

            } = slot;
        }

        ::fidl_next::Decode::decode(op.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(left.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(right.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Flags: u16 {
        const INLINE = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Flags {
    type Encoded = WireFlags;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Flags
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlags { value } = out);
        let _ = value.write(::fidl_next::WireU16::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireFlags> for Flags {
    fn from(wire: WireFlags) -> Self {
        Self::from_bits_retain(u16::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireFlags> for Flags {
    #[inline]
    fn take_from(from: &WireFlags) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Flags`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireFlags {
    value: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::ZeroPadding for WireFlags {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlags
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Flags> for WireFlags {
    fn from(natural: Flags) -> Self {
        Self { value: ::fidl_next::WireU16::from(natural.bits()) }
    }
}

#[derive(Clone, Debug, Default)]
pub struct FunctionApplication {
    pub func: Option<String>,

    pub args: Option<Vec<Option<Box<crate::Expression>>>>,

    pub flags: Option<crate::Flags>,
}

impl FunctionApplication {
    fn __max_ordinal(&self) -> usize {
        if self.func.is_some() {
            return 1;
        }

        if self.args.is_some() {
            return 3;
        }

        if self.flags.is_some() {
            return 4;
        }

        0
    }
}

impl ::fidl_next::Encodable for FunctionApplication {
    type Encoded = WireFunctionApplication;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for FunctionApplication
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFunctionApplication { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                4 => {
                    if let Some(flags) = &mut self.flags {
                        ::fidl_next::WireEnvelope::encode_value(
                            flags,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(args) = &mut self.args {
                        ::fidl_next::WireEnvelope::encode_value(
                            args,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(func) = &mut self.func {
                        ::fidl_next::WireEnvelope::encode_value(
                            func,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFunctionApplication> for FunctionApplication {
    #[inline]
    fn take_from(from: &WireFunctionApplication) -> Self {
        Self {
            func: from.func().map(::fidl_next::TakeFrom::take_from),

            args: from.args().map(::fidl_next::TakeFrom::take_from),

            flags: from.flags().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`FunctionApplication`].
#[repr(C)]
pub struct WireFunctionApplication {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireFunctionApplication {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFunctionApplication
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireString>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    let func = unsafe {
                        slot.deref_unchecked().deref_unchecked::<::fidl_next::WireString>()
                    };

                    if func.len() > 100 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: func.len() as u64,
                            limit: 100,
                        });
                    }

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<crate::WireOptionalExpression>,
                    >(slot.as_mut(), decoder)?;

                    let args = unsafe {
                        slot
                                            .deref_unchecked()
                                            .deref_unchecked::<
                                                ::fidl_next::WireVector<crate::WireOptionalExpression>
                                            >()
                    };

                    if args.len() > 5 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: args.len() as u64,
                            limit: 5,
                        });
                    }

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, crate::WireFlags>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireFunctionApplication {
    pub fn func(&self) -> Option<&::fidl_next::WireString> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn args(&self) -> Option<&::fidl_next::WireVector<crate::WireOptionalExpression>> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn flags(&self) -> Option<&crate::WireFlags> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireFunctionApplication {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("FunctionApplication")
            .field("func", &self.func())
            .field("args", &self.args())
            .field("flags", &self.flags())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum Expression {
    Value(u64),

    BinOp(crate::OverrideTest),

    FunctionApplication(crate::FunctionApplication),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Expression {
    type Encoded = WireExpression;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Expression
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExpression { raw } = out);

        match self {
            Self::Value(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u64>(value, 1, encoder, raw)?
            }

            Self::BinOp(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::OverrideTest>(
                    value, 2, encoder, raw,
                )?
            }

            Self::FunctionApplication(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::FunctionApplication,
            >(value, 3, encoder, raw)?,

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Expression> {
    type EncodedOption = WireOptionalExpression;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Expression>
where
    ___E: ?Sized,
    Expression: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExpression { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExpression> for Expression {
    #[inline]
    fn take_from(from: &WireExpression) -> Self {
        match from.raw.ordinal() {
            1 => Self::Value(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireU64>()
            })),

            2 => Self::BinOp(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<crate::WireOverrideTest>()
            })),

            3 => Self::FunctionApplication(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<crate::WireFunctionApplication>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalExpression> for Option<Box<Expression>> {
    #[inline]
    fn take_from(from: &WireOptionalExpression) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Expression`].
#[repr(transparent)]
pub struct WireExpression {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireExpression {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod expression {
    pub enum Ref<'union> {
        Value(&'union ::fidl_next::WireU64),

        BinOp(&'union crate::WireOverrideTest),

        FunctionApplication(&'union crate::WireFunctionApplication),

        UnknownOrdinal_(u64),
    }
}

impl WireExpression {
    pub fn as_ref(&self) -> crate::expression::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::expression::Ref::Value(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU64>()
            }),

            2 => crate::expression::Ref::BinOp(unsafe {
                self.raw.get().deref_unchecked::<crate::WireOverrideTest>()
            }),

            3 => crate::expression::Ref::FunctionApplication(unsafe {
                self.raw.get().deref_unchecked::<crate::WireFunctionApplication>()
            }),

            unknown => crate::expression::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExpression
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU64>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireFunctionApplication>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireExpression {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU64>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WireOverrideTest>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireFunctionApplication>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExpression {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalExpression {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalExpression {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExpression> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExpression
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU64>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireFunctionApplication>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalExpression {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnionMember {
    UnionData(u8),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnionMember {
    type Encoded = WireUnionMember;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnionMember
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionMember { raw } = out);

        match self {
            Self::UnionData(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u8>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionMember> {
    type EncodedOption = WireOptionalUnionMember;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionMember>
where
    ___E: ?Sized,
    UnionMember: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionMember { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnionMember> for UnionMember {
    #[inline]
    fn take_from(from: &WireUnionMember) -> Self {
        match from.raw.ordinal() {
            2 => Self::UnionData(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<u8>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnionMember> for Option<Box<UnionMember>> {
    #[inline]
    fn take_from(from: &WireOptionalUnionMember) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionMember`].
#[repr(transparent)]
pub struct WireUnionMember {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnionMember {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union_member {
    pub enum Ref<'union> {
        UnionData(&'union u8),

        UnknownOrdinal_(u64),
    }
}

impl WireUnionMember {
    pub fn as_ref(&self) -> crate::union_member::Ref<'_> {
        match self.raw.ordinal() {
            2 => crate::union_member::Ref::UnionData(unsafe {
                self.raw.get().deref_unchecked::<u8>()
            }),

            unknown => crate::union_member::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnionMember {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            2 => Self { raw: unsafe { self.raw.clone_unchecked::<u8>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionMember
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<u8>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionMember {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalUnionMember {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnionMember {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionMember> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnionMember {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnionMember { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            2 => Self { raw: unsafe { self.raw.clone_unchecked::<u8>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnionMember
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct TableData {
    pub data: u8,
}

impl ::fidl_next::Encodable for TableData {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u8 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireTableData;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TableData
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                data,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.data, encoder, data)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<TableData> {
    type EncodedOption = ::fidl_next::WireBox<WireTableData>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<TableData>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TableData: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTableData> for TableData {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u8 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireTableData) -> Self {
        Self { data: ::fidl_next::TakeFrom::take_from(&from.data) }
    }
}

/// The wire type corresponding to [`TableData`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireTableData {
    pub data: u8,
}

unsafe impl ::fidl_next::ZeroPadding for WireTableData {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableData
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut data,

            } = slot;
        }

        ::fidl_next::Decode::decode(data.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct TableMember {
    pub table_data: Option<Vec<crate::TableData>>,
}

impl TableMember {
    fn __max_ordinal(&self) -> usize {
        if self.table_data.is_some() {
            return 2;
        }

        0
    }
}

impl ::fidl_next::Encodable for TableMember {
    type Encoded = WireTableMember;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TableMember
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableMember { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                2 => {
                    if let Some(table_data) = &mut self.table_data {
                        ::fidl_next::WireEnvelope::encode_value(
                            table_data,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTableMember> for TableMember {
    #[inline]
    fn take_from(from: &WireTableMember) -> Self {
        Self { table_data: from.table_data().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`TableMember`].
#[repr(C)]
pub struct WireTableMember {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireTableMember {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableMember
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<crate::WireTableData>,
                    >(slot.as_mut(), decoder)?;

                    let table_data = unsafe {
                        slot.deref_unchecked()
                            .deref_unchecked::<::fidl_next::WireVector<crate::WireTableData>>()
                    };

                    if table_data.len() > 10 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: table_data.len() as u64,
                            limit: 10,
                        });
                    }

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireTableMember {
    pub fn table_data(&self) -> Option<&::fidl_next::WireVector<crate::WireTableData>> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireTableMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("TableMember").field("table_data", &self.table_data()).finish()
    }
}

#[derive(Clone, Debug)]
pub struct SomeProtocolSomeMethodRequest {
    pub union_member: crate::UnionMember,

    pub table_member: crate::TableMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodRequest {
    type Encoded = WireSomeProtocolSomeMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                union_member,
                table_member,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.union_member, encoder, union_member)?;

        ::fidl_next::Encode::encode(&mut self.table_member, encoder, table_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireSomeProtocolSomeMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodRequest> for SomeProtocolSomeMethodRequest {
    #[inline]
    fn take_from(from: &WireSomeProtocolSomeMethodRequest) -> Self {
        Self {
            union_member: ::fidl_next::TakeFrom::take_from(&from.union_member),

            table_member: ::fidl_next::TakeFrom::take_from(&from.table_member),
        }
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodRequest {
    pub union_member: crate::WireUnionMember,

    pub table_member: crate::WireTableMember,
}

unsafe impl ::fidl_next::ZeroPadding for WireSomeProtocolSomeMethodRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut union_member,
                mut table_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(union_member.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct SomeProtocolSomeMethodResponse {
    pub bits_member: crate::BitsMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::BitsMember as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireSomeProtocolSomeMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits_member,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.bits_member, encoder, bits_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireSomeProtocolSomeMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodResponse> for SomeProtocolSomeMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::BitsMember as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireSomeProtocolSomeMethodResponse) -> Self {
        Self { bits_member: ::fidl_next::TakeFrom::take_from(&from.bits_member) }
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodResponse {
    pub bits_member: crate::WireBitsMember,
}

unsafe impl ::fidl_next::ZeroPadding for WireSomeProtocolSomeMethodResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum SomeProtocolSomeMethodError {
    ErrorOne = 1,
    ErrorTwo = 2,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodError {
    type Encoded = WireSomeProtocolSomeMethodError;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodError
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSomeProtocolSomeMethodError { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::ErrorOne => 1,

            Self::ErrorTwo => 2,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    fn from(wire: WireSomeProtocolSomeMethodError) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrorOne,

            2 => Self::ErrorTwo,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    #[inline]
    fn take_from(from: &WireSomeProtocolSomeMethodError) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodError`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireSomeProtocolSomeMethodError {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireSomeProtocolSomeMethodError {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireSomeProtocolSomeMethodError {
    pub const ERROR_ONE: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32(1) };

    pub const ERROR_TWO: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodError
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<SomeProtocolSomeMethodError> for WireSomeProtocolSomeMethodError {
    fn from(natural: SomeProtocolSomeMethodError) -> Self {
        match natural {
            SomeProtocolSomeMethodError::ErrorOne => WireSomeProtocolSomeMethodError::ERROR_ONE,

            SomeProtocolSomeMethodError::ErrorTwo => WireSomeProtocolSomeMethodError::ERROR_TWO,

            SomeProtocolSomeMethodError::UnknownOrdinal_(value) => {
                WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32::from(value) }
            }
        }
    }
}

/// The type corresponding to the SomeProtocol protocol.
#[derive(Debug)]
pub struct SomeProtocol;

pub mod some_protocol {
    pub mod prelude {
        pub use crate::{
            some_protocol, SomeProtocol, SomeProtocolClientHandler, SomeProtocolClientSender,
            SomeProtocolServerHandler, SomeProtocolServerSender,
        };

        pub use crate::SomeProtocolSomeMethodRequest;

        pub use crate::SomeProtocolSomeMethodError;

        pub use crate::SomeProtocolSomeMethodResponse;
    }

    pub struct SomeMethod;

    impl ::fidl_next::Method for SomeMethod {
        const ORDINAL: u64 = 2515914517457749720;

        type Protocol = crate::SomeProtocol;

        type Request = crate::WireSomeProtocolSomeMethodRequest;

        type Response = ::fidl_next::WireResult<
            crate::WireSomeProtocolSomeMethodResponse,
            crate::WireSomeProtocolSomeMethodError,
        >;
    }
}

/// A helper trait for the `SomeProtocol` client sender.
pub trait SomeProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn some_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, some_protocol::SomeMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSomeProtocolSomeMethodRequest,
        >;
}

impl<___T> SomeProtocolClientSender for ::fidl_next::ClientSender<___T, SomeProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn some_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, some_protocol::SomeMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSomeProtocolSomeMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2515914517457749720, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the SomeProtocol protocol.
///
/// See [`SomeProtocol`] for more details.
pub trait SomeProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for SomeProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SomeProtocolClientHandler<___T>,

    <some_protocol::SomeMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SomeProtocol` server sender.
pub trait SomeProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> SomeProtocolServerSender for ::fidl_next::ServerSender<___T, SomeProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the SomeProtocol protocol.
///
/// See [`SomeProtocol`] for more details.
pub trait SomeProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn some_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, SomeProtocol>,

        request: ::fidl_next::RequestBuffer<___T, some_protocol::SomeMethod>,

        responder: ::fidl_next::Responder<some_protocol::SomeMethod>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for SomeProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SomeProtocolServerHandler<___T>,

    crate::WireSomeProtocolSomeMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2515914517457749720 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.some_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::TakeFrom<crate::WireBitsMember> for ::fidl_test_anonymous::BitsMember {
        #[inline]
        fn take_from(from: &crate::WireBitsMember) -> Self {
            Self::from_bits_retain(from.value.into())
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOp> for ::fidl_test_anonymous::Op {
        #[inline]
        fn take_from(from: &crate::WireOp) -> Self {
            match crate::Op::from(*from) {
                crate::Op::Add => Self::Add,

                crate::Op::Mul => Self::Mul,

                crate::Op::Div => Self::Div,

                crate::Op::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOverrideTest> for ::fidl_test_anonymous::OverrideTest {
        #[inline]
        fn take_from(from: &crate::WireOverrideTest) -> Self {
            Self {
                op: ::fidl_next::TakeFrom::take_from(&from.op),

                left: ::fidl_next::TakeFrom::take_from(&from.left),

                right: ::fidl_next::TakeFrom::take_from(&from.right),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireFlags> for ::fidl_test_anonymous::Flags {
        #[inline]
        fn take_from(from: &crate::WireFlags) -> Self {
            Self::from_bits_retain(from.value.into())
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireFunctionApplication>
        for ::fidl_test_anonymous::FunctionApplication
    {
        #[inline]
        fn take_from(from: &crate::WireFunctionApplication) -> Self {
            Self {
                func: from.func().map(::fidl_next::TakeFrom::take_from),

                args: from.args().map(::fidl_next::TakeFrom::take_from),

                flags: from.flags().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireExpression> for ::fidl_test_anonymous::Expression {
        #[inline]
        fn take_from(from: &crate::WireExpression) -> Self {
            match from.as_ref() {
                crate::expression::Ref::Value(value) => {
                    Self::Value(::fidl_next::TakeFrom::take_from(value))
                }

                crate::expression::Ref::BinOp(value) => {
                    Self::BinOp(::fidl_next::TakeFrom::take_from(value))
                }

                crate::expression::Ref::FunctionApplication(value) => {
                    Self::FunctionApplication(::fidl_next::TakeFrom::take_from(value))
                }

                crate::expression::Ref::UnknownOrdinal_(unknown_ordinal) => {
                    Self::__SourceBreaking { unknown_ordinal }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalExpression>
        for Option<Box<::fidl_test_anonymous::Expression>>
    {
        #[inline]
        fn take_from(from: &crate::WireOptionalExpression) -> Self {
            if let Some(inner) = from.as_ref() {
                Some(::fidl_next::TakeFrom::take_from(inner))
            } else {
                None
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnionMember> for ::fidl_test_anonymous::UnionMember {
        #[inline]
        fn take_from(from: &crate::WireUnionMember) -> Self {
            match from.as_ref() {
                crate::union_member::Ref::UnionData(value) => {
                    Self::UnionData(::fidl_next::TakeFrom::take_from(value))
                }

                crate::union_member::Ref::UnknownOrdinal_(unknown_ordinal) => {
                    Self::__SourceBreaking { unknown_ordinal }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnionMember>
        for Option<Box<::fidl_test_anonymous::UnionMember>>
    {
        #[inline]
        fn take_from(from: &crate::WireOptionalUnionMember) -> Self {
            if let Some(inner) = from.as_ref() {
                Some(::fidl_next::TakeFrom::take_from(inner))
            } else {
                None
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireTableData> for ::fidl_test_anonymous::TableData {
        #[inline]
        fn take_from(from: &crate::WireTableData) -> Self {
            Self { data: ::fidl_next::TakeFrom::take_from(&from.data) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireTableMember> for ::fidl_test_anonymous::TableMember {
        #[inline]
        fn take_from(from: &crate::WireTableMember) -> Self {
            Self {
                table_data: from.table_data().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireSomeProtocolSomeMethodRequest>
        for ::fidl_test_anonymous::SomeProtocolSomeMethodRequest
    {
        #[inline]
        fn take_from(from: &crate::WireSomeProtocolSomeMethodRequest) -> Self {
            Self {
                union_member: ::fidl_next::TakeFrom::take_from(&from.union_member),

                table_member: ::fidl_next::TakeFrom::take_from(&from.table_member),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireSomeProtocolSomeMethodResponse>
        for ::fidl_test_anonymous::SomeProtocolSomeMethodResponse
    {
        #[inline]
        fn take_from(from: &crate::WireSomeProtocolSomeMethodResponse) -> Self {
            Self { bits_member: ::fidl_next::TakeFrom::take_from(&from.bits_member) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireSomeProtocolSomeMethodError>
        for ::fidl_test_anonymous::SomeProtocolSomeMethodError
    {
        #[inline]
        fn take_from(from: &crate::WireSomeProtocolSomeMethodError) -> Self {
            match crate::SomeProtocolSomeMethodError::from(*from) {
                crate::SomeProtocolSomeMethodError::ErrorOne => Self::ErrorOne,

                crate::SomeProtocolSomeMethodError::ErrorTwo => Self::ErrorTwo,

                crate::SomeProtocolSomeMethodError::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `SomeProtocol`
    /// protocol.
    pub type SomeProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::SomeProtocol>;

    impl ::fidl_next::TakeFrom<crate::SomeProtocol> for ::fidl_test_anonymous::SomeProtocolMarker {
        #[inline]
        fn take_from(from: &crate::SomeProtocol) -> Self {
            Self
        }
    }
}
