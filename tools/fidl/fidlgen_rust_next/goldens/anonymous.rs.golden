// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsMember: u32 {
        const BIT_ONE = 1;
        const BIT_TWO = 2;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for BitsMember {
    type Encoded = WireBitsMember;
}

impl<___E> ::fidl_next::Encode<___E> for BitsMember
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsMember { mut value } = slot);
        *value = ::fidl_next::WireU32::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireBitsMember> for BitsMember {
    fn from(wire: WireBitsMember) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBitsMember> for BitsMember {
    #[inline]
    fn take_from(from: &WireBitsMember) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`BitsMember`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsMember {
    value: ::fidl_next::WireU32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsMember
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<BitsMember> for WireBitsMember {
    fn from(natural: BitsMember) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Op {
    Add = 1,
    Mul = 2,
    Div = 3,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Op {
    type Encoded = WireOp;
}

impl<___E> ::fidl_next::Encode<___E> for Op
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOp { mut value } = slot);
        *value = ::fidl_next::WireU32::from(match *self {
            Self::Add => 1,

            Self::Mul => 2,

            Self::Div => 3,

            Self::UnknownOrdinal_(value) => value,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireOp> for Op {
    fn from(wire: WireOp) -> Self {
        match u32::from(wire.value) {
            1 => Self::Add,

            2 => Self::Mul,

            3 => Self::Div,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireOp> for Op {
    #[inline]
    fn take_from(from: &WireOp) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Op`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireOp {
    value: ::fidl_next::WireU32,
}

impl WireOp {
    pub const ADD: WireOp = WireOp { value: ::fidl_next::WireU32(1) };

    pub const MUL: WireOp = WireOp { value: ::fidl_next::WireU32(2) };

    pub const DIV: WireOp = WireOp { value: ::fidl_next::WireU32(3) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOp
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Op> for WireOp {
    fn from(natural: Op) -> Self {
        match natural {
            Op::Add => WireOp::ADD,

            Op::Mul => WireOp::MUL,

            Op::Div => WireOp::DIV,

            Op::UnknownOrdinal_(value) => WireOp { value: ::fidl_next::WireU32::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
pub struct OverrideTest {
    pub op: crate::Op,

    pub left: Option<Box<crate::Expression>>,

    pub right: Option<Box<crate::Expression>>,
}

impl ::fidl_next::Encodable for OverrideTest {
    type Encoded = WireOverrideTest;
}

impl<___E> ::fidl_next::Encode<___E> for OverrideTest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                op,
                left,
                right,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.op, encoder, op)?;

        ::fidl_next::Encode::encode(&mut self.left, encoder, left)?;

        ::fidl_next::Encode::encode(&mut self.right, encoder, right)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OverrideTest> {
    type EncodedOption = ::fidl_next::WireBox<WireOverrideTest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OverrideTest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OverrideTest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOverrideTest> for OverrideTest {
    #[inline]
    fn take_from(from: &WireOverrideTest) -> Self {
        Self {
            op: ::fidl_next::TakeFrom::take_from(&from.op),

            left: ::fidl_next::TakeFrom::take_from(&from.left),

            right: ::fidl_next::TakeFrom::take_from(&from.right),
        }
    }
}

/// The wire type corersponding to [`OverrideTest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireOverrideTest {
    pub op: crate::WireOp,

    pub left: crate::WireOptionalExpression,

    pub right: crate::WireOptionalExpression,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOverrideTest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut op,
                mut left,
                mut right,

            } = slot;
        }

        ::fidl_next::Decode::decode(op.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(left.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(right.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Flags: u16 {
        const INLINE = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Flags {
    type Encoded = WireFlags;
}

impl<___E> ::fidl_next::Encode<___E> for Flags
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlags { mut value } = slot);
        *value = ::fidl_next::WireU16::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireFlags> for Flags {
    fn from(wire: WireFlags) -> Self {
        Self::from_bits_retain(u16::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireFlags> for Flags {
    #[inline]
    fn take_from(from: &WireFlags) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Flags`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireFlags {
    value: ::fidl_next::WireU16,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlags
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Flags> for WireFlags {
    fn from(natural: Flags) -> Self {
        Self { value: ::fidl_next::WireU16::from(natural.bits()) }
    }
}

#[derive(Clone, Debug)]
pub struct FunctionApplication {
    pub func: Option<String>,

    pub args: Option<Vec<Option<Box<crate::Expression>>>>,

    pub flags: Option<crate::Flags>,
}

impl FunctionApplication {
    fn __max_ordinal(&self) -> usize {
        if self.func.is_some() {
            return 1;
        }

        if self.args.is_some() {
            return 3;
        }

        if self.flags.is_some() {
            return 4;
        }

        0
    }
}

impl ::fidl_next::Encodable for FunctionApplication {
    type Encoded = WireFunctionApplication;
}

impl<___E> ::fidl_next::Encode<___E> for FunctionApplication
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFunctionApplication { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                4 => {
                    if let Some(flags) = &mut self.flags {
                        ::fidl_next::WireEnvelope::encode_value(
                            flags,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                3 => {
                    if let Some(args) = &mut self.args {
                        ::fidl_next::WireEnvelope::encode_value(
                            args,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                1 => {
                    if let Some(func) = &mut self.func {
                        ::fidl_next::WireEnvelope::encode_value(
                            func,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFunctionApplication> for FunctionApplication {
    #[inline]
    fn take_from(from: &WireFunctionApplication) -> Self {
        Self {
            func: from.func().map(::fidl_next::TakeFrom::take_from),

            args: from.args().map(::fidl_next::TakeFrom::take_from),

            flags: from.flags().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`FunctionApplication`].
#[repr(C)]
pub struct WireFunctionApplication {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFunctionApplication
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireString>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    let func = unsafe {
                        slot.deref_unchecked().deref_unchecked::<::fidl_next::WireString>()
                    };

                    if func.len() > 100 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: func.len() as u64,
                            limit: 100,
                        });
                    }

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<crate::WireOptionalExpression>,
                    >(slot.as_mut(), decoder)?;

                    let args = unsafe {
                        slot
                                            .deref_unchecked()
                                            .deref_unchecked::<
                                                ::fidl_next::WireVector<crate::WireOptionalExpression>
                                            >()
                    };

                    if args.len() > 5 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: args.len() as u64,
                            limit: 5,
                        });
                    }

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, crate::WireFlags>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireFunctionApplication {
    pub fn func(&self) -> Option<&::fidl_next::WireString> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn args(&self) -> Option<&::fidl_next::WireVector<crate::WireOptionalExpression>> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn flags(&self) -> Option<&crate::WireFlags> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireFunctionApplication {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("FunctionApplication")
            .field("func", &self.func())
            .field("args", &self.args())
            .field("flags", &self.flags())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum Expression {
    Value(u64),

    BinOp(crate::OverrideTest),

    FunctionApplication(crate::FunctionApplication),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Expression {
    type Encoded = WireExpression;
}

impl<___E> ::fidl_next::Encode<___E> for Expression
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExpression { raw } = slot);

        match self {
            Self::Value(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u64>(value, 1, encoder, raw)?
            }

            Self::BinOp(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::OverrideTest>(
                    value, 2, encoder, raw,
                )?
            }

            Self::FunctionApplication(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::FunctionApplication,
            >(value, 3, encoder, raw)?,

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Expression> {
    type EncodedOption = WireOptionalExpression;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Expression>
where
    ___E: ?Sized,
    Expression: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExpression { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExpression> for Expression {
    #[inline]
    fn take_from(from: &WireExpression) -> Self {
        match from.raw.ordinal() {
            1 => Self::Value(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::BinOp(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::FunctionApplication(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalExpression> for Option<Box<Expression>> {
    #[inline]
    fn take_from(from: &WireOptionalExpression) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Expression`].
#[repr(transparent)]
pub struct WireExpression {
    raw: ::fidl_next::RawWireUnion,
}

pub mod expression {
    pub enum Ref<'union> {
        Value(&'union ::fidl_next::WireU64),

        BinOp(&'union crate::WireOverrideTest),

        FunctionApplication(&'union crate::WireFunctionApplication),

        UnknownOrdinal_(u64),
    }
}

impl WireExpression {
    pub fn as_ref(&self) -> crate::expression::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::expression::Ref::Value(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::expression::Ref::BinOp(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::expression::Ref::FunctionApplication(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::expression::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExpression
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU64>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireFunctionApplication>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireExpression {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU64>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WireOverrideTest>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireFunctionApplication>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExpression {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalExpression {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExpression> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExpression
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU64>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireFunctionApplication>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalExpression {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnionMember {
    UnionData(u8),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnionMember {
    type Encoded = WireUnionMember;
}

impl<___E> ::fidl_next::Encode<___E> for UnionMember
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionMember { raw } = slot);

        match self {
            Self::UnionData(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u8>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionMember> {
    type EncodedOption = WireOptionalUnionMember;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionMember>
where
    ___E: ?Sized,
    UnionMember: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionMember { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnionMember> for UnionMember {
    #[inline]
    fn take_from(from: &WireUnionMember) -> Self {
        match from.raw.ordinal() {
            2 => Self::UnionData(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnionMember> for Option<Box<UnionMember>> {
    #[inline]
    fn take_from(from: &WireOptionalUnionMember) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionMember`].
#[repr(transparent)]
pub struct WireUnionMember {
    raw: ::fidl_next::RawWireUnion,
}

pub mod union_member {
    pub enum Ref<'union> {
        UnionData(&'union u8),

        UnknownOrdinal_(u64),
    }
}

impl WireUnionMember {
    pub fn as_ref(&self) -> crate::union_member::Ref<'_> {
        match self.raw.ordinal() {
            2 => crate::union_member::Ref::UnionData(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::union_member::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnionMember {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            2 => Self { raw: unsafe { self.raw.clone_unchecked::<u8>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionMember
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<u8>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionMember {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnionMember {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionMember> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnionMember {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnionMember { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            2 => Self { raw: unsafe { self.raw.clone_unchecked::<u8>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnionMember
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct TableData {
    pub data: u8,
}

impl ::fidl_next::Encodable for TableData {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u8 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireTableData;
}

impl<___E> ::fidl_next::Encode<___E> for TableData
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                data,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.data, encoder, data)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<TableData> {
    type EncodedOption = ::fidl_next::WireBox<WireTableData>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<TableData>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TableData: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTableData> for TableData {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u8 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireTableData) -> Self {
        Self { data: ::fidl_next::TakeFrom::take_from(&from.data) }
    }
}

/// The wire type corersponding to [`TableData`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireTableData {
    pub data: u8,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableData
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut data,

            } = slot;
        }

        ::fidl_next::Decode::decode(data.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TableMember {
    pub table_data: Option<Vec<crate::TableData>>,
}

impl TableMember {
    fn __max_ordinal(&self) -> usize {
        if self.table_data.is_some() {
            return 2;
        }

        0
    }
}

impl ::fidl_next::Encodable for TableMember {
    type Encoded = WireTableMember;
}

impl<___E> ::fidl_next::Encode<___E> for TableMember
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableMember { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                2 => {
                    if let Some(table_data) = &mut self.table_data {
                        ::fidl_next::WireEnvelope::encode_value(
                            table_data,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTableMember> for TableMember {
    #[inline]
    fn take_from(from: &WireTableMember) -> Self {
        Self { table_data: from.table_data().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`TableMember`].
#[repr(C)]
pub struct WireTableMember {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableMember
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<crate::WireTableData>,
                    >(slot.as_mut(), decoder)?;

                    let table_data = unsafe {
                        slot.deref_unchecked()
                            .deref_unchecked::<::fidl_next::WireVector<crate::WireTableData>>()
                    };

                    if table_data.len() > 10 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: table_data.len() as u64,
                            limit: 10,
                        });
                    }

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireTableMember {
    pub fn table_data(&self) -> Option<&::fidl_next::WireVector<crate::WireTableData>> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireTableMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("TableMember").field("table_data", &self.table_data()).finish()
    }
}

#[derive(Clone, Debug)]
pub struct SomeProtocolSomeMethodRequest {
    pub union_member: crate::UnionMember,

    pub table_member: crate::TableMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodRequest {
    type Encoded = WireSomeProtocolSomeMethodRequest;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                union_member,
                table_member,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.union_member, encoder, union_member)?;

        ::fidl_next::Encode::encode(&mut self.table_member, encoder, table_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireSomeProtocolSomeMethodRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodRequest> for SomeProtocolSomeMethodRequest {
    #[inline]
    fn take_from(from: &WireSomeProtocolSomeMethodRequest) -> Self {
        Self {
            union_member: ::fidl_next::TakeFrom::take_from(&from.union_member),

            table_member: ::fidl_next::TakeFrom::take_from(&from.table_member),
        }
    }
}

/// The wire type corersponding to [`SomeProtocolSomeMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodRequest {
    pub union_member: crate::WireUnionMember,

    pub table_member: crate::WireTableMember,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut union_member,
                mut table_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(union_member.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct SomeProtocolSomeMethodResponse {
    pub bits_member: crate::BitsMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::BitsMember as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireSomeProtocolSomeMethodResponse;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits_member,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.bits_member, encoder, bits_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireSomeProtocolSomeMethodResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodResponse> for SomeProtocolSomeMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::BitsMember as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireSomeProtocolSomeMethodResponse) -> Self {
        Self { bits_member: ::fidl_next::TakeFrom::take_from(&from.bits_member) }
    }
}

/// The wire type corersponding to [`SomeProtocolSomeMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodResponse {
    pub bits_member: crate::WireBitsMember,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum SomeProtocolSomeMethodError {
    ErrorOne = 1,
    ErrorTwo = 2,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodError {
    type Encoded = WireSomeProtocolSomeMethodError;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodError
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSomeProtocolSomeMethodError { mut value } = slot);
        *value = ::fidl_next::WireU32::from(match *self {
            Self::ErrorOne => 1,

            Self::ErrorTwo => 2,

            Self::UnknownOrdinal_(value) => value,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    fn from(wire: WireSomeProtocolSomeMethodError) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrorOne,

            2 => Self::ErrorTwo,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    #[inline]
    fn take_from(from: &WireSomeProtocolSomeMethodError) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodError`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireSomeProtocolSomeMethodError {
    value: ::fidl_next::WireU32,
}

impl WireSomeProtocolSomeMethodError {
    pub const ERROR_ONE: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32(1) };

    pub const ERROR_TWO: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodError
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<SomeProtocolSomeMethodError> for WireSomeProtocolSomeMethodError {
    fn from(natural: SomeProtocolSomeMethodError) -> Self {
        match natural {
            SomeProtocolSomeMethodError::ErrorOne => WireSomeProtocolSomeMethodError::ERROR_ONE,

            SomeProtocolSomeMethodError::ErrorTwo => WireSomeProtocolSomeMethodError::ERROR_TWO,

            SomeProtocolSomeMethodError::UnknownOrdinal_(value) => {
                WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32::from(value) }
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum SomeProtocolSomeMethodResult {
    Response(crate::SomeProtocolSomeMethodResponse),

    Err(crate::SomeProtocolSomeMethodError),
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodResult {
    type Encoded = WireSomeProtocolSomeMethodResult;
}

impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSomeProtocolSomeMethodResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::SomeProtocolSomeMethodResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::SomeProtocolSomeMethodError,
            >(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SomeProtocolSomeMethodResult> {
    type EncodedOption = WireOptionalSomeProtocolSomeMethodResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SomeProtocolSomeMethodResult>
where
    ___E: ?Sized,
    SomeProtocolSomeMethodResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalSomeProtocolSomeMethodResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSomeProtocolSomeMethodResult> for SomeProtocolSomeMethodResult {
    #[inline]
    fn take_from(from: &WireSomeProtocolSomeMethodResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalSomeProtocolSomeMethodResult>
    for Option<Box<SomeProtocolSomeMethodResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalSomeProtocolSomeMethodResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodResult`].
#[repr(transparent)]
pub struct WireSomeProtocolSomeMethodResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod some_protocol_some_method_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireSomeProtocolSomeMethodResponse),

        Err(&'union crate::WireSomeProtocolSomeMethodError),
    }
}

impl WireSomeProtocolSomeMethodResult {
    pub fn as_ref(&self) -> crate::some_protocol_some_method_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::some_protocol_some_method_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::some_protocol_some_method_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireSomeProtocolSomeMethodResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodResponse>()
                },
            },

            2 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodError>()
                },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodError,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireSomeProtocolSomeMethodResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireSomeProtocolSomeMethodResponse>().fmt(f)
            },
            2 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireSomeProtocolSomeMethodError>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalSomeProtocolSomeMethodResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalSomeProtocolSomeMethodResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireSomeProtocolSomeMethodResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalSomeProtocolSomeMethodResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalSomeProtocolSomeMethodResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodResponse>()
                },
            },

            2 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireSomeProtocolSomeMethodError>()
                },
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalSomeProtocolSomeMethodResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireSomeProtocolSomeMethodError,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalSomeProtocolSomeMethodResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the SomeProtocol protocol.
#[derive(Debug)]
pub struct SomeProtocol;

pub mod some_protocol {

    pub struct SomeMethod;

    impl ::fidl_next::Method for SomeMethod {
        const ORDINAL: u64 = 2515914517457749720;

        type Protocol = crate::SomeProtocol;

        type Request = crate::WireSomeProtocolSomeMethodRequest;

        type Response = crate::WireSomeProtocolSomeMethodResult;
    }
}

/// A helper trait for the `SomeProtocol` client sender.
pub trait SomeProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn some_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, some_protocol::SomeMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSomeProtocolSomeMethodRequest,
        >;
}

impl<___T> SomeProtocolClientSender for ::fidl_next::ClientSender<___T, SomeProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn some_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, some_protocol::SomeMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSomeProtocolSomeMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2515914517457749720, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the SomeProtocol protocol.
///
/// See [`SomeProtocol`] for more details.
pub trait SomeProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for SomeProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SomeProtocolClientHandler<___T>,

    crate::WireSomeProtocolSomeMethodResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SomeProtocol` server sender.
pub trait SomeProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> SomeProtocolServerSender for ::fidl_next::ServerSender<___T, SomeProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the SomeProtocol protocol.
///
/// See [`SomeProtocol`] for more details.
pub trait SomeProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn some_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, SomeProtocol>,

        request: ::fidl_next::RequestBuffer<___T, some_protocol::SomeMethod>,

        responder: ::fidl_next::Responder<some_protocol::SomeMethod>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for SomeProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SomeProtocolServerHandler<___T>,

    crate::WireSomeProtocolSomeMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2515914517457749720 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.some_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Commonly-used items that should usually be in scope, such as extension traits.
pub mod prelude {
    pub use super::{SomeProtocolClientSender, SomeProtocolServerSender};
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `SomeProtocol`
    /// protocol.
    pub type SomeProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::SomeProtocol>;
}
