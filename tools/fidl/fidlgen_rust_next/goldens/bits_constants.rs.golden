// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsType: u32 {
        const A = 1;
        const B = 128;
        const C = 2;

    }
}

impl ::fidl_next::Encodable for BitsType {
    type Encoded = WireBitsType;
}

impl<___E> ::fidl_next::Encode<___E> for BitsType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsType { mut value } = slot);
        *value = ::fidl_next::WireU32::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireBitsType> for BitsType {
    fn from(wire: WireBitsType) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBitsType> for BitsType {
    #[inline]
    fn take_from(from: &WireBitsType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`BitsType`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsType {
    value: ::fidl_next::WireU32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !BitsType::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: BitsType::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<BitsType> for WireBitsType {
    fn from(natural: BitsType) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

pub const CONST0: crate::BitsType = crate::BitsType::from_bits_retain(0);

pub const CONST1: crate::BitsType = crate::BitsType::A;

pub const CONST2: crate::BitsType = crate::BitsType::from_bits_retain(129);

pub const CONST3: crate::BitsType = crate::BitsType::from_bits_retain(131);

/// Commonly-used items that should usually be in scope, such as extension traits.
pub mod prelude {}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {}
