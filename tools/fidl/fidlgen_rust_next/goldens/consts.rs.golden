// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const ANSWER: u16 = 42;

pub const ANSWER_IN_BINARY: u16 = 42;

pub const ANSWER_NARROWED: u8 = 42;

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsType: u32 {
        const VALUE = 1;
        const TRUE = 2;

    }
}

impl ::fidl_next::Encodable for BitsType {
    type Encoded = WireBitsType;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for BitsType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsType { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBitsType> for BitsType {
    fn from(wire: WireBitsType) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBitsType> for BitsType {
    #[inline]
    fn take_from(from: &WireBitsType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`BitsType`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsType {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireBitsType {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !BitsType::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: BitsType::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<BitsType> for WireBitsType {
    fn from(natural: BitsType) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

pub const CONVERSION_FACTOR: f64 = 1.41421;

pub const DIAMOND: u64 = 1746410393481133080;

pub const ENABLED_FLAG: bool = true;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(i32)]
pub enum EnumType {
    Value = 1,
    True = 2,
}

impl ::fidl_next::Encodable for EnumType {
    type Encoded = WireEnumType;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for EnumType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnumType { value } = out);
        let _ = value.write(::fidl_next::WireI32::from(match *self {
            Self::Value => 1,

            Self::True => 2,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnumType> for EnumType {
    fn from(wire: WireEnumType) -> Self {
        match i32::from(wire.value) {
            1 => Self::Value,

            2 => Self::True,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnumType> for EnumType {
    #[inline]
    fn take_from(from: &WireEnumType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`EnumType`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnumType {
    value: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireEnumType {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnumType {
    pub const VALUE: WireEnumType = WireEnumType { value: ::fidl_next::WireI32(1) };

    pub const TRUE: WireEnumType = WireEnumType { value: ::fidl_next::WireI32(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnumType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match i32::from(*value) {
            1 | 2 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<EnumType> for WireEnumType {
    fn from(natural: EnumType) -> Self {
        match natural {
            EnumType::Value => WireEnumType::VALUE,

            EnumType::True => WireEnumType::TRUE,
        }
    }
}

pub const FUCHSIA: u64 = 4054509061583223046;

pub const MIN_TEMP: f32 = -273.15;

pub const OFFSET: i8 = -33;

pub const POPULATION_USA_2018: u32 = 330000000;

pub const USERNAME: &str = "\"squeenze\"";

pub const ZX_CONST: u64 = 65536;

pub const ZX_OBJ_VAL: ::fidl_next::fuchsia::zx::ObjectType =
    ::fidl_next::fuchsia::zx::ObjectType::CHANNEL;

pub const ZX_RIGHTS_VAL: ::fidl_next::fuchsia::zx::Rights = ::fidl_next::fuchsia::zx::Rights::READ;

pub const BITS_PRIMITIVE_TRUE: u32 = 2;

pub const BITS_PRIMITIVE_VAL: u32 = 1;

pub const BITS_PRIMITIVE_VAL_NARROWED: u8 = 1;

pub const BITS_TRUE: crate::BitsType = crate::BitsType::TRUE;

pub const BITS_VAL: crate::BitsType = crate::BitsType::VALUE;

pub const ENUM_PRIMITIVE_TRUE: i32 = 2;

pub const ENUM_PRIMITIVE_VAL: i32 = 1;

pub const ENUM_PRIMITIVE_VAL_NARROWED: i8 = 1;

pub const ENUM_TRUE: crate::EnumType = crate::EnumType::True;

pub const ENUM_VAL: crate::EnumType = crate::EnumType::Value;

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::TakeFrom<crate::WireBitsType> for ::fidl_test_consts::BitsType {
        #[inline]
        fn take_from(from: &crate::WireBitsType) -> Self {
            Self::from_bits_retain(from.value.into())
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireEnumType> for ::fidl_test_consts::EnumType {
        #[inline]
        fn take_from(from: &crate::WireEnumType) -> Self {
            match crate::EnumType::from(*from) {
                crate::EnumType::Value => Self::Value,

                crate::EnumType::True => Self::True_,
            }
        }
    }
}
