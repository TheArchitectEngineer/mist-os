// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub type AliasOfArray = [u64; 1];

/// The wire type corresponding to [`AliasOfArray`].
pub type WireAliasOfArray = [::fidl_next::WireU64; 1];

pub type U64 = u64;

/// The wire type corresponding to [`U64`].
pub type WireU64 = ::fidl_next::WireU64;

pub type AliasOfArrayContainingAliasOfArray = [u64; 2];

/// The wire type corresponding to [`AliasOfArrayContainingAliasOfArray`].
pub type WireAliasOfArrayContainingAliasOfArray = [::fidl_next::WireU64; 2];

pub type AliasOfBytes = Vec<u8>;

/// The wire type corresponding to [`AliasOfBytes`].
pub type WireAliasOfBytes = ::fidl_next::WireVector<u8>;

pub type AliasOfRequest =
    ::fidl_next::ServerEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::MyProtocol>;

/// The wire type corresponding to [`AliasOfRequest`].
pub type WireAliasOfRequest =
    ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::MyProtocol>;

pub type AliasOfString = String;

/// The wire type corresponding to [`AliasOfString`].
pub type WireAliasOfString = ::fidl_next::WireString;

pub type AliasOfVectorContainingAliasOfVector = Vec<u64>;

/// The wire type corresponding to [`AliasOfVectorContainingAliasOfVector`].
pub type WireAliasOfVectorContainingAliasOfVector = ::fidl_next::WireVector<::fidl_next::WireU64>;

/// The type corresponding to the MyProtocol protocol.
#[derive(Debug)]
pub struct MyProtocol;

pub mod my_protocol {
    pub mod prelude {
        pub use crate::{
            my_protocol, MyProtocol, MyProtocolClientHandler, MyProtocolClientSender,
            MyProtocolServerHandler, MyProtocolServerSender,
        };
    }
}

/// A helper trait for the `MyProtocol` client sender.
pub trait MyProtocolClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> MyProtocolClientSender for ::fidl_next::ClientSender<___T, MyProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the MyProtocol protocol.
///
/// See [`MyProtocol`] for more details.
pub trait MyProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for MyProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: MyProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `MyProtocol` server sender.
pub trait MyProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> MyProtocolServerSender for ::fidl_next::ServerSender<___T, MyProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the MyProtocol protocol.
///
/// See [`MyProtocol`] for more details.
pub trait MyProtocolServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for MyProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: MyProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

pub type Vector = Option<Vec<u64>>;

/// The wire type corresponding to [`Vector`].
pub type WireVector = ::fidl_next::WireOptionalVector<::fidl_next::WireU64>;

#[derive(Debug)]
pub struct Testing {
    pub u1: u64,

    pub u2: Vec<u64>,

    pub u3: [u64; 1],

    pub u4: Vec<Vec<u64>>,

    pub u5: Vec<[u64; 1]>,

    pub u6: [Vec<u64>; 4],

    pub u7: [[u64; 1]; 4],

    pub v1: Option<Vec<u64>>,

    pub v2: Vec<Option<Vec<u64>>>,

    pub v3: [Option<Vec<u64>>; 4],

    pub a1: [u64; 1],

    pub a2: Vec<[u64; 1]>,

    pub a3: [[u64; 1]; 4],

    pub r1: ::fidl_next::ServerEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::MyProtocol>,

    pub r2:
        Vec<::fidl_next::ServerEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::MyProtocol>>,

    pub r3:
        [::fidl_next::ServerEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::MyProtocol>; 4],

    pub b1: Vec<u8>,

    pub b2: Vec<Vec<u8>>,

    pub b3: [Vec<u8>; 4],

    pub s1: String,

    pub s2: Vec<String>,

    pub s3: [String; 4],

    pub vv1: Vec<u64>,

    pub vv2: Vec<Vec<u64>>,

    pub vv3: [Vec<u64>; 3],

    pub aa1: [u64; 2],

    pub aa2: Vec<[u64; 2]>,

    pub aa3: [[u64; 2]; 3],
}

impl ::fidl_next::Encodable for Testing {
    type Encoded = WireTesting;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Testing
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u1,
                u2,
                u3,
                u4,
                u5,
                u6,
                u7,
                v1,
                v2,
                v3,
                a1,
                a2,
                a3,
                r1,
                r2,
                r3,
                b1,
                b2,
                b3,
                s1,
                s2,
                s3,
                vv1,
                vv2,
                vv3,
                aa1,
                aa2,
                aa3,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.u1, encoder, u1)?;

        ::fidl_next::Encode::encode(&mut self.u2, encoder, u2)?;

        ::fidl_next::Encode::encode(&mut self.u3, encoder, u3)?;

        ::fidl_next::Encode::encode(&mut self.u4, encoder, u4)?;

        ::fidl_next::Encode::encode(&mut self.u5, encoder, u5)?;

        ::fidl_next::Encode::encode(&mut self.u6, encoder, u6)?;

        ::fidl_next::Encode::encode(&mut self.u7, encoder, u7)?;

        ::fidl_next::Encode::encode(&mut self.v1, encoder, v1)?;

        ::fidl_next::Encode::encode(&mut self.v2, encoder, v2)?;

        ::fidl_next::Encode::encode(&mut self.v3, encoder, v3)?;

        ::fidl_next::Encode::encode(&mut self.a1, encoder, a1)?;

        ::fidl_next::Encode::encode(&mut self.a2, encoder, a2)?;

        ::fidl_next::Encode::encode(&mut self.a3, encoder, a3)?;

        ::fidl_next::Encode::encode(&mut self.r1, encoder, r1)?;

        ::fidl_next::Encode::encode(&mut self.r2, encoder, r2)?;

        ::fidl_next::Encode::encode(&mut self.r3, encoder, r3)?;

        ::fidl_next::Encode::encode(&mut self.b1, encoder, b1)?;

        ::fidl_next::Encode::encode(&mut self.b2, encoder, b2)?;

        ::fidl_next::Encode::encode(&mut self.b3, encoder, b3)?;

        ::fidl_next::Encode::encode(&mut self.s1, encoder, s1)?;

        ::fidl_next::Encode::encode(&mut self.s2, encoder, s2)?;

        ::fidl_next::Encode::encode(&mut self.s3, encoder, s3)?;

        ::fidl_next::Encode::encode(&mut self.vv1, encoder, vv1)?;

        ::fidl_next::Encode::encode(&mut self.vv2, encoder, vv2)?;

        ::fidl_next::Encode::encode(&mut self.vv3, encoder, vv3)?;

        ::fidl_next::Encode::encode(&mut self.aa1, encoder, aa1)?;

        ::fidl_next::Encode::encode(&mut self.aa2, encoder, aa2)?;

        ::fidl_next::Encode::encode(&mut self.aa3, encoder, aa3)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Testing> {
    type EncodedOption = ::fidl_next::WireBox<WireTesting>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Testing>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Testing: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTesting> for Testing {
    #[inline]
    fn take_from(from: &WireTesting) -> Self {
        Self {
            u1: ::fidl_next::TakeFrom::take_from(&from.u1),

            u2: ::fidl_next::TakeFrom::take_from(&from.u2),

            u3: ::fidl_next::TakeFrom::take_from(&from.u3),

            u4: ::fidl_next::TakeFrom::take_from(&from.u4),

            u5: ::fidl_next::TakeFrom::take_from(&from.u5),

            u6: ::fidl_next::TakeFrom::take_from(&from.u6),

            u7: ::fidl_next::TakeFrom::take_from(&from.u7),

            v1: ::fidl_next::TakeFrom::take_from(&from.v1),

            v2: ::fidl_next::TakeFrom::take_from(&from.v2),

            v3: ::fidl_next::TakeFrom::take_from(&from.v3),

            a1: ::fidl_next::TakeFrom::take_from(&from.a1),

            a2: ::fidl_next::TakeFrom::take_from(&from.a2),

            a3: ::fidl_next::TakeFrom::take_from(&from.a3),

            r1: ::fidl_next::TakeFrom::take_from(&from.r1),

            r2: ::fidl_next::TakeFrom::take_from(&from.r2),

            r3: ::fidl_next::TakeFrom::take_from(&from.r3),

            b1: ::fidl_next::TakeFrom::take_from(&from.b1),

            b2: ::fidl_next::TakeFrom::take_from(&from.b2),

            b3: ::fidl_next::TakeFrom::take_from(&from.b3),

            s1: ::fidl_next::TakeFrom::take_from(&from.s1),

            s2: ::fidl_next::TakeFrom::take_from(&from.s2),

            s3: ::fidl_next::TakeFrom::take_from(&from.s3),

            vv1: ::fidl_next::TakeFrom::take_from(&from.vv1),

            vv2: ::fidl_next::TakeFrom::take_from(&from.vv2),

            vv3: ::fidl_next::TakeFrom::take_from(&from.vv3),

            aa1: ::fidl_next::TakeFrom::take_from(&from.aa1),

            aa2: ::fidl_next::TakeFrom::take_from(&from.aa2),

            aa3: ::fidl_next::TakeFrom::take_from(&from.aa3),
        }
    }
}

/// The wire type corresponding to [`Testing`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTesting {
    pub u1: ::fidl_next::WireU64,

    pub u2: ::fidl_next::WireVector<::fidl_next::WireU64>,

    pub u3: [::fidl_next::WireU64; 1],

    pub u4: ::fidl_next::WireVector<::fidl_next::WireVector<::fidl_next::WireU64>>,

    pub u5: ::fidl_next::WireVector<[::fidl_next::WireU64; 1]>,

    pub u6: [::fidl_next::WireVector<::fidl_next::WireU64>; 4],

    pub u7: [[::fidl_next::WireU64; 1]; 4],

    pub v1: ::fidl_next::WireOptionalVector<::fidl_next::WireU64>,

    pub v2: ::fidl_next::WireVector<::fidl_next::WireOptionalVector<::fidl_next::WireU64>>,

    pub v3: [::fidl_next::WireOptionalVector<::fidl_next::WireU64>; 4],

    pub a1: [::fidl_next::WireU64; 1],

    pub a2: ::fidl_next::WireVector<[::fidl_next::WireU64; 1]>,

    pub a3: [[::fidl_next::WireU64; 1]; 4],

    pub r1: ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::MyProtocol>,

    pub r2: ::fidl_next::WireVector<
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::MyProtocol>,
    >,

    pub r3:
        [::fidl_next::ServerEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::MyProtocol>; 4],

    pub b1: ::fidl_next::WireVector<u8>,

    pub b2: ::fidl_next::WireVector<::fidl_next::WireVector<u8>>,

    pub b3: [::fidl_next::WireVector<u8>; 4],

    pub s1: ::fidl_next::WireString,

    pub s2: ::fidl_next::WireVector<::fidl_next::WireString>,

    pub s3: [::fidl_next::WireString; 4],

    pub vv1: ::fidl_next::WireVector<::fidl_next::WireU64>,

    pub vv2: ::fidl_next::WireVector<::fidl_next::WireVector<::fidl_next::WireU64>>,

    pub vv3: [::fidl_next::WireVector<::fidl_next::WireU64>; 3],

    pub aa1: [::fidl_next::WireU64; 2],

    pub aa2: ::fidl_next::WireVector<[::fidl_next::WireU64; 2]>,

    pub aa3: [[::fidl_next::WireU64; 2]; 3],
}

unsafe impl ::fidl_next::ZeroPadding for WireTesting {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(316).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTesting
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u1,
                mut u2,
                mut u3,
                mut u4,
                mut u5,
                mut u6,
                mut u7,
                mut v1,
                mut v2,
                mut v3,
                mut a1,
                mut a2,
                mut a3,
                mut r1,
                mut r2,
                mut r3,
                mut b1,
                mut b2,
                mut b3,
                mut s1,
                mut s2,
                mut s3,
                mut vv1,
                mut vv2,
                mut vv3,
                mut aa1,
                mut aa2,
                mut aa3,

            } = slot;
        }

        ::fidl_next::Decode::decode(u1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u2.as_mut(), decoder)?;

        let u2 = unsafe { u2.deref_unchecked() };

        if u2.len() > 1 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: u2.len() as u64,
                limit: 1,
            });
        }

        ::fidl_next::Decode::decode(u3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u6.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(v1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(v2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(v3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(a1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(a2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(a3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(s1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(s2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(s3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vv1.as_mut(), decoder)?;

        let vv1 = unsafe { vv1.deref_unchecked() };

        if vv1.len() > 2 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: vv1.len() as u64,
                limit: 2,
            });
        }

        ::fidl_next::Decode::decode(vv2.as_mut(), decoder)?;

        let vv2 = unsafe { vv2.deref_unchecked() };

        if vv2.len() > 3 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: vv2.len() as u64,
                limit: 3,
            });
        }

        ::fidl_next::Decode::decode(vv3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(aa1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(aa2.as_mut(), decoder)?;

        let aa2 = unsafe { aa2.deref_unchecked() };

        if aa2.len() > 3 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: aa2.len() as u64,
                limit: 3,
            });
        }

        ::fidl_next::Decode::decode(aa3.as_mut(), decoder)?;

        Ok(())
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `MyProtocol`
    /// protocol.
    pub type MyProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::MyProtocol>;

    impl ::fidl_next::TakeFrom<crate::MyProtocol>
        for ::fidl_test_experimentalmaybefromalias::MyProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::MyProtocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireTesting> for ::fidl_test_experimentalmaybefromalias::Testing {
        #[inline]
        fn take_from(from: &crate::WireTesting) -> Self {
            Self {
                u1: ::fidl_next::TakeFrom::take_from(&from.u1),

                u2: ::fidl_next::TakeFrom::take_from(&from.u2),

                u3: ::fidl_next::TakeFrom::take_from(&from.u3),

                u4: ::fidl_next::TakeFrom::take_from(&from.u4),

                u5: ::fidl_next::TakeFrom::take_from(&from.u5),

                u6: ::fidl_next::TakeFrom::take_from(&from.u6),

                u7: ::fidl_next::TakeFrom::take_from(&from.u7),

                v1: ::fidl_next::TakeFrom::take_from(&from.v1),

                v2: ::fidl_next::TakeFrom::take_from(&from.v2),

                v3: ::fidl_next::TakeFrom::take_from(&from.v3),

                a1: ::fidl_next::TakeFrom::take_from(&from.a1),

                a2: ::fidl_next::TakeFrom::take_from(&from.a2),

                a3: ::fidl_next::TakeFrom::take_from(&from.a3),

                r1: ::fidl_next::TakeFrom::take_from(&from.r1),

                r2: ::fidl_next::TakeFrom::take_from(&from.r2),

                r3: ::fidl_next::TakeFrom::take_from(&from.r3),

                b1: ::fidl_next::TakeFrom::take_from(&from.b1),

                b2: ::fidl_next::TakeFrom::take_from(&from.b2),

                b3: ::fidl_next::TakeFrom::take_from(&from.b3),

                s1: ::fidl_next::TakeFrom::take_from(&from.s1),

                s2: ::fidl_next::TakeFrom::take_from(&from.s2),

                s3: ::fidl_next::TakeFrom::take_from(&from.s3),

                vv1: ::fidl_next::TakeFrom::take_from(&from.vv1),

                vv2: ::fidl_next::TakeFrom::take_from(&from.vv2),

                vv3: ::fidl_next::TakeFrom::take_from(&from.vv3),

                aa1: ::fidl_next::TakeFrom::take_from(&from.aa1),

                aa2: ::fidl_next::TakeFrom::take_from(&from.aa2),

                aa3: ::fidl_next::TakeFrom::take_from(&from.aa3),
            }
        }
    }
}
