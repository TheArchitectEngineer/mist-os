// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the Top protocol.
#[derive(Debug)]
pub struct Top;

pub mod top {
    pub mod prelude {
        pub use crate::{top, Top, TopClientHandler, TopServerHandler};

        pub use ::fidl_next_test_bottom::BottomGetFooResponse;
    }

    pub struct GetFoo;

    impl ::fidl_next::Method for GetFoo {
        const ORDINAL: u64 = 2618685789258237543;

        type Protocol = crate::Top;

        type Request = ();

        type Response = ::fidl_next_test_bottom::WireBottomGetFooResponse;
    }

    mod ___detail {

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::Top
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = TopClientSender<___T>;
            type ServerSender = TopServerSender<___T>;
        }

        /// The client sender for the `Top` protocol.
        pub struct TopClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> TopClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn get_foo(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::GetFoo, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2618685789258237543, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `Top` protocol.
        #[repr(transparent)]
        pub struct TopServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> TopServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the Top protocol.
///
/// See [`Top`] for more details.
pub trait TopClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for Top
where
    ___H: TopClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <top::GetFoo as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the Top protocol.
///
/// See [`Top`] for more details.
pub trait TopServerHandler<___T: ::fidl_next::Transport> {
    fn get_foo(
        &mut self,
        sender: &::fidl_next::ServerSender<Top, ___T>,

        responder: ::fidl_next::Responder<top::GetFoo>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for Top
where
    ___H: TopServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2618685789258237543 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.get_foo(sender, responder).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Top`
    /// protocol.
    pub type TopProxy = ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Top>;

    impl ::core::convert::From<crate::Top> for ::fidl_test_transitivedependenciescompose::TopMarker {
        #[inline]
        fn from(_: crate::Top) -> Self {
            Self
        }
    }
}
