// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the AnotherDiscoverableProtocol protocol.
#[derive(Debug)]
pub struct AnotherDiscoverableProtocol;

impl ::fidl_next::Discoverable for AnotherDiscoverableProtocol {
    const PROTOCOL_NAME: &'static str = "fake.library.FakeProtocol";
}

pub mod another_discoverable_protocol {
    pub mod prelude {
        pub use crate::{
            another_discoverable_protocol, AnotherDiscoverableProtocol,
            AnotherDiscoverableProtocolClientHandler, AnotherDiscoverableProtocolClientSender,
            AnotherDiscoverableProtocolServerHandler, AnotherDiscoverableProtocolServerSender,
        };
    }
}

/// A helper trait for the `AnotherDiscoverableProtocol` client sender.
pub trait AnotherDiscoverableProtocolClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> AnotherDiscoverableProtocolClientSender
    for ::fidl_next::ClientSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: AnotherDiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `AnotherDiscoverableProtocol` server sender.
pub trait AnotherDiscoverableProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> AnotherDiscoverableProtocolServerSender
    for ::fidl_next::ServerSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: AnotherDiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMethodARequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodARequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMethodARequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMethodARequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodARequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodARequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMethodARequest> for ChannelProtocolMethodARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMethodARequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMethodARequest) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolMethodARequest> for ChannelProtocolMethodARequest {
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolMethodARequest) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodARequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMethodARequest {
    type Decoded<'de> = WireChannelProtocolMethodARequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolEventARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolEventARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireChannelProtocolEventARequest> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolEventARequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolEventARequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolEventARequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolEventARequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolEventARequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolEventARequest> for ChannelProtocolEventARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireChannelProtocolEventARequest, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolEventARequest) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolEventARequest> for ChannelProtocolEventARequest {
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolEventARequest) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolEventARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolEventARequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolEventARequest {
    type Decoded<'de> = WireChannelProtocolEventARequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolEventARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodBRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMethodBRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodBRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMethodBRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMethodBRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMethodBRequest> for ChannelProtocolMethodBRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMethodBRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMethodBRequest) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolMethodBRequest> for ChannelProtocolMethodBRequest {
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolMethodBRequest) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodBRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBRequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMethodBRequest {
    type Decoded<'de> = WireChannelProtocolMethodBRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodBResponse {
    pub result: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMethodBResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodBResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                result,

            } = out;
        }

        ::fidl_next::Encode::encode(self.result, encoder, result)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                result,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.result, encoder, result)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMethodBResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMethodBResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMethodBResponse> for ChannelProtocolMethodBResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMethodBResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMethodBResponse) -> Self {
        Self { result: ::fidl_next::FromWire::from_wire(wire.result) }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolMethodBResponse>
    for ChannelProtocolMethodBResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolMethodBResponse) -> Self {
        Self { result: ::fidl_next::FromWireRef::from_wire_ref(&wire.result) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodBResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBResponse {
    pub result: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMethodBResponse {
    type Decoded<'de> = WireChannelProtocolMethodBResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut result,

            } = slot;
        }

        ::fidl_next::Decode::decode(result.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolTakeHandleRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolTakeHandleRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolTakeHandleRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolTakeHandleRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolTakeHandleRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolTakeHandleRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolTakeHandleRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolTakeHandleRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolTakeHandleRequest>
    for ChannelProtocolTakeHandleRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolTakeHandleRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolTakeHandleRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`ChannelProtocolTakeHandleRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolTakeHandleRequest {
    type Decoded<'de> = WireChannelProtocolTakeHandleRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolTakeHandleRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMutateSocketRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMutateSocketRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMutateSocketRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMutateSocketRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMutateSocketRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMutateSocketRequest>
    for ChannelProtocolMutateSocketRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMutateSocketRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMutateSocketRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMutateSocketRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMutateSocketRequest {
    type Decoded<'de> = WireChannelProtocolMutateSocketRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMutateSocketResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMutateSocketResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMutateSocketResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMutateSocketResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMutateSocketResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMutateSocketResponse>
    for ChannelProtocolMutateSocketResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMutateSocketResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMutateSocketResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMutateSocketResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMutateSocketResponse {
    type Decoded<'de> = WireChannelProtocolMutateSocketResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ChannelProtocol protocol.
#[derive(Debug)]
pub struct ChannelProtocol;

pub mod channel_protocol {
    pub mod prelude {
        pub use crate::{
            channel_protocol, ChannelProtocol, ChannelProtocolClientHandler,
            ChannelProtocolClientSender, ChannelProtocolServerHandler, ChannelProtocolServerSender,
        };

        pub use crate::ChannelProtocolEventARequest;

        pub use crate::ChannelProtocolMethodARequest;

        pub use crate::ChannelProtocolMethodBRequest;

        pub use crate::ChannelProtocolMethodBResponse;

        pub use crate::ChannelProtocolMutateSocketRequest;

        pub use crate::ChannelProtocolMutateSocketResponse;

        pub use crate::ChannelProtocolTakeHandleRequest;
    }

    pub struct MethodA;

    impl ::fidl_next::Method for MethodA {
        const ORDINAL: u64 = 3155008840945527714;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodARequest;

        type Response = ::fidl_next::Never;
    }

    pub struct EventA;

    impl ::fidl_next::Method for EventA {
        const ORDINAL: u64 = 2220452875311597006;

        type Protocol = crate::ChannelProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireChannelProtocolEventARequest;
    }

    pub struct MethodB;

    impl ::fidl_next::Method for MethodB {
        const ORDINAL: u64 = 8903004957800778182;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodBRequest;

        type Response = crate::WireChannelProtocolMethodBResponse;
    }

    pub struct TakeHandle;

    impl ::fidl_next::Method for TakeHandle {
        const ORDINAL: u64 = 591935489944717925;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolTakeHandleRequest;

        type Response = ();
    }

    pub struct MutateSocket;

    impl ::fidl_next::Method for MutateSocket {
        const ORDINAL: u64 = 7411742788430590287;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMutateSocketRequest;

        type Response = crate::WireChannelProtocolMutateSocketResponse;
    }
}

/// A helper trait for the `ChannelProtocol` client sender.
pub trait ChannelProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn method_a<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodARequest,
        >;

    fn method_b<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodBRequest,
        >;

    fn take_handle<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolTakeHandleRequest,
        >;

    fn mutate_socket<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMutateSocketRequest,
        >;
}

impl<___T> ChannelProtocolClientSender for ::fidl_next::ClientSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn method_a<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodARequest,
        >,
    {
        self.as_untyped().send_one_way(3155008840945527714, request)
    }

    fn method_b<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodBRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8903004957800778182, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn take_handle<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolTakeHandleRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(591935489944717925, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn mutate_socket<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMutateSocketRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(7411742788430590287, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn event_a(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, ChannelProtocol>,

        event: ::fidl_next::Response<___T, channel_protocol::EventA>,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: ChannelProtocolClientHandler<___T>,

    <channel_protocol::EventA as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MethodB as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MutateSocket as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            2220452875311597006 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_a(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ChannelProtocol` server sender.
pub trait ChannelProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn event_a<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <channel_protocol::EventA as ::fidl_next::Method>::Response,
        >;
}

impl<___T> ChannelProtocolServerSender for ::fidl_next::ServerSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn event_a<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <channel_protocol::EventA as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(2220452875311597006, request)
    }
}

/// A server handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method_a(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::Request<___T, channel_protocol::MethodA>,
    );

    fn method_b(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::Request<___T, channel_protocol::MethodB>,

        responder: ::fidl_next::Responder<channel_protocol::MethodB>,
    );

    fn take_handle(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::Request<___T, channel_protocol::TakeHandle>,

        responder: ::fidl_next::Responder<channel_protocol::TakeHandle>,
    );

    fn mutate_socket(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::Request<___T, channel_protocol::MutateSocket>,

        responder: ::fidl_next::Responder<channel_protocol::MutateSocket>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: ChannelProtocolServerHandler<___T>,

    <channel_protocol::MethodA as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MethodB as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::TakeHandle as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MutateSocket as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3155008840945527714 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.method_a(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8903004957800778182 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.method_b(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            591935489944717925 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.take_handle(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            7411742788430590287 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.mutate_socket(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the DiscoverableProtocol protocol.
#[derive(Debug)]
pub struct DiscoverableProtocol;

impl ::fidl_next::Discoverable for DiscoverableProtocol {
    const PROTOCOL_NAME: &'static str = "test.protocols.DiscoverableProtocol";
}

pub mod discoverable_protocol {
    pub mod prelude {
        pub use crate::{
            discoverable_protocol, DiscoverableProtocol, DiscoverableProtocolClientHandler,
            DiscoverableProtocolClientSender, DiscoverableProtocolServerHandler,
            DiscoverableProtocolServerSender,
        };
    }

    pub struct Method;

    impl ::fidl_next::Method for Method {
        const ORDINAL: u64 = 3455873048082739435;

        type Protocol = crate::DiscoverableProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `DiscoverableProtocol` client sender.
pub trait DiscoverableProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn method(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> DiscoverableProtocolClientSender
    for ::fidl_next::ClientSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn method(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(3455873048082739435, ())
    }
}

/// A client handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: DiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `DiscoverableProtocol` server sender.
pub trait DiscoverableProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DiscoverableProtocolServerSender
    for ::fidl_next::ServerSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method(&mut self, sender: &::fidl_next::ServerSender<___T, DiscoverableProtocol>);
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: DiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3455873048082739435 => {
                handler.method(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum ErrorEnum {
    ErrFoo = 1,
    ErrBar = 2,
}

impl ::fidl_next::Encodable for ErrorEnum {
    type Encoded = WireErrorEnum;
}
impl ::std::convert::TryFrom<u32> for ErrorEnum {
    type Error = ::fidl_next::UnknownStrictEnumMemberError;
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::ErrFoo),
            2 => Ok(Self::ErrBar),

            _ => Err(Self::Error::new(value.into())),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ErrorEnum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ErrorEnum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireErrorEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::ErrFoo => 1,

            Self::ErrBar => 2,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireErrorEnum> for ErrorEnum {
    fn from(wire: WireErrorEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrFoo,

            2 => Self::ErrBar,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWire<WireErrorEnum> for ErrorEnum {
    #[inline]
    fn from_wire(wire: WireErrorEnum) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireErrorEnum> for ErrorEnum {
    #[inline]
    fn from_wire_ref(wire: &WireErrorEnum) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`ErrorEnum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireErrorEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireErrorEnum {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireErrorEnum {
    pub const ERR_FOO: WireErrorEnum = WireErrorEnum { value: ::fidl_next::WireU32(1) };

    pub const ERR_BAR: WireErrorEnum = WireErrorEnum { value: ::fidl_next::WireU32(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireErrorEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 | 2 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<ErrorEnum> for WireErrorEnum {
    fn from(natural: ErrorEnum) -> Self {
        match natural {
            ErrorEnum::ErrFoo => WireErrorEnum::ERR_FOO,

            ErrorEnum::ErrBar => WireErrorEnum::ERR_BAR,
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolNoResponseMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolNoResponseMethodRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolNoResponseMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolNoResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolNoResponseMethodRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireHandleRightsProtocolNoResponseMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolNoResponseMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolNoResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolNoResponseMethodRequest>
    for HandleRightsProtocolNoResponseMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolNoResponseMethodRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolNoResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolNoResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolNoResponseMethodRequest {
    type Decoded<'de> = WireHandleRightsProtocolNoResponseMethodRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolNoResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolResponseMethodRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolResponseMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolResponseMethodRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireHandleRightsProtocolResponseMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolResponseMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolResponseMethodRequest>
    for HandleRightsProtocolResponseMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolResponseMethodRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolResponseMethodRequest {
    type Decoded<'de> = WireHandleRightsProtocolResponseMethodRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolResponseMethodResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolResponseMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolResponseMethodResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireHandleRightsProtocolResponseMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolResponseMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolResponseMethodResponse>
    for HandleRightsProtocolResponseMethodResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolResponseMethodResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolResponseMethodResponse) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolResponseMethodResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolResponseMethodResponse {
    type Decoded<'de> = WireHandleRightsProtocolResponseMethodResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolAnEventRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolAnEventRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolAnEventRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolAnEventRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolAnEventRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireHandleRightsProtocolAnEventRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolAnEventRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolAnEventRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolAnEventRequest>
    for HandleRightsProtocolAnEventRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolAnEventRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolAnEventRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolAnEventRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolAnEventRequest {
    type Decoded<'de> = WireHandleRightsProtocolAnEventRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolAnEventRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the HandleRightsProtocol protocol.
#[derive(Debug)]
pub struct HandleRightsProtocol;

pub mod handle_rights_protocol {
    pub mod prelude {
        pub use crate::{
            handle_rights_protocol, HandleRightsProtocol, HandleRightsProtocolClientHandler,
            HandleRightsProtocolClientSender, HandleRightsProtocolServerHandler,
            HandleRightsProtocolServerSender,
        };

        pub use crate::HandleRightsProtocolAnEventRequest;

        pub use crate::HandleRightsProtocolNoResponseMethodRequest;

        pub use crate::HandleRightsProtocolResponseMethodRequest;

        pub use crate::HandleRightsProtocolResponseMethodResponse;
    }

    pub struct NoResponseMethod;

    impl ::fidl_next::Method for NoResponseMethod {
        const ORDINAL: u64 = 1155044649514904573;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolNoResponseMethodRequest;

        type Response = ::fidl_next::Never;
    }

    pub struct ResponseMethod;

    impl ::fidl_next::Method for ResponseMethod {
        const ORDINAL: u64 = 5956276128041940295;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolResponseMethodRequest;

        type Response = crate::WireHandleRightsProtocolResponseMethodResponse;
    }

    pub struct AnEvent;

    impl ::fidl_next::Method for AnEvent {
        const ORDINAL: u64 = 476727631355490611;

        type Protocol = crate::HandleRightsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireHandleRightsProtocolAnEventRequest;
    }
}

/// A helper trait for the `HandleRightsProtocol` client sender.
pub trait HandleRightsProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn no_response_method<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >;

    fn response_method<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolResponseMethodRequest,
        >;
}

impl<___T> HandleRightsProtocolClientSender
    for ::fidl_next::ClientSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn no_response_method<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >,
    {
        self.as_untyped().send_one_way(1155044649514904573, request)
    }

    fn response_method<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolResponseMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5956276128041940295, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn an_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, HandleRightsProtocol>,

        event: ::fidl_next::Response<___T, handle_rights_protocol::AnEvent>,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: HandleRightsProtocolClientHandler<___T>,

    <handle_rights_protocol::ResponseMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <handle_rights_protocol::AnEvent as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            476727631355490611 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.an_event(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `HandleRightsProtocol` server sender.
pub trait HandleRightsProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn an_event<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <handle_rights_protocol::AnEvent as ::fidl_next::Method>::Response,
        >;
}

impl<___T> HandleRightsProtocolServerSender
    for ::fidl_next::ServerSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn an_event<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <handle_rights_protocol::AnEvent as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(476727631355490611, request)
    }
}

/// A server handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn no_response_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::Request<___T, handle_rights_protocol::NoResponseMethod>,
    );

    fn response_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::Request<___T, handle_rights_protocol::ResponseMethod>,

        responder: ::fidl_next::Responder<handle_rights_protocol::ResponseMethod>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: HandleRightsProtocolServerHandler<___T>,

    <handle_rights_protocol::NoResponseMethod as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <handle_rights_protocol::ResponseMethod as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1155044649514904573 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.no_response_method(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5956276128041940295 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.response_method(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

impl ::fidl_next::Encodable for ManyParametersFifteenRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireManyParametersFifteenRequest> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireManyParametersFifteenRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                p1,
                p2,
                p3,
                p4,
                p5,
                p6,
                p7,
                p8,
                p9,
                p10,
                p11,
                p12,
                p13,
                p14,
                p15,

            } = out;
        }

        ::fidl_next::Encode::encode(self.p1, encoder, p1)?;

        ::fidl_next::Encode::encode(self.p2, encoder, p2)?;

        ::fidl_next::Encode::encode(self.p3, encoder, p3)?;

        ::fidl_next::Encode::encode(self.p4, encoder, p4)?;

        ::fidl_next::Encode::encode(self.p5, encoder, p5)?;

        ::fidl_next::Encode::encode(self.p6, encoder, p6)?;

        ::fidl_next::Encode::encode(self.p7, encoder, p7)?;

        ::fidl_next::Encode::encode(self.p8, encoder, p8)?;

        ::fidl_next::Encode::encode(self.p9, encoder, p9)?;

        ::fidl_next::Encode::encode(self.p10, encoder, p10)?;

        ::fidl_next::Encode::encode(self.p11, encoder, p11)?;

        ::fidl_next::Encode::encode(self.p12, encoder, p12)?;

        ::fidl_next::Encode::encode(self.p13, encoder, p13)?;

        ::fidl_next::Encode::encode(self.p14, encoder, p14)?;

        ::fidl_next::Encode::encode(self.p15, encoder, p15)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                p1,
                p2,
                p3,
                p4,
                p5,
                p6,
                p7,
                p8,
                p9,
                p10,
                p11,
                p12,
                p13,
                p14,
                p15,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.p1, encoder, p1)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p2, encoder, p2)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p3, encoder, p3)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p4, encoder, p4)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p5, encoder, p5)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p6, encoder, p6)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p7, encoder, p7)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p8, encoder, p8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p9, encoder, p9)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p10, encoder, p10)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p11, encoder, p11)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p12, encoder, p12)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p13, encoder, p13)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p14, encoder, p14)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p15, encoder, p15)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ManyParametersFifteenRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireManyParametersFifteenRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ManyParametersFifteenRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ManyParametersFifteenRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireManyParametersFifteenRequest> for ManyParametersFifteenRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireManyParametersFifteenRequest, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireManyParametersFifteenRequest) -> Self {
        Self {
            p1: ::fidl_next::FromWire::from_wire(wire.p1),

            p2: ::fidl_next::FromWire::from_wire(wire.p2),

            p3: ::fidl_next::FromWire::from_wire(wire.p3),

            p4: ::fidl_next::FromWire::from_wire(wire.p4),

            p5: ::fidl_next::FromWire::from_wire(wire.p5),

            p6: ::fidl_next::FromWire::from_wire(wire.p6),

            p7: ::fidl_next::FromWire::from_wire(wire.p7),

            p8: ::fidl_next::FromWire::from_wire(wire.p8),

            p9: ::fidl_next::FromWire::from_wire(wire.p9),

            p10: ::fidl_next::FromWire::from_wire(wire.p10),

            p11: ::fidl_next::FromWire::from_wire(wire.p11),

            p12: ::fidl_next::FromWire::from_wire(wire.p12),

            p13: ::fidl_next::FromWire::from_wire(wire.p13),

            p14: ::fidl_next::FromWire::from_wire(wire.p14),

            p15: ::fidl_next::FromWire::from_wire(wire.p15),
        }
    }
}

impl ::fidl_next::FromWireRef<WireManyParametersFifteenRequest> for ManyParametersFifteenRequest {
    #[inline]
    fn from_wire_ref(wire: &WireManyParametersFifteenRequest) -> Self {
        Self {
            p1: ::fidl_next::FromWireRef::from_wire_ref(&wire.p1),

            p2: ::fidl_next::FromWireRef::from_wire_ref(&wire.p2),

            p3: ::fidl_next::FromWireRef::from_wire_ref(&wire.p3),

            p4: ::fidl_next::FromWireRef::from_wire_ref(&wire.p4),

            p5: ::fidl_next::FromWireRef::from_wire_ref(&wire.p5),

            p6: ::fidl_next::FromWireRef::from_wire_ref(&wire.p6),

            p7: ::fidl_next::FromWireRef::from_wire_ref(&wire.p7),

            p8: ::fidl_next::FromWireRef::from_wire_ref(&wire.p8),

            p9: ::fidl_next::FromWireRef::from_wire_ref(&wire.p9),

            p10: ::fidl_next::FromWireRef::from_wire_ref(&wire.p10),

            p11: ::fidl_next::FromWireRef::from_wire_ref(&wire.p11),

            p12: ::fidl_next::FromWireRef::from_wire_ref(&wire.p12),

            p13: ::fidl_next::FromWireRef::from_wire_ref(&wire.p13),

            p14: ::fidl_next::FromWireRef::from_wire_ref(&wire.p14),

            p15: ::fidl_next::FromWireRef::from_wire_ref(&wire.p15),
        }
    }
}

/// The wire type corresponding to [`ManyParametersFifteenRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

unsafe impl ::fidl_next::Wire for WireManyParametersFifteenRequest {
    type Decoded<'de> = WireManyParametersFifteenRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireManyParametersFifteenRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut p1,
                mut p2,
                mut p3,
                mut p4,
                mut p5,
                mut p6,
                mut p7,
                mut p8,
                mut p9,
                mut p10,
                mut p11,
                mut p12,
                mut p13,
                mut p14,
                mut p15,

            } = slot;
        }

        ::fidl_next::Decode::decode(p1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p6.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p9.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p10.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p11.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p12.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p13.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p14.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p15.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ManyParameters protocol.
#[derive(Debug)]
pub struct ManyParameters;

pub mod many_parameters {
    pub mod prelude {
        pub use crate::{
            many_parameters, ManyParameters, ManyParametersClientHandler,
            ManyParametersClientSender, ManyParametersServerHandler, ManyParametersServerSender,
        };

        pub use crate::ManyParametersFifteenRequest;
    }

    pub struct Fifteen;

    impl ::fidl_next::Method for Fifteen {
        const ORDINAL: u64 = 6423043252952467815;

        type Protocol = crate::ManyParameters;

        type Request = crate::WireManyParametersFifteenRequest;

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `ManyParameters` client sender.
pub trait ManyParametersClientSender {
    type Transport: ::fidl_next::Transport;

    fn fifteen<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireManyParametersFifteenRequest,
        >;
}

impl<___T> ManyParametersClientSender for ::fidl_next::ClientSender<___T, ManyParameters>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn fifteen<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireManyParametersFifteenRequest,
        >,
    {
        self.as_untyped().send_one_way(6423043252952467815, request)
    }
}

/// A client handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::Transport,
    ___H: ManyParametersClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ManyParameters` server sender.
pub trait ManyParametersServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ManyParametersServerSender for ::fidl_next::ServerSender<___T, ManyParameters>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersServerHandler<___T: ::fidl_next::Transport> {
    fn fifteen(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ManyParameters>,

        request: ::fidl_next::Request<___T, many_parameters::Fifteen>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::Transport,
    ___H: ManyParametersServerHandler<___T>,

    <many_parameters::Fifteen as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6423043252952467815 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.fifteen(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum TheUnion {
    V(u32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for TheUnion {
    type Encoded = WireTheUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TheUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTheUnion { raw, _phantom: _ } = out);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for TheUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTheUnion { raw, _phantom: _ } = out);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for TheUnion {
    type EncodedOption = WireOptionalTheUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for TheUnion
where
    ___E: ?Sized,
    TheUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalTheUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for TheUnion
where
    ___E: ?Sized,
    TheUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalTheUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireTheUnion> for TheUnion {
    #[inline]
    fn from_wire(wire: WireTheUnion) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::V(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireTheUnion> for TheUnion {
    #[inline]
    fn from_wire_ref(wire: &WireTheUnion) -> Self {
        match wire.raw.ordinal() {
            1 => Self::V(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalTheUnion> for Box<TheUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalTheUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalTheUnion> for Box<TheUnion> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalTheUnion) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`TheUnion`].
#[repr(transparent)]
pub struct WireTheUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireTheUnion {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireU32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireTheUnion {
    type Decoded<'de> = WireTheUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod the_union {
    pub enum Ref<'de> {
        V(&'de ::fidl_next::WireU32),

        UnknownOrdinal_(u64),
    }
}

impl WireTheUnion {
    pub fn as_ref(&self) -> crate::the_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::the_union::Ref::V(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            unknown => crate::the_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireTheUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalTheUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalTheUnion {
    type Decoded<'de> = WireOptionalTheUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalTheUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireTheUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireTheUnion> {
        if self.is_some() {
            Some(WireTheUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalTheUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalTheUnion {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MethodWithUnionUnionMethodRequest {
    pub u: crate::TheUnion,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireMethodWithUnionUnionMethodRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::TheUnion as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireMethodWithUnionUnionMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::Encode::encode(self.u, encoder, u)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for MethodWithUnionUnionMethodRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireMethodWithUnionUnionMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireMethodWithUnionUnionMethodRequest>
    for MethodWithUnionUnionMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireMethodWithUnionUnionMethodRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::TheUnion as ::fidl_next::FromWire<crate::WireTheUnion>
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn from_wire(wire: WireMethodWithUnionUnionMethodRequest) -> Self {
        Self { u: ::fidl_next::FromWire::from_wire(wire.u) }
    }
}

impl ::fidl_next::FromWireRef<WireMethodWithUnionUnionMethodRequest>
    for MethodWithUnionUnionMethodRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireMethodWithUnionUnionMethodRequest) -> Self {
        Self { u: ::fidl_next::FromWireRef::from_wire_ref(&wire.u) }
    }
}

/// The wire type corresponding to [`MethodWithUnionUnionMethodRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodRequest {
    pub u: crate::WireTheUnion,
}

unsafe impl ::fidl_next::Wire for WireMethodWithUnionUnionMethodRequest {
    type Decoded<'de> = WireMethodWithUnionUnionMethodRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MethodWithUnionUnionMethodResponse {
    pub u: Option<Box<crate::TheUnion>>,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireMethodWithUnionUnionMethodResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<Box<crate::TheUnion>> as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireMethodWithUnionUnionMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::Encode::encode(self.u, encoder, u)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for MethodWithUnionUnionMethodResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireMethodWithUnionUnionMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireMethodWithUnionUnionMethodResponse>
    for MethodWithUnionUnionMethodResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireMethodWithUnionUnionMethodResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<Box<crate::TheUnion>> as ::fidl_next::FromWire<
                crate::WireOptionalTheUnion,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireMethodWithUnionUnionMethodResponse) -> Self {
        Self { u: ::fidl_next::FromWire::from_wire(wire.u) }
    }
}

impl ::fidl_next::FromWireRef<WireMethodWithUnionUnionMethodResponse>
    for MethodWithUnionUnionMethodResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireMethodWithUnionUnionMethodResponse) -> Self {
        Self { u: ::fidl_next::FromWireRef::from_wire_ref(&wire.u) }
    }
}

/// The wire type corresponding to [`MethodWithUnionUnionMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodResponse {
    pub u: crate::WireOptionalTheUnion,
}

unsafe impl ::fidl_next::Wire for WireMethodWithUnionUnionMethodResponse {
    type Decoded<'de> = WireMethodWithUnionUnionMethodResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the MethodWithUnion protocol.
#[derive(Debug)]
pub struct MethodWithUnion;

pub mod method_with_union {
    pub mod prelude {
        pub use crate::{
            method_with_union, MethodWithUnion, MethodWithUnionClientHandler,
            MethodWithUnionClientSender, MethodWithUnionServerHandler, MethodWithUnionServerSender,
        };

        pub use crate::MethodWithUnionUnionMethodRequest;

        pub use crate::MethodWithUnionUnionMethodResponse;
    }

    pub struct UnionMethod;

    impl ::fidl_next::Method for UnionMethod {
        const ORDINAL: u64 = 4124874338266649112;

        type Protocol = crate::MethodWithUnion;

        type Request = crate::WireMethodWithUnionUnionMethodRequest;

        type Response = crate::WireMethodWithUnionUnionMethodResponse;
    }
}

/// A helper trait for the `MethodWithUnion` client sender.
pub trait MethodWithUnionClientSender {
    type Transport: ::fidl_next::Transport;

    fn union_method<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireMethodWithUnionUnionMethodRequest,
        >;
}

impl<___T> MethodWithUnionClientSender for ::fidl_next::ClientSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn union_method<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireMethodWithUnionUnionMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4124874338266649112, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::Transport,
    ___H: MethodWithUnionClientHandler<___T>,

    <method_with_union::UnionMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `MethodWithUnion` server sender.
pub trait MethodWithUnionServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> MethodWithUnionServerSender for ::fidl_next::ServerSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionServerHandler<___T: ::fidl_next::Transport> {
    fn union_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, MethodWithUnion>,

        request: ::fidl_next::Request<___T, method_with_union::UnionMethod>,

        responder: ::fidl_next::Responder<method_with_union::UnionMethod>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::Transport,
    ___H: MethodWithUnionServerHandler<___T>,

    <method_with_union::UnionMethod as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            4124874338266649112 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.union_method(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the PlatformServer protocol.
#[derive(Debug)]
pub struct PlatformServer;

impl ::fidl_next::Discoverable for PlatformServer {
    const PROTOCOL_NAME: &'static str = "test.protocols.PlatformServer";
}

pub mod platform_server {
    pub mod prelude {
        pub use crate::{
            platform_server, PlatformServer, PlatformServerClientHandler,
            PlatformServerClientSender, PlatformServerServerHandler, PlatformServerServerSender,
        };
    }
}

/// A helper trait for the `PlatformServer` client sender.
pub trait PlatformServerClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> PlatformServerClientSender for ::fidl_next::ClientSender<___T, PlatformServer>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::Transport,
    ___H: PlatformServerClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `PlatformServer` server sender.
pub trait PlatformServerServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> PlatformServerServerSender for ::fidl_next::ServerSender<___T, PlatformServer>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::Transport,
    ___H: PlatformServerServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ProtocolEnds {
    pub client:
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,

    pub server:
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,

    pub client_opt: ::fidl_next::ClientEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,

    pub server_opt: ::fidl_next::ServerEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for ProtocolEnds {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireProtocolEnds> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled()
                && <::fidl_next::ServerEnd<
                    ::fidl_next::fuchsia::zx::Channel,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ClientEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ServerEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    type Encoded = WireProtocolEnds;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ProtocolEnds
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                client,
                server,
                client_opt,
                server_opt,

            } = out;
        }

        ::fidl_next::Encode::encode(self.client, encoder, client)?;

        ::fidl_next::Encode::encode(self.server, encoder, server)?;

        ::fidl_next::Encode::encode(self.client_opt, encoder, client_opt)?;

        ::fidl_next::Encode::encode(self.server_opt, encoder, server_opt)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ProtocolEnds {
    type EncodedOption = ::fidl_next::WireBox<'static, WireProtocolEnds>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ProtocolEnds
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolEnds: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireProtocolEnds> for ProtocolEnds {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireProtocolEnds, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::FromWire<
                ::fidl_next::ClientEnd<
                    ::fidl_next::fuchsia::WireChannel,
                    crate::DiscoverableProtocol,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled()
                && <::fidl_next::ServerEnd<
                    ::fidl_next::fuchsia::zx::Channel,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::FromWire<
                    ::fidl_next::ServerEnd<
                        ::fidl_next::fuchsia::WireChannel,
                        crate::DiscoverableProtocol,
                    >,
                >>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ClientEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::FromWire<
                    ::fidl_next::ClientEnd<
                        ::fidl_next::fuchsia::WireOptionalChannel,
                        crate::DiscoverableProtocol,
                    >,
                >>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ServerEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::FromWire<
                    ::fidl_next::ServerEnd<
                        ::fidl_next::fuchsia::WireOptionalChannel,
                        crate::DiscoverableProtocol,
                    >,
                >>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireProtocolEnds) -> Self {
        Self {
            client: ::fidl_next::FromWire::from_wire(wire.client),

            server: ::fidl_next::FromWire::from_wire(wire.server),

            client_opt: ::fidl_next::FromWire::from_wire(wire.client_opt),

            server_opt: ::fidl_next::FromWire::from_wire(wire.server_opt),
        }
    }
}

/// The wire type corresponding to [`ProtocolEnds`].
#[derive(Debug)]
#[repr(C)]
pub struct WireProtocolEnds {
    pub client:
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,

    pub server:
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,

    pub client_opt: ::fidl_next::ClientEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,

    pub server_opt: ::fidl_next::ServerEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl ::fidl_next::Wire for WireProtocolEnds {
    type Decoded<'de> = WireProtocolEnds;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireProtocolEnds
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut client,
                mut server,
                mut client_opt,
                mut server_opt,

            } = slot;
        }

        ::fidl_next::Decode::decode(client.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_opt.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_opt.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(self.ret, encoder, ret)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseNoRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseNoRequestWithResponseResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWire::from_wire(wire.ret) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWireRef::from_wire_ref(&wire.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseNoRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de> {
    pub ret: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestNoResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestNoResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    #[inline]
    fn from_wire(wire: WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>) -> Self {
        Self { arg: ::fidl_next::FromWire::from_wire(wire.arg) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWireRef::from_wire_ref(&wire.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestNoResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de> {
    pub arg: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWire::from_wire(wire.arg) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWireRef::from_wire_ref(&wire.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestEmptyResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de> {
    pub arg: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWire::from_wire(wire.arg) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWireRef::from_wire_ref(&wire.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de> {
    pub arg: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(self.ret, encoder, ret)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWire::from_wire(wire.ret) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWireRef::from_wire_ref(&wire.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de> {
    pub ret: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseOnWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(self.ret, encoder, ret)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseOnWithResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseOnWithResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseOnWithResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseOnWithResponseRequest
{
    #[inline]
    fn from_wire(wire: WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>) -> Self {
        Self { ret: ::fidl_next::FromWire::from_wire(wire.ret) }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseOnWithResponseRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>) -> Self {
        Self { ret: ::fidl_next::FromWireRef::from_wire_ref(&wire.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseOnWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseOnWithResponseRequest<'de> {
    pub ret: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire for WireWithAndWithoutRequestResponseOnWithResponseRequest<'static> {
    type Decoded<'de> = WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithAndWithoutRequestResponse protocol.
#[derive(Debug)]
pub struct WithAndWithoutRequestResponse;

pub mod with_and_without_request_response {
    pub mod prelude {
        pub use crate::{
            with_and_without_request_response, WithAndWithoutRequestResponse,
            WithAndWithoutRequestResponseClientHandler, WithAndWithoutRequestResponseClientSender,
            WithAndWithoutRequestResponseServerHandler, WithAndWithoutRequestResponseServerSender,
        };

        pub use crate::WithAndWithoutRequestResponseNoRequestWithResponseResponse;

        pub use crate::WithAndWithoutRequestResponseOnWithResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestNoResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestWithResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestWithResponseResponse;
    }

    pub struct NoRequestNoResponse;

    impl ::fidl_next::Method for NoRequestNoResponse {
        const ORDINAL: u64 = 5413654872775949227;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct NoRequestEmptyResponse;

    impl ::fidl_next::Method for NoRequestEmptyResponse {
        const ORDINAL: u64 = 1631193469798418024;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ();
    }

    pub struct NoRequestWithResponse;

    impl ::fidl_next::Method for NoRequestWithResponse {
        const ORDINAL: u64 = 9037369643591427517;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response =
            crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>;
    }

    pub struct WithRequestNoResponse;

    impl ::fidl_next::Method for WithRequestNoResponse {
        const ORDINAL: u64 = 7326057319832554103;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request =
            crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct WithRequestEmptyResponse;

    impl ::fidl_next::Method for WithRequestEmptyResponse {
        const ORDINAL: u64 = 2877322062572412767;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request =
            crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>;

        type Response = ();
    }

    pub struct WithRequestWithResponse;

    impl ::fidl_next::Method for WithRequestWithResponse {
        const ORDINAL: u64 = 6417226585456833969;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request =
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>;

        type Response =
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>;
    }

    pub struct OnEmptyResponse;

    impl ::fidl_next::Method for OnEmptyResponse {
        const ORDINAL: u64 = 5397663296507358806;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct OnWithResponse;

    impl ::fidl_next::Method for OnWithResponse {
        const ORDINAL: u64 = 5811598563493228968;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::Never;

        type Response = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>;
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` client sender.
pub trait WithAndWithoutRequestResponseClientSender {
    type Transport: ::fidl_next::Transport;

    fn no_request_no_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn with_request_no_response<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>,
        >;

    fn with_request_empty_response<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<
                'static,
            >,
        >;

    fn with_request_with_response<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<
                'static,
            >,
        >;
}

impl<___T> WithAndWithoutRequestResponseClientSender
    for ::fidl_next::ClientSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn no_request_no_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(5413654872775949227, ())
    }

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1631193469798418024, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9037369643591427517, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn with_request_no_response<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>,
        >,
    {
        self.as_untyped().send_one_way(7326057319832554103, request)
    }

    fn with_request_empty_response<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<
                'static,
            >,
        >,
    {
        self.as_untyped()
            .send_two_way(2877322062572412767, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn with_request_with_response<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<
                'static,
            >,
        >,
    {
        self.as_untyped()
            .send_two_way(6417226585456833969, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseClientHandler<___T: ::fidl_next::Transport> {
    fn on_empty_response(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, WithAndWithoutRequestResponse>,
    );

    fn on_with_response(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, WithAndWithoutRequestResponse>,

        event: ::fidl_next::Response<___T, with_and_without_request_response::OnWithResponse>,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::Transport,
    ___H: WithAndWithoutRequestResponseClientHandler<___T>,

    <with_and_without_request_response::NoRequestWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::WithRequestWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::OnWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5397663296507358806 => {
                handler.on_empty_response(sender);
            }

            5811598563493228968 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.on_with_response(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` server sender.
pub trait WithAndWithoutRequestResponseServerSender {
    type Transport: ::fidl_next::Transport;

    fn on_empty_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn on_with_response<___R>(
                    &self,
                    request: ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <with_and_without_request_response::OnWithResponse as ::fidl_next::Method>::Response,
                    >;
}

impl<___T> WithAndWithoutRequestResponseServerSender
    for ::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn on_empty_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(5397663296507358806, ())
    }








                fn on_with_response<___R>(
                    &self,
                    request: ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                        <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <with_and_without_request_response::OnWithResponse as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(5811598563493228968, request)
    }
}

/// A server handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseServerHandler<___T: ::fidl_next::Transport> {
    fn no_request_no_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,
    );

    fn no_request_empty_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
    );

    fn no_request_with_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::Responder<with_and_without_request_response::NoRequestWithResponse>,
    );

    fn with_request_no_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::Request<
            ___T,
            with_and_without_request_response::WithRequestNoResponse,
        >,
    );

    fn with_request_empty_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::Request<
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
    );

    fn with_request_with_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::Request<
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::WithRequestWithResponse,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::Transport,
    ___H: WithAndWithoutRequestResponseServerHandler<___T>,

    <with_and_without_request_response::WithRequestNoResponse as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::WithRequestEmptyResponse as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::WithRequestWithResponse as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5413654872775949227 => {
                handler.no_request_no_response(sender);
            }

            7326057319832554103 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.with_request_no_response(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1631193469798418024 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.no_request_empty_response(sender, responder);
            }

            9037369643591427517 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.no_request_with_response(sender, responder);
            }

            2877322062572412767 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.with_request_empty_response(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            6417226585456833969 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.with_request_with_response(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WithErrorSyntaxResponseAsStructResponse {
    pub a: i64,

    pub b: i64,

    pub c: i64,
}

impl ::fidl_next::Encodable for WithErrorSyntaxResponseAsStructResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithErrorSyntaxResponseAsStructResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithErrorSyntaxResponseAsStructResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithErrorSyntaxResponseAsStructResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithErrorSyntaxResponseAsStructResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithErrorSyntaxResponseAsStructResponse>
    for WithErrorSyntaxResponseAsStructResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithErrorSyntaxResponseAsStructResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithErrorSyntaxResponseAsStructResponse) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),

            c: ::fidl_next::FromWire::from_wire(wire.c),
        }
    }
}

impl ::fidl_next::FromWireRef<WireWithErrorSyntaxResponseAsStructResponse>
    for WithErrorSyntaxResponseAsStructResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireWithErrorSyntaxResponseAsStructResponse) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),

            c: ::fidl_next::FromWireRef::from_wire_ref(&wire.c),
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxResponseAsStructResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxResponseAsStructResponse {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,

    pub c: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireWithErrorSyntaxResponseAsStructResponse {
    type Decoded<'de> = WireWithErrorSyntaxResponseAsStructResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxResponseAsStructResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

pub type WithErrorSyntaxErrorAsPrimitiveResponse = ();

/// The wire type corresponding to [`WithErrorSyntaxErrorAsPrimitiveResponse`].
pub type WireWithErrorSyntaxErrorAsPrimitiveResponse = ();

pub type WithErrorSyntaxErrorAsEnumResponse = ();

/// The wire type corresponding to [`WithErrorSyntaxErrorAsEnumResponse`].
pub type WireWithErrorSyntaxErrorAsEnumResponse = ();

#[derive(Debug)]
#[repr(C)]
pub struct WithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for WithErrorSyntaxHandleInResultResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithErrorSyntaxHandleInResultResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithErrorSyntaxHandleInResultResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxHandleInResultResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithErrorSyntaxHandleInResultResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithErrorSyntaxHandleInResultResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithErrorSyntaxHandleInResultResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxHandleInResultResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithErrorSyntaxHandleInResultResponse>
    for WithErrorSyntaxHandleInResultResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithErrorSyntaxHandleInResultResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithErrorSyntaxHandleInResultResponse) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxHandleInResultResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireWithErrorSyntaxHandleInResultResponse {
    type Decoded<'de> = WireWithErrorSyntaxHandleInResultResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxHandleInResultResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithErrorSyntax protocol.
#[derive(Debug)]
pub struct WithErrorSyntax;

pub mod with_error_syntax {
    pub mod prelude {
        pub use crate::{
            with_error_syntax, WithErrorSyntax, WithErrorSyntaxClientHandler,
            WithErrorSyntaxClientSender, WithErrorSyntaxServerHandler, WithErrorSyntaxServerSender,
        };

        pub use crate::ErrorEnum;

        pub use crate::WithErrorSyntaxErrorAsEnumResponse;

        pub use crate::WithErrorSyntaxErrorAsPrimitiveResponse;

        pub use crate::WithErrorSyntaxHandleInResultResponse;

        pub use crate::WithErrorSyntaxResponseAsStructResponse;
    }

    pub struct ResponseAsStruct;

    impl ::fidl_next::Method for ResponseAsStruct {
        const ORDINAL: u64 = 268248568430741139;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxResponseAsStructResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct ErrorAsPrimitive;

    impl ::fidl_next::Method for ErrorAsPrimitive {
        const ORDINAL: u64 = 6930994461233198567;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxErrorAsPrimitiveResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct ErrorAsEnum;

    impl ::fidl_next::Method for ErrorAsEnum {
        const ORDINAL: u64 = 5491891352371277635;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxErrorAsEnumResponse,
            crate::WireErrorEnum,
        >;
    }

    pub struct HandleInResult;

    impl ::fidl_next::Method for HandleInResult {
        const ORDINAL: u64 = 1371676333068455103;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxHandleInResultResponse,
            ::fidl_next::WireU32,
        >;
    }
}

/// A helper trait for the `WithErrorSyntax` client sender.
pub trait WithErrorSyntaxClientSender {
    type Transport: ::fidl_next::Transport;

    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    >;

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> WithErrorSyntaxClientSender for ::fidl_next::ClientSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(268248568430741139, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6930994461233198567, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5491891352371277635, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1371676333068455103, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::Transport,
    ___H: WithErrorSyntaxClientHandler<___T>,

    <with_error_syntax::ResponseAsStruct as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::ErrorAsPrimitive as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::ErrorAsEnum as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::HandleInResult as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithErrorSyntax` server sender.
pub trait WithErrorSyntaxServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> WithErrorSyntaxServerSender for ::fidl_next::ServerSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxServerHandler<___T: ::fidl_next::Transport> {
    fn response_as_struct(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::ResponseAsStruct>,
    );

    fn error_as_primitive(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::ErrorAsPrimitive>,
    );

    fn error_as_enum(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::ErrorAsEnum>,
    );

    fn handle_in_result(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::HandleInResult>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::Transport,
    ___H: WithErrorSyntaxServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            268248568430741139 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.response_as_struct(sender, responder);
            }

            6930994461233198567 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_as_primitive(sender, responder);
            }

            5491891352371277635 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_as_enum(sender, responder);
            }

            1371676333068455103 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.handle_in_result(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsClientEndsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsClientEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsClientEndsRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsClientEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsClientEndsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsClientEndsRequest>
    for WithProtocolEndsClientEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsClientEndsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::FromWire<
                ::fidl_next::ClientEnd<
                    ::fidl_next::fuchsia::WireChannel,
                    crate::DiscoverableProtocol,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsClientEndsRequest) -> Self {
        Self { in_: ::fidl_next::FromWire::from_wire(wire.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsClientEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsClientEndsRequest {
    type Decoded<'de> = WireWithProtocolEndsClientEndsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsClientEndsResponse {
    pub out: ::fidl_next::ClientEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsClientEndsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsClientEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsClientEndsResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsClientEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsClientEndsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsClientEndsResponse>
    for WithProtocolEndsClientEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsClientEndsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::FromWire<
                ::fidl_next::ClientEnd<
                    ::fidl_next::fuchsia::WireOptionalChannel,
                    crate::DiscoverableProtocol,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsClientEndsResponse) -> Self {
        Self { out: ::fidl_next::FromWire::from_wire(wire.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsClientEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsResponse {
    pub out: ::fidl_next::ClientEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsClientEndsResponse {
    type Decoded<'de> = WireWithProtocolEndsClientEndsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsServerEndsRequest {
    pub in_: ::fidl_next::ServerEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsServerEndsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsServerEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsServerEndsRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsServerEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsServerEndsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsServerEndsRequest>
    for WithProtocolEndsServerEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsServerEndsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::FromWire<
                ::fidl_next::ServerEnd<
                    ::fidl_next::fuchsia::WireOptionalChannel,
                    crate::DiscoverableProtocol,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsServerEndsRequest) -> Self {
        Self { in_: ::fidl_next::FromWire::from_wire(wire.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsServerEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsRequest {
    pub in_: ::fidl_next::ServerEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsServerEndsRequest {
    type Decoded<'de> = WireWithProtocolEndsServerEndsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsServerEndsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsServerEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsServerEndsResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsServerEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsServerEndsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsServerEndsResponse>
    for WithProtocolEndsServerEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsServerEndsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::FromWire<
                ::fidl_next::ServerEnd<
                    ::fidl_next::fuchsia::WireChannel,
                    crate::DiscoverableProtocol,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsServerEndsResponse) -> Self {
        Self { out: ::fidl_next::FromWire::from_wire(wire.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsServerEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsServerEndsResponse {
    type Decoded<'de> = WireWithProtocolEndsServerEndsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsStructContainingEndsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsStructContainingEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsStructContainingEndsRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireWithProtocolEndsStructContainingEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsStructContainingEndsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsStructContainingEndsRequest>
    for WithProtocolEndsStructContainingEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsStructContainingEndsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::ProtocolEnds as ::fidl_next::FromWire<crate::WireProtocolEnds>
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsStructContainingEndsRequest) -> Self {
        Self { in_: ::fidl_next::FromWire::from_wire(wire.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsStructContainingEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::WireProtocolEnds,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsStructContainingEndsRequest {
    type Decoded<'de> = WireWithProtocolEndsStructContainingEndsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsStructContainingEndsResponse {
    pub out: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsStructContainingEndsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsStructContainingEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsStructContainingEndsResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireWithProtocolEndsStructContainingEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsStructContainingEndsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsStructContainingEndsResponse>
    for WithProtocolEndsStructContainingEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsStructContainingEndsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::ProtocolEnds as ::fidl_next::FromWire<crate::WireProtocolEnds>
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsStructContainingEndsResponse) -> Self {
        Self { out: ::fidl_next::FromWire::from_wire(wire.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsStructContainingEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsResponse {
    pub out: crate::WireProtocolEnds,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsStructContainingEndsResponse {
    type Decoded<'de> = WireWithProtocolEndsStructContainingEndsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithProtocolEnds protocol.
#[derive(Debug)]
pub struct WithProtocolEnds;

pub mod with_protocol_ends {
    pub mod prelude {
        pub use crate::{
            with_protocol_ends, WithProtocolEnds, WithProtocolEndsClientHandler,
            WithProtocolEndsClientSender, WithProtocolEndsServerHandler,
            WithProtocolEndsServerSender,
        };

        pub use crate::WithProtocolEndsClientEndsRequest;

        pub use crate::WithProtocolEndsClientEndsResponse;

        pub use crate::WithProtocolEndsServerEndsRequest;

        pub use crate::WithProtocolEndsServerEndsResponse;

        pub use crate::WithProtocolEndsStructContainingEndsRequest;

        pub use crate::WithProtocolEndsStructContainingEndsResponse;
    }

    pub struct ClientEnds;

    impl ::fidl_next::Method for ClientEnds {
        const ORDINAL: u64 = 5870448041025163330;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsClientEndsRequest;

        type Response = crate::WireWithProtocolEndsClientEndsResponse;
    }

    pub struct ServerEnds;

    impl ::fidl_next::Method for ServerEnds {
        const ORDINAL: u64 = 8115535094437022259;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsServerEndsRequest;

        type Response = crate::WireWithProtocolEndsServerEndsResponse;
    }

    pub struct StructContainingEnds;

    impl ::fidl_next::Method for StructContainingEnds {
        const ORDINAL: u64 = 4076866772260025813;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsStructContainingEndsRequest;

        type Response = crate::WireWithProtocolEndsStructContainingEndsResponse;
    }
}

/// A helper trait for the `WithProtocolEnds` client sender.
pub trait WithProtocolEndsClientSender {
    type Transport: ::fidl_next::Transport;

    fn client_ends<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsClientEndsRequest,
        >;

    fn server_ends<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsServerEndsRequest,
        >;

    fn struct_containing_ends<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >;
}

impl<___T> WithProtocolEndsClientSender for ::fidl_next::ClientSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn client_ends<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsClientEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5870448041025163330, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn server_ends<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsServerEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8115535094437022259, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn struct_containing_ends<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4076866772260025813, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::Transport,
    ___H: WithProtocolEndsClientHandler<___T>,

    <with_protocol_ends::ClientEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::ServerEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::StructContainingEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithProtocolEnds` server sender.
pub trait WithProtocolEndsServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> WithProtocolEndsServerSender for ::fidl_next::ServerSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsServerHandler<___T: ::fidl_next::Transport> {
    fn client_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::Request<___T, with_protocol_ends::ClientEnds>,

        responder: ::fidl_next::Responder<with_protocol_ends::ClientEnds>,
    );

    fn server_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::Request<___T, with_protocol_ends::ServerEnds>,

        responder: ::fidl_next::Responder<with_protocol_ends::ServerEnds>,
    );

    fn struct_containing_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::Request<___T, with_protocol_ends::StructContainingEnds>,

        responder: ::fidl_next::Responder<with_protocol_ends::StructContainingEnds>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::Transport,
    ___H: WithProtocolEndsServerHandler<___T>,

    <with_protocol_ends::ClientEnds as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::ServerEnds as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::StructContainingEnds as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5870448041025163330 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.client_ends(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            8115535094437022259 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.server_ends(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            4076866772260025813 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.struct_containing_ends(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `AnotherDiscoverableProtocol`
    /// protocol.
    pub type AnotherDiscoverableProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::AnotherDiscoverableProtocol,
    >;

    impl ::core::convert::From<crate::AnotherDiscoverableProtocol>
        for ::fidl_test_protocols::AnotherDiscoverableProtocolMarker
    {
        #[inline]
        fn from(_: crate::AnotherDiscoverableProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ChannelProtocol`
    /// protocol.
    pub type ChannelProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ChannelProtocol>;

    impl ::core::convert::From<crate::ChannelProtocol>
        for ::fidl_test_protocols::ChannelProtocolMarker
    {
        #[inline]
        fn from(_: crate::ChannelProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `DiscoverableProtocol`
    /// protocol.
    pub type DiscoverableProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>;

    impl ::core::convert::From<crate::DiscoverableProtocol>
        for ::fidl_test_protocols::DiscoverableProtocolMarker
    {
        #[inline]
        fn from(_: crate::DiscoverableProtocol) -> Self {
            Self
        }
    }

    impl ::core::convert::From<crate::ErrorEnum> for ::fidl_test_protocols::ErrorEnum {
        #[inline]
        fn from(from: crate::ErrorEnum) -> Self {
            match crate::ErrorEnum::from(from) {
                crate::ErrorEnum::ErrFoo => Self::ErrFoo,

                crate::ErrorEnum::ErrBar => Self::ErrBar,
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `HandleRightsProtocol`
    /// protocol.
    pub type HandleRightsProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::HandleRightsProtocol>;

    impl ::core::convert::From<crate::HandleRightsProtocol>
        for ::fidl_test_protocols::HandleRightsProtocolMarker
    {
        #[inline]
        fn from(_: crate::HandleRightsProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ManyParameters`
    /// protocol.
    pub type ManyParametersProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ManyParameters>;

    impl ::core::convert::From<crate::ManyParameters> for ::fidl_test_protocols::ManyParametersMarker {
        #[inline]
        fn from(_: crate::ManyParameters) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `MethodWithUnion`
    /// protocol.
    pub type MethodWithUnionProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::MethodWithUnion>;

    impl ::core::convert::From<crate::MethodWithUnion>
        for ::fidl_test_protocols::MethodWithUnionMarker
    {
        #[inline]
        fn from(_: crate::MethodWithUnion) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `PlatformServer`
    /// protocol.
    pub type PlatformServerProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::PlatformServer>;

    impl ::core::convert::From<crate::PlatformServer> for ::fidl_test_protocols::PlatformServer_Marker {
        #[inline]
        fn from(_: crate::PlatformServer) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithAndWithoutRequestResponse`
    /// protocol.
    pub type WithAndWithoutRequestResponseProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::WithAndWithoutRequestResponse,
    >;

    impl ::core::convert::From<crate::WithAndWithoutRequestResponse>
        for ::fidl_test_protocols::WithAndWithoutRequestResponseMarker
    {
        #[inline]
        fn from(_: crate::WithAndWithoutRequestResponse) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithErrorSyntax`
    /// protocol.
    pub type WithErrorSyntaxProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::WithErrorSyntax>;

    impl ::core::convert::From<crate::WithErrorSyntax>
        for ::fidl_test_protocols::WithErrorSyntaxMarker
    {
        #[inline]
        fn from(_: crate::WithErrorSyntax) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithProtocolEnds`
    /// protocol.
    pub type WithProtocolEndsProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::WithProtocolEnds>;

    impl ::core::convert::From<crate::WithProtocolEnds>
        for ::fidl_test_protocols::WithProtocolEndsMarker
    {
        #[inline]
        fn from(_: crate::WithProtocolEnds) -> Self {
            Self
        }
    }
}
