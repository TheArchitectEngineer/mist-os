// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the AnotherDiscoverableProtocol protocol.
#[derive(Debug)]
pub struct AnotherDiscoverableProtocol;

impl ::fidl_next::Discoverable for AnotherDiscoverableProtocol {
    const PROTOCOL_NAME: &'static str = "fake.library.FakeProtocol";
}

pub mod another_discoverable_protocol {
    pub mod prelude {
        pub use crate::{
            another_discoverable_protocol, AnotherDiscoverableProtocol,
            AnotherDiscoverableProtocolClientHandler, AnotherDiscoverableProtocolServerHandler,
        };
    }

    mod ___detail {

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::AnotherDiscoverableProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = AnotherDiscoverableProtocolClientSender<___T>;
            type ServerSender = AnotherDiscoverableProtocolServerSender<___T>;
        }

        /// The client sender for the `AnotherDiscoverableProtocol` protocol.
        pub struct AnotherDiscoverableProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> AnotherDiscoverableProtocolClientSender<___T> where ___T: ::fidl_next::Transport {}

        /// The server sender for the `AnotherDiscoverableProtocol` protocol.
        #[repr(transparent)]
        pub struct AnotherDiscoverableProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> AnotherDiscoverableProtocolServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for AnotherDiscoverableProtocol
where
    ___H: AnotherDiscoverableProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolServerHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for AnotherDiscoverableProtocol
where
    ___H: AnotherDiscoverableProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMethodARequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodARequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMethodARequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMethodARequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodARequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodARequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMethodARequest> for ChannelProtocolMethodARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMethodARequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMethodARequest) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolMethodARequest> for ChannelProtocolMethodARequest {
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolMethodARequest) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodARequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMethodARequest {
    type Decoded<'de> = WireChannelProtocolMethodARequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolEventARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolEventARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireChannelProtocolEventARequest> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolEventARequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolEventARequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolEventARequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolEventARequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolEventARequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolEventARequest> for ChannelProtocolEventARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireChannelProtocolEventARequest, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolEventARequest) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolEventARequest> for ChannelProtocolEventARequest {
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolEventARequest) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolEventARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolEventARequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolEventARequest {
    type Decoded<'de> = WireChannelProtocolEventARequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolEventARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodBRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMethodBRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodBRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMethodBRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMethodBRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMethodBRequest> for ChannelProtocolMethodBRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMethodBRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMethodBRequest) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolMethodBRequest> for ChannelProtocolMethodBRequest {
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolMethodBRequest) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodBRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBRequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMethodBRequest {
    type Decoded<'de> = WireChannelProtocolMethodBRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodBResponse {
    pub result: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMethodBResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodBResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                result,

            } = out;
        }

        ::fidl_next::Encode::encode(self.result, encoder, result)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                result,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.result, encoder, result)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMethodBResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMethodBResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMethodBResponse> for ChannelProtocolMethodBResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMethodBResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMethodBResponse) -> Self {
        Self { result: ::fidl_next::FromWire::from_wire(wire.result) }
    }
}

impl ::fidl_next::FromWireRef<WireChannelProtocolMethodBResponse>
    for ChannelProtocolMethodBResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireChannelProtocolMethodBResponse) -> Self {
        Self { result: ::fidl_next::FromWireRef::from_wire_ref(&wire.result) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodBResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBResponse {
    pub result: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMethodBResponse {
    type Decoded<'de> = WireChannelProtocolMethodBResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut result,

            } = slot;
        }

        ::fidl_next::Decode::decode(result.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolTakeHandleRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolTakeHandleRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolTakeHandleRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolTakeHandleRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolTakeHandleRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolTakeHandleRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolTakeHandleRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolTakeHandleRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolTakeHandleRequest>
    for ChannelProtocolTakeHandleRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolTakeHandleRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolTakeHandleRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`ChannelProtocolTakeHandleRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolTakeHandleRequest {
    type Decoded<'de> = WireChannelProtocolTakeHandleRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolTakeHandleRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::zx::Socket,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMutateSocketRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMutateSocketRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMutateSocketRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMutateSocketRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMutateSocketRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMutateSocketRequest>
    for ChannelProtocolMutateSocketRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMutateSocketRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireSocket,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMutateSocketRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMutateSocketRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::WireSocket,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMutateSocketRequest {
    type Decoded<'de> = WireChannelProtocolMutateSocketRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::zx::Socket,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireChannelProtocolMutateSocketResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMutateSocketResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ChannelProtocolMutateSocketResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireChannelProtocolMutateSocketResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ChannelProtocolMutateSocketResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireChannelProtocolMutateSocketResponse>
    for ChannelProtocolMutateSocketResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireChannelProtocolMutateSocketResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireSocket,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireChannelProtocolMutateSocketResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMutateSocketResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::WireSocket,
}

unsafe impl ::fidl_next::Wire for WireChannelProtocolMutateSocketResponse {
    type Decoded<'de> = WireChannelProtocolMutateSocketResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ChannelProtocol protocol.
#[derive(Debug)]
pub struct ChannelProtocol;

pub mod channel_protocol {
    pub mod prelude {
        pub use crate::{
            channel_protocol, ChannelProtocol, ChannelProtocolClientHandler,
            ChannelProtocolServerHandler,
        };

        pub use crate::ChannelProtocolEventARequest;

        pub use crate::ChannelProtocolMethodARequest;

        pub use crate::ChannelProtocolMethodBRequest;

        pub use crate::ChannelProtocolMethodBResponse;

        pub use crate::ChannelProtocolMutateSocketRequest;

        pub use crate::ChannelProtocolMutateSocketResponse;

        pub use crate::ChannelProtocolTakeHandleRequest;
    }

    pub struct MethodA;

    impl ::fidl_next::Method for MethodA {
        const ORDINAL: u64 = 3155008840945527714;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodARequest;

        type Response = ::fidl_next::Never;
    }

    pub struct EventA;

    impl ::fidl_next::Method for EventA {
        const ORDINAL: u64 = 2220452875311597006;

        type Protocol = crate::ChannelProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireChannelProtocolEventARequest;
    }

    pub struct MethodB;

    impl ::fidl_next::Method for MethodB {
        const ORDINAL: u64 = 8903004957800778182;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodBRequest;

        type Response = crate::WireChannelProtocolMethodBResponse;
    }

    pub struct TakeHandle;

    impl ::fidl_next::Method for TakeHandle {
        const ORDINAL: u64 = 591935489944717925;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolTakeHandleRequest;

        type Response = ();
    }

    pub struct MutateSocket;

    impl ::fidl_next::Method for MutateSocket {
        const ORDINAL: u64 = 7411742788430590287;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMutateSocketRequest;

        type Response = crate::WireChannelProtocolMutateSocketResponse;
    }

    mod ___detail {

        pub struct MethodA<T0, T1> {
            a: T0,

            b: T1,
        }

        impl<T0, T1> ::fidl_next::Encodable for MethodA<T0, T1>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,
        {
            type Encoded = crate::WireChannelProtocolMethodARequest;
        }

        unsafe impl<___E, T0, T1> ::fidl_next::Encode<___E> for MethodA<T0, T1>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        a,
                        b,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.a, encoder, a)?;

                ::fidl_next::Encode::encode(self.b, encoder, b)?;

                Ok(())
            }
        }

        pub struct EventA<T0, T1> {
            a: T0,

            b: T1,
        }

        impl<T0, T1> ::fidl_next::Encodable for EventA<T0, T1>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,
        {
            type Encoded = crate::WireChannelProtocolEventARequest;
        }

        unsafe impl<___E, T0, T1> ::fidl_next::Encode<___E> for EventA<T0, T1>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        a,
                        b,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.a, encoder, a)?;

                ::fidl_next::Encode::encode(self.b, encoder, b)?;

                Ok(())
            }
        }

        pub struct MethodB<T0, T1> {
            a: T0,

            b: T1,
        }

        impl<T0, T1> ::fidl_next::Encodable for MethodB<T0, T1>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,
        {
            type Encoded = crate::WireChannelProtocolMethodBRequest;
        }

        unsafe impl<___E, T0, T1> ::fidl_next::Encode<___E> for MethodB<T0, T1>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        a,
                        b,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.a, encoder, a)?;

                ::fidl_next::Encode::encode(self.b, encoder, b)?;

                Ok(())
            }
        }

        pub struct TakeHandle<T0> {
            h: T0,
        }

        impl<T0> ::fidl_next::Encodable for TakeHandle<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireHandle>,
        {
            type Encoded = crate::WireChannelProtocolTakeHandleRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for TakeHandle<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireHandle>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        h,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.h, encoder, h)?;

                Ok(())
            }
        }

        pub struct MutateSocket<T0> {
            a: T0,
        }

        impl<T0> ::fidl_next::Encodable for MutateSocket<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            type Encoded = crate::WireChannelProtocolMutateSocketRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for MutateSocket<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        a,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.a, encoder, a)?;

                Ok(())
            }
        }

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::ChannelProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = ChannelProtocolClientSender<___T>;
            type ServerSender = ChannelProtocolServerSender<___T>;
        }

        /// The client sender for the `ChannelProtocol` protocol.
        pub struct ChannelProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> ChannelProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn method_a(
                &self,

                a: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,

                b: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,
            {
                self.method_a_with(MethodA { a, b })
            }

            pub fn method_a_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireChannelProtocolMethodARequest,
                >,
            {
                self.sender.send_one_way(3155008840945527714, request)
            }

            pub fn method_b(
                &self,

                a: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,

                b: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::MethodB, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,
            {
                self.method_b_with(MethodB { a, b })
            }

            pub fn method_b_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::MethodB, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireChannelProtocolMethodBRequest,
                >,
            {
                self.sender
                    .send_two_way(8903004957800778182, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn take_handle(
                &self,

                h: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireHandle,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TakeHandle, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.take_handle_with(TakeHandle { h })
            }

            pub fn take_handle_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TakeHandle, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireChannelProtocolTakeHandleRequest,
                >,
            {
                self.sender
                    .send_two_way(591935489944717925, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn mutate_socket(
                &self,

                a: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireSocket,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::MutateSocket, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.mutate_socket_with(MutateSocket { a })
            }

            pub fn mutate_socket_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::MutateSocket, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireChannelProtocolMutateSocketRequest,
                >,
            {
                self.sender
                    .send_two_way(7411742788430590287, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `ChannelProtocol` protocol.
        #[repr(transparent)]
        pub struct ChannelProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> ChannelProtocolServerSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn event_a(
                &self,

                a: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,

                b: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,
            {
                self.event_a_with(EventA { a, b })
            }

            pub fn event_a_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventA as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(2220452875311597006, request)
            }
        }
    }
}

/// A client handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn event_a(
        &mut self,
        sender: &::fidl_next::ClientSender<ChannelProtocol, ___T>,

        event: ::fidl_next::Response<channel_protocol::EventA, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for ChannelProtocol
where
    ___H: ChannelProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <channel_protocol::EventA as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MethodB as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MutateSocket as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            2220452875311597006 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_a(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method_a(
        &mut self,
        sender: &::fidl_next::ServerSender<ChannelProtocol, ___T>,

        request: ::fidl_next::Request<channel_protocol::MethodA, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn method_b(
        &mut self,
        sender: &::fidl_next::ServerSender<ChannelProtocol, ___T>,

        request: ::fidl_next::Request<channel_protocol::MethodB, ___T>,

        responder: ::fidl_next::Responder<channel_protocol::MethodB>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn take_handle(
        &mut self,
        sender: &::fidl_next::ServerSender<ChannelProtocol, ___T>,

        request: ::fidl_next::Request<channel_protocol::TakeHandle, ___T>,

        responder: ::fidl_next::Responder<channel_protocol::TakeHandle>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn mutate_socket(
        &mut self,
        sender: &::fidl_next::ServerSender<ChannelProtocol, ___T>,

        request: ::fidl_next::Request<channel_protocol::MutateSocket, ___T>,

        responder: ::fidl_next::Responder<channel_protocol::MutateSocket>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for ChannelProtocol
where
    ___H: ChannelProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <channel_protocol::MethodA as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MethodB as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::TakeHandle as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MutateSocket as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3155008840945527714 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.method_a(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8903004957800778182 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.method_b(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            591935489944717925 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.take_handle(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            7411742788430590287 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.mutate_socket(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the DiscoverableProtocol protocol.
#[derive(Debug)]
pub struct DiscoverableProtocol;

impl ::fidl_next::Discoverable for DiscoverableProtocol {
    const PROTOCOL_NAME: &'static str = "test.protocols.DiscoverableProtocol";
}

pub mod discoverable_protocol {
    pub mod prelude {
        pub use crate::{
            discoverable_protocol, DiscoverableProtocol, DiscoverableProtocolClientHandler,
            DiscoverableProtocolServerHandler,
        };
    }

    pub struct Method;

    impl ::fidl_next::Method for Method {
        const ORDINAL: u64 = 3455873048082739435;

        type Protocol = crate::DiscoverableProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    mod ___detail {

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::DiscoverableProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = DiscoverableProtocolClientSender<___T>;
            type ServerSender = DiscoverableProtocolServerSender<___T>;
        }

        /// The client sender for the `DiscoverableProtocol` protocol.
        pub struct DiscoverableProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> DiscoverableProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn method(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(3455873048082739435, ())
            }
        }

        /// The server sender for the `DiscoverableProtocol` protocol.
        #[repr(transparent)]
        pub struct DiscoverableProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> DiscoverableProtocolServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for DiscoverableProtocol
where
    ___H: DiscoverableProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method(
        &mut self,
        sender: &::fidl_next::ServerSender<DiscoverableProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for DiscoverableProtocol
where
    ___H: DiscoverableProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3455873048082739435 => {
                handler.method(sender).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum ErrorEnum {
    ErrFoo = 1,
    ErrBar = 2,
}

impl ::fidl_next::Encodable for ErrorEnum {
    type Encoded = WireErrorEnum;
}
impl ::std::convert::TryFrom<u32> for ErrorEnum {
    type Error = ::fidl_next::UnknownStrictEnumMemberError;
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::ErrFoo),
            2 => Ok(Self::ErrBar),

            _ => Err(Self::Error::new(value.into())),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ErrorEnum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ErrorEnum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireErrorEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::ErrFoo => 1,

            Self::ErrBar => 2,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireErrorEnum> for ErrorEnum {
    fn from(wire: WireErrorEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrFoo,

            2 => Self::ErrBar,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWire<WireErrorEnum> for ErrorEnum {
    #[inline]
    fn from_wire(wire: WireErrorEnum) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireErrorEnum> for ErrorEnum {
    #[inline]
    fn from_wire_ref(wire: &WireErrorEnum) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`ErrorEnum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireErrorEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireErrorEnum {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireErrorEnum {
    pub const ERR_FOO: WireErrorEnum = WireErrorEnum { value: ::fidl_next::WireU32(1) };

    pub const ERR_BAR: WireErrorEnum = WireErrorEnum { value: ::fidl_next::WireU32(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireErrorEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 | 2 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<ErrorEnum> for WireErrorEnum {
    fn from(natural: ErrorEnum) -> Self {
        match natural {
            ErrorEnum::ErrFoo => WireErrorEnum::ERR_FOO,

            ErrorEnum::ErrBar => WireErrorEnum::ERR_BAR,
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Socket,
}

impl ::fidl_next::Encodable for HandleRightsProtocolNoResponseMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolNoResponseMethodRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolNoResponseMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolNoResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolNoResponseMethodRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireHandleRightsProtocolNoResponseMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolNoResponseMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolNoResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolNoResponseMethodRequest>
    for HandleRightsProtocolNoResponseMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolNoResponseMethodRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireSocket,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolNoResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolNoResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireSocket,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolNoResponseMethodRequest {
    type Decoded<'de> = WireHandleRightsProtocolNoResponseMethodRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolNoResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Socket,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolResponseMethodRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolResponseMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolResponseMethodRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireHandleRightsProtocolResponseMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolResponseMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolResponseMethodRequest>
    for HandleRightsProtocolResponseMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolResponseMethodRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireSocket,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireSocket,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolResponseMethodRequest {
    type Decoded<'de> = WireHandleRightsProtocolResponseMethodRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::zx::Socket,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolResponseMethodResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolResponseMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolResponseMethodResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireHandleRightsProtocolResponseMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolResponseMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolResponseMethodResponse>
    for HandleRightsProtocolResponseMethodResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolResponseMethodResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireSocket,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolResponseMethodResponse) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolResponseMethodResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::WireSocket,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolResponseMethodResponse {
    type Decoded<'de> = WireHandleRightsProtocolResponseMethodResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::zx::Socket,
}

impl ::fidl_next::Encodable for HandleRightsProtocolAnEventRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireHandleRightsProtocolAnEventRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolAnEventRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolAnEventRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for HandleRightsProtocolAnEventRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireHandleRightsProtocolAnEventRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for HandleRightsProtocolAnEventRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolAnEventRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireHandleRightsProtocolAnEventRequest>
    for HandleRightsProtocolAnEventRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireHandleRightsProtocolAnEventRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Socket as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireSocket,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireHandleRightsProtocolAnEventRequest) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolAnEventRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::WireSocket,
}

unsafe impl ::fidl_next::Wire for WireHandleRightsProtocolAnEventRequest {
    type Decoded<'de> = WireHandleRightsProtocolAnEventRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolAnEventRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the HandleRightsProtocol protocol.
#[derive(Debug)]
pub struct HandleRightsProtocol;

pub mod handle_rights_protocol {
    pub mod prelude {
        pub use crate::{
            handle_rights_protocol, HandleRightsProtocol, HandleRightsProtocolClientHandler,
            HandleRightsProtocolServerHandler,
        };

        pub use crate::HandleRightsProtocolAnEventRequest;

        pub use crate::HandleRightsProtocolNoResponseMethodRequest;

        pub use crate::HandleRightsProtocolResponseMethodRequest;

        pub use crate::HandleRightsProtocolResponseMethodResponse;
    }

    pub struct NoResponseMethod;

    impl ::fidl_next::Method for NoResponseMethod {
        const ORDINAL: u64 = 1155044649514904573;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolNoResponseMethodRequest;

        type Response = ::fidl_next::Never;
    }

    pub struct ResponseMethod;

    impl ::fidl_next::Method for ResponseMethod {
        const ORDINAL: u64 = 5956276128041940295;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolResponseMethodRequest;

        type Response = crate::WireHandleRightsProtocolResponseMethodResponse;
    }

    pub struct AnEvent;

    impl ::fidl_next::Method for AnEvent {
        const ORDINAL: u64 = 476727631355490611;

        type Protocol = crate::HandleRightsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireHandleRightsProtocolAnEventRequest;
    }

    mod ___detail {

        pub struct NoResponseMethod<T0> {
            h: T0,
        }

        impl<T0> ::fidl_next::Encodable for NoResponseMethod<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            type Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for NoResponseMethod<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        h,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.h, encoder, h)?;

                Ok(())
            }
        }

        pub struct ResponseMethod<T0> {
            h: T0,
        }

        impl<T0> ::fidl_next::Encodable for ResponseMethod<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            type Encoded = crate::WireHandleRightsProtocolResponseMethodRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for ResponseMethod<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        h,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.h, encoder, h)?;

                Ok(())
            }
        }

        pub struct AnEvent<T0> {
            h: T0,
        }

        impl<T0> ::fidl_next::Encodable for AnEvent<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            type Encoded = crate::WireHandleRightsProtocolAnEventRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for AnEvent<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireSocket>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        h,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.h, encoder, h)?;

                Ok(())
            }
        }

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::HandleRightsProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = HandleRightsProtocolClientSender<___T>;
            type ServerSender = HandleRightsProtocolServerSender<___T>;
        }

        /// The client sender for the `HandleRightsProtocol` protocol.
        pub struct HandleRightsProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> HandleRightsProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn no_response_method(
                &self,

                h: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireSocket,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.no_response_method_with(NoResponseMethod { h })
            }

            pub fn no_response_method_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest,
                >,
            {
                self.sender.send_one_way(1155044649514904573, request)
            }

            pub fn response_method(
                &self,

                h: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireSocket,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ResponseMethod, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.response_method_with(ResponseMethod { h })
            }

            pub fn response_method_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ResponseMethod, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireHandleRightsProtocolResponseMethodRequest,
                >,
            {
                self.sender
                    .send_two_way(5956276128041940295, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `HandleRightsProtocol` protocol.
        #[repr(transparent)]
        pub struct HandleRightsProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> HandleRightsProtocolServerSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn an_event(
                &self,

                h: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireSocket,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.an_event_with(AnEvent { h })
            }

            pub fn an_event_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::AnEvent as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(476727631355490611, request)
            }
        }
    }
}

/// A client handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn an_event(
        &mut self,
        sender: &::fidl_next::ClientSender<HandleRightsProtocol, ___T>,

        event: ::fidl_next::Response<handle_rights_protocol::AnEvent, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for HandleRightsProtocol
where
    ___H: HandleRightsProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <handle_rights_protocol::ResponseMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <handle_rights_protocol::AnEvent as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            476727631355490611 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.an_event(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn no_response_method(
        &mut self,
        sender: &::fidl_next::ServerSender<HandleRightsProtocol, ___T>,

        request: ::fidl_next::Request<handle_rights_protocol::NoResponseMethod, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn response_method(
        &mut self,
        sender: &::fidl_next::ServerSender<HandleRightsProtocol, ___T>,

        request: ::fidl_next::Request<handle_rights_protocol::ResponseMethod, ___T>,

        responder: ::fidl_next::Responder<handle_rights_protocol::ResponseMethod>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for HandleRightsProtocol
where
    ___H: HandleRightsProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <handle_rights_protocol::NoResponseMethod as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <handle_rights_protocol::ResponseMethod as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1155044649514904573 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.no_response_method(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5956276128041940295 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.response_method(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

impl ::fidl_next::Encodable for ManyParametersFifteenRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireManyParametersFifteenRequest> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireManyParametersFifteenRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                p1,
                p2,
                p3,
                p4,
                p5,
                p6,
                p7,
                p8,
                p9,
                p10,
                p11,
                p12,
                p13,
                p14,
                p15,

            } = out;
        }

        ::fidl_next::Encode::encode(self.p1, encoder, p1)?;

        ::fidl_next::Encode::encode(self.p2, encoder, p2)?;

        ::fidl_next::Encode::encode(self.p3, encoder, p3)?;

        ::fidl_next::Encode::encode(self.p4, encoder, p4)?;

        ::fidl_next::Encode::encode(self.p5, encoder, p5)?;

        ::fidl_next::Encode::encode(self.p6, encoder, p6)?;

        ::fidl_next::Encode::encode(self.p7, encoder, p7)?;

        ::fidl_next::Encode::encode(self.p8, encoder, p8)?;

        ::fidl_next::Encode::encode(self.p9, encoder, p9)?;

        ::fidl_next::Encode::encode(self.p10, encoder, p10)?;

        ::fidl_next::Encode::encode(self.p11, encoder, p11)?;

        ::fidl_next::Encode::encode(self.p12, encoder, p12)?;

        ::fidl_next::Encode::encode(self.p13, encoder, p13)?;

        ::fidl_next::Encode::encode(self.p14, encoder, p14)?;

        ::fidl_next::Encode::encode(self.p15, encoder, p15)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                p1,
                p2,
                p3,
                p4,
                p5,
                p6,
                p7,
                p8,
                p9,
                p10,
                p11,
                p12,
                p13,
                p14,
                p15,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.p1, encoder, p1)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p2, encoder, p2)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p3, encoder, p3)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p4, encoder, p4)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p5, encoder, p5)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p6, encoder, p6)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p7, encoder, p7)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p8, encoder, p8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p9, encoder, p9)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p10, encoder, p10)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p11, encoder, p11)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p12, encoder, p12)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p13, encoder, p13)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p14, encoder, p14)?;

        ::fidl_next::EncodeRef::encode_ref(&self.p15, encoder, p15)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ManyParametersFifteenRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireManyParametersFifteenRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ManyParametersFifteenRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ManyParametersFifteenRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireManyParametersFifteenRequest> for ManyParametersFifteenRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireManyParametersFifteenRequest, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireManyParametersFifteenRequest) -> Self {
        Self {
            p1: ::fidl_next::FromWire::from_wire(wire.p1),

            p2: ::fidl_next::FromWire::from_wire(wire.p2),

            p3: ::fidl_next::FromWire::from_wire(wire.p3),

            p4: ::fidl_next::FromWire::from_wire(wire.p4),

            p5: ::fidl_next::FromWire::from_wire(wire.p5),

            p6: ::fidl_next::FromWire::from_wire(wire.p6),

            p7: ::fidl_next::FromWire::from_wire(wire.p7),

            p8: ::fidl_next::FromWire::from_wire(wire.p8),

            p9: ::fidl_next::FromWire::from_wire(wire.p9),

            p10: ::fidl_next::FromWire::from_wire(wire.p10),

            p11: ::fidl_next::FromWire::from_wire(wire.p11),

            p12: ::fidl_next::FromWire::from_wire(wire.p12),

            p13: ::fidl_next::FromWire::from_wire(wire.p13),

            p14: ::fidl_next::FromWire::from_wire(wire.p14),

            p15: ::fidl_next::FromWire::from_wire(wire.p15),
        }
    }
}

impl ::fidl_next::FromWireRef<WireManyParametersFifteenRequest> for ManyParametersFifteenRequest {
    #[inline]
    fn from_wire_ref(wire: &WireManyParametersFifteenRequest) -> Self {
        Self {
            p1: ::fidl_next::FromWireRef::from_wire_ref(&wire.p1),

            p2: ::fidl_next::FromWireRef::from_wire_ref(&wire.p2),

            p3: ::fidl_next::FromWireRef::from_wire_ref(&wire.p3),

            p4: ::fidl_next::FromWireRef::from_wire_ref(&wire.p4),

            p5: ::fidl_next::FromWireRef::from_wire_ref(&wire.p5),

            p6: ::fidl_next::FromWireRef::from_wire_ref(&wire.p6),

            p7: ::fidl_next::FromWireRef::from_wire_ref(&wire.p7),

            p8: ::fidl_next::FromWireRef::from_wire_ref(&wire.p8),

            p9: ::fidl_next::FromWireRef::from_wire_ref(&wire.p9),

            p10: ::fidl_next::FromWireRef::from_wire_ref(&wire.p10),

            p11: ::fidl_next::FromWireRef::from_wire_ref(&wire.p11),

            p12: ::fidl_next::FromWireRef::from_wire_ref(&wire.p12),

            p13: ::fidl_next::FromWireRef::from_wire_ref(&wire.p13),

            p14: ::fidl_next::FromWireRef::from_wire_ref(&wire.p14),

            p15: ::fidl_next::FromWireRef::from_wire_ref(&wire.p15),
        }
    }
}

/// The wire type corresponding to [`ManyParametersFifteenRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

unsafe impl ::fidl_next::Wire for WireManyParametersFifteenRequest {
    type Decoded<'de> = WireManyParametersFifteenRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireManyParametersFifteenRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut p1,
                mut p2,
                mut p3,
                mut p4,
                mut p5,
                mut p6,
                mut p7,
                mut p8,
                mut p9,
                mut p10,
                mut p11,
                mut p12,
                mut p13,
                mut p14,
                mut p15,

            } = slot;
        }

        ::fidl_next::Decode::decode(p1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p6.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p9.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p10.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p11.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p12.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p13.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p14.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p15.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ManyParameters protocol.
#[derive(Debug)]
pub struct ManyParameters;

pub mod many_parameters {
    pub mod prelude {
        pub use crate::{
            many_parameters, ManyParameters, ManyParametersClientHandler,
            ManyParametersServerHandler,
        };

        pub use crate::ManyParametersFifteenRequest;
    }

    pub struct Fifteen;

    impl ::fidl_next::Method for Fifteen {
        const ORDINAL: u64 = 6423043252952467815;

        type Protocol = crate::ManyParameters;

        type Request = crate::WireManyParametersFifteenRequest;

        type Response = ::fidl_next::Never;
    }

    mod ___detail {

        pub struct Fifteen<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
            p1: T0,

            p2: T1,

            p3: T2,

            p4: T3,

            p5: T4,

            p6: T5,

            p7: T6,

            p8: T7,

            p9: T8,

            p10: T9,

            p11: T10,

            p12: T11,

            p13: T12,

            p14: T13,

            p15: T14,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ::fidl_next::Encodable
            for Fifteen<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
        where
            T0: ::fidl_next::Encodable<Encoded = bool>,

            T1: ::fidl_next::Encodable<Encoded = bool>,

            T2: ::fidl_next::Encodable<Encoded = bool>,

            T3: ::fidl_next::Encodable<Encoded = bool>,

            T4: ::fidl_next::Encodable<Encoded = bool>,

            T5: ::fidl_next::Encodable<Encoded = bool>,

            T6: ::fidl_next::Encodable<Encoded = bool>,

            T7: ::fidl_next::Encodable<Encoded = bool>,

            T8: ::fidl_next::Encodable<Encoded = bool>,

            T9: ::fidl_next::Encodable<Encoded = bool>,

            T10: ::fidl_next::Encodable<Encoded = bool>,

            T11: ::fidl_next::Encodable<Encoded = bool>,

            T12: ::fidl_next::Encodable<Encoded = bool>,

            T13: ::fidl_next::Encodable<Encoded = bool>,

            T14: ::fidl_next::Encodable<Encoded = bool>,
        {
            type Encoded = crate::WireManyParametersFifteenRequest;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
            ::fidl_next::Encode<___E>
            for Fifteen<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            T0: ::fidl_next::Encode<___E, Encoded = bool>,

            T1: ::fidl_next::Encode<___E, Encoded = bool>,

            T2: ::fidl_next::Encode<___E, Encoded = bool>,

            T3: ::fidl_next::Encode<___E, Encoded = bool>,

            T4: ::fidl_next::Encode<___E, Encoded = bool>,

            T5: ::fidl_next::Encode<___E, Encoded = bool>,

            T6: ::fidl_next::Encode<___E, Encoded = bool>,

            T7: ::fidl_next::Encode<___E, Encoded = bool>,

            T8: ::fidl_next::Encode<___E, Encoded = bool>,

            T9: ::fidl_next::Encode<___E, Encoded = bool>,

            T10: ::fidl_next::Encode<___E, Encoded = bool>,

            T11: ::fidl_next::Encode<___E, Encoded = bool>,

            T12: ::fidl_next::Encode<___E, Encoded = bool>,

            T13: ::fidl_next::Encode<___E, Encoded = bool>,

            T14: ::fidl_next::Encode<___E, Encoded = bool>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        p1,
                        p2,
                        p3,
                        p4,
                        p5,
                        p6,
                        p7,
                        p8,
                        p9,
                        p10,
                        p11,
                        p12,
                        p13,
                        p14,
                        p15,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.p1, encoder, p1)?;

                ::fidl_next::Encode::encode(self.p2, encoder, p2)?;

                ::fidl_next::Encode::encode(self.p3, encoder, p3)?;

                ::fidl_next::Encode::encode(self.p4, encoder, p4)?;

                ::fidl_next::Encode::encode(self.p5, encoder, p5)?;

                ::fidl_next::Encode::encode(self.p6, encoder, p6)?;

                ::fidl_next::Encode::encode(self.p7, encoder, p7)?;

                ::fidl_next::Encode::encode(self.p8, encoder, p8)?;

                ::fidl_next::Encode::encode(self.p9, encoder, p9)?;

                ::fidl_next::Encode::encode(self.p10, encoder, p10)?;

                ::fidl_next::Encode::encode(self.p11, encoder, p11)?;

                ::fidl_next::Encode::encode(self.p12, encoder, p12)?;

                ::fidl_next::Encode::encode(self.p13, encoder, p13)?;

                ::fidl_next::Encode::encode(self.p14, encoder, p14)?;

                ::fidl_next::Encode::encode(self.p15, encoder, p15)?;

                Ok(())
            }
        }

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::ManyParameters
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = ManyParametersClientSender<___T>;
            type ServerSender = ManyParametersServerSender<___T>;
        }

        /// The client sender for the `ManyParameters` protocol.
        pub struct ManyParametersClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> ManyParametersClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn fifteen(
                &self,

                p1: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p2: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p3: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p4: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p5: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p6: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p7: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p9: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p10: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p11: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p12: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p13: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p14: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,

                p15: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = bool,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,
            {
                self.fifteen_with(Fifteen {
                    p1,

                    p2,

                    p3,

                    p4,

                    p5,

                    p6,

                    p7,

                    p8,

                    p9,

                    p10,

                    p11,

                    p12,

                    p13,

                    p14,

                    p15,
                })
            }

            pub fn fifteen_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireManyParametersFifteenRequest,
                >,
            {
                self.sender.send_one_way(6423043252952467815, request)
            }
        }

        /// The server sender for the `ManyParameters` protocol.
        #[repr(transparent)]
        pub struct ManyParametersServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> ManyParametersServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for ManyParameters
where
    ___H: ManyParametersClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersServerHandler<___T: ::fidl_next::Transport> {
    fn fifteen(
        &mut self,
        sender: &::fidl_next::ServerSender<ManyParameters, ___T>,

        request: ::fidl_next::Request<many_parameters::Fifteen, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for ManyParameters
where
    ___H: ManyParametersServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <many_parameters::Fifteen as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6423043252952467815 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.fifteen(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum TheUnion {
    V(u32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for TheUnion {
    type Encoded = WireTheUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TheUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTheUnion { raw, _phantom: _ } = out);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for TheUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTheUnion { raw, _phantom: _ } = out);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for TheUnion {
    type EncodedOption = WireOptionalTheUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for TheUnion
where
    ___E: ?Sized,
    TheUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalTheUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for TheUnion
where
    ___E: ?Sized,
    TheUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalTheUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireTheUnion> for TheUnion {
    #[inline]
    fn from_wire(wire: WireTheUnion) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::V(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireTheUnion> for TheUnion {
    #[inline]
    fn from_wire_ref(wire: &WireTheUnion) -> Self {
        match wire.raw.ordinal() {
            1 => Self::V(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalTheUnion> for Box<TheUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalTheUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalTheUnion> for Box<TheUnion> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalTheUnion) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`TheUnion`].
#[repr(transparent)]
pub struct WireTheUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireTheUnion {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireU32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireTheUnion {
    type Decoded<'de> = WireTheUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod the_union {
    pub enum Ref<'de> {
        V(&'de ::fidl_next::WireU32),

        UnknownOrdinal_(u64),
    }
}

impl WireTheUnion {
    pub fn as_ref(&self) -> crate::the_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::the_union::Ref::V(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            unknown => crate::the_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireTheUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalTheUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalTheUnion {
    type Decoded<'de> = WireOptionalTheUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalTheUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireTheUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireTheUnion> {
        if self.is_some() {
            Some(WireTheUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalTheUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalTheUnion {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MethodWithUnionUnionMethodRequest {
    pub u: crate::TheUnion,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireMethodWithUnionUnionMethodRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::TheUnion as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireMethodWithUnionUnionMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::Encode::encode(self.u, encoder, u)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for MethodWithUnionUnionMethodRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireMethodWithUnionUnionMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireMethodWithUnionUnionMethodRequest>
    for MethodWithUnionUnionMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireMethodWithUnionUnionMethodRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::TheUnion as ::fidl_next::FromWire<crate::WireTheUnion>
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn from_wire(wire: WireMethodWithUnionUnionMethodRequest) -> Self {
        Self { u: ::fidl_next::FromWire::from_wire(wire.u) }
    }
}

impl ::fidl_next::FromWireRef<WireMethodWithUnionUnionMethodRequest>
    for MethodWithUnionUnionMethodRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireMethodWithUnionUnionMethodRequest) -> Self {
        Self { u: ::fidl_next::FromWireRef::from_wire_ref(&wire.u) }
    }
}

/// The wire type corresponding to [`MethodWithUnionUnionMethodRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodRequest {
    pub u: crate::WireTheUnion,
}

unsafe impl ::fidl_next::Wire for WireMethodWithUnionUnionMethodRequest {
    type Decoded<'de> = WireMethodWithUnionUnionMethodRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MethodWithUnionUnionMethodResponse {
    pub u: Option<Box<crate::TheUnion>>,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireMethodWithUnionUnionMethodResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<Box<crate::TheUnion>> as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireMethodWithUnionUnionMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::Encode::encode(self.u, encoder, u)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for MethodWithUnionUnionMethodResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireMethodWithUnionUnionMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireMethodWithUnionUnionMethodResponse>
    for MethodWithUnionUnionMethodResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireMethodWithUnionUnionMethodResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<Box<crate::TheUnion>> as ::fidl_next::FromWire<
                crate::WireOptionalTheUnion,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireMethodWithUnionUnionMethodResponse) -> Self {
        Self { u: ::fidl_next::FromWire::from_wire(wire.u) }
    }
}

impl ::fidl_next::FromWireRef<WireMethodWithUnionUnionMethodResponse>
    for MethodWithUnionUnionMethodResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireMethodWithUnionUnionMethodResponse) -> Self {
        Self { u: ::fidl_next::FromWireRef::from_wire_ref(&wire.u) }
    }
}

/// The wire type corresponding to [`MethodWithUnionUnionMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodResponse {
    pub u: crate::WireOptionalTheUnion,
}

unsafe impl ::fidl_next::Wire for WireMethodWithUnionUnionMethodResponse {
    type Decoded<'de> = WireMethodWithUnionUnionMethodResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the MethodWithUnion protocol.
#[derive(Debug)]
pub struct MethodWithUnion;

pub mod method_with_union {
    pub mod prelude {
        pub use crate::{
            method_with_union, MethodWithUnion, MethodWithUnionClientHandler,
            MethodWithUnionServerHandler,
        };

        pub use crate::MethodWithUnionUnionMethodRequest;

        pub use crate::MethodWithUnionUnionMethodResponse;
    }

    pub struct UnionMethod;

    impl ::fidl_next::Method for UnionMethod {
        const ORDINAL: u64 = 4124874338266649112;

        type Protocol = crate::MethodWithUnion;

        type Request = crate::WireMethodWithUnionUnionMethodRequest;

        type Response = crate::WireMethodWithUnionUnionMethodResponse;
    }

    mod ___detail {

        pub struct UnionMethod<T0> {
            u: T0,
        }

        impl<T0> ::fidl_next::Encodable for UnionMethod<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = crate::WireTheUnion>,
        {
            type Encoded = crate::WireMethodWithUnionUnionMethodRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for UnionMethod<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            T0: ::fidl_next::Encode<___E, Encoded = crate::WireTheUnion>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        u,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.u, encoder, u)?;

                Ok(())
            }
        }

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::MethodWithUnion
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = MethodWithUnionClientSender<___T>;
            type ServerSender = MethodWithUnionServerSender<___T>;
        }

        /// The client sender for the `MethodWithUnion` protocol.
        pub struct MethodWithUnionClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> MethodWithUnionClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn union_method(
                &self,

                u: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireTheUnion,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::UnionMethod, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,
            {
                self.union_method_with(UnionMethod { u })
            }

            pub fn union_method_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::UnionMethod, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireMethodWithUnionUnionMethodRequest,
                >,
            {
                self.sender
                    .send_two_way(4124874338266649112, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `MethodWithUnion` protocol.
        #[repr(transparent)]
        pub struct MethodWithUnionServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> MethodWithUnionServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for MethodWithUnion
where
    ___H: MethodWithUnionClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <method_with_union::UnionMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionServerHandler<___T: ::fidl_next::Transport> {
    fn union_method(
        &mut self,
        sender: &::fidl_next::ServerSender<MethodWithUnion, ___T>,

        request: ::fidl_next::Request<method_with_union::UnionMethod, ___T>,

        responder: ::fidl_next::Responder<method_with_union::UnionMethod>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for MethodWithUnion
where
    ___H: MethodWithUnionServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <method_with_union::UnionMethod as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            4124874338266649112 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.union_method(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the PlatformServer protocol.
#[derive(Debug)]
pub struct PlatformServer;

impl ::fidl_next::Discoverable for PlatformServer {
    const PROTOCOL_NAME: &'static str = "test.protocols.PlatformServer";
}

pub mod platform_server {
    pub mod prelude {
        pub use crate::{
            platform_server, PlatformServer, PlatformServerClientHandler,
            PlatformServerServerHandler,
        };
    }

    mod ___detail {

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::PlatformServer
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = PlatformServerClientSender<___T>;
            type ServerSender = PlatformServerServerSender<___T>;
        }

        /// The client sender for the `PlatformServer` protocol.
        pub struct PlatformServerClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> PlatformServerClientSender<___T> where ___T: ::fidl_next::Transport {}

        /// The server sender for the `PlatformServer` protocol.
        #[repr(transparent)]
        pub struct PlatformServerServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> PlatformServerServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for PlatformServer
where
    ___H: PlatformServerClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerServerHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for PlatformServer
where
    ___H: PlatformServerServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ProtocolEnds {
    pub client:
        ::fidl_next::ClientEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,

    pub server:
        ::fidl_next::ServerEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,

    pub client_opt: Option<
        ::fidl_next::ClientEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,
    >,

    pub server_opt: Option<
        ::fidl_next::ServerEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,
    >,
}

impl ::fidl_next::Encodable for ProtocolEnds {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireProtocolEnds> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                crate::DiscoverableProtocol,
                ::fidl_next::fuchsia::zx::Channel,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled()
                && <::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::zx::Channel,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <Option<
                    ::fidl_next::ClientEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::zx::Channel,
                    >,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <Option<
                    ::fidl_next::ServerEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::zx::Channel,
                    >,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    type Encoded = WireProtocolEnds;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ProtocolEnds
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                client,
                server,
                client_opt,
                server_opt,

            } = out;
        }

        ::fidl_next::Encode::encode(self.client, encoder, client)?;

        ::fidl_next::Encode::encode(self.server, encoder, server)?;

        ::fidl_next::Encode::encode(self.client_opt, encoder, client_opt)?;

        ::fidl_next::Encode::encode(self.server_opt, encoder, server_opt)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ProtocolEnds {
    type EncodedOption = ::fidl_next::WireBox<'static, WireProtocolEnds>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ProtocolEnds
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolEnds: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireProtocolEnds> for ProtocolEnds {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireProtocolEnds, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                crate::DiscoverableProtocol,
                ::fidl_next::fuchsia::zx::Channel,
            > as ::fidl_next::FromWire<
                ::fidl_next::ClientEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled()
                && <::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::zx::Channel,
                > as ::fidl_next::FromWire<
                    ::fidl_next::ServerEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >>::COPY_OPTIMIZATION
                    .is_enabled()
                && <Option<
                    ::fidl_next::ClientEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::zx::Channel,
                    >,
                > as ::fidl_next::FromWire<
                    ::fidl_next::ClientEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >>::COPY_OPTIMIZATION
                    .is_enabled()
                && <Option<
                    ::fidl_next::ServerEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::zx::Channel,
                    >,
                > as ::fidl_next::FromWire<
                    ::fidl_next::ServerEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireProtocolEnds) -> Self {
        Self {
            client: ::fidl_next::FromWire::from_wire(wire.client),

            server: ::fidl_next::FromWire::from_wire(wire.server),

            client_opt: ::fidl_next::FromWire::from_wire(wire.client_opt),

            server_opt: ::fidl_next::FromWire::from_wire(wire.server_opt),
        }
    }
}

/// The wire type corresponding to [`ProtocolEnds`].
#[derive(Debug)]
#[repr(C)]
pub struct WireProtocolEnds {
    pub client:
        ::fidl_next::ClientEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::WireChannel>,

    pub server:
        ::fidl_next::ServerEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::WireChannel>,

    pub client_opt: ::fidl_next::ClientEnd<
        crate::DiscoverableProtocol,
        ::fidl_next::fuchsia::WireOptionalChannel,
    >,

    pub server_opt: ::fidl_next::ServerEnd<
        crate::DiscoverableProtocol,
        ::fidl_next::fuchsia::WireOptionalChannel,
    >,
}

unsafe impl ::fidl_next::Wire for WireProtocolEnds {
    type Decoded<'de> = WireProtocolEnds;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireProtocolEnds
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut client,
                mut server,
                mut client_opt,
                mut server_opt,

            } = slot;
        }

        ::fidl_next::Decode::decode(client.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_opt.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_opt.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(self.ret, encoder, ret)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseNoRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseNoRequestWithResponseResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWire::from_wire(wire.ret) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWireRef::from_wire_ref(&wire.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseNoRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de> {
    pub ret: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestNoResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestNoResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    #[inline]
    fn from_wire(wire: WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>) -> Self {
        Self { arg: ::fidl_next::FromWire::from_wire(wire.arg) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWireRef::from_wire_ref(&wire.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestNoResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de> {
    pub arg: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWire::from_wire(wire.arg) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWireRef::from_wire_ref(&wire.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestEmptyResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de> {
    pub arg: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWire::from_wire(wire.arg) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>,
    ) -> Self {
        Self { arg: ::fidl_next::FromWireRef::from_wire_ref(&wire.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de> {
    pub arg: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(self.ret, encoder, ret)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    #[inline]
    fn from_wire(
        wire: WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWire::from_wire(wire.ret) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>,
    ) -> Self {
        Self { ret: ::fidl_next::FromWireRef::from_wire_ref(&wire.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de> {
    pub ret: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>
{
    type Decoded<'de> = WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseOnWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(self.ret, encoder, ret)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithAndWithoutRequestResponseOnWithResponseRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseOnWithResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseOnWithResponseRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseOnWithResponseRequest
{
    #[inline]
    fn from_wire(wire: WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>) -> Self {
        Self { ret: ::fidl_next::FromWire::from_wire(wire.ret) }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>>
    for WithAndWithoutRequestResponseOnWithResponseRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>) -> Self {
        Self { ret: ::fidl_next::FromWireRef::from_wire_ref(&wire.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseOnWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseOnWithResponseRequest<'de> {
    pub ret: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire for WireWithAndWithoutRequestResponseOnWithResponseRequest<'static> {
    type Decoded<'de> = WireWithAndWithoutRequestResponseOnWithResponseRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithAndWithoutRequestResponse protocol.
#[derive(Debug)]
pub struct WithAndWithoutRequestResponse;

pub mod with_and_without_request_response {
    pub mod prelude {
        pub use crate::{
            with_and_without_request_response, WithAndWithoutRequestResponse,
            WithAndWithoutRequestResponseClientHandler, WithAndWithoutRequestResponseServerHandler,
        };

        pub use crate::WithAndWithoutRequestResponseNoRequestWithResponseResponse;

        pub use crate::WithAndWithoutRequestResponseOnWithResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestNoResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestWithResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestWithResponseResponse;
    }

    pub struct NoRequestNoResponse;

    impl ::fidl_next::Method for NoRequestNoResponse {
        const ORDINAL: u64 = 5413654872775949227;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct NoRequestEmptyResponse;

    impl ::fidl_next::Method for NoRequestEmptyResponse {
        const ORDINAL: u64 = 1631193469798418024;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ();
    }

    pub struct NoRequestWithResponse;

    impl ::fidl_next::Method for NoRequestWithResponse {
        const ORDINAL: u64 = 9037369643591427517;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response =
            crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse<'static>;
    }

    pub struct WithRequestNoResponse;

    impl ::fidl_next::Method for WithRequestNoResponse {
        const ORDINAL: u64 = 7326057319832554103;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request =
            crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct WithRequestEmptyResponse;

    impl ::fidl_next::Method for WithRequestEmptyResponse {
        const ORDINAL: u64 = 2877322062572412767;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request =
            crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>;

        type Response = ();
    }

    pub struct WithRequestWithResponse;

    impl ::fidl_next::Method for WithRequestWithResponse {
        const ORDINAL: u64 = 6417226585456833969;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request =
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>;

        type Response =
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse<'static>;
    }

    pub struct OnEmptyResponse;

    impl ::fidl_next::Method for OnEmptyResponse {
        const ORDINAL: u64 = 5397663296507358806;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct OnWithResponse;

    impl ::fidl_next::Method for OnWithResponse {
        const ORDINAL: u64 = 5811598563493228968;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::Never;

        type Response = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>;
    }

    mod ___detail {

        pub struct WithRequestNoResponse<T0> {
            arg: T0,
        }

        impl<T0> ::fidl_next::Encodable for WithRequestNoResponse<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireString<'static>>,
        {
            type Encoded =
                crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<'static>;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for WithRequestNoResponse<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireString<'static>>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        arg,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

                Ok(())
            }
        }

        pub struct WithRequestEmptyResponse<T0> {
            arg: T0,
        }

        impl<T0> ::fidl_next::Encodable for WithRequestEmptyResponse<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireString<'static>>,
        {
            type Encoded =
                crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for WithRequestEmptyResponse<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireString<'static>>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        arg,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

                Ok(())
            }
        }

        pub struct WithRequestWithResponse<T0> {
            arg: T0,
        }

        impl<T0> ::fidl_next::Encodable for WithRequestWithResponse<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireString<'static>>,
        {
            type Encoded =
                crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for WithRequestWithResponse<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireString<'static>>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        arg,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.arg, encoder, arg)?;

                Ok(())
            }
        }

        pub struct OnWithResponse<T0> {
            ret: T0,
        }

        impl<T0> ::fidl_next::Encodable for OnWithResponse<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireString<'static>>,
        {
            type Encoded = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest<'static>;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for OnWithResponse<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireString<'static>>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        ret,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.ret, encoder, ret)?;

                Ok(())
            }
        }

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::WithAndWithoutRequestResponse
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = WithAndWithoutRequestResponseClientSender<___T>;
            type ServerSender = WithAndWithoutRequestResponseServerSender<___T>;
        }

        /// The client sender for the `WithAndWithoutRequestResponse` protocol.
        pub struct WithAndWithoutRequestResponseClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> WithAndWithoutRequestResponseClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn no_request_no_response(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(5413654872775949227, ())
            }

            pub fn no_request_empty_response(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::NoRequestEmptyResponse, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1631193469798418024, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn no_request_with_response(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::NoRequestWithResponse, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(9037369643591427517, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn with_request_no_response(
                &self,

                arg: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireString<'static>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.with_request_no_response_with(WithRequestNoResponse { arg })
            }

            pub fn with_request_no_response_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest<
                        'static,
                    >,
                >,
            {
                self.sender.send_one_way(7326057319832554103, request)
            }

            pub fn with_request_empty_response(
                &self,

                arg: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireString<'static>,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::WithRequestEmptyResponse, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.with_request_empty_response_with(WithRequestEmptyResponse { arg })
            }



                            pub fn with_request_empty_response_with<___R>(
                                &self,
                                request: ___R,
                            ) -> Result<
                                ::fidl_next::ResponseFuture<'_, super::WithRequestEmptyResponse, ___T>,
                                ::fidl_next::EncodeError,
                            >
                            where
                                ___R: ::fidl_next::Encode<
                                    <___T as ::fidl_next::Transport>::SendBuffer,
                                    Encoded = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest<'static>,
                                >,
                            {
                self.sender
                    .send_two_way(2877322062572412767, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn with_request_with_response(
                &self,

                arg: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireString<'static>,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::WithRequestWithResponse, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.with_request_with_response_with(WithRequestWithResponse { arg })
            }



                            pub fn with_request_with_response_with<___R>(
                                &self,
                                request: ___R,
                            ) -> Result<
                                ::fidl_next::ResponseFuture<'_, super::WithRequestWithResponse, ___T>,
                                ::fidl_next::EncodeError,
                            >
                            where
                                ___R: ::fidl_next::Encode<
                                    <___T as ::fidl_next::Transport>::SendBuffer,
                                    Encoded = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest<'static>,
                                >,
                            {
                self.sender
                    .send_two_way(6417226585456833969, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `WithAndWithoutRequestResponse` protocol.
        #[repr(transparent)]
        pub struct WithAndWithoutRequestResponseServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> WithAndWithoutRequestResponseServerSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn on_empty_response(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_event(5397663296507358806, ())
            }

            pub fn on_with_response(
                &self,

                ret: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireString<'static>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.on_with_response_with(OnWithResponse { ret })
            }

            pub fn on_with_response_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::OnWithResponse as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(5811598563493228968, request)
            }
        }
    }
}

/// A client handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseClientHandler<___T: ::fidl_next::Transport> {
    fn on_empty_response(
        &mut self,
        sender: &::fidl_next::ClientSender<WithAndWithoutRequestResponse, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn on_with_response(
        &mut self,
        sender: &::fidl_next::ClientSender<WithAndWithoutRequestResponse, ___T>,

        event: ::fidl_next::Response<with_and_without_request_response::OnWithResponse, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for WithAndWithoutRequestResponse
where
    ___H: WithAndWithoutRequestResponseClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <with_and_without_request_response::NoRequestWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::WithRequestWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::OnWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5397663296507358806 => {
                handler.on_empty_response(sender).await;
            }

            5811598563493228968 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.on_with_response(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseServerHandler<___T: ::fidl_next::Transport> {
    fn no_request_no_response(
        &mut self,
        sender: &::fidl_next::ServerSender<WithAndWithoutRequestResponse, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn no_request_empty_response(
        &mut self,
        sender: &::fidl_next::ServerSender<WithAndWithoutRequestResponse, ___T>,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn no_request_with_response(
        &mut self,
        sender: &::fidl_next::ServerSender<WithAndWithoutRequestResponse, ___T>,

        responder: ::fidl_next::Responder<with_and_without_request_response::NoRequestWithResponse>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn with_request_no_response(
        &mut self,
        sender: &::fidl_next::ServerSender<WithAndWithoutRequestResponse, ___T>,

        request: ::fidl_next::Request<
            with_and_without_request_response::WithRequestNoResponse,
            ___T,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn with_request_empty_response(
        &mut self,
        sender: &::fidl_next::ServerSender<WithAndWithoutRequestResponse, ___T>,

        request: ::fidl_next::Request<
            with_and_without_request_response::WithRequestEmptyResponse,
            ___T,
        >,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn with_request_with_response(
        &mut self,
        sender: &::fidl_next::ServerSender<WithAndWithoutRequestResponse, ___T>,

        request: ::fidl_next::Request<
            with_and_without_request_response::WithRequestWithResponse,
            ___T,
        >,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::WithRequestWithResponse,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for WithAndWithoutRequestResponse
where
    ___H: WithAndWithoutRequestResponseServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <with_and_without_request_response::WithRequestNoResponse as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::WithRequestEmptyResponse as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::WithRequestWithResponse as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5413654872775949227 => {
                handler.no_request_no_response(sender).await;
            }

            7326057319832554103 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.with_request_no_response(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1631193469798418024 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.no_request_empty_response(sender, responder).await;
            }

            9037369643591427517 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.no_request_with_response(sender, responder).await;
            }

            2877322062572412767 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => {
                        handler.with_request_empty_response(sender, decoded, responder).await
                    }
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            6417226585456833969 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => {
                        handler.with_request_with_response(sender, decoded, responder).await
                    }
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WithErrorSyntaxResponseAsStructResponse {
    pub a: i64,

    pub b: i64,

    pub c: i64,
}

impl ::fidl_next::Encodable for WithErrorSyntaxResponseAsStructResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithErrorSyntaxResponseAsStructResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithErrorSyntaxResponseAsStructResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithErrorSyntaxResponseAsStructResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithErrorSyntaxResponseAsStructResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithErrorSyntaxResponseAsStructResponse>
    for WithErrorSyntaxResponseAsStructResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithErrorSyntaxResponseAsStructResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithErrorSyntaxResponseAsStructResponse) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),

            c: ::fidl_next::FromWire::from_wire(wire.c),
        }
    }
}

impl ::fidl_next::FromWireRef<WireWithErrorSyntaxResponseAsStructResponse>
    for WithErrorSyntaxResponseAsStructResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireWithErrorSyntaxResponseAsStructResponse) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),

            c: ::fidl_next::FromWireRef::from_wire_ref(&wire.c),
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxResponseAsStructResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxResponseAsStructResponse {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,

    pub c: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireWithErrorSyntaxResponseAsStructResponse {
    type Decoded<'de> = WireWithErrorSyntaxResponseAsStructResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxResponseAsStructResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

pub type WithErrorSyntaxErrorAsPrimitiveResponse = ();

/// The wire type corresponding to [`WithErrorSyntaxErrorAsPrimitiveResponse`].
pub type WireWithErrorSyntaxErrorAsPrimitiveResponse = ();

pub type WithErrorSyntaxErrorAsEnumResponse = ();

/// The wire type corresponding to [`WithErrorSyntaxErrorAsEnumResponse`].
pub type WireWithErrorSyntaxErrorAsEnumResponse = ();

#[derive(Debug)]
#[repr(C)]
pub struct WithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for WithErrorSyntaxHandleInResultResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithErrorSyntaxHandleInResultResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithErrorSyntaxHandleInResultResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxHandleInResultResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithErrorSyntaxHandleInResultResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithErrorSyntaxHandleInResultResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithErrorSyntaxHandleInResultResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxHandleInResultResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithErrorSyntaxHandleInResultResponse>
    for WithErrorSyntaxHandleInResultResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithErrorSyntaxHandleInResultResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::FromWire<
                ::fidl_next::fuchsia::WireHandle,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithErrorSyntaxHandleInResultResponse) -> Self {
        Self { h: ::fidl_next::FromWire::from_wire(wire.h) }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxHandleInResultResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::Wire for WireWithErrorSyntaxHandleInResultResponse {
    type Decoded<'de> = WireWithErrorSyntaxHandleInResultResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxHandleInResultResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithErrorSyntax protocol.
#[derive(Debug)]
pub struct WithErrorSyntax;

pub mod with_error_syntax {
    pub mod prelude {
        pub use crate::{
            with_error_syntax, WithErrorSyntax, WithErrorSyntaxClientHandler,
            WithErrorSyntaxServerHandler,
        };

        pub use crate::ErrorEnum;

        pub use crate::WithErrorSyntaxErrorAsEnumResponse;

        pub use crate::WithErrorSyntaxErrorAsPrimitiveResponse;

        pub use crate::WithErrorSyntaxHandleInResultResponse;

        pub use crate::WithErrorSyntaxResponseAsStructResponse;
    }

    pub struct ResponseAsStruct;

    impl ::fidl_next::Method for ResponseAsStruct {
        const ORDINAL: u64 = 268248568430741139;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxResponseAsStructResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct ErrorAsPrimitive;

    impl ::fidl_next::Method for ErrorAsPrimitive {
        const ORDINAL: u64 = 6930994461233198567;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxErrorAsPrimitiveResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct ErrorAsEnum;

    impl ::fidl_next::Method for ErrorAsEnum {
        const ORDINAL: u64 = 5491891352371277635;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxErrorAsEnumResponse,
            crate::WireErrorEnum,
        >;
    }

    pub struct HandleInResult;

    impl ::fidl_next::Method for HandleInResult {
        const ORDINAL: u64 = 1371676333068455103;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireWithErrorSyntaxHandleInResultResponse,
            ::fidl_next::WireU32,
        >;
    }

    mod ___detail {

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::WithErrorSyntax
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = WithErrorSyntaxClientSender<___T>;
            type ServerSender = WithErrorSyntaxServerSender<___T>;
        }

        /// The client sender for the `WithErrorSyntax` protocol.
        pub struct WithErrorSyntaxClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> WithErrorSyntaxClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn response_as_struct(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ResponseAsStruct, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(268248568430741139, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_as_primitive(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorAsPrimitive, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6930994461233198567, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_as_enum(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorAsEnum, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5491891352371277635, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn handle_in_result(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::HandleInResult, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1371676333068455103, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `WithErrorSyntax` protocol.
        #[repr(transparent)]
        pub struct WithErrorSyntaxServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> WithErrorSyntaxServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for WithErrorSyntax
where
    ___H: WithErrorSyntaxClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <with_error_syntax::ResponseAsStruct as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::ErrorAsPrimitive as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::ErrorAsEnum as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::HandleInResult as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxServerHandler<___T: ::fidl_next::Transport> {
    fn response_as_struct(
        &mut self,
        sender: &::fidl_next::ServerSender<WithErrorSyntax, ___T>,

        responder: ::fidl_next::Responder<with_error_syntax::ResponseAsStruct>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_as_primitive(
        &mut self,
        sender: &::fidl_next::ServerSender<WithErrorSyntax, ___T>,

        responder: ::fidl_next::Responder<with_error_syntax::ErrorAsPrimitive>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_as_enum(
        &mut self,
        sender: &::fidl_next::ServerSender<WithErrorSyntax, ___T>,

        responder: ::fidl_next::Responder<with_error_syntax::ErrorAsEnum>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn handle_in_result(
        &mut self,
        sender: &::fidl_next::ServerSender<WithErrorSyntax, ___T>,

        responder: ::fidl_next::Responder<with_error_syntax::HandleInResult>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for WithErrorSyntax
where
    ___H: WithErrorSyntaxServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            268248568430741139 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.response_as_struct(sender, responder).await;
            }

            6930994461233198567 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_as_primitive(sender, responder).await;
            }

            5491891352371277635 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_as_enum(sender, responder).await;
            }

            1371676333068455103 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.handle_in_result(sender, responder).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::ClientEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsClientEndsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                crate::DiscoverableProtocol,
                ::fidl_next::fuchsia::zx::Channel,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsClientEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsClientEndsRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsClientEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsClientEndsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsClientEndsRequest>
    for WithProtocolEndsClientEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsClientEndsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                crate::DiscoverableProtocol,
                ::fidl_next::fuchsia::zx::Channel,
            > as ::fidl_next::FromWire<
                ::fidl_next::ClientEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsClientEndsRequest) -> Self {
        Self { in_: ::fidl_next::FromWire::from_wire(wire.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsClientEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::ClientEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::WireChannel>,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsClientEndsRequest {
    type Decoded<'de> = WireWithProtocolEndsClientEndsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsClientEndsResponse {
    pub out: Option<
        ::fidl_next::ClientEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsClientEndsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<
                ::fidl_next::ClientEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::zx::Channel,
                >,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsClientEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsClientEndsResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsClientEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsClientEndsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsClientEndsResponse>
    for WithProtocolEndsClientEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsClientEndsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<
                ::fidl_next::ClientEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::zx::Channel,
                >,
            > as ::fidl_next::FromWire<
                ::fidl_next::ClientEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsClientEndsResponse) -> Self {
        Self { out: ::fidl_next::FromWire::from_wire(wire.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsClientEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsResponse {
    pub out: ::fidl_next::ClientEnd<
        crate::DiscoverableProtocol,
        ::fidl_next::fuchsia::WireOptionalChannel,
    >,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsClientEndsResponse {
    type Decoded<'de> = WireWithProtocolEndsClientEndsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsServerEndsRequest {
    pub in_: Option<
        ::fidl_next::ServerEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsServerEndsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<
                ::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::zx::Channel,
                >,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsServerEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsServerEndsRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsServerEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsServerEndsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsServerEndsRequest>
    for WithProtocolEndsServerEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsServerEndsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<
                ::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::zx::Channel,
                >,
            > as ::fidl_next::FromWire<
                ::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsServerEndsRequest) -> Self {
        Self { in_: ::fidl_next::FromWire::from_wire(wire.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsServerEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsRequest {
    pub in_: ::fidl_next::ServerEnd<
        crate::DiscoverableProtocol,
        ::fidl_next::fuchsia::WireOptionalChannel,
    >,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsServerEndsRequest {
    type Decoded<'de> = WireWithProtocolEndsServerEndsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::ServerEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::zx::Channel>,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsServerEndsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                crate::DiscoverableProtocol,
                ::fidl_next::fuchsia::zx::Channel,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsServerEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsServerEndsResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireWithProtocolEndsServerEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsServerEndsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsServerEndsResponse>
    for WithProtocolEndsServerEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsServerEndsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                crate::DiscoverableProtocol,
                ::fidl_next::fuchsia::zx::Channel,
            > as ::fidl_next::FromWire<
                ::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsServerEndsResponse) -> Self {
        Self { out: ::fidl_next::FromWire::from_wire(wire.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsServerEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::ServerEnd<crate::DiscoverableProtocol, ::fidl_next::fuchsia::WireChannel>,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsServerEndsResponse {
    type Decoded<'de> = WireWithProtocolEndsServerEndsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsStructContainingEndsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsStructContainingEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsStructContainingEndsRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireWithProtocolEndsStructContainingEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsStructContainingEndsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsStructContainingEndsRequest>
    for WithProtocolEndsStructContainingEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsStructContainingEndsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::ProtocolEnds as ::fidl_next::FromWire<crate::WireProtocolEnds>
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsStructContainingEndsRequest) -> Self {
        Self { in_: ::fidl_next::FromWire::from_wire(wire.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsStructContainingEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::WireProtocolEnds,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsStructContainingEndsRequest {
    type Decoded<'de> = WireWithProtocolEndsStructContainingEndsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsStructContainingEndsResponse {
    pub out: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireWithProtocolEndsStructContainingEndsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsStructContainingEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for WithProtocolEndsStructContainingEndsResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireWithProtocolEndsStructContainingEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for WithProtocolEndsStructContainingEndsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireWithProtocolEndsStructContainingEndsResponse>
    for WithProtocolEndsStructContainingEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireWithProtocolEndsStructContainingEndsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::ProtocolEnds as ::fidl_next::FromWire<crate::WireProtocolEnds>
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn from_wire(wire: WireWithProtocolEndsStructContainingEndsResponse) -> Self {
        Self { out: ::fidl_next::FromWire::from_wire(wire.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsStructContainingEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsResponse {
    pub out: crate::WireProtocolEnds,
}

unsafe impl ::fidl_next::Wire for WireWithProtocolEndsStructContainingEndsResponse {
    type Decoded<'de> = WireWithProtocolEndsStructContainingEndsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithProtocolEnds protocol.
#[derive(Debug)]
pub struct WithProtocolEnds;

pub mod with_protocol_ends {
    pub mod prelude {
        pub use crate::{
            with_protocol_ends, WithProtocolEnds, WithProtocolEndsClientHandler,
            WithProtocolEndsServerHandler,
        };

        pub use crate::WithProtocolEndsClientEndsRequest;

        pub use crate::WithProtocolEndsClientEndsResponse;

        pub use crate::WithProtocolEndsServerEndsRequest;

        pub use crate::WithProtocolEndsServerEndsResponse;

        pub use crate::WithProtocolEndsStructContainingEndsRequest;

        pub use crate::WithProtocolEndsStructContainingEndsResponse;
    }

    pub struct ClientEnds;

    impl ::fidl_next::Method for ClientEnds {
        const ORDINAL: u64 = 5870448041025163330;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsClientEndsRequest;

        type Response = crate::WireWithProtocolEndsClientEndsResponse;
    }

    pub struct ServerEnds;

    impl ::fidl_next::Method for ServerEnds {
        const ORDINAL: u64 = 8115535094437022259;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsServerEndsRequest;

        type Response = crate::WireWithProtocolEndsServerEndsResponse;
    }

    pub struct StructContainingEnds;

    impl ::fidl_next::Method for StructContainingEnds {
        const ORDINAL: u64 = 4076866772260025813;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsStructContainingEndsRequest;

        type Response = crate::WireWithProtocolEndsStructContainingEndsResponse;
    }

    mod ___detail {

        pub struct ClientEnds<T0> {
            in_: T0,
        }

        impl<T0> ::fidl_next::Encodable for ClientEnds<T0>
        where
            T0: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ClientEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,
        {
            type Encoded = crate::WireWithProtocolEndsClientEndsRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for ClientEnds<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ClientEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        in_,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

                Ok(())
            }
        }

        pub struct ServerEnds<T0> {
            in_: T0,
        }

        impl<T0> ::fidl_next::Encodable for ServerEnds<T0>
        where
            T0: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,
        {
            type Encoded = crate::WireWithProtocolEndsServerEndsRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for ServerEnds<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ServerEnd<
                    crate::DiscoverableProtocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        in_,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

                Ok(())
            }
        }

        pub struct StructContainingEnds<T0> {
            in_: T0,
        }

        impl<T0> ::fidl_next::Encodable for StructContainingEnds<T0>
        where
            T0: ::fidl_next::Encodable<Encoded = crate::WireProtocolEnds>,
        {
            type Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest;
        }

        unsafe impl<___E, T0> ::fidl_next::Encode<___E> for StructContainingEnds<T0>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = crate::WireProtocolEnds>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        in_,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.in_, encoder, in_)?;

                Ok(())
            }
        }

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::WithProtocolEnds
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = WithProtocolEndsClientSender<___T>;
            type ServerSender = WithProtocolEndsServerSender<___T>;
        }

        /// The client sender for the `WithProtocolEnds` protocol.
        pub struct WithProtocolEndsClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> WithProtocolEndsClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn client_ends(
                &self,

                in_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ClientEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ClientEnds, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.client_ends_with(ClientEnds { in_ })
            }

            pub fn client_ends_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ClientEnds, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireWithProtocolEndsClientEndsRequest,
                >,
            {
                self.sender
                    .send_two_way(5870448041025163330, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn server_ends(
                &self,

                in_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ServerEnd<
                        crate::DiscoverableProtocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ServerEnds, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.server_ends_with(ServerEnds { in_ })
            }

            pub fn server_ends_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ServerEnds, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireWithProtocolEndsServerEndsRequest,
                >,
            {
                self.sender
                    .send_two_way(8115535094437022259, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn struct_containing_ends(
                &self,

                in_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireProtocolEnds,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StructContainingEnds, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.struct_containing_ends_with(StructContainingEnds { in_ })
            }

            pub fn struct_containing_ends_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StructContainingEnds, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest,
                >,
            {
                self.sender
                    .send_two_way(4076866772260025813, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `WithProtocolEnds` protocol.
        #[repr(transparent)]
        pub struct WithProtocolEndsServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> WithProtocolEndsServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for WithProtocolEnds
where
    ___H: WithProtocolEndsClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <with_protocol_ends::ClientEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::ServerEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::StructContainingEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsServerHandler<___T: ::fidl_next::Transport> {
    fn client_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<WithProtocolEnds, ___T>,

        request: ::fidl_next::Request<with_protocol_ends::ClientEnds, ___T>,

        responder: ::fidl_next::Responder<with_protocol_ends::ClientEnds>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn server_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<WithProtocolEnds, ___T>,

        request: ::fidl_next::Request<with_protocol_ends::ServerEnds, ___T>,

        responder: ::fidl_next::Responder<with_protocol_ends::ServerEnds>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn struct_containing_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<WithProtocolEnds, ___T>,

        request: ::fidl_next::Request<with_protocol_ends::StructContainingEnds, ___T>,

        responder: ::fidl_next::Responder<with_protocol_ends::StructContainingEnds>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for WithProtocolEnds
where
    ___H: WithProtocolEndsServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <with_protocol_ends::ClientEnds as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::ServerEnds as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::StructContainingEnds as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5870448041025163330 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.client_ends(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            8115535094437022259 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.server_ends(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            4076866772260025813 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.struct_containing_ends(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `AnotherDiscoverableProtocol`
    /// protocol.
    pub type AnotherDiscoverableProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::AnotherDiscoverableProtocol,
    >;

    impl ::core::convert::From<crate::AnotherDiscoverableProtocol>
        for ::fidl_test_protocols::AnotherDiscoverableProtocolMarker
    {
        #[inline]
        fn from(_: crate::AnotherDiscoverableProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ChannelProtocol`
    /// protocol.
    pub type ChannelProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ChannelProtocol>;

    impl ::core::convert::From<crate::ChannelProtocol>
        for ::fidl_test_protocols::ChannelProtocolMarker
    {
        #[inline]
        fn from(_: crate::ChannelProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `DiscoverableProtocol`
    /// protocol.
    pub type DiscoverableProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>;

    impl ::core::convert::From<crate::DiscoverableProtocol>
        for ::fidl_test_protocols::DiscoverableProtocolMarker
    {
        #[inline]
        fn from(_: crate::DiscoverableProtocol) -> Self {
            Self
        }
    }

    impl ::core::convert::From<crate::ErrorEnum> for ::fidl_test_protocols::ErrorEnum {
        #[inline]
        fn from(from: crate::ErrorEnum) -> Self {
            match crate::ErrorEnum::from(from) {
                crate::ErrorEnum::ErrFoo => Self::ErrFoo,

                crate::ErrorEnum::ErrBar => Self::ErrBar,
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `HandleRightsProtocol`
    /// protocol.
    pub type HandleRightsProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::HandleRightsProtocol>;

    impl ::core::convert::From<crate::HandleRightsProtocol>
        for ::fidl_test_protocols::HandleRightsProtocolMarker
    {
        #[inline]
        fn from(_: crate::HandleRightsProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ManyParameters`
    /// protocol.
    pub type ManyParametersProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ManyParameters>;

    impl ::core::convert::From<crate::ManyParameters> for ::fidl_test_protocols::ManyParametersMarker {
        #[inline]
        fn from(_: crate::ManyParameters) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `MethodWithUnion`
    /// protocol.
    pub type MethodWithUnionProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::MethodWithUnion>;

    impl ::core::convert::From<crate::MethodWithUnion>
        for ::fidl_test_protocols::MethodWithUnionMarker
    {
        #[inline]
        fn from(_: crate::MethodWithUnion) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `PlatformServer`
    /// protocol.
    pub type PlatformServerProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::PlatformServer>;

    impl ::core::convert::From<crate::PlatformServer> for ::fidl_test_protocols::PlatformServer_Marker {
        #[inline]
        fn from(_: crate::PlatformServer) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithAndWithoutRequestResponse`
    /// protocol.
    pub type WithAndWithoutRequestResponseProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::WithAndWithoutRequestResponse,
    >;

    impl ::core::convert::From<crate::WithAndWithoutRequestResponse>
        for ::fidl_test_protocols::WithAndWithoutRequestResponseMarker
    {
        #[inline]
        fn from(_: crate::WithAndWithoutRequestResponse) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithErrorSyntax`
    /// protocol.
    pub type WithErrorSyntaxProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::WithErrorSyntax>;

    impl ::core::convert::From<crate::WithErrorSyntax>
        for ::fidl_test_protocols::WithErrorSyntaxMarker
    {
        #[inline]
        fn from(_: crate::WithErrorSyntax) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithProtocolEnds`
    /// protocol.
    pub type WithProtocolEndsProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::WithProtocolEnds>;

    impl ::core::convert::From<crate::WithProtocolEnds>
        for ::fidl_test_protocols::WithProtocolEndsMarker
    {
        #[inline]
        fn from(_: crate::WithProtocolEnds) -> Self {
            Self
        }
    }
}
