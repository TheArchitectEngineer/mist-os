// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the AnotherDiscoverableProtocol protocol.
#[derive(Debug)]
pub struct AnotherDiscoverableProtocol;

impl ::fidl_next::Discoverable for AnotherDiscoverableProtocol {
    const PROTOCOL_NAME: &'static str = "another_discoverable_protocol";
}

pub mod another_discoverable_protocol {
    pub mod prelude {
        pub use crate::{
            another_discoverable_protocol, AnotherDiscoverableProtocol,
            AnotherDiscoverableProtocolClientHandler, AnotherDiscoverableProtocolClientSender,
            AnotherDiscoverableProtocolServerHandler, AnotherDiscoverableProtocolServerSender,
        };
    }
}

/// A helper trait for the `AnotherDiscoverableProtocol` client sender.
pub trait AnotherDiscoverableProtocolClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> AnotherDiscoverableProtocolClientSender
    for ::fidl_next::ClientSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: AnotherDiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `AnotherDiscoverableProtocol` server sender.
pub trait AnotherDiscoverableProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> AnotherDiscoverableProtocolServerSender
    for ::fidl_next::ServerSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: AnotherDiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodARequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodARequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMethodARequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodARequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodARequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodARequest> for ChannelProtocolMethodARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireChannelProtocolMethodARequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodARequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::ZeroPadding for WireChannelProtocolMethodARequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolEventARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolEventARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolEventARequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolEventARequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolEventARequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolEventARequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolEventARequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolEventARequest> for ChannelProtocolEventARequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireChannelProtocolEventARequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolEventARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolEventARequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::ZeroPadding for WireChannelProtocolEventARequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolEventARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodBRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodBRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodBRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMethodBRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodBRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodBRequest> for ChannelProtocolMethodBRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireChannelProtocolMethodBRequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodBRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBRequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::ZeroPadding for WireChannelProtocolMethodBRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ChannelProtocolMethodBResponse {
    pub result: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMethodBResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                result,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.result, encoder, result)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodBResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMethodBResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodBResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodBResponse> for ChannelProtocolMethodBResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireChannelProtocolMethodBResponse) -> Self {
        Self { result: ::fidl_next::TakeFrom::take_from(&from.result) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMethodBResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBResponse {
    pub result: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::ZeroPadding for WireChannelProtocolMethodBResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut result,

            } = slot;
        }

        ::fidl_next::Decode::decode(result.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolTakeHandleRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolTakeHandleRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolTakeHandleRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolTakeHandleRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolTakeHandleRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolTakeHandleRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolTakeHandleRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolTakeHandleRequest>
    for ChannelProtocolTakeHandleRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireChannelProtocolTakeHandleRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corresponding to [`ChannelProtocolTakeHandleRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireChannelProtocolTakeHandleRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolTakeHandleRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMutateSocketRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMutateSocketRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMutateSocketRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMutateSocketRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMutateSocketRequest>
    for ChannelProtocolMutateSocketRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireChannelProtocolMutateSocketRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMutateSocketRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireChannelProtocolMutateSocketRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireChannelProtocolMutateSocketResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMutateSocketResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMutateSocketResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMutateSocketResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMutateSocketResponse>
    for ChannelProtocolMutateSocketResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireChannelProtocolMutateSocketResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corresponding to [`ChannelProtocolMutateSocketResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireChannelProtocolMutateSocketResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ChannelProtocol protocol.
#[derive(Debug)]
pub struct ChannelProtocol;

pub mod channel_protocol {
    pub mod prelude {
        pub use crate::{
            channel_protocol, ChannelProtocol, ChannelProtocolClientHandler,
            ChannelProtocolClientSender, ChannelProtocolServerHandler, ChannelProtocolServerSender,
        };

        pub use crate::ChannelProtocolEventARequest;

        pub use crate::ChannelProtocolMethodARequest;

        pub use crate::ChannelProtocolMethodBRequest;

        pub use crate::ChannelProtocolMethodBResponse;

        pub use crate::ChannelProtocolMutateSocketRequest;

        pub use crate::ChannelProtocolMutateSocketResponse;

        pub use crate::ChannelProtocolTakeHandleRequest;
    }

    pub struct MethodA;

    impl ::fidl_next::Method for MethodA {
        const ORDINAL: u64 = 3155008840945527714;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodARequest;

        type Response = ::fidl_next::Never;
    }

    pub struct EventA;

    impl ::fidl_next::Method for EventA {
        const ORDINAL: u64 = 2220452875311597006;

        type Protocol = crate::ChannelProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireChannelProtocolEventARequest;
    }

    pub struct MethodB;

    impl ::fidl_next::Method for MethodB {
        const ORDINAL: u64 = 8903004957800778182;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodBRequest;

        type Response = crate::WireChannelProtocolMethodBResponse;
    }

    pub struct TakeHandle;

    impl ::fidl_next::Method for TakeHandle {
        const ORDINAL: u64 = 591935489944717925;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolTakeHandleRequest;

        type Response = ();
    }

    pub struct MutateSocket;

    impl ::fidl_next::Method for MutateSocket {
        const ORDINAL: u64 = 7411742788430590287;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMutateSocketRequest;

        type Response = crate::WireChannelProtocolMutateSocketResponse;
    }
}

/// A helper trait for the `ChannelProtocol` client sender.
pub trait ChannelProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn method_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodARequest,
        >;

    fn method_b<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodBRequest,
        >;

    fn take_handle<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolTakeHandleRequest,
        >;

    fn mutate_socket<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMutateSocketRequest,
        >;
}

impl<___T> ChannelProtocolClientSender for ::fidl_next::ClientSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn method_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodARequest,
        >,
    {
        self.as_untyped().send_one_way(3155008840945527714, request)
    }

    fn method_b<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodBRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8903004957800778182, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn take_handle<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolTakeHandleRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(591935489944717925, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn mutate_socket<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireChannelProtocolMutateSocketRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(7411742788430590287, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn event_a(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, ChannelProtocol>,

        message: ::fidl_next::ResponseBuffer<___T, channel_protocol::EventA>,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: ChannelProtocolClientHandler<___T>,

    <channel_protocol::EventA as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MethodB as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <channel_protocol::MutateSocket as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            2220452875311597006 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_a(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ChannelProtocol` server sender.
pub trait ChannelProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn event_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <channel_protocol::EventA as ::fidl_next::Method>::Response,
        >;
}

impl<___T> ChannelProtocolServerSender for ::fidl_next::ServerSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn event_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <channel_protocol::EventA as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(2220452875311597006, request)
    }
}

/// A server handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method_a(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::RequestBuffer<___T, channel_protocol::MethodA>,
    );

    fn method_b(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::RequestBuffer<___T, channel_protocol::MethodB>,

        responder: ::fidl_next::Responder<channel_protocol::MethodB>,
    );

    fn take_handle(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::RequestBuffer<___T, channel_protocol::TakeHandle>,

        responder: ::fidl_next::Responder<channel_protocol::TakeHandle>,
    );

    fn mutate_socket(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::RequestBuffer<___T, channel_protocol::MutateSocket>,

        responder: ::fidl_next::Responder<channel_protocol::MutateSocket>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: ChannelProtocolServerHandler<___T>,

    crate::WireChannelProtocolMethodARequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireChannelProtocolMethodBRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireChannelProtocolTakeHandleRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireChannelProtocolMutateSocketRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3155008840945527714 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.method_a(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8903004957800778182 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.method_b(sender, buffer, responder);
            }

            591935489944717925 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.take_handle(sender, buffer, responder);
            }

            7411742788430590287 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.mutate_socket(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the DiscoverableProtocol protocol.
#[derive(Debug)]
pub struct DiscoverableProtocol;

impl ::fidl_next::Discoverable for DiscoverableProtocol {
    const PROTOCOL_NAME: &'static str = "discoverable_protocol";
}

pub mod discoverable_protocol {
    pub mod prelude {
        pub use crate::{
            discoverable_protocol, DiscoverableProtocol, DiscoverableProtocolClientHandler,
            DiscoverableProtocolClientSender, DiscoverableProtocolServerHandler,
            DiscoverableProtocolServerSender,
        };
    }

    pub struct Method;

    impl ::fidl_next::Method for Method {
        const ORDINAL: u64 = 3455873048082739435;

        type Protocol = crate::DiscoverableProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `DiscoverableProtocol` client sender.
pub trait DiscoverableProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn method(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> DiscoverableProtocolClientSender
    for ::fidl_next::ClientSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn method(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(3455873048082739435, &mut ())
    }
}

/// A client handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: DiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `DiscoverableProtocol` server sender.
pub trait DiscoverableProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DiscoverableProtocolServerSender
    for ::fidl_next::ServerSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method(&mut self, sender: &::fidl_next::ServerSender<___T, DiscoverableProtocol>);
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: DiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3455873048082739435 => {
                handler.method(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum ErrorEnum {
    ErrFoo = 1,
    ErrBar = 2,
}

impl ::fidl_next::Encodable for ErrorEnum {
    type Encoded = WireErrorEnum;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ErrorEnum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireErrorEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::ErrFoo => 1,

            Self::ErrBar => 2,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireErrorEnum> for ErrorEnum {
    fn from(wire: WireErrorEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrFoo,

            2 => Self::ErrBar,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireErrorEnum> for ErrorEnum {
    #[inline]
    fn take_from(from: &WireErrorEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`ErrorEnum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireErrorEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireErrorEnum {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireErrorEnum {
    pub const ERR_FOO: WireErrorEnum = WireErrorEnum { value: ::fidl_next::WireU32(1) };

    pub const ERR_BAR: WireErrorEnum = WireErrorEnum { value: ::fidl_next::WireU32(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireErrorEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 | 2 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<ErrorEnum> for WireErrorEnum {
    fn from(natural: ErrorEnum) -> Self {
        match natural {
            ErrorEnum::ErrFoo => WireErrorEnum::ERR_FOO,

            ErrorEnum::ErrBar => WireErrorEnum::ERR_BAR,
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolNoResponseMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolNoResponseMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolNoResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolNoResponseMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolNoResponseMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<HandleRightsProtocolNoResponseMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolNoResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolNoResponseMethodRequest>
    for HandleRightsProtocolNoResponseMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireHandleRightsProtocolNoResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolNoResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireHandleRightsProtocolNoResponseMethodRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolNoResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolResponseMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolResponseMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolResponseMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolResponseMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolResponseMethodRequest>
    for HandleRightsProtocolResponseMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireHandleRightsProtocolResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireHandleRightsProtocolResponseMethodRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolResponseMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolResponseMethodResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolResponseMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<HandleRightsProtocolResponseMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolResponseMethodResponse>
    for HandleRightsProtocolResponseMethodResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireHandleRightsProtocolResponseMethodResponse) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolResponseMethodResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireHandleRightsProtocolResponseMethodResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct HandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolAnEventRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireHandleRightsProtocolAnEventRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolAnEventRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolAnEventRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolAnEventRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolAnEventRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolAnEventRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolAnEventRequest>
    for HandleRightsProtocolAnEventRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireHandleRightsProtocolAnEventRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corresponding to [`HandleRightsProtocolAnEventRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireHandleRightsProtocolAnEventRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolAnEventRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the HandleRightsProtocol protocol.
#[derive(Debug)]
pub struct HandleRightsProtocol;

pub mod handle_rights_protocol {
    pub mod prelude {
        pub use crate::{
            handle_rights_protocol, HandleRightsProtocol, HandleRightsProtocolClientHandler,
            HandleRightsProtocolClientSender, HandleRightsProtocolServerHandler,
            HandleRightsProtocolServerSender,
        };

        pub use crate::HandleRightsProtocolAnEventRequest;

        pub use crate::HandleRightsProtocolNoResponseMethodRequest;

        pub use crate::HandleRightsProtocolResponseMethodRequest;

        pub use crate::HandleRightsProtocolResponseMethodResponse;
    }

    pub struct NoResponseMethod;

    impl ::fidl_next::Method for NoResponseMethod {
        const ORDINAL: u64 = 1155044649514904573;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolNoResponseMethodRequest;

        type Response = ::fidl_next::Never;
    }

    pub struct ResponseMethod;

    impl ::fidl_next::Method for ResponseMethod {
        const ORDINAL: u64 = 5956276128041940295;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolResponseMethodRequest;

        type Response = crate::WireHandleRightsProtocolResponseMethodResponse;
    }

    pub struct AnEvent;

    impl ::fidl_next::Method for AnEvent {
        const ORDINAL: u64 = 476727631355490611;

        type Protocol = crate::HandleRightsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireHandleRightsProtocolAnEventRequest;
    }
}

/// A helper trait for the `HandleRightsProtocol` client sender.
pub trait HandleRightsProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn no_response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >;

    fn response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolResponseMethodRequest,
        >;
}

impl<___T> HandleRightsProtocolClientSender
    for ::fidl_next::ClientSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn no_response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >,
    {
        self.as_untyped().send_one_way(1155044649514904573, request)
    }

    fn response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolResponseMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5956276128041940295, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn an_event(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, HandleRightsProtocol>,

        message: ::fidl_next::ResponseBuffer<___T, handle_rights_protocol::AnEvent>,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: HandleRightsProtocolClientHandler<___T>,

    <handle_rights_protocol::ResponseMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <handle_rights_protocol::AnEvent as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            476727631355490611 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.an_event(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `HandleRightsProtocol` server sender.
pub trait HandleRightsProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn an_event<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <handle_rights_protocol::AnEvent as ::fidl_next::Method>::Response,
        >;
}

impl<___T> HandleRightsProtocolServerSender
    for ::fidl_next::ServerSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn an_event<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <handle_rights_protocol::AnEvent as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(476727631355490611, request)
    }
}

/// A server handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn no_response_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::RequestBuffer<___T, handle_rights_protocol::NoResponseMethod>,
    );

    fn response_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::RequestBuffer<___T, handle_rights_protocol::ResponseMethod>,

        responder: ::fidl_next::Responder<handle_rights_protocol::ResponseMethod>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: HandleRightsProtocolServerHandler<___T>,

    crate::WireHandleRightsProtocolNoResponseMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireHandleRightsProtocolResponseMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1155044649514904573 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.no_response_method(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5956276128041940295 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.response_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

impl ::fidl_next::Encodable for ManyParametersFifteenRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireManyParametersFifteenRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                p1,
                p2,
                p3,
                p4,
                p5,
                p6,
                p7,
                p8,
                p9,
                p10,
                p11,
                p12,
                p13,
                p14,
                p15,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.p1, encoder, p1)?;

        ::fidl_next::Encode::encode(&mut self.p2, encoder, p2)?;

        ::fidl_next::Encode::encode(&mut self.p3, encoder, p3)?;

        ::fidl_next::Encode::encode(&mut self.p4, encoder, p4)?;

        ::fidl_next::Encode::encode(&mut self.p5, encoder, p5)?;

        ::fidl_next::Encode::encode(&mut self.p6, encoder, p6)?;

        ::fidl_next::Encode::encode(&mut self.p7, encoder, p7)?;

        ::fidl_next::Encode::encode(&mut self.p8, encoder, p8)?;

        ::fidl_next::Encode::encode(&mut self.p9, encoder, p9)?;

        ::fidl_next::Encode::encode(&mut self.p10, encoder, p10)?;

        ::fidl_next::Encode::encode(&mut self.p11, encoder, p11)?;

        ::fidl_next::Encode::encode(&mut self.p12, encoder, p12)?;

        ::fidl_next::Encode::encode(&mut self.p13, encoder, p13)?;

        ::fidl_next::Encode::encode(&mut self.p14, encoder, p14)?;

        ::fidl_next::Encode::encode(&mut self.p15, encoder, p15)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ManyParametersFifteenRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireManyParametersFifteenRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ManyParametersFifteenRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ManyParametersFifteenRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireManyParametersFifteenRequest> for ManyParametersFifteenRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireManyParametersFifteenRequest) -> Self {
        Self {
            p1: ::fidl_next::TakeFrom::take_from(&from.p1),

            p2: ::fidl_next::TakeFrom::take_from(&from.p2),

            p3: ::fidl_next::TakeFrom::take_from(&from.p3),

            p4: ::fidl_next::TakeFrom::take_from(&from.p4),

            p5: ::fidl_next::TakeFrom::take_from(&from.p5),

            p6: ::fidl_next::TakeFrom::take_from(&from.p6),

            p7: ::fidl_next::TakeFrom::take_from(&from.p7),

            p8: ::fidl_next::TakeFrom::take_from(&from.p8),

            p9: ::fidl_next::TakeFrom::take_from(&from.p9),

            p10: ::fidl_next::TakeFrom::take_from(&from.p10),

            p11: ::fidl_next::TakeFrom::take_from(&from.p11),

            p12: ::fidl_next::TakeFrom::take_from(&from.p12),

            p13: ::fidl_next::TakeFrom::take_from(&from.p13),

            p14: ::fidl_next::TakeFrom::take_from(&from.p14),

            p15: ::fidl_next::TakeFrom::take_from(&from.p15),
        }
    }
}

/// The wire type corresponding to [`ManyParametersFifteenRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireManyParametersFifteenRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireManyParametersFifteenRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut p1,
                mut p2,
                mut p3,
                mut p4,
                mut p5,
                mut p6,
                mut p7,
                mut p8,
                mut p9,
                mut p10,
                mut p11,
                mut p12,
                mut p13,
                mut p14,
                mut p15,

            } = slot;
        }

        ::fidl_next::Decode::decode(p1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p6.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p9.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p10.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p11.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p12.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p13.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p14.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p15.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ManyParameters protocol.
#[derive(Debug)]
pub struct ManyParameters;

pub mod many_parameters {
    pub mod prelude {
        pub use crate::{
            many_parameters, ManyParameters, ManyParametersClientHandler,
            ManyParametersClientSender, ManyParametersServerHandler, ManyParametersServerSender,
        };

        pub use crate::ManyParametersFifteenRequest;
    }

    pub struct Fifteen;

    impl ::fidl_next::Method for Fifteen {
        const ORDINAL: u64 = 6423043252952467815;

        type Protocol = crate::ManyParameters;

        type Request = crate::WireManyParametersFifteenRequest;

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `ManyParameters` client sender.
pub trait ManyParametersClientSender {
    type Transport: ::fidl_next::Transport;

    fn fifteen<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireManyParametersFifteenRequest,
        >;
}

impl<___T> ManyParametersClientSender for ::fidl_next::ClientSender<___T, ManyParameters>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn fifteen<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireManyParametersFifteenRequest,
        >,
    {
        self.as_untyped().send_one_way(6423043252952467815, request)
    }
}

/// A client handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::Transport,
    ___H: ManyParametersClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ManyParameters` server sender.
pub trait ManyParametersServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ManyParametersServerSender for ::fidl_next::ServerSender<___T, ManyParameters>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersServerHandler<___T: ::fidl_next::Transport> {
    fn fifteen(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ManyParameters>,

        request: ::fidl_next::RequestBuffer<___T, many_parameters::Fifteen>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::Transport,
    ___H: ManyParametersServerHandler<___T>,

    crate::WireManyParametersFifteenRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6423043252952467815 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.fifteen(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum TheUnion {
    V(u32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for TheUnion {
    type Encoded = WireTheUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TheUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTheUnion { raw } = out);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<TheUnion> {
    type EncodedOption = WireOptionalTheUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<TheUnion>
where
    ___E: ?Sized,
    TheUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalTheUnion { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTheUnion> for TheUnion {
    #[inline]
    fn take_from(from: &WireTheUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::V(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalTheUnion> for Option<Box<TheUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalTheUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`TheUnion`].
#[repr(transparent)]
pub struct WireTheUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireTheUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod the_union {
    pub enum Ref<'union> {
        V(&'union ::fidl_next::WireU32),

        UnknownOrdinal_(u64),
    }
}

impl WireTheUnion {
    pub fn as_ref(&self) -> crate::the_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::the_union::Ref::V(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            unknown => crate::the_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireTheUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalTheUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalTheUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalTheUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireTheUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalTheUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalTheUnion { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MethodWithUnionUnionMethodRequest {
    pub u: crate::TheUnion,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::TheUnion as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireMethodWithUnionUnionMethodRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MethodWithUnionUnionMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireMethodWithUnionUnionMethodRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<MethodWithUnionUnionMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMethodWithUnionUnionMethodRequest>
    for MethodWithUnionUnionMethodRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::TheUnion as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireMethodWithUnionUnionMethodRequest) -> Self {
        Self { u: ::fidl_next::TakeFrom::take_from(&from.u) }
    }
}

/// The wire type corresponding to [`MethodWithUnionUnionMethodRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodRequest {
    pub u: crate::WireTheUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireMethodWithUnionUnionMethodRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MethodWithUnionUnionMethodResponse {
    pub u: Option<Box<crate::TheUnion>>,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<Box<crate::TheUnion>> as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireMethodWithUnionUnionMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MethodWithUnionUnionMethodResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireMethodWithUnionUnionMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<MethodWithUnionUnionMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMethodWithUnionUnionMethodResponse>
    for MethodWithUnionUnionMethodResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <Option<Box<crate::TheUnion>> as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireMethodWithUnionUnionMethodResponse) -> Self {
        Self { u: ::fidl_next::TakeFrom::take_from(&from.u) }
    }
}

/// The wire type corresponding to [`MethodWithUnionUnionMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodResponse {
    pub u: crate::WireOptionalTheUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireMethodWithUnionUnionMethodResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the MethodWithUnion protocol.
#[derive(Debug)]
pub struct MethodWithUnion;

pub mod method_with_union {
    pub mod prelude {
        pub use crate::{
            method_with_union, MethodWithUnion, MethodWithUnionClientHandler,
            MethodWithUnionClientSender, MethodWithUnionServerHandler, MethodWithUnionServerSender,
        };

        pub use crate::MethodWithUnionUnionMethodRequest;

        pub use crate::MethodWithUnionUnionMethodResponse;
    }

    pub struct UnionMethod;

    impl ::fidl_next::Method for UnionMethod {
        const ORDINAL: u64 = 4124874338266649112;

        type Protocol = crate::MethodWithUnion;

        type Request = crate::WireMethodWithUnionUnionMethodRequest;

        type Response = crate::WireMethodWithUnionUnionMethodResponse;
    }
}

/// A helper trait for the `MethodWithUnion` client sender.
pub trait MethodWithUnionClientSender {
    type Transport: ::fidl_next::Transport;

    fn union_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireMethodWithUnionUnionMethodRequest,
        >;
}

impl<___T> MethodWithUnionClientSender for ::fidl_next::ClientSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn union_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireMethodWithUnionUnionMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4124874338266649112, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::Transport,
    ___H: MethodWithUnionClientHandler<___T>,

    <method_with_union::UnionMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `MethodWithUnion` server sender.
pub trait MethodWithUnionServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> MethodWithUnionServerSender for ::fidl_next::ServerSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionServerHandler<___T: ::fidl_next::Transport> {
    fn union_method(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, MethodWithUnion>,

        request: ::fidl_next::RequestBuffer<___T, method_with_union::UnionMethod>,

        responder: ::fidl_next::Responder<method_with_union::UnionMethod>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::Transport,
    ___H: MethodWithUnionServerHandler<___T>,

    crate::WireMethodWithUnionUnionMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            4124874338266649112 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.union_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the PlatformServer protocol.
#[derive(Debug)]
pub struct PlatformServer;

impl ::fidl_next::Discoverable for PlatformServer {
    const PROTOCOL_NAME: &'static str = "platform_server";
}

pub mod platform_server {
    pub mod prelude {
        pub use crate::{
            platform_server, PlatformServer, PlatformServerClientHandler,
            PlatformServerClientSender, PlatformServerServerHandler, PlatformServerServerSender,
        };
    }
}

/// A helper trait for the `PlatformServer` client sender.
pub trait PlatformServerClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> PlatformServerClientSender for ::fidl_next::ClientSender<___T, PlatformServer>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::Transport,
    ___H: PlatformServerClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `PlatformServer` server sender.
pub trait PlatformServerServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> PlatformServerServerSender for ::fidl_next::ServerSender<___T, PlatformServer>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::Transport,
    ___H: PlatformServerServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ProtocolEnds {
    pub client:
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,

    pub server:
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,

    pub client_opt: ::fidl_next::ClientEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,

    pub server_opt: ::fidl_next::ServerEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for ProtocolEnds {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled()
                && <::fidl_next::ServerEnd<
                    ::fidl_next::fuchsia::zx::Channel,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ClientEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ServerEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    type Encoded = WireProtocolEnds;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ProtocolEnds
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                client,
                server,
                client_opt,
                server_opt,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.client, encoder, client)?;

        ::fidl_next::Encode::encode(&mut self.server, encoder, server)?;

        ::fidl_next::Encode::encode(&mut self.client_opt, encoder, client_opt)?;

        ::fidl_next::Encode::encode(&mut self.server_opt, encoder, server_opt)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolEnds> {
    type EncodedOption = ::fidl_next::WireBox<WireProtocolEnds>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolEnds>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolEnds: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolEnds> for ProtocolEnds {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled()
                && <::fidl_next::ServerEnd<
                    ::fidl_next::fuchsia::zx::Channel,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ClientEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled()
                && <::fidl_next::ServerEnd<
                    Option<::fidl_next::fuchsia::zx::Channel>,
                    crate::DiscoverableProtocol,
                > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireProtocolEnds) -> Self {
        Self {
            client: ::fidl_next::TakeFrom::take_from(&from.client),

            server: ::fidl_next::TakeFrom::take_from(&from.server),

            client_opt: ::fidl_next::TakeFrom::take_from(&from.client_opt),

            server_opt: ::fidl_next::TakeFrom::take_from(&from.server_opt),
        }
    }
}

/// The wire type corresponding to [`ProtocolEnds`].
#[derive(Debug)]
#[repr(C)]
pub struct WireProtocolEnds {
    pub client:
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,

    pub server:
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,

    pub client_opt: ::fidl_next::ClientEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,

    pub server_opt: ::fidl_next::ServerEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl ::fidl_next::ZeroPadding for WireProtocolEnds {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireProtocolEnds
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut client,
                mut server,
                mut client_opt,
                mut server_opt,

            } = slot;
        }

        ::fidl_next::Decode::decode(client.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_opt.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_opt.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct SyscallProtocolMethodCRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for SyscallProtocolMethodCRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireSyscallProtocolMethodCRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SyscallProtocolMethodCRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SyscallProtocolMethodCRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireSyscallProtocolMethodCRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<SyscallProtocolMethodCRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SyscallProtocolMethodCRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSyscallProtocolMethodCRequest> for SyscallProtocolMethodCRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireSyscallProtocolMethodCRequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`SyscallProtocolMethodCRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireSyscallProtocolMethodCRequest {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::ZeroPadding for WireSyscallProtocolMethodCRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSyscallProtocolMethodCRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the SyscallProtocol protocol.
#[derive(Debug)]
pub struct SyscallProtocol;

pub mod syscall_protocol {
    pub mod prelude {
        pub use crate::{
            syscall_protocol, SyscallProtocol, SyscallProtocolClientHandler,
            SyscallProtocolClientSender, SyscallProtocolServerHandler, SyscallProtocolServerSender,
        };

        pub use crate::SyscallProtocolMethodCRequest;
    }

    pub struct MethodC;

    impl ::fidl_next::Method for MethodC {
        const ORDINAL: u64 = 1468025868259603279;

        type Protocol = crate::SyscallProtocol;

        type Request = crate::WireSyscallProtocolMethodCRequest;

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `SyscallProtocol` client sender.
pub trait SyscallProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn method_c<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSyscallProtocolMethodCRequest,
        >;
}

impl<___T> SyscallProtocolClientSender for ::fidl_next::ClientSender<___T, SyscallProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn method_c<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSyscallProtocolMethodCRequest,
        >,
    {
        self.as_untyped().send_one_way(1468025868259603279, request)
    }
}

/// A client handler for the SyscallProtocol protocol.
///
/// See [`SyscallProtocol`] for more details.
pub trait SyscallProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for SyscallProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SyscallProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SyscallProtocol` server sender.
pub trait SyscallProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> SyscallProtocolServerSender for ::fidl_next::ServerSender<___T, SyscallProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the SyscallProtocol protocol.
///
/// See [`SyscallProtocol`] for more details.
pub trait SyscallProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method_c(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, SyscallProtocol>,

        request: ::fidl_next::RequestBuffer<___T, syscall_protocol::MethodC>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for SyscallProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SyscallProtocolServerHandler<___T>,

    crate::WireSyscallProtocolMethodCRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1468025868259603279 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.method_c(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseNoRequestWithResponseResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseNoRequestWithResponseResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseNoRequestWithResponseResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseNoRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    #[inline]
    fn take_from(from: &WireWithAndWithoutRequestResponseNoRequestWithResponseResponse) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseNoRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: ::fidl_next::WireString,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestNoResponseRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestNoResponseRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestNoResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestNoResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    #[inline]
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestNoResponseRequest) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestNoResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: ::fidl_next::WireString,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    #[inline]
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestEmptyResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: ::fidl_next::WireString,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    #[inline]
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestWithResponseRequest) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: ::fidl_next::WireString,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    #[inline]
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestWithResponseResponse) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseWithRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: ::fidl_next::WireString,
}

unsafe impl ::fidl_next::ZeroPadding
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseOnWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseOnWithResponseRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithAndWithoutRequestResponseOnWithResponseRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseOnWithResponseRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseOnWithResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseOnWithResponseRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseOnWithResponseRequest>
    for WithAndWithoutRequestResponseOnWithResponseRequest
{
    #[inline]
    fn take_from(from: &WireWithAndWithoutRequestResponseOnWithResponseRequest) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
    }
}

/// The wire type corresponding to [`WithAndWithoutRequestResponseOnWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: ::fidl_next::WireString,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithAndWithoutRequestResponseOnWithResponseRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseOnWithResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithAndWithoutRequestResponse protocol.
#[derive(Debug)]
pub struct WithAndWithoutRequestResponse;

pub mod with_and_without_request_response {
    pub mod prelude {
        pub use crate::{
            with_and_without_request_response, WithAndWithoutRequestResponse,
            WithAndWithoutRequestResponseClientHandler, WithAndWithoutRequestResponseClientSender,
            WithAndWithoutRequestResponseServerHandler, WithAndWithoutRequestResponseServerSender,
        };

        pub use crate::WithAndWithoutRequestResponseNoRequestWithResponseResponse;

        pub use crate::WithAndWithoutRequestResponseOnWithResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestNoResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestWithResponseRequest;

        pub use crate::WithAndWithoutRequestResponseWithRequestWithResponseResponse;
    }

    pub struct NoRequestNoResponse;

    impl ::fidl_next::Method for NoRequestNoResponse {
        const ORDINAL: u64 = 5413654872775949227;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct NoRequestEmptyResponse;

    impl ::fidl_next::Method for NoRequestEmptyResponse {
        const ORDINAL: u64 = 1631193469798418024;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ();
    }

    pub struct NoRequestWithResponse;

    impl ::fidl_next::Method for NoRequestWithResponse {
        const ORDINAL: u64 = 9037369643591427517;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse;
    }

    pub struct WithRequestNoResponse;

    impl ::fidl_next::Method for WithRequestNoResponse {
        const ORDINAL: u64 = 7326057319832554103;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest;

        type Response = ::fidl_next::Never;
    }

    pub struct WithRequestEmptyResponse;

    impl ::fidl_next::Method for WithRequestEmptyResponse {
        const ORDINAL: u64 = 2877322062572412767;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

        type Response = ();
    }

    pub struct WithRequestWithResponse;

    impl ::fidl_next::Method for WithRequestWithResponse {
        const ORDINAL: u64 = 6417226585456833969;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest;

        type Response = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse;
    }

    pub struct OnEmptyResponse;

    impl ::fidl_next::Method for OnEmptyResponse {
        const ORDINAL: u64 = 5397663296507358806;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct OnWithResponse;

    impl ::fidl_next::Method for OnWithResponse {
        const ORDINAL: u64 = 5811598563493228968;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::Never;

        type Response = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest;
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` client sender.
pub trait WithAndWithoutRequestResponseClientSender {
    type Transport: ::fidl_next::Transport;

    fn no_request_no_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn with_request_no_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest,
        >;

    fn with_request_empty_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        >;

    fn with_request_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest,
        >;
}

impl<___T> WithAndWithoutRequestResponseClientSender
    for ::fidl_next::ClientSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn no_request_no_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(5413654872775949227, &mut ())
    }

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1631193469798418024, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9037369643591427517, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn with_request_no_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest,
        >,
    {
        self.as_untyped().send_one_way(7326057319832554103, request)
    }

    fn with_request_empty_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2877322062572412767, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn with_request_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(6417226585456833969, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseClientHandler<___T: ::fidl_next::Transport> {
    fn on_empty_response(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, WithAndWithoutRequestResponse>,
    );

    fn on_with_response(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, WithAndWithoutRequestResponse>,

        message: ::fidl_next::ResponseBuffer<
            ___T,
            with_and_without_request_response::OnWithResponse,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::Transport,
    ___H: WithAndWithoutRequestResponseClientHandler<___T>,

    <with_and_without_request_response::NoRequestWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::WithRequestWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_and_without_request_response::OnWithResponse as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5397663296507358806 => {
                handler.on_empty_response(sender);
            }

            5811598563493228968 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.on_with_response(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` server sender.
pub trait WithAndWithoutRequestResponseServerSender {
    type Transport: ::fidl_next::Transport;

    fn on_empty_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn on_with_response<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <with_and_without_request_response::OnWithResponse as ::fidl_next::Method>::Response,
                    >;
}

impl<___T> WithAndWithoutRequestResponseServerSender
    for ::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn on_empty_response(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(5397663296507358806, &mut ())
    }








                fn on_with_response<___R>(
                    &self,
                    request: &mut ___R,
                ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
                where
                    ___R: ::fidl_next::Encode<
                            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
                        Encoded = <with_and_without_request_response::OnWithResponse as ::fidl_next::Method>::Response,
                    >,
                {
        self.as_untyped().send_event(5811598563493228968, request)
    }
}

/// A server handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseServerHandler<___T: ::fidl_next::Transport> {
    fn no_request_no_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,
    );

    fn no_request_empty_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
    );

    fn no_request_with_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::Responder<with_and_without_request_response::NoRequestWithResponse>,
    );

    fn with_request_no_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestNoResponse,
        >,
    );

    fn with_request_empty_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
    );

    fn with_request_with_response(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,

        responder: ::fidl_next::Responder<
            with_and_without_request_response::WithRequestWithResponse,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::Transport,
    ___H: WithAndWithoutRequestResponseServerHandler<___T>,

    crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5413654872775949227 => {
                handler.no_request_no_response(sender);
            }

            7326057319832554103 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.with_request_no_response(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1631193469798418024 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.no_request_empty_response(sender, responder);
            }

            9037369643591427517 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.no_request_with_response(sender, responder);
            }

            2877322062572412767 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.with_request_empty_response(sender, buffer, responder);
            }

            6417226585456833969 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.with_request_with_response(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WithErrorSyntaxResponseAsStructResponse {
    pub a: i64,

    pub b: i64,

    pub c: i64,
}

impl ::fidl_next::Encodable for WithErrorSyntaxResponseAsStructResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithErrorSyntaxResponseAsStructResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        ::fidl_next::Encode::encode(&mut self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxResponseAsStructResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithErrorSyntaxResponseAsStructResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxResponseAsStructResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxResponseAsStructResponse>
    for WithErrorSyntaxResponseAsStructResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithErrorSyntaxResponseAsStructResponse) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),

            c: ::fidl_next::TakeFrom::take_from(&from.c),
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxResponseAsStructResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxResponseAsStructResponse {
    pub a: ::fidl_next::WireI64,

    pub b: ::fidl_next::WireI64,

    pub c: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithErrorSyntaxResponseAsStructResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxResponseAsStructResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

pub type WithErrorSyntaxErrorAsPrimitiveResponse = ();

/// The wire type corresponding to [`WithErrorSyntaxErrorAsPrimitiveResponse`].
pub type WireWithErrorSyntaxErrorAsPrimitiveResponse = ();

pub type WithErrorSyntaxErrorAsEnumResponse = ();

/// The wire type corresponding to [`WithErrorSyntaxErrorAsEnumResponse`].
pub type WireWithErrorSyntaxErrorAsEnumResponse = ();

#[derive(Debug)]
#[repr(C)]
pub struct WithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for WithErrorSyntaxHandleInResultResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithErrorSyntaxHandleInResultResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxHandleInResultResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxHandleInResultResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithErrorSyntaxHandleInResultResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxHandleInResultResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxHandleInResultResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxHandleInResultResponse>
    for WithErrorSyntaxHandleInResultResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::fuchsia::zx::Handle as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithErrorSyntaxHandleInResultResponse) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxHandleInResultResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithErrorSyntaxHandleInResultResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxHandleInResultResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithErrorSyntax protocol.
#[derive(Debug)]
pub struct WithErrorSyntax;

pub mod with_error_syntax {
    pub mod prelude {
        pub use crate::{
            with_error_syntax, WithErrorSyntax, WithErrorSyntaxClientHandler,
            WithErrorSyntaxClientSender, WithErrorSyntaxServerHandler, WithErrorSyntaxServerSender,
        };

        pub use crate::ErrorEnum;

        pub use crate::WithErrorSyntaxErrorAsEnumResponse;

        pub use crate::WithErrorSyntaxErrorAsPrimitiveResponse;

        pub use crate::WithErrorSyntaxHandleInResultResponse;

        pub use crate::WithErrorSyntaxResponseAsStructResponse;
    }

    pub struct ResponseAsStruct;

    impl ::fidl_next::Method for ResponseAsStruct {
        const ORDINAL: u64 = 268248568430741139;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireWithErrorSyntaxResponseAsStructResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct ErrorAsPrimitive;

    impl ::fidl_next::Method for ErrorAsPrimitive {
        const ORDINAL: u64 = 6930994461233198567;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireWithErrorSyntaxErrorAsPrimitiveResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct ErrorAsEnum;

    impl ::fidl_next::Method for ErrorAsEnum {
        const ORDINAL: u64 = 5491891352371277635;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireWithErrorSyntaxErrorAsEnumResponse,
            crate::WireErrorEnum,
        >;
    }

    pub struct HandleInResult;

    impl ::fidl_next::Method for HandleInResult {
        const ORDINAL: u64 = 1371676333068455103;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            crate::WireWithErrorSyntaxHandleInResultResponse,
            ::fidl_next::WireU32,
        >;
    }
}

/// A helper trait for the `WithErrorSyntax` client sender.
pub trait WithErrorSyntaxClientSender {
    type Transport: ::fidl_next::Transport;

    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    >;

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> WithErrorSyntaxClientSender for ::fidl_next::ClientSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(268248568430741139, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6930994461233198567, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5491891352371277635, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1371676333068455103, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::Transport,
    ___H: WithErrorSyntaxClientHandler<___T>,

    <with_error_syntax::ResponseAsStruct as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::ErrorAsPrimitive as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::ErrorAsEnum as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_error_syntax::HandleInResult as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithErrorSyntax` server sender.
pub trait WithErrorSyntaxServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> WithErrorSyntaxServerSender for ::fidl_next::ServerSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxServerHandler<___T: ::fidl_next::Transport> {
    fn response_as_struct(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::ResponseAsStruct>,
    );

    fn error_as_primitive(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::ErrorAsPrimitive>,
    );

    fn error_as_enum(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::ErrorAsEnum>,
    );

    fn handle_in_result(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::Responder<with_error_syntax::HandleInResult>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::Transport,
    ___H: WithErrorSyntaxServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            268248568430741139 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.response_as_struct(sender, responder);
            }

            6930994461233198567 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_as_primitive(sender, responder);
            }

            5491891352371277635 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_as_enum(sender, responder);
            }

            1371676333068455103 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.handle_in_result(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsClientEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsClientEndsRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsClientEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsClientEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsClientEndsRequest>
    for WithProtocolEndsClientEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithProtocolEndsClientEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsClientEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsRequest {
    pub in_: ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithProtocolEndsClientEndsRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsClientEndsResponse {
    pub out: ::fidl_next::ClientEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsClientEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsClientEndsResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsClientEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsClientEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsClientEndsResponse>
    for WithProtocolEndsClientEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ClientEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithProtocolEndsClientEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsClientEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsResponse {
    pub out: ::fidl_next::ClientEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithProtocolEndsClientEndsResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsServerEndsRequest {
    pub in_: ::fidl_next::ServerEnd<
        Option<::fidl_next::fuchsia::zx::Channel>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsServerEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsServerEndsRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsServerEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsServerEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsServerEndsRequest>
    for WithProtocolEndsServerEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                Option<::fidl_next::fuchsia::zx::Channel>,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithProtocolEndsServerEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsServerEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsRequest {
    pub in_: ::fidl_next::ServerEnd<
        ::fidl_next::fuchsia::WireOptionalChannel,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithProtocolEndsServerEndsRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsServerEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsServerEndsResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsServerEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsServerEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsServerEndsResponse>
    for WithProtocolEndsServerEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <::fidl_next::ServerEnd<
                ::fidl_next::fuchsia::zx::Channel,
                crate::DiscoverableProtocol,
            > as ::fidl_next::Encodable>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithProtocolEndsServerEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsServerEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsResponse {
    pub out: ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::DiscoverableProtocol>,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithProtocolEndsServerEndsResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsStructContainingEndsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsStructContainingEndsRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsStructContainingEndsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithProtocolEndsStructContainingEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsStructContainingEndsRequest>
    for WithProtocolEndsStructContainingEndsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithProtocolEndsStructContainingEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsStructContainingEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::WireProtocolEnds,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithProtocolEndsStructContainingEndsRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WithProtocolEndsStructContainingEndsResponse {
    pub out: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireWithProtocolEndsStructContainingEndsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsStructContainingEndsResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsStructContainingEndsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithProtocolEndsStructContainingEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsStructContainingEndsResponse>
    for WithProtocolEndsStructContainingEndsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::ProtocolEnds as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireWithProtocolEndsStructContainingEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
    }
}

/// The wire type corresponding to [`WithProtocolEndsStructContainingEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsResponse {
    pub out: crate::WireProtocolEnds,
}

unsafe impl ::fidl_next::ZeroPadding for WireWithProtocolEndsStructContainingEndsResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithProtocolEnds protocol.
#[derive(Debug)]
pub struct WithProtocolEnds;

pub mod with_protocol_ends {
    pub mod prelude {
        pub use crate::{
            with_protocol_ends, WithProtocolEnds, WithProtocolEndsClientHandler,
            WithProtocolEndsClientSender, WithProtocolEndsServerHandler,
            WithProtocolEndsServerSender,
        };

        pub use crate::WithProtocolEndsClientEndsRequest;

        pub use crate::WithProtocolEndsClientEndsResponse;

        pub use crate::WithProtocolEndsServerEndsRequest;

        pub use crate::WithProtocolEndsServerEndsResponse;

        pub use crate::WithProtocolEndsStructContainingEndsRequest;

        pub use crate::WithProtocolEndsStructContainingEndsResponse;
    }

    pub struct ClientEnds;

    impl ::fidl_next::Method for ClientEnds {
        const ORDINAL: u64 = 5870448041025163330;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsClientEndsRequest;

        type Response = crate::WireWithProtocolEndsClientEndsResponse;
    }

    pub struct ServerEnds;

    impl ::fidl_next::Method for ServerEnds {
        const ORDINAL: u64 = 8115535094437022259;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsServerEndsRequest;

        type Response = crate::WireWithProtocolEndsServerEndsResponse;
    }

    pub struct StructContainingEnds;

    impl ::fidl_next::Method for StructContainingEnds {
        const ORDINAL: u64 = 4076866772260025813;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsStructContainingEndsRequest;

        type Response = crate::WireWithProtocolEndsStructContainingEndsResponse;
    }
}

/// A helper trait for the `WithProtocolEnds` client sender.
pub trait WithProtocolEndsClientSender {
    type Transport: ::fidl_next::Transport;

    fn client_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsClientEndsRequest,
        >;

    fn server_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsServerEndsRequest,
        >;

    fn struct_containing_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >;
}

impl<___T> WithProtocolEndsClientSender for ::fidl_next::ClientSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn client_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsClientEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5870448041025163330, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn server_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsServerEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8115535094437022259, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn struct_containing_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4076866772260025813, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::Transport,
    ___H: WithProtocolEndsClientHandler<___T>,

    <with_protocol_ends::ClientEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::ServerEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <with_protocol_ends::StructContainingEnds as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithProtocolEnds` server sender.
pub trait WithProtocolEndsServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> WithProtocolEndsServerSender for ::fidl_next::ServerSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsServerHandler<___T: ::fidl_next::Transport> {
    fn client_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::RequestBuffer<___T, with_protocol_ends::ClientEnds>,

        responder: ::fidl_next::Responder<with_protocol_ends::ClientEnds>,
    );

    fn server_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::RequestBuffer<___T, with_protocol_ends::ServerEnds>,

        responder: ::fidl_next::Responder<with_protocol_ends::ServerEnds>,
    );

    fn struct_containing_ends(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::RequestBuffer<___T, with_protocol_ends::StructContainingEnds>,

        responder: ::fidl_next::Responder<with_protocol_ends::StructContainingEnds>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::Transport,
    ___H: WithProtocolEndsServerHandler<___T>,

    crate::WireWithProtocolEndsClientEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireWithProtocolEndsServerEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireWithProtocolEndsStructContainingEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5870448041025163330 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.client_ends(sender, buffer, responder);
            }

            8115535094437022259 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.server_ends(sender, buffer, responder);
            }

            4076866772260025813 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.struct_containing_ends(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `AnotherDiscoverableProtocol`
    /// protocol.
    pub type AnotherDiscoverableProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::AnotherDiscoverableProtocol,
    >;

    impl ::fidl_next::TakeFrom<crate::AnotherDiscoverableProtocol>
        for ::fidl_test_protocols::AnotherDiscoverableProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::AnotherDiscoverableProtocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireChannelProtocolMethodARequest>
        for ::fidl_test_protocols::ChannelProtocolMethodARequest
    {
        #[inline]
        fn take_from(from: &crate::WireChannelProtocolMethodARequest) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireChannelProtocolEventARequest>
        for ::fidl_test_protocols::ChannelProtocolEventARequest
    {
        #[inline]
        fn take_from(from: &crate::WireChannelProtocolEventARequest) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireChannelProtocolMethodBRequest>
        for ::fidl_test_protocols::ChannelProtocolMethodBRequest
    {
        #[inline]
        fn take_from(from: &crate::WireChannelProtocolMethodBRequest) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireChannelProtocolMethodBResponse>
        for ::fidl_test_protocols::ChannelProtocolMethodBResponse
    {
        #[inline]
        fn take_from(from: &crate::WireChannelProtocolMethodBResponse) -> Self {
            Self { result: ::fidl_next::TakeFrom::take_from(&from.result) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireChannelProtocolTakeHandleRequest>
        for ::fidl_test_protocols::ChannelProtocolTakeHandleRequest
    {
        #[inline]
        fn take_from(from: &crate::WireChannelProtocolTakeHandleRequest) -> Self {
            Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireChannelProtocolMutateSocketRequest>
        for ::fidl_test_protocols::ChannelProtocolMutateSocketRequest
    {
        #[inline]
        fn take_from(from: &crate::WireChannelProtocolMutateSocketRequest) -> Self {
            Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireChannelProtocolMutateSocketResponse>
        for ::fidl_test_protocols::ChannelProtocolMutateSocketResponse
    {
        #[inline]
        fn take_from(from: &crate::WireChannelProtocolMutateSocketResponse) -> Self {
            Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ChannelProtocol`
    /// protocol.
    pub type ChannelProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ChannelProtocol>;

    impl ::fidl_next::TakeFrom<crate::ChannelProtocol>
        for ::fidl_test_protocols::ChannelProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::ChannelProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `DiscoverableProtocol`
    /// protocol.
    pub type DiscoverableProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::DiscoverableProtocol>;

    impl ::fidl_next::TakeFrom<crate::DiscoverableProtocol>
        for ::fidl_test_protocols::DiscoverableProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::DiscoverableProtocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireErrorEnum> for ::fidl_test_protocols::ErrorEnum {
        #[inline]
        fn take_from(from: &crate::WireErrorEnum) -> Self {
            match crate::ErrorEnum::from(*from) {
                crate::ErrorEnum::ErrFoo => Self::ErrFoo,

                crate::ErrorEnum::ErrBar => Self::ErrBar,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireHandleRightsProtocolNoResponseMethodRequest>
        for ::fidl_test_protocols::HandleRightsProtocolNoResponseMethodRequest
    {
        #[inline]
        fn take_from(from: &crate::WireHandleRightsProtocolNoResponseMethodRequest) -> Self {
            Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireHandleRightsProtocolResponseMethodRequest>
        for ::fidl_test_protocols::HandleRightsProtocolResponseMethodRequest
    {
        #[inline]
        fn take_from(from: &crate::WireHandleRightsProtocolResponseMethodRequest) -> Self {
            Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireHandleRightsProtocolResponseMethodResponse>
        for ::fidl_test_protocols::HandleRightsProtocolResponseMethodResponse
    {
        #[inline]
        fn take_from(from: &crate::WireHandleRightsProtocolResponseMethodResponse) -> Self {
            Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireHandleRightsProtocolAnEventRequest>
        for ::fidl_test_protocols::HandleRightsProtocolAnEventRequest
    {
        #[inline]
        fn take_from(from: &crate::WireHandleRightsProtocolAnEventRequest) -> Self {
            Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `HandleRightsProtocol`
    /// protocol.
    pub type HandleRightsProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::HandleRightsProtocol>;

    impl ::fidl_next::TakeFrom<crate::HandleRightsProtocol>
        for ::fidl_test_protocols::HandleRightsProtocolMarker
    {
        #[inline]
        fn take_from(from: &crate::HandleRightsProtocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireManyParametersFifteenRequest>
        for ::fidl_test_protocols::ManyParametersFifteenRequest
    {
        #[inline]
        fn take_from(from: &crate::WireManyParametersFifteenRequest) -> Self {
            Self {
                p1: ::fidl_next::TakeFrom::take_from(&from.p1),

                p2: ::fidl_next::TakeFrom::take_from(&from.p2),

                p3: ::fidl_next::TakeFrom::take_from(&from.p3),

                p4: ::fidl_next::TakeFrom::take_from(&from.p4),

                p5: ::fidl_next::TakeFrom::take_from(&from.p5),

                p6: ::fidl_next::TakeFrom::take_from(&from.p6),

                p7: ::fidl_next::TakeFrom::take_from(&from.p7),

                p8: ::fidl_next::TakeFrom::take_from(&from.p8),

                p9: ::fidl_next::TakeFrom::take_from(&from.p9),

                p10: ::fidl_next::TakeFrom::take_from(&from.p10),

                p11: ::fidl_next::TakeFrom::take_from(&from.p11),

                p12: ::fidl_next::TakeFrom::take_from(&from.p12),

                p13: ::fidl_next::TakeFrom::take_from(&from.p13),

                p14: ::fidl_next::TakeFrom::take_from(&from.p14),

                p15: ::fidl_next::TakeFrom::take_from(&from.p15),
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ManyParameters`
    /// protocol.
    pub type ManyParametersProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ManyParameters>;

    impl ::fidl_next::TakeFrom<crate::ManyParameters> for ::fidl_test_protocols::ManyParametersMarker {
        #[inline]
        fn take_from(from: &crate::ManyParameters) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireTheUnion> for ::fidl_test_protocols::TheUnion {
        #[inline]
        fn take_from(from: &crate::WireTheUnion) -> Self {
            match from.as_ref() {
                crate::the_union::Ref::V(value) => Self::V(::fidl_next::TakeFrom::take_from(value)),

                crate::the_union::Ref::UnknownOrdinal_(unknown_ordinal) => {
                    Self::__SourceBreaking { unknown_ordinal }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalTheUnion>
        for Option<Box<::fidl_test_protocols::TheUnion>>
    {
        #[inline]
        fn take_from(from: &crate::WireOptionalTheUnion) -> Self {
            if let Some(inner) = from.as_ref() {
                Some(::fidl_next::TakeFrom::take_from(inner))
            } else {
                None
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireMethodWithUnionUnionMethodRequest>
        for ::fidl_test_protocols::MethodWithUnionUnionMethodRequest
    {
        #[inline]
        fn take_from(from: &crate::WireMethodWithUnionUnionMethodRequest) -> Self {
            Self { u: ::fidl_next::TakeFrom::take_from(&from.u) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireMethodWithUnionUnionMethodResponse>
        for ::fidl_test_protocols::MethodWithUnionUnionMethodResponse
    {
        #[inline]
        fn take_from(from: &crate::WireMethodWithUnionUnionMethodResponse) -> Self {
            Self { u: ::fidl_next::TakeFrom::take_from(&from.u) }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `MethodWithUnion`
    /// protocol.
    pub type MethodWithUnionProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::MethodWithUnion>;

    impl ::fidl_next::TakeFrom<crate::MethodWithUnion>
        for ::fidl_test_protocols::MethodWithUnionMarker
    {
        #[inline]
        fn take_from(from: &crate::MethodWithUnion) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `PlatformServer`
    /// protocol.
    pub type PlatformServerProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::PlatformServer>;

    impl ::fidl_next::TakeFrom<crate::PlatformServer> for ::fidl_test_protocols::PlatformServer_Marker {
        #[inline]
        fn take_from(from: &crate::PlatformServer) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireProtocolEnds> for ::fidl_test_protocols::ProtocolEnds {
        #[inline]
        fn take_from(from: &crate::WireProtocolEnds) -> Self {
            Self {
                client: ::fidl_next::TakeFrom::take_from(&from.client),

                server: ::fidl_next::TakeFrom::take_from(&from.server),

                client_opt: ::fidl_next::TakeFrom::take_from(&from.client_opt),

                server_opt: ::fidl_next::TakeFrom::take_from(&from.server_opt),
            }
        }
    }

    impl
        ::fidl_next::TakeFrom<crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse>
        for ::fidl_test_protocols::WithAndWithoutRequestResponseNoRequestWithResponseResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse,
        ) -> Self {
            Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest>
        for ::fidl_test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest,
        ) -> Self {
            Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
        }
    }

    impl
        ::fidl_next::TakeFrom<
            crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        > for ::fidl_test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        ) -> Self {
            Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
        }
    }

    impl
        ::fidl_next::TakeFrom<
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest,
        > for ::fidl_test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest
    {
        #[inline]
        fn take_from(
            from: &crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest,
        ) -> Self {
            Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
        }
    }

    impl
        ::fidl_next::TakeFrom<
            crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse,
        > for ::fidl_test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseResponse
    {
        #[inline]
        fn take_from(
            from: &crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse,
        ) -> Self {
            Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithAndWithoutRequestResponseOnWithResponseRequest>
        for ::fidl_test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
    {
        #[inline]
        fn take_from(from: &crate::WireWithAndWithoutRequestResponseOnWithResponseRequest) -> Self {
            Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithAndWithoutRequestResponse`
    /// protocol.
    pub type WithAndWithoutRequestResponseProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::WithAndWithoutRequestResponse,
    >;

    impl ::fidl_next::TakeFrom<crate::WithAndWithoutRequestResponse>
        for ::fidl_test_protocols::WithAndWithoutRequestResponseMarker
    {
        #[inline]
        fn take_from(from: &crate::WithAndWithoutRequestResponse) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithErrorSyntaxResponseAsStructResponse>
        for ::fidl_test_protocols::WithErrorSyntaxResponseAsStructResponse
    {
        #[inline]
        fn take_from(from: &crate::WireWithErrorSyntaxResponseAsStructResponse) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),

                c: ::fidl_next::TakeFrom::take_from(&from.c),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithErrorSyntaxHandleInResultResponse>
        for ::fidl_test_protocols::WithErrorSyntaxHandleInResultResponse
    {
        #[inline]
        fn take_from(from: &crate::WireWithErrorSyntaxHandleInResultResponse) -> Self {
            Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithErrorSyntax`
    /// protocol.
    pub type WithErrorSyntaxProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::WithErrorSyntax>;

    impl ::fidl_next::TakeFrom<crate::WithErrorSyntax>
        for ::fidl_test_protocols::WithErrorSyntaxMarker
    {
        #[inline]
        fn take_from(from: &crate::WithErrorSyntax) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithProtocolEndsClientEndsRequest>
        for ::fidl_test_protocols::WithProtocolEndsClientEndsRequest
    {
        #[inline]
        fn take_from(from: &crate::WireWithProtocolEndsClientEndsRequest) -> Self {
            Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithProtocolEndsClientEndsResponse>
        for ::fidl_test_protocols::WithProtocolEndsClientEndsResponse
    {
        #[inline]
        fn take_from(from: &crate::WireWithProtocolEndsClientEndsResponse) -> Self {
            Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithProtocolEndsServerEndsRequest>
        for ::fidl_test_protocols::WithProtocolEndsServerEndsRequest
    {
        #[inline]
        fn take_from(from: &crate::WireWithProtocolEndsServerEndsRequest) -> Self {
            Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithProtocolEndsServerEndsResponse>
        for ::fidl_test_protocols::WithProtocolEndsServerEndsResponse
    {
        #[inline]
        fn take_from(from: &crate::WireWithProtocolEndsServerEndsResponse) -> Self {
            Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithProtocolEndsStructContainingEndsRequest>
        for ::fidl_test_protocols::WithProtocolEndsStructContainingEndsRequest
    {
        #[inline]
        fn take_from(from: &crate::WireWithProtocolEndsStructContainingEndsRequest) -> Self {
            Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireWithProtocolEndsStructContainingEndsResponse>
        for ::fidl_test_protocols::WithProtocolEndsStructContainingEndsResponse
    {
        #[inline]
        fn take_from(from: &crate::WireWithProtocolEndsStructContainingEndsResponse) -> Self {
            Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `WithProtocolEnds`
    /// protocol.
    pub type WithProtocolEndsProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::WithProtocolEnds>;

    impl ::fidl_next::TakeFrom<crate::WithProtocolEnds>
        for ::fidl_test_protocols::WithProtocolEndsMarker
    {
        #[inline]
        fn take_from(from: &crate::WithProtocolEnds) -> Self {
            Self
        }
    }
}
