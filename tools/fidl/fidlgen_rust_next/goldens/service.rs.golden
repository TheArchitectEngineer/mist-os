// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the EmptyService service.
#[derive(Debug)]
pub struct EmptyService;

/// A helper trait for instances of the `EmptyService` service.
pub trait EmptyServiceInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;
}

impl<___I> EmptyServiceInstance for ::fidl_next::ServiceInstance<___I, EmptyService>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;
}

/// The type corresponding to the FirstProtocol protocol.
#[derive(Debug)]
pub struct FirstProtocol;

pub mod first_protocol {
    pub mod prelude {
        pub use crate::{
            first_protocol, FirstProtocol, FirstProtocolClientHandler, FirstProtocolClientSender,
            FirstProtocolServerHandler, FirstProtocolServerSender,
        };
    }

    pub struct MethodOnFirst;

    impl ::fidl_next::Method for MethodOnFirst {
        const ORDINAL: u64 = 6352548393671797041;

        type Protocol = crate::FirstProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `FirstProtocol` client sender.
pub trait FirstProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn method_on_first(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> FirstProtocolClientSender for ::fidl_next::ClientSender<___T, FirstProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn method_on_first(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(6352548393671797041, &mut ())
    }
}

/// A client handler for the FirstProtocol protocol.
///
/// See [`FirstProtocol`] for more details.
pub trait FirstProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for FirstProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: FirstProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `FirstProtocol` server sender.
pub trait FirstProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> FirstProtocolServerSender for ::fidl_next::ServerSender<___T, FirstProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the FirstProtocol protocol.
///
/// See [`FirstProtocol`] for more details.
pub trait FirstProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method_on_first(&mut self, sender: &::fidl_next::ServerSender<___T, FirstProtocol>);
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for FirstProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: FirstProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6352548393671797041 => {
                handler.method_on_first(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the MultiHeterogeneousMemberService service.
#[derive(Debug)]
pub struct MultiHeterogeneousMemberService;

/// A helper trait for instances of the `MultiHeterogeneousMemberService` service.
pub trait MultiHeterogeneousMemberServiceInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;

    /// Attempts to connect to the `first_member` member.
    fn first_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    >;

    /// Attempts to connect to the `second_member` member.
    fn second_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::SecondProtocol>,
        >,
        Self::Error,
    >;
}

impl<___I> MultiHeterogeneousMemberServiceInstance
    for ::fidl_next::ServiceInstance<___I, MultiHeterogeneousMemberService>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;

    fn first_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    > {
        self.as_untyped_mut().connect("first_member").map(::fidl_next::ClientEnd::from_untyped)
    }

    fn second_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::SecondProtocol>,
        >,
        Self::Error,
    > {
        self.as_untyped_mut().connect("second_member").map(::fidl_next::ClientEnd::from_untyped)
    }
}

/// The type corresponding to the MultiHomogeneousMemberService service.
#[derive(Debug)]
pub struct MultiHomogeneousMemberService;

/// A helper trait for instances of the `MultiHomogeneousMemberService` service.
pub trait MultiHomogeneousMemberServiceInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;

    /// Attempts to connect to the `first_member` member.
    fn first_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    >;

    /// Attempts to connect to the `second_member` member.
    fn second_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    >;
}

impl<___I> MultiHomogeneousMemberServiceInstance
    for ::fidl_next::ServiceInstance<___I, MultiHomogeneousMemberService>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;

    fn first_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    > {
        self.as_untyped_mut().connect("first_member").map(::fidl_next::ClientEnd::from_untyped)
    }

    fn second_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    > {
        self.as_untyped_mut().connect("second_member").map(::fidl_next::ClientEnd::from_untyped)
    }
}

/// The type corresponding to the SecondProtocol protocol.
#[derive(Debug)]
pub struct SecondProtocol;

pub mod second_protocol {
    pub mod prelude {
        pub use crate::{
            second_protocol, SecondProtocol, SecondProtocolClientHandler,
            SecondProtocolClientSender, SecondProtocolServerHandler, SecondProtocolServerSender,
        };
    }

    pub struct MethodOnSecond;

    impl ::fidl_next::Method for MethodOnSecond {
        const ORDINAL: u64 = 8121179205110225988;

        type Protocol = crate::SecondProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `SecondProtocol` client sender.
pub trait SecondProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn method_on_second(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> SecondProtocolClientSender for ::fidl_next::ClientSender<___T, SecondProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn method_on_second(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(8121179205110225988, &mut ())
    }
}

/// A client handler for the SecondProtocol protocol.
///
/// See [`SecondProtocol`] for more details.
pub trait SecondProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for SecondProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SecondProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SecondProtocol` server sender.
pub trait SecondProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> SecondProtocolServerSender for ::fidl_next::ServerSender<___T, SecondProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the SecondProtocol protocol.
///
/// See [`SecondProtocol`] for more details.
pub trait SecondProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn method_on_second(&mut self, sender: &::fidl_next::ServerSender<___T, SecondProtocol>);
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for SecondProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: SecondProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            8121179205110225988 => {
                handler.method_on_second(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the SingleMemberService service.
#[derive(Debug)]
pub struct SingleMemberService;

/// A helper trait for instances of the `SingleMemberService` service.
pub trait SingleMemberServiceInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;

    /// Attempts to connect to the `single_member` member.
    fn single_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    >;
}

impl<___I> SingleMemberServiceInstance for ::fidl_next::ServiceInstance<___I, SingleMemberService>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;

    fn single_member(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>,
        >,
        Self::Error,
    > {
        self.as_untyped_mut().connect("single_member").map(::fidl_next::ClientEnd::from_untyped)
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `FirstProtocol`
    /// protocol.
    pub type FirstProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::FirstProtocol>;

    impl ::fidl_next::TakeFrom<crate::FirstProtocol> for ::fidl_test_service::FirstProtocolMarker {
        #[inline]
        fn take_from(from: &crate::FirstProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `SecondProtocol`
    /// protocol.
    pub type SecondProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::SecondProtocol>;

    impl ::fidl_next::TakeFrom<crate::SecondProtocol> for ::fidl_test_service::SecondProtocolMarker {
        #[inline]
        fn take_from(from: &crate::SecondProtocol) -> Self {
            Self
        }
    }
}
