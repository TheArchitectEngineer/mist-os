// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const BOOL: bool = true;

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const B = 8;

    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded = WireBits;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::FromWire<WireBits> for Bits {
    #[inline]
    fn from_wire(wire: WireBits) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireBits> for Bits {
    #[inline]
    fn from_wire_ref(wire: &WireBits) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireBits {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !Bits::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: Bits::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

pub const UINT32: u32 = 4;

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsType: u32 {
        const VALUE = 1;
        const SECOND_VALUE = 4;
        const THIRD_VALUE = 2;

    }
}

impl ::fidl_next::Encodable for BitsType {
    type Encoded = WireBitsType;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for BitsType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for BitsType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsType { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBitsType> for BitsType {
    fn from(wire: WireBitsType) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::FromWire<WireBitsType> for BitsType {
    #[inline]
    fn from_wire(wire: WireBitsType) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireBitsType> for BitsType {
    #[inline]
    fn from_wire_ref(wire: &WireBitsType) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`BitsType`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsType {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireBitsType {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !BitsType::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: BitsType::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<BitsType> for WireBitsType {
    fn from(natural: BitsType) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Enum {
    E = 170,
}

impl ::fidl_next::Encodable for Enum {
    type Encoded = WireEnum;
}
impl ::std::convert::TryFrom<u32> for Enum {
    type Error = ::fidl_next::UnknownStrictEnumMemberError;
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            170 => Ok(Self::E),

            _ => Err(Self::Error::new(value.into())),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::E => 170,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            170 => Self::E,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWire<WireEnum> for Enum {
    #[inline]
    fn from_wire(wire: WireEnum) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireEnum> for Enum {
    #[inline]
    fn from_wire_ref(wire: &WireEnum) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireEnum {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnum {
    pub const E: WireEnum = WireEnum { value: ::fidl_next::WireU32(170) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            170 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::E => WireEnum::E,
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(i32)]
pub enum EnumType {
    Value = 3,
    SecondValue = 4,
}

impl ::fidl_next::Encodable for EnumType {
    type Encoded = WireEnumType;
}
impl ::std::convert::TryFrom<i32> for EnumType {
    type Error = ::fidl_next::UnknownStrictEnumMemberError;
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        match value {
            3 => Ok(Self::Value),
            4 => Ok(Self::SecondValue),

            _ => Err(Self::Error::new(value.into())),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for EnumType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for EnumType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnumType { value } = out);
        let _ = value.write(::fidl_next::WireI32::from(match *self {
            Self::Value => 3,

            Self::SecondValue => 4,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnumType> for EnumType {
    fn from(wire: WireEnumType) -> Self {
        match i32::from(wire.value) {
            3 => Self::Value,

            4 => Self::SecondValue,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWire<WireEnumType> for EnumType {
    #[inline]
    fn from_wire(wire: WireEnumType) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireEnumType> for EnumType {
    #[inline]
    fn from_wire_ref(wire: &WireEnumType) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`EnumType`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnumType {
    value: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireEnumType {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnumType {
    pub const VALUE: WireEnumType = WireEnumType { value: ::fidl_next::WireI32(3) };

    pub const SECOND_VALUE: WireEnumType = WireEnumType { value: ::fidl_next::WireI32(4) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnumType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match i32::from(*value) {
            3 | 4 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<EnumType> for WireEnumType {
    fn from(natural: EnumType) -> Self {
        match natural {
            EnumType::Value => WireEnumType::VALUE,

            EnumType::SecondValue => WireEnumType::SECOND_VALUE,
        }
    }
}

pub const FLOAT32: f32 = 3.14159;

pub const FLOAT64: f64 = 3.14159;

pub const INT16: i16 = 4;

pub const INT32: i32 = 4;

pub const INT64: i64 = 4;

pub const INT8: i8 = 4;

pub const STRING: &str = "string";

#[derive(Clone, Debug)]
pub struct Struct {
    pub int64_with_default: i64,

    pub string_with_default: String,

    pub bool_with_default: bool,

    pub enum_with_default: crate::Enum,

    pub bits_with_default: crate::Bits,
}

impl ::fidl_next::Encodable for Struct {
    type Encoded = WireStruct<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                int64_with_default,
                string_with_default,
                bool_with_default,
                enum_with_default,
                bits_with_default,

            } = out;
        }

        ::fidl_next::Encode::encode(self.int64_with_default, encoder, int64_with_default)?;

        ::fidl_next::Encode::encode(self.string_with_default, encoder, string_with_default)?;

        ::fidl_next::Encode::encode(self.bool_with_default, encoder, bool_with_default)?;

        ::fidl_next::Encode::encode(self.enum_with_default, encoder, enum_with_default)?;

        ::fidl_next::Encode::encode(self.bits_with_default, encoder, bits_with_default)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                int64_with_default,
                string_with_default,
                bool_with_default,
                enum_with_default,
                bits_with_default,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.int64_with_default, encoder, int64_with_default)?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.string_with_default,
            encoder,
            string_with_default,
        )?;

        ::fidl_next::EncodeRef::encode_ref(&self.bool_with_default, encoder, bool_with_default)?;

        ::fidl_next::EncodeRef::encode_ref(&self.enum_with_default, encoder, enum_with_default)?;

        ::fidl_next::EncodeRef::encode_ref(&self.bits_with_default, encoder, bits_with_default)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Struct {
    type EncodedOption = ::fidl_next::WireBox<'static, WireStruct<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Struct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Struct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireStruct<'de>> for Struct {
    #[inline]
    fn from_wire(wire: WireStruct<'de>) -> Self {
        Self {
            int64_with_default: ::fidl_next::FromWire::from_wire(wire.int64_with_default),

            string_with_default: ::fidl_next::FromWire::from_wire(wire.string_with_default),

            bool_with_default: ::fidl_next::FromWire::from_wire(wire.bool_with_default),

            enum_with_default: ::fidl_next::FromWire::from_wire(wire.enum_with_default),

            bits_with_default: ::fidl_next::FromWire::from_wire(wire.bits_with_default),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireStruct<'de>> for Struct {
    #[inline]
    fn from_wire_ref(wire: &WireStruct<'de>) -> Self {
        Self {
            int64_with_default: ::fidl_next::FromWireRef::from_wire_ref(&wire.int64_with_default),

            string_with_default: ::fidl_next::FromWireRef::from_wire_ref(&wire.string_with_default),

            bool_with_default: ::fidl_next::FromWireRef::from_wire_ref(&wire.bool_with_default),

            enum_with_default: ::fidl_next::FromWireRef::from_wire_ref(&wire.enum_with_default),

            bits_with_default: ::fidl_next::FromWireRef::from_wire_ref(&wire.bits_with_default),
        }
    }
}

/// The wire type corresponding to [`Struct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireStruct<'de> {
    pub int64_with_default: ::fidl_next::WireI64,

    pub string_with_default: ::fidl_next::WireString<'de>,

    pub bool_with_default: bool,

    pub enum_with_default: crate::WireEnum,

    pub bits_with_default: crate::WireBits,
}

unsafe impl ::fidl_next::Wire for WireStruct<'static> {
    type Decoded<'de> = WireStruct<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(25).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut int64_with_default,
                mut string_with_default,
                mut bool_with_default,
                mut enum_with_default,
                mut bits_with_default,

            } = slot;
        }

        ::fidl_next::Decode::decode(int64_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(string_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(bool_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(enum_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(bits_with_default.as_mut(), decoder)?;

        Ok(())
    }
}

pub const UINT16: u16 = 4;

pub const UINT64: u64 = 4;

pub const UINT8: u8 = 4;

pub const BITS_PRIMITIVE_VAL: u32 = 1;

pub const BITS_VAL: crate::BitsType = crate::BitsType::VALUE;

pub const ENUM_PRIMITIVE_VAL: i32 = 3;

pub const ENUM_VAL: crate::EnumType = crate::EnumType::Value;

pub const OR_RESULT: crate::BitsType = crate::BitsType::from_bits_retain(7);

pub const OR_RESULT_PRIMITIVE_VAL: u32 = 5;

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::core::convert::From<crate::Bits> for ::fidl_test_constants::Bits {
        #[inline]
        fn from(from: crate::Bits) -> Self {
            Self::from_bits_retain(from.bits())
        }
    }

    impl ::core::convert::From<crate::BitsType> for ::fidl_test_constants::BitsType {
        #[inline]
        fn from(from: crate::BitsType) -> Self {
            Self::from_bits_retain(from.bits())
        }
    }

    impl ::core::convert::From<crate::Enum> for ::fidl_test_constants::Enum {
        #[inline]
        fn from(from: crate::Enum) -> Self {
            match crate::Enum::from(from) {
                crate::Enum::E => Self::E,
            }
        }
    }

    impl ::core::convert::From<crate::EnumType> for ::fidl_test_constants::EnumType {
        #[inline]
        fn from(from: crate::EnumType) -> Self {
            match crate::EnumType::from(from) {
                crate::EnumType::Value => Self::Value,

                crate::EnumType::SecondValue => Self::SecondValue,
            }
        }
    }
}
