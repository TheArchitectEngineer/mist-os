// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const ALL_BINDINGS: u32 = 0;

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding4 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding4;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding4
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding4> {
    type EncodedOption = ::fidl_next::WireBox<WireShouldNeverAppearInAnyBinding4>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding4>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding4: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding4> for ShouldNeverAppearInAnyBinding4 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding4) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`ShouldNeverAppearInAnyBinding4`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding4
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding5 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding5 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding5 {
    type Encoded = WireShouldNeverAppearInAnyBinding5;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding5
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding5 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(
                            a,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding5> for ShouldNeverAppearInAnyBinding5 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding5) -> Self {
        Self { a: from.a().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding5`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding5 {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding5
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireShouldNeverAppearInAnyBinding5 {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding5").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding6 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding6 {
    type Encoded = WireShouldNeverAppearInAnyBinding6;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding6 { raw } = slot);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding6> {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding6;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding6>
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding6: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding6 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding6> for ShouldNeverAppearInAnyBinding6 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding6) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding6>
    for Option<Box<ShouldNeverAppearInAnyBinding6>>
{
    #[inline]
    fn take_from(from: &WireOptionalShouldNeverAppearInAnyBinding6) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding6`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding6 {
    raw: ::fidl_next::RawWireUnion,
}

pub mod should_never_appear_in_any_binding6 {
    pub enum Ref<'union> {
        A(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding6 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding6::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding6::Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::should_never_appear_in_any_binding6::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding6 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding6 {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalShouldNeverAppearInAnyBinding6 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding6> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding6 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding6 {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct AllowedDeniedResponse {
    pub should_never_appear_in_any_binding_4: crate::ShouldNeverAppearInAnyBinding4,

    pub should_never_appear_in_any_binding_5: crate::ShouldNeverAppearInAnyBinding5,

    pub should_never_appear_in_any_binding_6: crate::ShouldNeverAppearInAnyBinding6,
}

impl ::fidl_next::Encodable for AllowedDeniedResponse {
    type Encoded = WireAllowedDeniedResponse;
}

impl<___E> ::fidl_next::Encode<___E> for AllowedDeniedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_4,
                should_never_appear_in_any_binding_5,
                should_never_appear_in_any_binding_6,

            } = slot;
        }

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_4,
            encoder,
            should_never_appear_in_any_binding_4,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_5,
            encoder,
            should_never_appear_in_any_binding_5,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_6,
            encoder,
            should_never_appear_in_any_binding_6,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<AllowedDeniedResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireAllowedDeniedResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<AllowedDeniedResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllowedDeniedResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireAllowedDeniedResponse> for AllowedDeniedResponse {
    #[inline]
    fn take_from(from: &WireAllowedDeniedResponse) -> Self {
        Self {
            should_never_appear_in_any_binding_4: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_4,
            ),

            should_never_appear_in_any_binding_5: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_5,
            ),

            should_never_appear_in_any_binding_6: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_6,
            ),
        }
    }
}

/// The wire type corersponding to [`AllowedDeniedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireAllowedDeniedResponse {
    pub should_never_appear_in_any_binding_4: crate::WireShouldNeverAppearInAnyBinding4,

    pub should_never_appear_in_any_binding_5: crate::WireShouldNeverAppearInAnyBinding5,

    pub should_never_appear_in_any_binding_6: crate::WireShouldNeverAppearInAnyBinding6,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireAllowedDeniedResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_4,
                mut should_never_appear_in_any_binding_5,
                mut should_never_appear_in_any_binding_6,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_6.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum AllowedDeniedResult {
    Response(crate::AllowedDeniedResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for AllowedDeniedResult {
    type Encoded = WireAllowedDeniedResult;
}

impl<___E> ::fidl_next::Encode<___E> for AllowedDeniedResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireAllowedDeniedResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::AllowedDeniedResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<AllowedDeniedResult> {
    type EncodedOption = WireOptionalAllowedDeniedResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<AllowedDeniedResult>
where
    ___E: ?Sized,
    AllowedDeniedResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalAllowedDeniedResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireAllowedDeniedResult> for AllowedDeniedResult {
    #[inline]
    fn take_from(from: &WireAllowedDeniedResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalAllowedDeniedResult> for Option<Box<AllowedDeniedResult>> {
    #[inline]
    fn take_from(from: &WireOptionalAllowedDeniedResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`AllowedDeniedResult`].
#[repr(transparent)]
pub struct WireAllowedDeniedResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod allowed_denied_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireAllowedDeniedResponse),

        Err(&'union ::fidl_next::WireU32),
    }
}

impl WireAllowedDeniedResult {
    pub fn as_ref(&self) -> crate::allowed_denied_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::allowed_denied_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => {
                crate::allowed_denied_result::Ref::Err(unsafe { self.raw.get().deref_unchecked() })
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireAllowedDeniedResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireAllowedDeniedResponse>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireAllowedDeniedResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireAllowedDeniedResponse>().fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalAllowedDeniedResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalAllowedDeniedResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireAllowedDeniedResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalAllowedDeniedResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireAllowedDeniedResponse>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalAllowedDeniedResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the Allowed protocol.
#[derive(Debug)]
pub struct Allowed;

pub mod allowed {

    pub struct Denied;

    impl ::fidl_next::Method for Denied {
        const ORDINAL: u64 = 3826178105137551123;

        type Protocol = crate::Allowed;

        type Request = ();

        type Response = crate::WireAllowedDeniedResult;
    }
}

/// A helper trait for the `Allowed` client sender.
pub trait AllowedClientSender {
    type Transport: ::fidl_next::Transport;

    fn denied(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, allowed::Denied>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> AllowedClientSender for ::fidl_next::ClientSender<___T, Allowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn denied(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, allowed::Denied>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3826178105137551123, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the Allowed protocol.
///
/// See [`Allowed`] for more details.
pub trait AllowedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Allowed
where
    ___T: ::fidl_next::Transport,
    ___H: AllowedClientHandler<___T>,

    crate::WireAllowedDeniedResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Allowed` server sender.
pub trait AllowedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> AllowedServerSender for ::fidl_next::ServerSender<___T, Allowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the Allowed protocol.
///
/// See [`Allowed`] for more details.
pub trait AllowedServerHandler<___T: ::fidl_next::Transport> {
    fn denied(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Allowed>,

        responder: ::fidl_next::Responder<allowed::Denied>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Allowed
where
    ___T: ::fidl_next::Transport,
    ___H: AllowedServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            3826178105137551123 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.denied(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the ContainsAllowed protocol.
#[derive(Debug)]
pub struct ContainsAllowed;

pub mod contains_allowed {}

/// A helper trait for the `ContainsAllowed` client sender.
pub trait ContainsAllowedClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ContainsAllowedClientSender for ::fidl_next::ClientSender<___T, ContainsAllowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the ContainsAllowed protocol.
///
/// See [`ContainsAllowed`] for more details.
pub trait ContainsAllowedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ContainsAllowed
where
    ___T: ::fidl_next::Transport,
    ___H: ContainsAllowedClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ContainsAllowed` server sender.
pub trait ContainsAllowedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ContainsAllowedServerSender for ::fidl_next::ServerSender<___T, ContainsAllowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ContainsAllowed protocol.
///
/// See [`ContainsAllowed`] for more details.
pub trait ContainsAllowedServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ContainsAllowed
where
    ___T: ::fidl_next::Transport,
    ___H: ContainsAllowedServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding1 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding1;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding1
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding1> {
    type EncodedOption = ::fidl_next::WireBox<WireShouldNeverAppearInAnyBinding1>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding1>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding1: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding1> for ShouldNeverAppearInAnyBinding1 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding1) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`ShouldNeverAppearInAnyBinding1`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding1
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding2 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding2 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding2 {
    type Encoded = WireShouldNeverAppearInAnyBinding2;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding2
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding2 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(
                            a,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding2> for ShouldNeverAppearInAnyBinding2 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding2) -> Self {
        Self { a: from.a().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding2`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding2 {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding2
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireShouldNeverAppearInAnyBinding2 {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding2").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding3 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding3 {
    type Encoded = WireShouldNeverAppearInAnyBinding3;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding3
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding3 { raw } = slot);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding3> {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding3;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding3>
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding3: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding3 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding3> for ShouldNeverAppearInAnyBinding3 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding3) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding3>
    for Option<Box<ShouldNeverAppearInAnyBinding3>>
{
    #[inline]
    fn take_from(from: &WireOptionalShouldNeverAppearInAnyBinding3) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding3`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding3 {
    raw: ::fidl_next::RawWireUnion,
}

pub mod should_never_appear_in_any_binding3 {
    pub enum Ref<'union> {
        A(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding3 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding3::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding3::Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::should_never_appear_in_any_binding3::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding3 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding3
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding3 {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalShouldNeverAppearInAnyBinding3 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding3> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding3 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding3 {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding3
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedShouldNeverAppearInAnyBindingRequest {
    pub should_never_appear_in_any_binding_1: crate::ShouldNeverAppearInAnyBinding1,

    pub should_never_appear_in_any_binding_2: crate::ShouldNeverAppearInAnyBinding2,

    pub should_never_appear_in_any_binding_3: crate::ShouldNeverAppearInAnyBinding3,
}

impl ::fidl_next::Encodable for DeniedShouldNeverAppearInAnyBindingRequest {
    type Encoded = WireDeniedShouldNeverAppearInAnyBindingRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DeniedShouldNeverAppearInAnyBindingRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_1,
                should_never_appear_in_any_binding_2,
                should_never_appear_in_any_binding_3,

            } = slot;
        }

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_1,
            encoder,
            should_never_appear_in_any_binding_1,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_2,
            encoder,
            should_never_appear_in_any_binding_2,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_3,
            encoder,
            should_never_appear_in_any_binding_3,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DeniedShouldNeverAppearInAnyBindingRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDeniedShouldNeverAppearInAnyBindingRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DeniedShouldNeverAppearInAnyBindingRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedShouldNeverAppearInAnyBindingRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDeniedShouldNeverAppearInAnyBindingRequest>
    for DeniedShouldNeverAppearInAnyBindingRequest
{
    #[inline]
    fn take_from(from: &WireDeniedShouldNeverAppearInAnyBindingRequest) -> Self {
        Self {
            should_never_appear_in_any_binding_1: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_1,
            ),

            should_never_appear_in_any_binding_2: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_2,
            ),

            should_never_appear_in_any_binding_3: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_3,
            ),
        }
    }
}

/// The wire type corersponding to [`DeniedShouldNeverAppearInAnyBindingRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedShouldNeverAppearInAnyBindingRequest {
    pub should_never_appear_in_any_binding_1: crate::WireShouldNeverAppearInAnyBinding1,

    pub should_never_appear_in_any_binding_2: crate::WireShouldNeverAppearInAnyBinding2,

    pub should_never_appear_in_any_binding_3: crate::WireShouldNeverAppearInAnyBinding3,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDeniedShouldNeverAppearInAnyBindingRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_1,
                mut should_never_appear_in_any_binding_2,
                mut should_never_appear_in_any_binding_3,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_3.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Denied protocol.
#[derive(Debug)]
pub struct Denied;

pub mod denied {

    pub struct ShouldNeverAppearInAnyBinding;

    impl ::fidl_next::Method for ShouldNeverAppearInAnyBinding {
        const ORDINAL: u64 = 5338181991150205725;

        type Protocol = crate::Denied;

        type Request = crate::WireDeniedShouldNeverAppearInAnyBindingRequest;

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `Denied` client sender.
pub trait DeniedClientSender {
    type Transport: ::fidl_next::Transport;

    fn should_never_appear_in_any_binding<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDeniedShouldNeverAppearInAnyBindingRequest,
        >;
}

impl<___T> DeniedClientSender for ::fidl_next::ClientSender<___T, Denied>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn should_never_appear_in_any_binding<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDeniedShouldNeverAppearInAnyBindingRequest,
        >,
    {
        self.as_untyped().send_one_way(5338181991150205725, request)
    }
}

/// A client handler for the Denied protocol.
///
/// See [`Denied`] for more details.
pub trait DeniedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Denied
where
    ___T: ::fidl_next::Transport,
    ___H: DeniedClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Denied` server sender.
pub trait DeniedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DeniedServerSender for ::fidl_next::ServerSender<___T, Denied>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the Denied protocol.
///
/// See [`Denied`] for more details.
pub trait DeniedServerHandler<___T: ::fidl_next::Transport> {
    fn should_never_appear_in_any_binding(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Denied>,

        request: ::fidl_next::RequestBuffer<___T, denied::ShouldNeverAppearInAnyBinding>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Denied
where
    ___T: ::fidl_next::Transport,
    ___H: DeniedServerHandler<___T>,

    crate::WireDeniedShouldNeverAppearInAnyBindingRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5338181991150205725 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.should_never_appear_in_any_binding(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding7 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding7;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding7
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding7> {
    type EncodedOption = ::fidl_next::WireBox<WireShouldNeverAppearInAnyBinding7>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding7>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding7: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding7> for ShouldNeverAppearInAnyBinding7 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding7) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`ShouldNeverAppearInAnyBinding7`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding7
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ShouldNeverAppearInAnyBinding8 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding8 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding8 {
    type Encoded = WireShouldNeverAppearInAnyBinding8;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding8
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding8 { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(
                            a,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding8> for ShouldNeverAppearInAnyBinding8 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding8) -> Self {
        Self { a: from.a().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding8`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding8 {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding8
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireShouldNeverAppearInAnyBinding8 {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding8").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding9 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding9 {
    type Encoded = WireShouldNeverAppearInAnyBinding9;
}

impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding9
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding9 { raw } = slot);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding9> {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding9;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding9>
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding9: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding9 { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding9> for ShouldNeverAppearInAnyBinding9 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding9) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding9>
    for Option<Box<ShouldNeverAppearInAnyBinding9>>
{
    #[inline]
    fn take_from(from: &WireOptionalShouldNeverAppearInAnyBinding9) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding9`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding9 {
    raw: ::fidl_next::RawWireUnion,
}

pub mod should_never_appear_in_any_binding9 {
    pub enum Ref<'union> {
        A(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding9 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding9::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding9::Ref::A(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::should_never_appear_in_any_binding9::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding9 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding9
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding9 {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalShouldNeverAppearInAnyBinding9 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding9> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding9 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding9 {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding9
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedAnonymous {
    pub should_never_appear_in_any_binding_7: crate::ShouldNeverAppearInAnyBinding7,

    pub should_never_appear_in_any_binding_8: crate::ShouldNeverAppearInAnyBinding8,

    pub should_never_appear_in_any_binding_9: crate::ShouldNeverAppearInAnyBinding9,
}

impl ::fidl_next::Encodable for DeniedAnonymous {
    type Encoded = WireDeniedAnonymous;
}

impl<___E> ::fidl_next::Encode<___E> for DeniedAnonymous
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_7,
                should_never_appear_in_any_binding_8,
                should_never_appear_in_any_binding_9,

            } = slot;
        }

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_7,
            encoder,
            should_never_appear_in_any_binding_7,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_8,
            encoder,
            should_never_appear_in_any_binding_8,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_9,
            encoder,
            should_never_appear_in_any_binding_9,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DeniedAnonymous> {
    type EncodedOption = ::fidl_next::WireBox<WireDeniedAnonymous>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DeniedAnonymous>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedAnonymous: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDeniedAnonymous> for DeniedAnonymous {
    #[inline]
    fn take_from(from: &WireDeniedAnonymous) -> Self {
        Self {
            should_never_appear_in_any_binding_7: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_7,
            ),

            should_never_appear_in_any_binding_8: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_8,
            ),

            should_never_appear_in_any_binding_9: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_9,
            ),
        }
    }
}

/// The wire type corersponding to [`DeniedAnonymous`].
#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedAnonymous {
    pub should_never_appear_in_any_binding_7: crate::WireShouldNeverAppearInAnyBinding7,

    pub should_never_appear_in_any_binding_8: crate::WireShouldNeverAppearInAnyBinding8,

    pub should_never_appear_in_any_binding_9: crate::WireShouldNeverAppearInAnyBinding9,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDeniedAnonymous
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_7,
                mut should_never_appear_in_any_binding_8,
                mut should_never_appear_in_any_binding_9,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_9.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyCppRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyCppRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyCppRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyCppRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyCppRequest>
    for DenyEachBindingOnlyDenyCppRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyCppRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyCppRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyCppResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyCppResponse;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyCppResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyCppResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyCppResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyCppResponse>
    for DenyEachBindingOnlyDenyCppResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyCppResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyCppResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum DenyEachBindingOnlyDenyCppResult {
    Response(crate::DenyEachBindingOnlyDenyCppResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppResult {
    type Encoded = WireDenyEachBindingOnlyDenyCppResult;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBindingOnlyDenyCppResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::DenyEachBindingOnlyDenyCppResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyCppResult> {
    type EncodedOption = WireOptionalDenyEachBindingOnlyDenyCppResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyCppResult>
where
    ___E: ?Sized,
    DenyEachBindingOnlyDenyCppResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBindingOnlyDenyCppResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyCppResult>
    for DenyEachBindingOnlyDenyCppResult
{
    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyCppResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalDenyEachBindingOnlyDenyCppResult>
    for Option<Box<DenyEachBindingOnlyDenyCppResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalDenyEachBindingOnlyDenyCppResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyCppResult`].
#[repr(transparent)]
pub struct WireDenyEachBindingOnlyDenyCppResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod deny_each_binding_only_deny_cpp_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireDenyEachBindingOnlyDenyCppResponse),

        Err(&'union ::fidl_next::WireU32),
    }
}

impl WireDenyEachBindingOnlyDenyCppResult {
    pub fn as_ref(&self) -> crate::deny_each_binding_only_deny_cpp_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::deny_each_binding_only_deny_cpp_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::deny_each_binding_only_deny_cpp_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireDenyEachBindingOnlyDenyCppResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyCppResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyCppResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireDenyEachBindingOnlyDenyCppResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBindingOnlyDenyCppResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBindingOnlyDenyCppResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalDenyEachBindingOnlyDenyCppResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBindingOnlyDenyCppResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalDenyEachBindingOnlyDenyCppResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalDenyEachBindingOnlyDenyCppResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyCppResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalDenyEachBindingOnlyDenyCppResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyCppResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalDenyEachBindingOnlyDenyCppResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyDartRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyDartRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyDartRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyDartRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyDartRequest>
    for DenyEachBindingOnlyDenyDartRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyDartRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyDartRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyDartResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyDartResponse;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyDartResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyDartResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyDartResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyDartResponse>
    for DenyEachBindingOnlyDenyDartResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyDartResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyDartResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum DenyEachBindingOnlyDenyDartResult {
    Response(crate::DenyEachBindingOnlyDenyDartResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartResult {
    type Encoded = WireDenyEachBindingOnlyDenyDartResult;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBindingOnlyDenyDartResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::DenyEachBindingOnlyDenyDartResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyDartResult> {
    type EncodedOption = WireOptionalDenyEachBindingOnlyDenyDartResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyDartResult>
where
    ___E: ?Sized,
    DenyEachBindingOnlyDenyDartResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBindingOnlyDenyDartResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyDartResult>
    for DenyEachBindingOnlyDenyDartResult
{
    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyDartResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalDenyEachBindingOnlyDenyDartResult>
    for Option<Box<DenyEachBindingOnlyDenyDartResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalDenyEachBindingOnlyDenyDartResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyDartResult`].
#[repr(transparent)]
pub struct WireDenyEachBindingOnlyDenyDartResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod deny_each_binding_only_deny_dart_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireDenyEachBindingOnlyDenyDartResponse),

        Err(&'union ::fidl_next::WireU32),
    }
}

impl WireDenyEachBindingOnlyDenyDartResult {
    pub fn as_ref(&self) -> crate::deny_each_binding_only_deny_dart_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::deny_each_binding_only_deny_dart_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::deny_each_binding_only_deny_dart_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireDenyEachBindingOnlyDenyDartResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyDartResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyDartResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireDenyEachBindingOnlyDenyDartResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBindingOnlyDenyDartResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBindingOnlyDenyDartResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalDenyEachBindingOnlyDenyDartResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBindingOnlyDenyDartResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalDenyEachBindingOnlyDenyDartResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalDenyEachBindingOnlyDenyDartResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyDartResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalDenyEachBindingOnlyDenyDartResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyDartResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalDenyEachBindingOnlyDenyDartResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyGoRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyGoRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyGoRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyGoRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyGoRequest>
    for DenyEachBindingOnlyDenyGoRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyGoRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyGoRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyGoResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyGoResponse;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyGoResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyGoResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyGoResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyGoResponse>
    for DenyEachBindingOnlyDenyGoResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyGoResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyGoResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum DenyEachBindingOnlyDenyGoResult {
    Response(crate::DenyEachBindingOnlyDenyGoResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoResult {
    type Encoded = WireDenyEachBindingOnlyDenyGoResult;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBindingOnlyDenyGoResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::DenyEachBindingOnlyDenyGoResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyGoResult> {
    type EncodedOption = WireOptionalDenyEachBindingOnlyDenyGoResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyGoResult>
where
    ___E: ?Sized,
    DenyEachBindingOnlyDenyGoResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBindingOnlyDenyGoResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyGoResult>
    for DenyEachBindingOnlyDenyGoResult
{
    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyGoResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalDenyEachBindingOnlyDenyGoResult>
    for Option<Box<DenyEachBindingOnlyDenyGoResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalDenyEachBindingOnlyDenyGoResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyGoResult`].
#[repr(transparent)]
pub struct WireDenyEachBindingOnlyDenyGoResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod deny_each_binding_only_deny_go_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireDenyEachBindingOnlyDenyGoResponse),

        Err(&'union ::fidl_next::WireU32),
    }
}

impl WireDenyEachBindingOnlyDenyGoResult {
    pub fn as_ref(&self) -> crate::deny_each_binding_only_deny_go_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::deny_each_binding_only_deny_go_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::deny_each_binding_only_deny_go_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireDenyEachBindingOnlyDenyGoResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyGoResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyGoResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireDenyEachBindingOnlyDenyGoResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBindingOnlyDenyGoResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBindingOnlyDenyGoResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalDenyEachBindingOnlyDenyGoResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBindingOnlyDenyGoResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalDenyEachBindingOnlyDenyGoResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalDenyEachBindingOnlyDenyGoResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyGoResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalDenyEachBindingOnlyDenyGoResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyGoResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalDenyEachBindingOnlyDenyGoResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyLibfuzzerRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyLibfuzzerRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyLibfuzzerRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyLibfuzzerRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyLibfuzzerRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyLibfuzzerRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyLibfuzzerRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyLibfuzzerRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyLibfuzzerRequest>
    for DenyEachBindingOnlyDenyLibfuzzerRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyLibfuzzerRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyLibfuzzerRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyLibfuzzerRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyLibfuzzerRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyLibfuzzerResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyLibfuzzerResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyLibfuzzerResponse;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyLibfuzzerResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyLibfuzzerResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyLibfuzzerResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyLibfuzzerResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyLibfuzzerResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyLibfuzzerResponse>
    for DenyEachBindingOnlyDenyLibfuzzerResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyLibfuzzerResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyLibfuzzerResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyLibfuzzerResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyLibfuzzerResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum DenyEachBindingOnlyDenyLibfuzzerResult {
    Response(crate::DenyEachBindingOnlyDenyLibfuzzerResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyLibfuzzerResult {
    type Encoded = WireDenyEachBindingOnlyDenyLibfuzzerResult;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyLibfuzzerResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBindingOnlyDenyLibfuzzerResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::DenyEachBindingOnlyDenyLibfuzzerResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyLibfuzzerResult> {
    type EncodedOption = WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyLibfuzzerResult>
where
    ___E: ?Sized,
    DenyEachBindingOnlyDenyLibfuzzerResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyLibfuzzerResult>
    for DenyEachBindingOnlyDenyLibfuzzerResult
{
    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyLibfuzzerResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult>
    for Option<Box<DenyEachBindingOnlyDenyLibfuzzerResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyLibfuzzerResult`].
#[repr(transparent)]
pub struct WireDenyEachBindingOnlyDenyLibfuzzerResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod deny_each_binding_only_deny_libfuzzer_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireDenyEachBindingOnlyDenyLibfuzzerResponse),

        Err(&'union ::fidl_next::WireU32),
    }
}

impl WireDenyEachBindingOnlyDenyLibfuzzerResult {
    pub fn as_ref(&self) -> crate::deny_each_binding_only_deny_libfuzzer_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::deny_each_binding_only_deny_libfuzzer_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::deny_each_binding_only_deny_libfuzzer_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireDenyEachBindingOnlyDenyLibfuzzerResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw
                        .clone_unchecked::<crate::WireDenyEachBindingOnlyDenyLibfuzzerResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyLibfuzzerResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyLibfuzzerResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireDenyEachBindingOnlyDenyLibfuzzerResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBindingOnlyDenyLibfuzzerResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBindingOnlyDenyLibfuzzerResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw
                        .clone_unchecked::<crate::WireDenyEachBindingOnlyDenyLibfuzzerResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyLibfuzzerResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalDenyEachBindingOnlyDenyLibfuzzerResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyRustRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyRustRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyRustRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyRustRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyRustRequest>
    for DenyEachBindingOnlyDenyRustRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyRustRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyRustRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyRustResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyRustResponse;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyRustResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyRustResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyRustResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyRustResponse>
    for DenyEachBindingOnlyDenyRustResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyRustResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenyRustResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum DenyEachBindingOnlyDenyRustResult {
    Response(crate::DenyEachBindingOnlyDenyRustResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustResult {
    type Encoded = WireDenyEachBindingOnlyDenyRustResult;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBindingOnlyDenyRustResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::DenyEachBindingOnlyDenyRustResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyRustResult> {
    type EncodedOption = WireOptionalDenyEachBindingOnlyDenyRustResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyRustResult>
where
    ___E: ?Sized,
    DenyEachBindingOnlyDenyRustResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBindingOnlyDenyRustResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyRustResult>
    for DenyEachBindingOnlyDenyRustResult
{
    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyRustResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalDenyEachBindingOnlyDenyRustResult>
    for Option<Box<DenyEachBindingOnlyDenyRustResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalDenyEachBindingOnlyDenyRustResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyRustResult`].
#[repr(transparent)]
pub struct WireDenyEachBindingOnlyDenyRustResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod deny_each_binding_only_deny_rust_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireDenyEachBindingOnlyDenyRustResponse),

        Err(&'union ::fidl_next::WireU32),
    }
}

impl WireDenyEachBindingOnlyDenyRustResult {
    pub fn as_ref(&self) -> crate::deny_each_binding_only_deny_rust_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::deny_each_binding_only_deny_rust_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::deny_each_binding_only_deny_rust_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireDenyEachBindingOnlyDenyRustResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyRustResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyRustResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireDenyEachBindingOnlyDenyRustResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBindingOnlyDenyRustResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBindingOnlyDenyRustResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalDenyEachBindingOnlyDenyRustResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBindingOnlyDenyRustResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalDenyEachBindingOnlyDenyRustResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalDenyEachBindingOnlyDenyRustResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireDenyEachBindingOnlyDenyRustResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalDenyEachBindingOnlyDenyRustResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenyRustResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalDenyEachBindingOnlyDenyRustResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenySyzkallerRequest;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenySyzkallerRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenySyzkallerRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenySyzkallerRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenySyzkallerRequest>
    for DenyEachBindingOnlyDenySyzkallerRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenySyzkallerRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenySyzkallerRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenySyzkallerResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenySyzkallerResponse;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenySyzkallerResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenySyzkallerResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenySyzkallerResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenySyzkallerResponse>
    for DenyEachBindingOnlyDenySyzkallerResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenySyzkallerResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corersponding to [`DenyEachBindingOnlyDenySyzkallerResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum DenyEachBindingOnlyDenySyzkallerResult {
    Response(crate::DenyEachBindingOnlyDenySyzkallerResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerResult {
    type Encoded = WireDenyEachBindingOnlyDenySyzkallerResult;
}

impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireDenyEachBindingOnlyDenySyzkallerResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::DenyEachBindingOnlyDenySyzkallerResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenySyzkallerResult> {
    type EncodedOption = WireOptionalDenyEachBindingOnlyDenySyzkallerResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenySyzkallerResult>
where
    ___E: ?Sized,
    DenyEachBindingOnlyDenySyzkallerResult: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalDenyEachBindingOnlyDenySyzkallerResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenySyzkallerResult>
    for DenyEachBindingOnlyDenySyzkallerResult
{
    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenySyzkallerResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalDenyEachBindingOnlyDenySyzkallerResult>
    for Option<Box<DenyEachBindingOnlyDenySyzkallerResult>>
{
    #[inline]
    fn take_from(from: &WireOptionalDenyEachBindingOnlyDenySyzkallerResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenySyzkallerResult`].
#[repr(transparent)]
pub struct WireDenyEachBindingOnlyDenySyzkallerResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod deny_each_binding_only_deny_syzkaller_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireDenyEachBindingOnlyDenySyzkallerResponse),

        Err(&'union ::fidl_next::WireU32),
    }
}

impl WireDenyEachBindingOnlyDenySyzkallerResult {
    pub fn as_ref(&self) -> crate::deny_each_binding_only_deny_syzkaller_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::deny_each_binding_only_deny_syzkaller_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::deny_each_binding_only_deny_syzkaller_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireDenyEachBindingOnlyDenySyzkallerResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw
                        .clone_unchecked::<crate::WireDenyEachBindingOnlyDenySyzkallerResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenySyzkallerResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireDenyEachBindingOnlyDenySyzkallerResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireDenyEachBindingOnlyDenySyzkallerResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalDenyEachBindingOnlyDenySyzkallerResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalDenyEachBindingOnlyDenySyzkallerResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireDenyEachBindingOnlyDenySyzkallerResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalDenyEachBindingOnlyDenySyzkallerResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalDenyEachBindingOnlyDenySyzkallerResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw
                        .clone_unchecked::<crate::WireDenyEachBindingOnlyDenySyzkallerResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalDenyEachBindingOnlyDenySyzkallerResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireDenyEachBindingOnlyDenySyzkallerResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalDenyEachBindingOnlyDenySyzkallerResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the DenyEachBinding protocol.
#[derive(Debug)]
pub struct DenyEachBinding;

pub mod deny_each_binding {

    pub struct OnlyDenyCpp;

    impl ::fidl_next::Method for OnlyDenyCpp {
        const ORDINAL: u64 = 2957648440141224850;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyCppRequest;

        type Response = crate::WireDenyEachBindingOnlyDenyCppResult;
    }

    pub struct OnlyDenyDart;

    impl ::fidl_next::Method for OnlyDenyDart {
        const ORDINAL: u64 = 8446571910689294295;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyDartRequest;

        type Response = crate::WireDenyEachBindingOnlyDenyDartResult;
    }

    pub struct OnlyDenyGo;

    impl ::fidl_next::Method for OnlyDenyGo {
        const ORDINAL: u64 = 7311125300308839833;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyGoRequest;

        type Response = crate::WireDenyEachBindingOnlyDenyGoResult;
    }

    pub struct OnlyDenyLibfuzzer;

    impl ::fidl_next::Method for OnlyDenyLibfuzzer {
        const ORDINAL: u64 = 2184115815603862302;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyLibfuzzerRequest;

        type Response = crate::WireDenyEachBindingOnlyDenyLibfuzzerResult;
    }

    pub struct OnlyDenyRust;

    impl ::fidl_next::Method for OnlyDenyRust {
        const ORDINAL: u64 = 3719805222870932662;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyRustRequest;

        type Response = crate::WireDenyEachBindingOnlyDenyRustResult;
    }

    pub struct OnlyDenySyzkaller;

    impl ::fidl_next::Method for OnlyDenySyzkaller {
        const ORDINAL: u64 = 2319043834522757514;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenySyzkallerRequest;

        type Response = crate::WireDenyEachBindingOnlyDenySyzkallerResult;
    }
}

/// A helper trait for the `DenyEachBinding` client sender.
pub trait DenyEachBindingClientSender {
    type Transport: ::fidl_next::Transport;

    fn only_deny_cpp<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyCpp>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyCppRequest,
        >;

    fn only_deny_dart<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyDart>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyDartRequest,
        >;

    fn only_deny_go<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyGo>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyGoRequest,
        >;

    fn only_deny_libfuzzer<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyLibfuzzer>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyLibfuzzerRequest,
        >;

    fn only_deny_rust<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyRust>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyRustRequest,
        >;

    fn only_deny_syzkaller<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenySyzkaller>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenySyzkallerRequest,
        >;
}

impl<___T> DenyEachBindingClientSender for ::fidl_next::ClientSender<___T, DenyEachBinding>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn only_deny_cpp<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyCpp>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyCppRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2957648440141224850, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_dart<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyDart>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyDartRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8446571910689294295, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_go<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyGo>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyGoRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(7311125300308839833, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_libfuzzer<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyLibfuzzer>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyLibfuzzerRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2184115815603862302, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_rust<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyRust>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyRustRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(3719805222870932662, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_syzkaller<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenySyzkaller>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenySyzkallerRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2319043834522757514, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the DenyEachBinding protocol.
///
/// See [`DenyEachBinding`] for more details.
pub trait DenyEachBindingClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for DenyEachBinding
where
    ___T: ::fidl_next::Transport,
    ___H: DenyEachBindingClientHandler<___T>,

    crate::WireDenyEachBindingOnlyDenyCppResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyDartResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyGoResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyLibfuzzerResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyRustResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenySyzkallerResult:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `DenyEachBinding` server sender.
pub trait DenyEachBindingServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DenyEachBindingServerSender for ::fidl_next::ServerSender<___T, DenyEachBinding>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the DenyEachBinding protocol.
///
/// See [`DenyEachBinding`] for more details.
pub trait DenyEachBindingServerHandler<___T: ::fidl_next::Transport> {
    fn only_deny_cpp(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyCpp>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyCpp>,
    );

    fn only_deny_dart(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyDart>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyDart>,
    );

    fn only_deny_go(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyGo>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyGo>,
    );

    fn only_deny_libfuzzer(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyLibfuzzer>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyLibfuzzer>,
    );

    fn only_deny_rust(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyRust>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyRust>,
    );

    fn only_deny_syzkaller(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenySyzkaller>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenySyzkaller>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for DenyEachBinding
where
    ___T: ::fidl_next::Transport,
    ___H: DenyEachBindingServerHandler<___T>,

    crate::WireDenyEachBindingOnlyDenyCppRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyDartRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyGoRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyLibfuzzerRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyRustRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenySyzkallerRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2957648440141224850 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_cpp(sender, buffer, responder);
            }

            8446571910689294295 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_dart(sender, buffer, responder);
            }

            7311125300308839833 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_go(sender, buffer, responder);
            }

            2184115815603862302 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_libfuzzer(sender, buffer, responder);
            }

            3719805222870932662 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_rust(sender, buffer, responder);
            }

            2319043834522757514 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_syzkaller(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the ImportsSameNameContext protocol.
#[derive(Debug)]
pub struct ImportsSameNameContext;

pub mod imports_same_name_context {

    pub struct AlwaysDenied;

    impl ::fidl_next::Method for AlwaysDenied {
        const ORDINAL: u64 = 6808317417318106526;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest;

        type Response = ::fidl_next::Never;
    }

    pub struct Unattributed;

    impl ::fidl_next::Method for Unattributed {
        const ORDINAL: u64 = 475191379775102607;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct AlwaysAppearsInImportingLibrary;

    impl ::fidl_next::Method for AlwaysAppearsInImportingLibrary {
        const ORDINAL: u64 = 2914965219653596920;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `ImportsSameNameContext` client sender.
pub trait ImportsSameNameContextClientSender {
    type Transport: ::fidl_next::Transport;

    fn always_denied<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest,
        >;

    fn unattributed(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn always_appears_in_importing_library(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> ImportsSameNameContextClientSender
    for ::fidl_next::ClientSender<___T, ImportsSameNameContext>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn always_denied<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest,
        >,
    {
        self.as_untyped().send_one_way(6808317417318106526, request)
    }

    fn unattributed(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(475191379775102607, &mut ())
    }

    fn always_appears_in_importing_library(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(2914965219653596920, &mut ())
    }
}

/// A client handler for the ImportsSameNameContext protocol.
///
/// See [`ImportsSameNameContext`] for more details.
pub trait ImportsSameNameContextClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ImportsSameNameContext
where
    ___T: ::fidl_next::Transport,
    ___H: ImportsSameNameContextClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ImportsSameNameContext` server sender.
pub trait ImportsSameNameContextServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ImportsSameNameContextServerSender
    for ::fidl_next::ServerSender<___T, ImportsSameNameContext>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ImportsSameNameContext protocol.
///
/// See [`ImportsSameNameContext`] for more details.
pub trait ImportsSameNameContextServerHandler<___T: ::fidl_next::Transport> {
    fn always_denied(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>,

        request: ::fidl_next::RequestBuffer<___T, imports_same_name_context::AlwaysDenied>,
    );

    fn unattributed(&mut self, sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>);

    fn always_appears_in_importing_library(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ImportsSameNameContext
where
    ___T: ::fidl_next::Transport,
    ___H: ImportsSameNameContextServerHandler<___T>,

    ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6808317417318106526 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.always_denied(sender, buffer);
            }

            475191379775102607 => {
                handler.unattributed(sender);
            }

            2914965219653596920 => {
                handler.always_appears_in_importing_library(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

impl ::fidl_next::Encodable for MemberOnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireMemberOnlyAppearsInImportingLibrary;
}

impl<___E> ::fidl_next::Encode<___E> for MemberOnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MemberOnlyAppearsInImportingLibrary> {
    type EncodedOption = ::fidl_next::WireBox<WireMemberOnlyAppearsInImportingLibrary>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<MemberOnlyAppearsInImportingLibrary>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MemberOnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMemberOnlyAppearsInImportingLibrary>
    for MemberOnlyAppearsInImportingLibrary
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireMemberOnlyAppearsInImportingLibrary) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`MemberOnlyAppearsInImportingLibrary`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMemberOnlyAppearsInImportingLibrary
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct OnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::MemberOnlyAppearsInImportingLibrary,
}

impl ::fidl_next::Encodable for OnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::MemberOnlyAppearsInImportingLibrary as ::fidl_next::Encodable
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    type Encoded = WireOnlyAppearsInImportingLibrary;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                member_only_appears_in_importing_library,

            } = slot;
        }

        ::fidl_next::Encode::encode(
            &mut self.member_only_appears_in_importing_library,
            encoder,
            member_only_appears_in_importing_library,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyAppearsInImportingLibrary> {
    type EncodedOption = ::fidl_next::WireBox<WireOnlyAppearsInImportingLibrary>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyAppearsInImportingLibrary>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyAppearsInImportingLibrary> for OnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::MemberOnlyAppearsInImportingLibrary as ::fidl_next::Encodable
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn take_from(from: &WireOnlyAppearsInImportingLibrary) -> Self {
        Self {
            member_only_appears_in_importing_library: ::fidl_next::TakeFrom::take_from(
                &from.member_only_appears_in_importing_library,
            ),
        }
    }
}

/// The wire type corersponding to [`OnlyAppearsInImportingLibrary`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::WireMemberOnlyAppearsInImportingLibrary,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyAppearsInImportingLibrary
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut member_only_appears_in_importing_library,

            } = slot;
        }

        ::fidl_next::Decode::decode(member_only_appears_in_importing_library.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the OnlyCppAndDeps protocol.
#[derive(Debug)]
pub struct OnlyCppAndDeps;

pub mod only_cpp_and_deps {}

/// A helper trait for the `OnlyCppAndDeps` client sender.
pub trait OnlyCppAndDepsClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyCppAndDepsClientSender for ::fidl_next::ClientSender<___T, OnlyCppAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the OnlyCppAndDeps protocol.
///
/// See [`OnlyCppAndDeps`] for more details.
pub trait OnlyCppAndDepsClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for OnlyCppAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyCppAndDepsClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `OnlyCppAndDeps` server sender.
pub trait OnlyCppAndDepsServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyCppAndDepsServerSender for ::fidl_next::ServerSender<___T, OnlyCppAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the OnlyCppAndDeps protocol.
///
/// See [`OnlyCppAndDeps`] for more details.
pub trait OnlyCppAndDepsServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for OnlyCppAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyCppAndDepsServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum OnlyDart {
    A = 1,
}

impl ::fidl_next::Encodable for OnlyDart {
    type Encoded = WireOnlyDart;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyDart
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyDart { mut value } = slot);
        *value = ::fidl_next::WireU32::from(match *self {
            Self::A => 1,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireOnlyDart> for OnlyDart {
    fn from(wire: WireOnlyDart) -> Self {
        match u32::from(wire.value) {
            1 => Self::A,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOnlyDart> for OnlyDart {
    #[inline]
    fn take_from(from: &WireOnlyDart) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`OnlyDart`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireOnlyDart {
    value: ::fidl_next::WireU32,
}

impl WireOnlyDart {
    pub const A: WireOnlyDart = WireOnlyDart { value: ::fidl_next::WireU32(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyDart
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlyDart> for WireOnlyDart {
    fn from(natural: OnlyDart) -> Self {
        match natural {
            OnlyDart::A => WireOnlyDart::A,
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct OnlyGo {}

impl ::fidl_next::Encodable for OnlyGo {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireOnlyGo;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyGo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyGo> {
    type EncodedOption = ::fidl_next::WireBox<WireOnlyGo>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyGo>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyGo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyGo> for OnlyGo {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireOnlyGo) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`OnlyGo`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyGo {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyGo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

/// The type corresponding to the OnlyHlcpp service.
#[derive(Debug)]
pub struct OnlyHlcpp;

/// A helper trait for instances of the `OnlyHlcpp` service.
pub trait OnlyHlcppInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;
}

impl<___I> OnlyHlcppInstance for ::fidl_next::ServiceInstance<___I, OnlyHlcpp>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;
}

/// The type corresponding to the OnlyLibfuzzerAndDeps protocol.
#[derive(Debug)]
pub struct OnlyLibfuzzerAndDeps;

pub mod only_libfuzzer_and_deps {}

/// A helper trait for the `OnlyLibfuzzerAndDeps` client sender.
pub trait OnlyLibfuzzerAndDepsClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyLibfuzzerAndDepsClientSender
    for ::fidl_next::ClientSender<___T, OnlyLibfuzzerAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the OnlyLibfuzzerAndDeps protocol.
///
/// See [`OnlyLibfuzzerAndDeps`] for more details.
pub trait OnlyLibfuzzerAndDepsClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for OnlyLibfuzzerAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyLibfuzzerAndDepsClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `OnlyLibfuzzerAndDeps` server sender.
pub trait OnlyLibfuzzerAndDepsServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyLibfuzzerAndDepsServerSender
    for ::fidl_next::ServerSender<___T, OnlyLibfuzzerAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the OnlyLibfuzzerAndDeps protocol.
///
/// See [`OnlyLibfuzzerAndDeps`] for more details.
pub trait OnlyLibfuzzerAndDepsServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for OnlyLibfuzzerAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyLibfuzzerAndDepsServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum OnlyLlcpp {
    X(u32),
}

impl ::fidl_next::Encodable for OnlyLlcpp {
    type Encoded = WireOnlyLlcpp;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyLlcpp
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyLlcpp { raw } = slot);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyLlcpp> {
    type EncodedOption = WireOptionalOnlyLlcpp;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyLlcpp>
where
    ___E: ?Sized,
    OnlyLlcpp: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOnlyLlcpp { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyLlcpp> for OnlyLlcpp {
    #[inline]
    fn take_from(from: &WireOnlyLlcpp) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalOnlyLlcpp> for Option<Box<OnlyLlcpp>> {
    #[inline]
    fn take_from(from: &WireOptionalOnlyLlcpp) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`OnlyLlcpp`].
#[repr(transparent)]
pub struct WireOnlyLlcpp {
    raw: ::fidl_next::RawWireUnion,
}

pub mod only_llcpp {
    pub enum Ref<'union> {
        X(&'union ::fidl_next::WireU32),
    }
}

impl WireOnlyLlcpp {
    pub fn as_ref(&self) -> crate::only_llcpp::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::only_llcpp::Ref::X(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireOnlyLlcpp {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyLlcpp
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOnlyLlcpp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOnlyLlcpp {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalOnlyLlcpp {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOnlyLlcpp> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalOnlyLlcpp {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalOnlyLlcpp { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalOnlyLlcpp
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalOnlyLlcpp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct OnlyRust {}

impl OnlyRust {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for OnlyRust {
    type Encoded = WireOnlyRust;
}

impl<___E> ::fidl_next::Encode<___E> for OnlyRust
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyRust { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyRust> for OnlyRust {
    #[inline]
    fn take_from(from: &WireOnlyRust) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`OnlyRust`].
#[repr(C)]
pub struct WireOnlyRust {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyRust
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireOnlyRust {}

impl ::core::fmt::Debug for WireOnlyRust {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OnlyRust").finish()
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct OnlySyzkaller: u32 {
        const A = 1;

    }
}

impl ::fidl_next::Encodable for OnlySyzkaller {
    type Encoded = WireOnlySyzkaller;
}

impl<___E> ::fidl_next::Encode<___E> for OnlySyzkaller
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlySyzkaller { mut value } = slot);
        *value = ::fidl_next::WireU32::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireOnlySyzkaller> for OnlySyzkaller {
    fn from(wire: WireOnlySyzkaller) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireOnlySyzkaller> for OnlySyzkaller {
    #[inline]
    fn take_from(from: &WireOnlySyzkaller) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`OnlySyzkaller`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireOnlySyzkaller {
    value: ::fidl_next::WireU32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlySyzkaller
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !OnlySyzkaller::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: OnlySyzkaller::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlySyzkaller> for WireOnlySyzkaller {
    fn from(natural: OnlySyzkaller) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

/// Commonly-used items that should usually be in scope, such as extension traits.
pub mod prelude {
    pub use super::{
        AllowedClientSender, AllowedServerSender, ContainsAllowedClientSender,
        ContainsAllowedServerSender, DeniedClientSender, DeniedServerSender,
        DenyEachBindingClientSender, DenyEachBindingServerSender,
        ImportsSameNameContextClientSender, ImportsSameNameContextServerSender,
        OnlyCppAndDepsClientSender, OnlyCppAndDepsServerSender, OnlyHlcppInstance,
        OnlyLibfuzzerAndDepsClientSender, OnlyLibfuzzerAndDepsServerSender,
    };
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Allowed`
    /// protocol.
    pub type AllowedProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Allowed>;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ContainsAllowed`
    /// protocol.
    pub type ContainsAllowedProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ContainsAllowed>;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Denied`
    /// protocol.
    pub type DeniedProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Denied>;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `DenyEachBinding`
    /// protocol.
    pub type DenyEachBindingProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::DenyEachBinding>;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ImportsSameNameContext`
    /// protocol.
    pub type ImportsSameNameContextProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ImportsSameNameContext>;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `OnlyCppAndDeps`
    /// protocol.
    pub type OnlyCppAndDepsProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::OnlyCppAndDeps>;

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `OnlyLibfuzzerAndDeps`
    /// protocol.
    pub type OnlyLibfuzzerAndDepsProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::OnlyLibfuzzerAndDeps>;
}
