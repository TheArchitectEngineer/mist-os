// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const ALL_BINDINGS: u32 = 0;

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding4 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireShouldNeverAppearInAnyBinding4,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding4;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding4
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding4
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ShouldNeverAppearInAnyBinding4 {
    type EncodedOption = ::fidl_next::WireBox<'static, WireShouldNeverAppearInAnyBinding4>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ShouldNeverAppearInAnyBinding4
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding4: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ShouldNeverAppearInAnyBinding4
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding4: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding4> for ShouldNeverAppearInAnyBinding4 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireShouldNeverAppearInAnyBinding4,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding4) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding4>
    for ShouldNeverAppearInAnyBinding4
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding4) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding4`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding4 {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding4;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding4
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ShouldNeverAppearInAnyBinding5 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding5 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding5 {
    type Encoded = WireShouldNeverAppearInAnyBinding5<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding5
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding5 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = self.a.take() {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding5
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding5 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = &self.a {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding5<'de>>
    for ShouldNeverAppearInAnyBinding5
{
    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding5<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let a = wire.table.get(1);

        Self {
            a: a.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe { envelope.read_unchecked::<bool>() })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding5<'de>>
    for ShouldNeverAppearInAnyBinding5
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding5<'de>) -> Self {
        Self {
            a: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<bool>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding5`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding5<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireShouldNeverAppearInAnyBinding5<'de> {
    fn drop(&mut self) {
        let _ = self.table.get(1).map(|envelope| unsafe { envelope.read_unchecked::<bool>() });
    }
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding5<'static> {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding5<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding5<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireShouldNeverAppearInAnyBinding5<'de> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding5<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding5").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding6 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding6 {
    type Encoded = WireShouldNeverAppearInAnyBinding6;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding6 { raw, _phantom: _ } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding6 { raw, _phantom: _ } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ShouldNeverAppearInAnyBinding6 {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding6;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ShouldNeverAppearInAnyBinding6
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding6: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding6 { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ShouldNeverAppearInAnyBinding6
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding6: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding6 { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding6> for ShouldNeverAppearInAnyBinding6 {
    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding6) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::A(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding6>
    for ShouldNeverAppearInAnyBinding6
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding6) -> Self {
        match wire.raw.ordinal() {
            1 => Self::A(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalShouldNeverAppearInAnyBinding6>
    for Box<ShouldNeverAppearInAnyBinding6>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalShouldNeverAppearInAnyBinding6) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalShouldNeverAppearInAnyBinding6>
    for Box<ShouldNeverAppearInAnyBinding6>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalShouldNeverAppearInAnyBinding6) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding6`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding6 {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireShouldNeverAppearInAnyBinding6 {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<bool>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding6 {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding6;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod should_never_appear_in_any_binding6 {
    pub enum Ref<'de> {
        A(&'de bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding6 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding6::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding6::Ref::A(unsafe {
                self.raw.get().deref_unchecked::<bool>()
            }),

            unknown => crate::should_never_appear_in_any_binding6::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding6 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding6 {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalShouldNeverAppearInAnyBinding6 {
    type Decoded<'de> = WireOptionalShouldNeverAppearInAnyBinding6;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalShouldNeverAppearInAnyBinding6 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding6> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireShouldNeverAppearInAnyBinding6> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding6 {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding6 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding6 {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct AllowedDeniedResponse {
    pub should_never_appear_in_any_binding_4: crate::ShouldNeverAppearInAnyBinding4,

    pub should_never_appear_in_any_binding_5: crate::ShouldNeverAppearInAnyBinding5,

    pub should_never_appear_in_any_binding_6: crate::ShouldNeverAppearInAnyBinding6,
}

impl ::fidl_next::Encodable for AllowedDeniedResponse {
    type Encoded = WireAllowedDeniedResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for AllowedDeniedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_4,
                should_never_appear_in_any_binding_5,
                should_never_appear_in_any_binding_6,

            } = out;
        }

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_4,
            encoder,
            should_never_appear_in_any_binding_4,
        )?;

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_5,
            encoder,
            should_never_appear_in_any_binding_5,
        )?;

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_6,
            encoder,
            should_never_appear_in_any_binding_6,
        )?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for AllowedDeniedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_4,
                should_never_appear_in_any_binding_5,
                should_never_appear_in_any_binding_6,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_4,
            encoder,
            should_never_appear_in_any_binding_4,
        )?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_5,
            encoder,
            should_never_appear_in_any_binding_5,
        )?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_6,
            encoder,
            should_never_appear_in_any_binding_6,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for AllowedDeniedResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireAllowedDeniedResponse<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for AllowedDeniedResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllowedDeniedResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for AllowedDeniedResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllowedDeniedResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireAllowedDeniedResponse<'de>> for AllowedDeniedResponse {
    #[inline]
    fn from_wire(wire: WireAllowedDeniedResponse<'de>) -> Self {
        Self {
            should_never_appear_in_any_binding_4: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_4,
            ),

            should_never_appear_in_any_binding_5: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_5,
            ),

            should_never_appear_in_any_binding_6: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_6,
            ),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireAllowedDeniedResponse<'de>> for AllowedDeniedResponse {
    #[inline]
    fn from_wire_ref(wire: &WireAllowedDeniedResponse<'de>) -> Self {
        Self {
            should_never_appear_in_any_binding_4: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_4,
            ),

            should_never_appear_in_any_binding_5: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_5,
            ),

            should_never_appear_in_any_binding_6: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_6,
            ),
        }
    }
}

/// The wire type corresponding to [`AllowedDeniedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireAllowedDeniedResponse<'de> {
    pub should_never_appear_in_any_binding_4: crate::WireShouldNeverAppearInAnyBinding4,

    pub should_never_appear_in_any_binding_5: crate::WireShouldNeverAppearInAnyBinding5<'de>,

    pub should_never_appear_in_any_binding_6: crate::WireShouldNeverAppearInAnyBinding6,
}

unsafe impl ::fidl_next::Wire for WireAllowedDeniedResponse<'static> {
    type Decoded<'de> = WireAllowedDeniedResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireAllowedDeniedResponse<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_4,
                mut should_never_appear_in_any_binding_5,
                mut should_never_appear_in_any_binding_6,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_6.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Allowed protocol.
#[derive(Debug)]
pub struct Allowed;

pub mod allowed {
    pub mod prelude {
        pub use crate::{
            allowed, Allowed, AllowedClientHandler, AllowedClientSender, AllowedServerHandler,
            AllowedServerSender,
        };

        pub use crate::AllowedDeniedResponse;
    }

    pub struct Denied;

    impl ::fidl_next::Method for Denied {
        const ORDINAL: u64 = 3826178105137551123;

        type Protocol = crate::Allowed;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireAllowedDeniedResponse<'static>,
            ::fidl_next::WireU32,
        >;
    }
}

/// A helper trait for the `Allowed` client sender.
pub trait AllowedClientSender {
    type Transport: ::fidl_next::Transport;

    fn denied(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, allowed::Denied>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> AllowedClientSender for ::fidl_next::ClientSender<___T, Allowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn denied(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, allowed::Denied>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3826178105137551123, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the Allowed protocol.
///
/// See [`Allowed`] for more details.
pub trait AllowedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Allowed
where
    ___T: ::fidl_next::Transport,
    ___H: AllowedClientHandler<___T>,

    <allowed::Denied as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Allowed` server sender.
pub trait AllowedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> AllowedServerSender for ::fidl_next::ServerSender<___T, Allowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the Allowed protocol.
///
/// See [`Allowed`] for more details.
pub trait AllowedServerHandler<___T: ::fidl_next::Transport> {
    fn denied(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Allowed>,

        responder: ::fidl_next::Responder<allowed::Denied>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Allowed
where
    ___T: ::fidl_next::Transport,
    ___H: AllowedServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            3826178105137551123 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.denied(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the ContainsAllowed protocol.
#[derive(Debug)]
pub struct ContainsAllowed;

pub mod contains_allowed {
    pub mod prelude {
        pub use crate::{
            contains_allowed, ContainsAllowed, ContainsAllowedClientHandler,
            ContainsAllowedClientSender, ContainsAllowedServerHandler, ContainsAllowedServerSender,
        };
    }
}

/// A helper trait for the `ContainsAllowed` client sender.
pub trait ContainsAllowedClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ContainsAllowedClientSender for ::fidl_next::ClientSender<___T, ContainsAllowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the ContainsAllowed protocol.
///
/// See [`ContainsAllowed`] for more details.
pub trait ContainsAllowedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ContainsAllowed
where
    ___T: ::fidl_next::Transport,
    ___H: ContainsAllowedClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ContainsAllowed` server sender.
pub trait ContainsAllowedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ContainsAllowedServerSender for ::fidl_next::ServerSender<___T, ContainsAllowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ContainsAllowed protocol.
///
/// See [`ContainsAllowed`] for more details.
pub trait ContainsAllowedServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ContainsAllowed
where
    ___T: ::fidl_next::Transport,
    ___H: ContainsAllowedServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding1 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireShouldNeverAppearInAnyBinding1,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding1;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding1
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding1
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ShouldNeverAppearInAnyBinding1 {
    type EncodedOption = ::fidl_next::WireBox<'static, WireShouldNeverAppearInAnyBinding1>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ShouldNeverAppearInAnyBinding1
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding1: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ShouldNeverAppearInAnyBinding1
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding1: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding1> for ShouldNeverAppearInAnyBinding1 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireShouldNeverAppearInAnyBinding1,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding1) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding1>
    for ShouldNeverAppearInAnyBinding1
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding1) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding1`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding1 {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding1;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding1
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ShouldNeverAppearInAnyBinding2 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding2 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding2 {
    type Encoded = WireShouldNeverAppearInAnyBinding2<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding2
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding2 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = self.a.take() {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding2
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding2 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = &self.a {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding2<'de>>
    for ShouldNeverAppearInAnyBinding2
{
    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding2<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let a = wire.table.get(1);

        Self {
            a: a.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe { envelope.read_unchecked::<bool>() })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding2<'de>>
    for ShouldNeverAppearInAnyBinding2
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding2<'de>) -> Self {
        Self {
            a: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<bool>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding2`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding2<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireShouldNeverAppearInAnyBinding2<'de> {
    fn drop(&mut self) {
        let _ = self.table.get(1).map(|envelope| unsafe { envelope.read_unchecked::<bool>() });
    }
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding2<'static> {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding2<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding2<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireShouldNeverAppearInAnyBinding2<'de> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding2<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding2").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding3 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding3 {
    type Encoded = WireShouldNeverAppearInAnyBinding3;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding3
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding3 { raw, _phantom: _ } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding3
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding3 { raw, _phantom: _ } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ShouldNeverAppearInAnyBinding3 {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding3;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ShouldNeverAppearInAnyBinding3
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding3: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding3 { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ShouldNeverAppearInAnyBinding3
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding3: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding3 { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding3> for ShouldNeverAppearInAnyBinding3 {
    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding3) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::A(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding3>
    for ShouldNeverAppearInAnyBinding3
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding3) -> Self {
        match wire.raw.ordinal() {
            1 => Self::A(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalShouldNeverAppearInAnyBinding3>
    for Box<ShouldNeverAppearInAnyBinding3>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalShouldNeverAppearInAnyBinding3) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalShouldNeverAppearInAnyBinding3>
    for Box<ShouldNeverAppearInAnyBinding3>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalShouldNeverAppearInAnyBinding3) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding3`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding3 {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireShouldNeverAppearInAnyBinding3 {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<bool>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding3 {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding3;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod should_never_appear_in_any_binding3 {
    pub enum Ref<'de> {
        A(&'de bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding3 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding3::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding3::Ref::A(unsafe {
                self.raw.get().deref_unchecked::<bool>()
            }),

            unknown => crate::should_never_appear_in_any_binding3::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding3 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding3
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding3 {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalShouldNeverAppearInAnyBinding3 {
    type Decoded<'de> = WireOptionalShouldNeverAppearInAnyBinding3;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalShouldNeverAppearInAnyBinding3 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding3> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireShouldNeverAppearInAnyBinding3> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding3 {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding3 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding3 {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding3
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedShouldNeverAppearInAnyBindingRequest {
    pub should_never_appear_in_any_binding_1: crate::ShouldNeverAppearInAnyBinding1,

    pub should_never_appear_in_any_binding_2: crate::ShouldNeverAppearInAnyBinding2,

    pub should_never_appear_in_any_binding_3: crate::ShouldNeverAppearInAnyBinding3,
}

impl ::fidl_next::Encodable for DeniedShouldNeverAppearInAnyBindingRequest {
    type Encoded = WireDeniedShouldNeverAppearInAnyBindingRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DeniedShouldNeverAppearInAnyBindingRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_1,
                should_never_appear_in_any_binding_2,
                should_never_appear_in_any_binding_3,

            } = out;
        }

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_1,
            encoder,
            should_never_appear_in_any_binding_1,
        )?;

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_2,
            encoder,
            should_never_appear_in_any_binding_2,
        )?;

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_3,
            encoder,
            should_never_appear_in_any_binding_3,
        )?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DeniedShouldNeverAppearInAnyBindingRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_1,
                should_never_appear_in_any_binding_2,
                should_never_appear_in_any_binding_3,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_1,
            encoder,
            should_never_appear_in_any_binding_1,
        )?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_2,
            encoder,
            should_never_appear_in_any_binding_2,
        )?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_3,
            encoder,
            should_never_appear_in_any_binding_3,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DeniedShouldNeverAppearInAnyBindingRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireDeniedShouldNeverAppearInAnyBindingRequest<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DeniedShouldNeverAppearInAnyBindingRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedShouldNeverAppearInAnyBindingRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DeniedShouldNeverAppearInAnyBindingRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedShouldNeverAppearInAnyBindingRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireDeniedShouldNeverAppearInAnyBindingRequest<'de>>
    for DeniedShouldNeverAppearInAnyBindingRequest
{
    #[inline]
    fn from_wire(wire: WireDeniedShouldNeverAppearInAnyBindingRequest<'de>) -> Self {
        Self {
            should_never_appear_in_any_binding_1: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_1,
            ),

            should_never_appear_in_any_binding_2: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_2,
            ),

            should_never_appear_in_any_binding_3: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_3,
            ),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireDeniedShouldNeverAppearInAnyBindingRequest<'de>>
    for DeniedShouldNeverAppearInAnyBindingRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireDeniedShouldNeverAppearInAnyBindingRequest<'de>) -> Self {
        Self {
            should_never_appear_in_any_binding_1: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_1,
            ),

            should_never_appear_in_any_binding_2: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_2,
            ),

            should_never_appear_in_any_binding_3: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_3,
            ),
        }
    }
}

/// The wire type corresponding to [`DeniedShouldNeverAppearInAnyBindingRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedShouldNeverAppearInAnyBindingRequest<'de> {
    pub should_never_appear_in_any_binding_1: crate::WireShouldNeverAppearInAnyBinding1,

    pub should_never_appear_in_any_binding_2: crate::WireShouldNeverAppearInAnyBinding2<'de>,

    pub should_never_appear_in_any_binding_3: crate::WireShouldNeverAppearInAnyBinding3,
}

unsafe impl ::fidl_next::Wire for WireDeniedShouldNeverAppearInAnyBindingRequest<'static> {
    type Decoded<'de> = WireDeniedShouldNeverAppearInAnyBindingRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireDeniedShouldNeverAppearInAnyBindingRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_1,
                mut should_never_appear_in_any_binding_2,
                mut should_never_appear_in_any_binding_3,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_3.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Denied protocol.
#[derive(Debug)]
pub struct Denied;

pub mod denied {
    pub mod prelude {
        pub use crate::{
            denied, Denied, DeniedClientHandler, DeniedClientSender, DeniedServerHandler,
            DeniedServerSender,
        };

        pub use crate::DeniedShouldNeverAppearInAnyBindingRequest;
    }

    pub struct ShouldNeverAppearInAnyBinding;

    impl ::fidl_next::Method for ShouldNeverAppearInAnyBinding {
        const ORDINAL: u64 = 5338181991150205725;

        type Protocol = crate::Denied;

        type Request = crate::WireDeniedShouldNeverAppearInAnyBindingRequest<'static>;

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `Denied` client sender.
pub trait DeniedClientSender {
    type Transport: ::fidl_next::Transport;

    fn should_never_appear_in_any_binding<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDeniedShouldNeverAppearInAnyBindingRequest<'static>,
        >;
}

impl<___T> DeniedClientSender for ::fidl_next::ClientSender<___T, Denied>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn should_never_appear_in_any_binding<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDeniedShouldNeverAppearInAnyBindingRequest<'static>,
        >,
    {
        self.as_untyped().send_one_way(5338181991150205725, request)
    }
}

/// A client handler for the Denied protocol.
///
/// See [`Denied`] for more details.
pub trait DeniedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Denied
where
    ___T: ::fidl_next::Transport,
    ___H: DeniedClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Denied` server sender.
pub trait DeniedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DeniedServerSender for ::fidl_next::ServerSender<___T, Denied>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the Denied protocol.
///
/// See [`Denied`] for more details.
pub trait DeniedServerHandler<___T: ::fidl_next::Transport> {
    fn should_never_appear_in_any_binding(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Denied>,

        request: ::fidl_next::Request<___T, denied::ShouldNeverAppearInAnyBinding>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Denied
where
    ___T: ::fidl_next::Transport,
    ___H: DeniedServerHandler<___T>,

    <denied::ShouldNeverAppearInAnyBinding as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5338181991150205725 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.should_never_appear_in_any_binding(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding7 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireShouldNeverAppearInAnyBinding7,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding7;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding7
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding7
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ShouldNeverAppearInAnyBinding7 {
    type EncodedOption = ::fidl_next::WireBox<'static, WireShouldNeverAppearInAnyBinding7>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ShouldNeverAppearInAnyBinding7
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding7: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ShouldNeverAppearInAnyBinding7
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding7: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding7> for ShouldNeverAppearInAnyBinding7 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireShouldNeverAppearInAnyBinding7,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding7) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding7>
    for ShouldNeverAppearInAnyBinding7
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding7) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding7`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding7 {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding7;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding7
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ShouldNeverAppearInAnyBinding8 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding8 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding8 {
    type Encoded = WireShouldNeverAppearInAnyBinding8<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding8
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding8 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = self.a.take() {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding8
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding8 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = &self.a {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding8<'de>>
    for ShouldNeverAppearInAnyBinding8
{
    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding8<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let a = wire.table.get(1);

        Self {
            a: a.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe { envelope.read_unchecked::<bool>() })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding8<'de>>
    for ShouldNeverAppearInAnyBinding8
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding8<'de>) -> Self {
        Self {
            a: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<bool>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding8`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding8<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireShouldNeverAppearInAnyBinding8<'de> {
    fn drop(&mut self) {
        let _ = self.table.get(1).map(|envelope| unsafe { envelope.read_unchecked::<bool>() });
    }
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding8<'static> {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding8<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding8<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireShouldNeverAppearInAnyBinding8<'de> {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding8<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding8").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding9 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding9 {
    type Encoded = WireShouldNeverAppearInAnyBinding9;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding9
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding9 { raw, _phantom: _ } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ShouldNeverAppearInAnyBinding9
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding9 { raw, _phantom: _ } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ShouldNeverAppearInAnyBinding9 {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding9;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ShouldNeverAppearInAnyBinding9
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding9: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding9 { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ShouldNeverAppearInAnyBinding9
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding9: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding9 { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireShouldNeverAppearInAnyBinding9> for ShouldNeverAppearInAnyBinding9 {
    #[inline]
    fn from_wire(wire: WireShouldNeverAppearInAnyBinding9) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::A(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireShouldNeverAppearInAnyBinding9>
    for ShouldNeverAppearInAnyBinding9
{
    #[inline]
    fn from_wire_ref(wire: &WireShouldNeverAppearInAnyBinding9) -> Self {
        match wire.raw.ordinal() {
            1 => Self::A(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalShouldNeverAppearInAnyBinding9>
    for Box<ShouldNeverAppearInAnyBinding9>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalShouldNeverAppearInAnyBinding9) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalShouldNeverAppearInAnyBinding9>
    for Box<ShouldNeverAppearInAnyBinding9>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalShouldNeverAppearInAnyBinding9) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding9`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding9 {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireShouldNeverAppearInAnyBinding9 {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<bool>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireShouldNeverAppearInAnyBinding9 {
    type Decoded<'de> = WireShouldNeverAppearInAnyBinding9;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod should_never_appear_in_any_binding9 {
    pub enum Ref<'de> {
        A(&'de bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding9 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding9::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding9::Ref::A(unsafe {
                self.raw.get().deref_unchecked::<bool>()
            }),

            unknown => crate::should_never_appear_in_any_binding9::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding9 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding9
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding9 {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalShouldNeverAppearInAnyBinding9 {
    type Decoded<'de> = WireOptionalShouldNeverAppearInAnyBinding9;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalShouldNeverAppearInAnyBinding9 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding9> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireShouldNeverAppearInAnyBinding9> {
        if self.is_some() {
            Some(WireShouldNeverAppearInAnyBinding9 {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding9 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding9 {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding9
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedAnonymous {
    pub should_never_appear_in_any_binding_7: crate::ShouldNeverAppearInAnyBinding7,

    pub should_never_appear_in_any_binding_8: crate::ShouldNeverAppearInAnyBinding8,

    pub should_never_appear_in_any_binding_9: crate::ShouldNeverAppearInAnyBinding9,
}

impl ::fidl_next::Encodable for DeniedAnonymous {
    type Encoded = WireDeniedAnonymous<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DeniedAnonymous
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_7,
                should_never_appear_in_any_binding_8,
                should_never_appear_in_any_binding_9,

            } = out;
        }

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_7,
            encoder,
            should_never_appear_in_any_binding_7,
        )?;

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_8,
            encoder,
            should_never_appear_in_any_binding_8,
        )?;

        ::fidl_next::Encode::encode(
            self.should_never_appear_in_any_binding_9,
            encoder,
            should_never_appear_in_any_binding_9,
        )?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DeniedAnonymous
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_7,
                should_never_appear_in_any_binding_8,
                should_never_appear_in_any_binding_9,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_7,
            encoder,
            should_never_appear_in_any_binding_7,
        )?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_8,
            encoder,
            should_never_appear_in_any_binding_8,
        )?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.should_never_appear_in_any_binding_9,
            encoder,
            should_never_appear_in_any_binding_9,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DeniedAnonymous {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDeniedAnonymous<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DeniedAnonymous
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedAnonymous: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DeniedAnonymous
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedAnonymous: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireDeniedAnonymous<'de>> for DeniedAnonymous {
    #[inline]
    fn from_wire(wire: WireDeniedAnonymous<'de>) -> Self {
        Self {
            should_never_appear_in_any_binding_7: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_7,
            ),

            should_never_appear_in_any_binding_8: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_8,
            ),

            should_never_appear_in_any_binding_9: ::fidl_next::FromWire::from_wire(
                wire.should_never_appear_in_any_binding_9,
            ),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireDeniedAnonymous<'de>> for DeniedAnonymous {
    #[inline]
    fn from_wire_ref(wire: &WireDeniedAnonymous<'de>) -> Self {
        Self {
            should_never_appear_in_any_binding_7: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_7,
            ),

            should_never_appear_in_any_binding_8: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_8,
            ),

            should_never_appear_in_any_binding_9: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.should_never_appear_in_any_binding_9,
            ),
        }
    }
}

/// The wire type corresponding to [`DeniedAnonymous`].
#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedAnonymous<'de> {
    pub should_never_appear_in_any_binding_7: crate::WireShouldNeverAppearInAnyBinding7,

    pub should_never_appear_in_any_binding_8: crate::WireShouldNeverAppearInAnyBinding8<'de>,

    pub should_never_appear_in_any_binding_9: crate::WireShouldNeverAppearInAnyBinding9,
}

unsafe impl ::fidl_next::Wire for WireDeniedAnonymous<'static> {
    type Decoded<'de> = WireDeniedAnonymous<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDeniedAnonymous<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_7,
                mut should_never_appear_in_any_binding_8,
                mut should_never_appear_in_any_binding_9,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_9.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyCppRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyCppRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyCppRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyCppRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyCppRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyCppRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyCppRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyCppRequest>
    for DenyEachBindingOnlyDenyCppRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyCppRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyCppRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyCppRequest>
    for DenyEachBindingOnlyDenyCppRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyCppRequest) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyCppRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyCppRequest {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyCppRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyCppResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyCppResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyCppResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyCppResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyCppResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyCppResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyCppResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyCppResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyCppResponse>
    for DenyEachBindingOnlyDenyCppResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyCppResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyCppResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyCppResponse>
    for DenyEachBindingOnlyDenyCppResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyCppResponse) -> Self {
        Self { b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyCppResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyCppResponse {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyCppResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyDartRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyDartRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyDartRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyDartRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyDartRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyDartRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyDartRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyDartRequest>
    for DenyEachBindingOnlyDenyDartRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyDartRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyDartRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyDartRequest>
    for DenyEachBindingOnlyDenyDartRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyDartRequest) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyDartRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyDartRequest {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyDartRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyDartResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyDartResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyDartResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyDartResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyDartResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyDartResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyDartResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyDartResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyDartResponse>
    for DenyEachBindingOnlyDenyDartResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyDartResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyDartResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyDartResponse>
    for DenyEachBindingOnlyDenyDartResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyDartResponse) -> Self {
        Self { b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyDartResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyDartResponse {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyDartResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyGoRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyGoRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyGoRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyGoRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyGoRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyGoRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyGoRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyGoRequest>
    for DenyEachBindingOnlyDenyGoRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyGoRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyGoRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyGoRequest>
    for DenyEachBindingOnlyDenyGoRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyGoRequest) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyGoRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyGoRequest {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyGoRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyGoResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyGoResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyGoResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyGoResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyGoResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyGoResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyGoResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyGoResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyGoResponse>
    for DenyEachBindingOnlyDenyGoResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyGoResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyGoResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyGoResponse>
    for DenyEachBindingOnlyDenyGoResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyGoResponse) -> Self {
        Self { b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyGoResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyGoResponse {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyGoResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyPythonRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyPythonRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyPythonRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyPythonRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyPythonRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyPythonRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyPythonRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyPythonRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyPythonRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyPythonRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyPythonRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyPythonRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyPythonRequest>
    for DenyEachBindingOnlyDenyPythonRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyPythonRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyPythonRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyPythonRequest>
    for DenyEachBindingOnlyDenyPythonRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyPythonRequest) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyPythonRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyPythonRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyPythonRequest {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyPythonRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyPythonRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyPythonResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyPythonResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyPythonResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyPythonResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyPythonResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyPythonResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyPythonResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyPythonResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyPythonResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyPythonResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyPythonResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyPythonResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyPythonResponse>
    for DenyEachBindingOnlyDenyPythonResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyPythonResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyPythonResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyPythonResponse>
    for DenyEachBindingOnlyDenyPythonResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyPythonResponse) -> Self {
        Self { b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyPythonResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyPythonResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyPythonResponse {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyPythonResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyPythonResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyRustRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyRustRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyRustRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyRustRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyRustRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyRustRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyRustRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyRustRequest>
    for DenyEachBindingOnlyDenyRustRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyRustRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyRustRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyRustRequest>
    for DenyEachBindingOnlyDenyRustRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyRustRequest) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyRustRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyRustRequest {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyRustRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyRustResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenyRustResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyRustResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenyRustResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenyRustResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenyRustResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenyRustResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenyRustResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenyRustResponse>
    for DenyEachBindingOnlyDenyRustResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenyRustResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenyRustResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenyRustResponse>
    for DenyEachBindingOnlyDenyRustResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenyRustResponse) -> Self {
        Self { b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyRustResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenyRustResponse {
    type Decoded<'de> = WireDenyEachBindingOnlyDenyRustResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenySyzkallerRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenySyzkallerRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenySyzkallerRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenySyzkallerRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenySyzkallerRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenySyzkallerRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenySyzkallerRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenySyzkallerRequest>
    for DenyEachBindingOnlyDenySyzkallerRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenySyzkallerRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenySyzkallerRequest) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenySyzkallerRequest>
    for DenyEachBindingOnlyDenySyzkallerRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenySyzkallerRequest) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenySyzkallerRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenySyzkallerRequest {
    type Decoded<'de> = WireDenyEachBindingOnlyDenySyzkallerRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenySyzkallerResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireDenyEachBindingOnlyDenySyzkallerResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenySyzkallerResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for DenyEachBindingOnlyDenySyzkallerResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for DenyEachBindingOnlyDenySyzkallerResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireDenyEachBindingOnlyDenySyzkallerResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for DenyEachBindingOnlyDenySyzkallerResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for DenyEachBindingOnlyDenySyzkallerResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireDenyEachBindingOnlyDenySyzkallerResponse>
    for DenyEachBindingOnlyDenySyzkallerResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireDenyEachBindingOnlyDenySyzkallerResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireDenyEachBindingOnlyDenySyzkallerResponse) -> Self {
        Self { b: ::fidl_next::FromWire::from_wire(wire.b) }
    }
}

impl ::fidl_next::FromWireRef<WireDenyEachBindingOnlyDenySyzkallerResponse>
    for DenyEachBindingOnlyDenySyzkallerResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireDenyEachBindingOnlyDenySyzkallerResponse) -> Self {
        Self { b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenySyzkallerResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireDenyEachBindingOnlyDenySyzkallerResponse {
    type Decoded<'de> = WireDenyEachBindingOnlyDenySyzkallerResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the DenyEachBinding protocol.
#[derive(Debug)]
pub struct DenyEachBinding;

pub mod deny_each_binding {
    pub mod prelude {
        pub use crate::{
            deny_each_binding, DenyEachBinding, DenyEachBindingClientHandler,
            DenyEachBindingClientSender, DenyEachBindingServerHandler, DenyEachBindingServerSender,
        };

        pub use crate::DenyEachBindingOnlyDenyCppRequest;

        pub use crate::DenyEachBindingOnlyDenyDartRequest;

        pub use crate::DenyEachBindingOnlyDenyGoRequest;

        pub use crate::DenyEachBindingOnlyDenyPythonRequest;

        pub use crate::DenyEachBindingOnlyDenyRustRequest;

        pub use crate::DenyEachBindingOnlyDenySyzkallerRequest;

        pub use crate::DenyEachBindingOnlyDenyCppResponse;

        pub use crate::DenyEachBindingOnlyDenyDartResponse;

        pub use crate::DenyEachBindingOnlyDenyGoResponse;

        pub use crate::DenyEachBindingOnlyDenyPythonResponse;

        pub use crate::DenyEachBindingOnlyDenyRustResponse;

        pub use crate::DenyEachBindingOnlyDenySyzkallerResponse;
    }

    pub struct OnlyDenyCpp;

    impl ::fidl_next::Method for OnlyDenyCpp {
        const ORDINAL: u64 = 2957648440141224850;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyCppRequest;

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireDenyEachBindingOnlyDenyCppResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyDart;

    impl ::fidl_next::Method for OnlyDenyDart {
        const ORDINAL: u64 = 8446571910689294295;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyDartRequest;

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireDenyEachBindingOnlyDenyDartResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyGo;

    impl ::fidl_next::Method for OnlyDenyGo {
        const ORDINAL: u64 = 7311125300308839833;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyGoRequest;

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireDenyEachBindingOnlyDenyGoResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyPython;

    impl ::fidl_next::Method for OnlyDenyPython {
        const ORDINAL: u64 = 3010747198252652930;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyPythonRequest;

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireDenyEachBindingOnlyDenyPythonResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyRust;

    impl ::fidl_next::Method for OnlyDenyRust {
        const ORDINAL: u64 = 3719805222870932662;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyRustRequest;

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireDenyEachBindingOnlyDenyRustResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenySyzkaller;

    impl ::fidl_next::Method for OnlyDenySyzkaller {
        const ORDINAL: u64 = 2319043834522757514;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenySyzkallerRequest;

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireDenyEachBindingOnlyDenySyzkallerResponse,
            ::fidl_next::WireU32,
        >;
    }
}

/// A helper trait for the `DenyEachBinding` client sender.
pub trait DenyEachBindingClientSender {
    type Transport: ::fidl_next::Transport;

    fn only_deny_cpp<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyCpp>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyCppRequest,
        >;

    fn only_deny_dart<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyDart>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyDartRequest,
        >;

    fn only_deny_go<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyGo>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyGoRequest,
        >;

    fn only_deny_python<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyPython>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyPythonRequest,
        >;

    fn only_deny_rust<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyRust>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyRustRequest,
        >;

    fn only_deny_syzkaller<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenySyzkaller>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenySyzkallerRequest,
        >;
}

impl<___T> DenyEachBindingClientSender for ::fidl_next::ClientSender<___T, DenyEachBinding>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn only_deny_cpp<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyCpp>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyCppRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2957648440141224850, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_dart<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyDart>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyDartRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8446571910689294295, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_go<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyGo>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyGoRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(7311125300308839833, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_python<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyPython>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyPythonRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(3010747198252652930, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_rust<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyRust>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyRustRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(3719805222870932662, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_syzkaller<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenySyzkaller>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenySyzkallerRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2319043834522757514, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the DenyEachBinding protocol.
///
/// See [`DenyEachBinding`] for more details.
pub trait DenyEachBindingClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for DenyEachBinding
where
    ___T: ::fidl_next::Transport,
    ___H: DenyEachBindingClientHandler<___T>,

    <deny_each_binding::OnlyDenyCpp as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyDart as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyGo as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyPython as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyRust as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenySyzkaller as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `DenyEachBinding` server sender.
pub trait DenyEachBindingServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DenyEachBindingServerSender for ::fidl_next::ServerSender<___T, DenyEachBinding>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the DenyEachBinding protocol.
///
/// See [`DenyEachBinding`] for more details.
pub trait DenyEachBindingServerHandler<___T: ::fidl_next::Transport> {
    fn only_deny_cpp(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::Request<___T, deny_each_binding::OnlyDenyCpp>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyCpp>,
    );

    fn only_deny_dart(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::Request<___T, deny_each_binding::OnlyDenyDart>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyDart>,
    );

    fn only_deny_go(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::Request<___T, deny_each_binding::OnlyDenyGo>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyGo>,
    );

    fn only_deny_python(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::Request<___T, deny_each_binding::OnlyDenyPython>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyPython>,
    );

    fn only_deny_rust(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::Request<___T, deny_each_binding::OnlyDenyRust>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyRust>,
    );

    fn only_deny_syzkaller(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::Request<___T, deny_each_binding::OnlyDenySyzkaller>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenySyzkaller>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for DenyEachBinding
where
    ___T: ::fidl_next::Transport,
    ___H: DenyEachBindingServerHandler<___T>,

    <deny_each_binding::OnlyDenyCpp as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyDart as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyGo as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyPython as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyRust as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenySyzkaller as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2957648440141224850 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.only_deny_cpp(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            8446571910689294295 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.only_deny_dart(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            7311125300308839833 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.only_deny_go(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            3010747198252652930 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.only_deny_python(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            3719805222870932662 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.only_deny_rust(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            2319043834522757514 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.only_deny_syzkaller(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the ImportsSameNameContext protocol.
#[derive(Debug)]
pub struct ImportsSameNameContext;

pub mod imports_same_name_context {
    pub mod prelude {
        pub use crate::{
            imports_same_name_context, ImportsSameNameContext, ImportsSameNameContextClientHandler,
            ImportsSameNameContextClientSender, ImportsSameNameContextServerHandler,
            ImportsSameNameContextServerSender,
        };

        pub use ::fidl_next_test_dependent::ContainsDeniedAlwaysDeniedRequest;
    }

    pub struct AlwaysDenied;

    impl ::fidl_next::Method for AlwaysDenied {
        const ORDINAL: u64 = 6808317417318106526;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest;

        type Response = ::fidl_next::Never;
    }

    pub struct Unattributed;

    impl ::fidl_next::Method for Unattributed {
        const ORDINAL: u64 = 475191379775102607;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct AlwaysAppearsInImportingLibrary;

    impl ::fidl_next::Method for AlwaysAppearsInImportingLibrary {
        const ORDINAL: u64 = 2914965219653596920;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `ImportsSameNameContext` client sender.
pub trait ImportsSameNameContextClientSender {
    type Transport: ::fidl_next::Transport;

    fn always_denied<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest,
        >;

    fn unattributed(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn always_appears_in_importing_library(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> ImportsSameNameContextClientSender
    for ::fidl_next::ClientSender<___T, ImportsSameNameContext>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn always_denied<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest,
        >,
    {
        self.as_untyped().send_one_way(6808317417318106526, request)
    }

    fn unattributed(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(475191379775102607, ())
    }

    fn always_appears_in_importing_library(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(2914965219653596920, ())
    }
}

/// A client handler for the ImportsSameNameContext protocol.
///
/// See [`ImportsSameNameContext`] for more details.
pub trait ImportsSameNameContextClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ImportsSameNameContext
where
    ___T: ::fidl_next::Transport,
    ___H: ImportsSameNameContextClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ImportsSameNameContext` server sender.
pub trait ImportsSameNameContextServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ImportsSameNameContextServerSender
    for ::fidl_next::ServerSender<___T, ImportsSameNameContext>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ImportsSameNameContext protocol.
///
/// See [`ImportsSameNameContext`] for more details.
pub trait ImportsSameNameContextServerHandler<___T: ::fidl_next::Transport> {
    fn always_denied(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>,

        request: ::fidl_next::Request<___T, imports_same_name_context::AlwaysDenied>,
    );

    fn unattributed(&mut self, sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>);

    fn always_appears_in_importing_library(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ImportsSameNameContext
where
    ___T: ::fidl_next::Transport,
    ___H: ImportsSameNameContextServerHandler<___T>,

    <imports_same_name_context::AlwaysDenied as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6808317417318106526 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.always_denied(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            475191379775102607 => {
                handler.unattributed(sender);
            }

            2914965219653596920 => {
                handler.always_appears_in_importing_library(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

impl ::fidl_next::Encodable for MemberOnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireMemberOnlyAppearsInImportingLibrary,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireMemberOnlyAppearsInImportingLibrary;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MemberOnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for MemberOnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for MemberOnlyAppearsInImportingLibrary {
    type EncodedOption = ::fidl_next::WireBox<'static, WireMemberOnlyAppearsInImportingLibrary>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for MemberOnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MemberOnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for MemberOnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MemberOnlyAppearsInImportingLibrary: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireMemberOnlyAppearsInImportingLibrary>
    for MemberOnlyAppearsInImportingLibrary
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireMemberOnlyAppearsInImportingLibrary,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::FromWire<bool>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireMemberOnlyAppearsInImportingLibrary) -> Self {
        Self { a: ::fidl_next::FromWire::from_wire(wire.a) }
    }
}

impl ::fidl_next::FromWireRef<WireMemberOnlyAppearsInImportingLibrary>
    for MemberOnlyAppearsInImportingLibrary
{
    #[inline]
    fn from_wire_ref(wire: &WireMemberOnlyAppearsInImportingLibrary) -> Self {
        Self { a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a) }
    }
}

/// The wire type corresponding to [`MemberOnlyAppearsInImportingLibrary`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

unsafe impl ::fidl_next::Wire for WireMemberOnlyAppearsInImportingLibrary {
    type Decoded<'de> = WireMemberOnlyAppearsInImportingLibrary;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMemberOnlyAppearsInImportingLibrary
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct OnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::MemberOnlyAppearsInImportingLibrary,
}

impl ::fidl_next::Encodable for OnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireOnlyAppearsInImportingLibrary,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::MemberOnlyAppearsInImportingLibrary as ::fidl_next::Encodable
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    type Encoded = WireOnlyAppearsInImportingLibrary;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                member_only_appears_in_importing_library,

            } = out;
        }

        ::fidl_next::Encode::encode(
            self.member_only_appears_in_importing_library,
            encoder,
            member_only_appears_in_importing_library,
        )?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                member_only_appears_in_importing_library,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(
            &self.member_only_appears_in_importing_library,
            encoder,
            member_only_appears_in_importing_library,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for OnlyAppearsInImportingLibrary {
    type EncodedOption = ::fidl_next::WireBox<'static, WireOnlyAppearsInImportingLibrary>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for OnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for OnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyAppearsInImportingLibrary: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireOnlyAppearsInImportingLibrary> for OnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireOnlyAppearsInImportingLibrary,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::MemberOnlyAppearsInImportingLibrary as ::fidl_next::FromWire<
                crate::WireMemberOnlyAppearsInImportingLibrary,
            >>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireOnlyAppearsInImportingLibrary) -> Self {
        Self {
            member_only_appears_in_importing_library: ::fidl_next::FromWire::from_wire(
                wire.member_only_appears_in_importing_library,
            ),
        }
    }
}

impl ::fidl_next::FromWireRef<WireOnlyAppearsInImportingLibrary> for OnlyAppearsInImportingLibrary {
    #[inline]
    fn from_wire_ref(wire: &WireOnlyAppearsInImportingLibrary) -> Self {
        Self {
            member_only_appears_in_importing_library: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.member_only_appears_in_importing_library,
            ),
        }
    }
}

/// The wire type corresponding to [`OnlyAppearsInImportingLibrary`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::WireMemberOnlyAppearsInImportingLibrary,
}

unsafe impl ::fidl_next::Wire for WireOnlyAppearsInImportingLibrary {
    type Decoded<'de> = WireOnlyAppearsInImportingLibrary;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyAppearsInImportingLibrary
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut member_only_appears_in_importing_library,

            } = slot;
        }

        ::fidl_next::Decode::decode(member_only_appears_in_importing_library.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the OnlyCppAndDeps protocol.
#[derive(Debug)]
pub struct OnlyCppAndDeps;

pub mod only_cpp_and_deps {
    pub mod prelude {
        pub use crate::{
            only_cpp_and_deps, OnlyCppAndDeps, OnlyCppAndDepsClientHandler,
            OnlyCppAndDepsClientSender, OnlyCppAndDepsServerHandler, OnlyCppAndDepsServerSender,
        };
    }
}

/// A helper trait for the `OnlyCppAndDeps` client sender.
pub trait OnlyCppAndDepsClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyCppAndDepsClientSender for ::fidl_next::ClientSender<___T, OnlyCppAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the OnlyCppAndDeps protocol.
///
/// See [`OnlyCppAndDeps`] for more details.
pub trait OnlyCppAndDepsClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for OnlyCppAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyCppAndDepsClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `OnlyCppAndDeps` server sender.
pub trait OnlyCppAndDepsServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyCppAndDepsServerSender for ::fidl_next::ServerSender<___T, OnlyCppAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the OnlyCppAndDeps protocol.
///
/// See [`OnlyCppAndDeps`] for more details.
pub trait OnlyCppAndDepsServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for OnlyCppAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyCppAndDepsServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum OnlyDart {
    A = 1,
}

impl ::fidl_next::Encodable for OnlyDart {
    type Encoded = WireOnlyDart;
}
impl ::std::convert::TryFrom<u32> for OnlyDart {
    type Error = ::fidl_next::UnknownStrictEnumMemberError;
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::A),

            _ => Err(Self::Error::new(value.into())),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyDart
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OnlyDart
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyDart { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::A => 1,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireOnlyDart> for OnlyDart {
    fn from(wire: WireOnlyDart) -> Self {
        match u32::from(wire.value) {
            1 => Self::A,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWire<WireOnlyDart> for OnlyDart {
    #[inline]
    fn from_wire(wire: WireOnlyDart) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireOnlyDart> for OnlyDart {
    #[inline]
    fn from_wire_ref(wire: &WireOnlyDart) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`OnlyDart`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireOnlyDart {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireOnlyDart {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireOnlyDart {
    pub const A: WireOnlyDart = WireOnlyDart { value: ::fidl_next::WireU32(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyDart
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlyDart> for WireOnlyDart {
    fn from(natural: OnlyDart) -> Self {
        match natural {
            OnlyDart::A => WireOnlyDart::A,
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct OnlyGo {}

impl ::fidl_next::Encodable for OnlyGo {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireOnlyGo> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireOnlyGo;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyGo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OnlyGo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for OnlyGo {
    type EncodedOption = ::fidl_next::WireBox<'static, WireOnlyGo>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for OnlyGo
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyGo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for OnlyGo
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyGo: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireOnlyGo> for OnlyGo {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireOnlyGo, Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn from_wire(wire: WireOnlyGo) -> Self {
        Self {}
    }
}

impl ::fidl_next::FromWireRef<WireOnlyGo> for OnlyGo {
    #[inline]
    fn from_wire_ref(wire: &WireOnlyGo) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`OnlyGo`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyGo {}

unsafe impl ::fidl_next::Wire for WireOnlyGo {
    type Decoded<'de> = WireOnlyGo;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyGo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

/// The type corresponding to the OnlyHlcpp service.
#[derive(Debug)]
pub struct OnlyHlcpp;

impl ::fidl_next::Service for OnlyHlcpp {
    const SERVICE_NAME: &'static str = "test.bindingsdenylist.OnlyHlcpp";
    const MEMBER_NAMES: &'static [&'static str] = &[];
}

/// A helper trait for instances of the `OnlyHlcpp` service.
pub trait OnlyHlcppInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;
}

impl<___I> OnlyHlcppInstance for ::fidl_next::ServiceInstance<___I, OnlyHlcpp>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;
}

#[derive(Clone, Debug)]
pub enum OnlyLlcpp {
    X(u32),
}

impl ::fidl_next::Encodable for OnlyLlcpp {
    type Encoded = WireOnlyLlcpp;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyLlcpp
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyLlcpp { raw, _phantom: _ } = out);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OnlyLlcpp
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyLlcpp { raw, _phantom: _ } = out);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &u32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for OnlyLlcpp {
    type EncodedOption = WireOptionalOnlyLlcpp;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for OnlyLlcpp
where
    ___E: ?Sized,
    OnlyLlcpp: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOnlyLlcpp { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for OnlyLlcpp
where
    ___E: ?Sized,
    OnlyLlcpp: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOnlyLlcpp { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireOnlyLlcpp> for OnlyLlcpp {
    #[inline]
    fn from_wire(wire: WireOnlyLlcpp) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::X(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireOnlyLlcpp> for OnlyLlcpp {
    #[inline]
    fn from_wire_ref(wire: &WireOnlyLlcpp) -> Self {
        match wire.raw.ordinal() {
            1 => Self::X(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalOnlyLlcpp> for Box<OnlyLlcpp> {
    #[inline]
    fn from_wire_option(wire: WireOptionalOnlyLlcpp) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalOnlyLlcpp> for Box<OnlyLlcpp> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalOnlyLlcpp) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`OnlyLlcpp`].
#[repr(transparent)]
pub struct WireOnlyLlcpp {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireOnlyLlcpp {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireU32>() };
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl ::fidl_next::Wire for WireOnlyLlcpp {
    type Decoded<'de> = WireOnlyLlcpp;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod only_llcpp {
    pub enum Ref<'de> {
        X(&'de ::fidl_next::WireU32),
    }
}

impl WireOnlyLlcpp {
    pub fn as_ref(&self) -> crate::only_llcpp::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::only_llcpp::Ref::X(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireOnlyLlcpp {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyLlcpp
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOnlyLlcpp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOnlyLlcpp {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalOnlyLlcpp {
    type Decoded<'de> = WireOptionalOnlyLlcpp;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalOnlyLlcpp {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOnlyLlcpp> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireOnlyLlcpp> {
        if self.is_some() {
            Some(WireOnlyLlcpp { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalOnlyLlcpp {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalOnlyLlcpp {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalOnlyLlcpp
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalOnlyLlcpp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct OnlyPython {}

impl OnlyPython {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for OnlyPython {
    type Encoded = WireOnlyPython<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyPython
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyPython { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OnlyPython
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyPython { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireOnlyPython<'de>> for OnlyPython {
    #[inline]
    fn from_wire(wire: WireOnlyPython<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

impl<'de> ::fidl_next::FromWireRef<WireOnlyPython<'de>> for OnlyPython {
    #[inline]
    fn from_wire_ref(wire: &WireOnlyPython<'de>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`OnlyPython`].
#[repr(C)]
pub struct WireOnlyPython<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireOnlyPython<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireOnlyPython<'static> {
    type Decoded<'de> = WireOnlyPython<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyPython<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireOnlyPython<'de> {}

impl<'de> ::core::fmt::Debug for WireOnlyPython<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OnlyPython").finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct OnlyRust {}

impl OnlyRust {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for OnlyRust {
    type Encoded = WireOnlyRust<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyRust
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyRust { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OnlyRust
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyRust { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireOnlyRust<'de>> for OnlyRust {
    #[inline]
    fn from_wire(wire: WireOnlyRust<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

impl<'de> ::fidl_next::FromWireRef<WireOnlyRust<'de>> for OnlyRust {
    #[inline]
    fn from_wire_ref(wire: &WireOnlyRust<'de>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`OnlyRust`].
#[repr(C)]
pub struct WireOnlyRust<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireOnlyRust<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireOnlyRust<'static> {
    type Decoded<'de> = WireOnlyRust<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyRust<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireOnlyRust<'de> {}

impl<'de> ::core::fmt::Debug for WireOnlyRust<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OnlyRust").finish()
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct OnlySyzkaller: u32 {
        const A = 1;

    }
}

impl ::fidl_next::Encodable for OnlySyzkaller {
    type Encoded = WireOnlySyzkaller;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlySyzkaller
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OnlySyzkaller
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlySyzkaller { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireOnlySyzkaller> for OnlySyzkaller {
    fn from(wire: WireOnlySyzkaller) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::FromWire<WireOnlySyzkaller> for OnlySyzkaller {
    #[inline]
    fn from_wire(wire: WireOnlySyzkaller) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireOnlySyzkaller> for OnlySyzkaller {
    #[inline]
    fn from_wire_ref(wire: &WireOnlySyzkaller) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`OnlySyzkaller`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireOnlySyzkaller {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireOnlySyzkaller {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlySyzkaller
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !OnlySyzkaller::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: OnlySyzkaller::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlySyzkaller> for WireOnlySyzkaller {
    fn from(natural: OnlySyzkaller) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Allowed`
    /// protocol.
    pub type AllowedProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Allowed>;

    impl ::core::convert::From<crate::Allowed> for ::fidl_test_bindingsdenylist::AllowedMarker {
        #[inline]
        fn from(_: crate::Allowed) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `DenyEachBinding`
    /// protocol.
    pub type DenyEachBindingProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::DenyEachBinding>;

    impl ::core::convert::From<crate::DenyEachBinding>
        for ::fidl_test_bindingsdenylist::DenyEachBindingMarker
    {
        #[inline]
        fn from(_: crate::DenyEachBinding) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ImportsSameNameContext`
    /// protocol.
    pub type ImportsSameNameContextProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ImportsSameNameContext>;

    impl ::core::convert::From<crate::ImportsSameNameContext>
        for ::fidl_test_bindingsdenylist::ImportsSameNameContextMarker
    {
        #[inline]
        fn from(_: crate::ImportsSameNameContext) -> Self {
            Self
        }
    }
}
