// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
#[repr(C)]
pub struct AllInstants {
    pub monotonic: i64,

    pub boot: i64,

    pub monotonic_ticks: i64,

    pub boot_ticks: i64,
}

impl ::fidl_next::Encodable for AllInstants {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireAllInstants;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for AllInstants
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                monotonic,
                boot,
                monotonic_ticks,
                boot_ticks,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.monotonic, encoder, monotonic)?;

        ::fidl_next::Encode::encode(&mut self.boot, encoder, boot)?;

        ::fidl_next::Encode::encode(&mut self.monotonic_ticks, encoder, monotonic_ticks)?;

        ::fidl_next::Encode::encode(&mut self.boot_ticks, encoder, boot_ticks)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<AllInstants> {
    type EncodedOption = ::fidl_next::WireBox<WireAllInstants>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<AllInstants>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllInstants: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireAllInstants> for AllInstants {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireAllInstants) -> Self {
        Self {
            monotonic: ::fidl_next::TakeFrom::take_from(&from.monotonic),

            boot: ::fidl_next::TakeFrom::take_from(&from.boot),

            monotonic_ticks: ::fidl_next::TakeFrom::take_from(&from.monotonic_ticks),

            boot_ticks: ::fidl_next::TakeFrom::take_from(&from.boot_ticks),
        }
    }
}

/// The wire type corresponding to [`AllInstants`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireAllInstants {
    pub monotonic: ::fidl_next::WireI64,

    pub boot: ::fidl_next::WireI64,

    pub monotonic_ticks: ::fidl_next::WireI64,

    pub boot_ticks: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::ZeroPadding for WireAllInstants {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireAllInstants
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut monotonic,
                mut boot,
                mut monotonic_ticks,
                mut boot_ticks,

            } = slot;
        }

        ::fidl_next::Decode::decode(monotonic.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(boot.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(monotonic_ticks.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(boot_ticks.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ComplexInstants {
    pub monotonic: Option<[i64; 10]>,

    pub boot: Option<Vec<i64>>,

    pub monotonic_ticks: Option<[i64; 10]>,

    pub boot_ticks: Option<[i64; 10]>,
}

impl ComplexInstants {
    fn __max_ordinal(&self) -> usize {
        if self.monotonic.is_some() {
            return 1;
        }

        if self.boot.is_some() {
            return 2;
        }

        if self.monotonic_ticks.is_some() {
            return 3;
        }

        if self.boot_ticks.is_some() {
            return 4;
        }

        0
    }
}

impl ::fidl_next::Encodable for ComplexInstants {
    type Encoded = WireComplexInstants;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ComplexInstants
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireComplexInstants { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                4 => {
                    if let Some(boot_ticks) = &mut self.boot_ticks {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot_ticks,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(monotonic_ticks) = &mut self.monotonic_ticks {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic_ticks,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                2 => {
                    if let Some(boot) = &mut self.boot {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(monotonic) = &mut self.monotonic {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireComplexInstants> for ComplexInstants {
    #[inline]
    fn take_from(from: &WireComplexInstants) -> Self {
        Self {
            monotonic: from.monotonic().map(::fidl_next::TakeFrom::take_from),

            boot: from.boot().map(::fidl_next::TakeFrom::take_from),

            monotonic_ticks: from.monotonic_ticks().map(::fidl_next::TakeFrom::take_from),

            boot_ticks: from.boot_ticks().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`ComplexInstants`].
#[repr(C)]
pub struct WireComplexInstants {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireComplexInstants {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireComplexInstants
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::WireI64; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<::fidl_next::WireI64>,
                    >(slot.as_mut(), decoder)?;

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::WireI64; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::WireI64; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireComplexInstants {
    pub fn monotonic(&self) -> Option<&[::fidl_next::WireI64; 10]> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn boot(&self) -> Option<&::fidl_next::WireVector<::fidl_next::WireI64>> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn monotonic_ticks(&self) -> Option<&[::fidl_next::WireI64; 10]> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn boot_ticks(&self) -> Option<&[::fidl_next::WireI64; 10]> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireComplexInstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ComplexInstants")
            .field("monotonic", &self.monotonic())
            .field("boot", &self.boot())
            .field("monotonic_ticks", &self.monotonic_ticks())
            .field("boot_ticks", &self.boot_ticks())
            .finish()
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::TakeFrom<crate::WireAllInstants> for ::fidl_test_time::AllInstants {
        #[inline]
        fn take_from(from: &crate::WireAllInstants) -> Self {
            Self {
                monotonic: ::fidl_next::TakeFrom::take_from(&from.monotonic),

                boot: ::fidl_next::TakeFrom::take_from(&from.boot),

                monotonic_ticks: ::fidl_next::TakeFrom::take_from(&from.monotonic_ticks),

                boot_ticks: ::fidl_next::TakeFrom::take_from(&from.boot_ticks),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireComplexInstants> for ::fidl_test_time::ComplexInstants {
        #[inline]
        fn take_from(from: &crate::WireComplexInstants) -> Self {
            Self {
                monotonic: from.monotonic().map(::fidl_next::TakeFrom::take_from),

                boot: from.boot().map(::fidl_next::TakeFrom::take_from),

                monotonic_ticks: from.monotonic_ticks().map(::fidl_next::TakeFrom::take_from),

                boot_ticks: from.boot_ticks().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }
}
