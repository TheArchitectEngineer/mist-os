// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
#[repr(C)]
pub struct Empty {}

impl ::fidl_next::Encodable for Empty {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireEmpty;
}

impl<___E> ::fidl_next::Encode<___E> for Empty
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Empty> {
    type EncodedOption = ::fidl_next::WireBox<WireEmpty>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Empty>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Empty: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireEmpty> for Empty {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireEmpty) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`Empty`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireEmpty {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEmpty
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum EmptyFlexibleUnion {
    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for EmptyFlexibleUnion {
    type Encoded = WireEmptyFlexibleUnion;
}

impl<___E> ::fidl_next::Encode<___E> for EmptyFlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEmptyFlexibleUnion { raw } = slot);

        match self {
            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<EmptyFlexibleUnion> {
    type EncodedOption = WireOptionalEmptyFlexibleUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<EmptyFlexibleUnion>
where
    ___E: ?Sized,
    EmptyFlexibleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalEmptyFlexibleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireEmptyFlexibleUnion> for EmptyFlexibleUnion {
    #[inline]
    fn take_from(from: &WireEmptyFlexibleUnion) -> Self {
        match from.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalEmptyFlexibleUnion> for Option<Box<EmptyFlexibleUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalEmptyFlexibleUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`EmptyFlexibleUnion`].
#[repr(transparent)]
pub struct WireEmptyFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod empty_flexible_union {
    pub enum Ref {
        UnknownOrdinal_(u64),
    }
}

impl WireEmptyFlexibleUnion {
    pub fn as_ref(&self) -> crate::empty_flexible_union::Ref {
        match self.raw.ordinal() {
            unknown => crate::empty_flexible_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireEmptyFlexibleUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEmptyFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireEmptyFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalEmptyFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalEmptyFlexibleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireEmptyFlexibleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalEmptyFlexibleUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalEmptyFlexibleUnion { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalEmptyFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalEmptyFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitFlexibleUnion {
    I(i64),

    F(f32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ExplicitFlexibleUnion {
    type Encoded = WireExplicitFlexibleUnion;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitFlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFlexibleUnion { raw } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 4, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitFlexibleUnion> {
    type EncodedOption = WireOptionalExplicitFlexibleUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitFlexibleUnion>
where
    ___E: ?Sized,
    ExplicitFlexibleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFlexibleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExplicitFlexibleUnion> for ExplicitFlexibleUnion {
    #[inline]
    fn take_from(from: &WireExplicitFlexibleUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            4 => Self::F(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalExplicitFlexibleUnion>
    for Option<Box<ExplicitFlexibleUnion>>
{
    #[inline]
    fn take_from(from: &WireOptionalExplicitFlexibleUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitFlexibleUnion`].
#[repr(transparent)]
pub struct WireExplicitFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod explicit_flexible_union {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::WireI64),

        F(&'union ::fidl_next::WireF32),

        UnknownOrdinal_(u64),
    }
}

impl WireExplicitFlexibleUnion {
    pub fn as_ref(&self) -> crate::explicit_flexible_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => {
                crate::explicit_flexible_union::Ref::I(unsafe { self.raw.get().deref_unchecked() })
            }

            4 => {
                crate::explicit_flexible_union::Ref::F(unsafe { self.raw.get().deref_unchecked() })
            }

            unknown => crate::explicit_flexible_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireExplicitFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireF32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalExplicitFlexibleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFlexibleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalExplicitFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitFoo {
    I(i32),

    S(String),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ExplicitFoo {
    type Encoded = WireExplicitFoo;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFoo { raw } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitFoo> {
    type EncodedOption = WireOptionalExplicitFoo;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitFoo>
where
    ___E: ?Sized,
    ExplicitFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExplicitFoo> for ExplicitFoo {
    #[inline]
    fn take_from(from: &WireExplicitFoo) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalExplicitFoo> for Option<Box<ExplicitFoo>> {
    #[inline]
    fn take_from(from: &WireOptionalExplicitFoo) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitFoo`].
#[repr(transparent)]
pub struct WireExplicitFoo {
    raw: ::fidl_next::RawWireUnion,
}

pub mod explicit_foo {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::WireI32),

        S(&'union ::fidl_next::WireString),

        UnknownOrdinal_(u64),
    }
}

impl WireExplicitFoo {
    pub fn as_ref(&self) -> crate::explicit_foo::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::explicit_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::explicit_foo::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireExplicitFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFoo {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalExplicitFoo {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFoo> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalExplicitFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct Pizza {
    pub toppings: Vec<String>,
}

impl ::fidl_next::Encodable for Pizza {
    type Encoded = WirePizza;
}

impl<___E> ::fidl_next::Encode<___E> for Pizza
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                toppings,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.toppings, encoder, toppings)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Pizza> {
    type EncodedOption = ::fidl_next::WireBox<WirePizza>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Pizza>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pizza: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePizza> for Pizza {
    #[inline]
    fn take_from(from: &WirePizza) -> Self {
        Self { toppings: ::fidl_next::TakeFrom::take_from(&from.toppings) }
    }
}

/// The wire type corersponding to [`Pizza`].
#[derive(Debug)]
#[repr(C)]
pub struct WirePizza {
    pub toppings: ::fidl_next::WireVector<::fidl_next::WireString>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePizza
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut toppings,

            } = slot;
        }

        ::fidl_next::Decode::decode(toppings.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Pasta {
    pub sauce: String,
}

impl ::fidl_next::Encodable for Pasta {
    type Encoded = WirePasta;
}

impl<___E> ::fidl_next::Encode<___E> for Pasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                sauce,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.sauce, encoder, sauce)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Pasta> {
    type EncodedOption = ::fidl_next::WireBox<WirePasta>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Pasta>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePasta> for Pasta {
    #[inline]
    fn take_from(from: &WirePasta) -> Self {
        Self { sauce: ::fidl_next::TakeFrom::take_from(&from.sauce) }
    }
}

/// The wire type corersponding to [`Pasta`].
#[derive(Debug)]
#[repr(C)]
pub struct WirePasta {
    pub sauce: ::fidl_next::WireString,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut sauce,

            } = slot;
        }

        ::fidl_next::Decode::decode(sauce.as_mut(), decoder)?;

        let sauce = unsafe { sauce.deref_unchecked() };

        if sauce.len() > 16 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: sauce.len() as u64,
                limit: 16,
            });
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitPizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for ExplicitPizzaOrPasta {
    type Encoded = WireExplicitPizzaOrPasta;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitPizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitPizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 4, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitPizzaOrPasta> {
    type EncodedOption = WireOptionalExplicitPizzaOrPasta;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitPizzaOrPasta>
where
    ___E: ?Sized,
    ExplicitPizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitPizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExplicitPizzaOrPasta> for ExplicitPizzaOrPasta {
    #[inline]
    fn take_from(from: &WireExplicitPizzaOrPasta) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            4 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalExplicitPizzaOrPasta> for Option<Box<ExplicitPizzaOrPasta>> {
    #[inline]
    fn take_from(from: &WireOptionalExplicitPizzaOrPasta) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitPizzaOrPasta`].
#[repr(transparent)]
pub struct WireExplicitPizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

pub mod explicit_pizza_or_pasta {
    pub enum Ref<'union> {
        Pizza(&'union crate::WirePizza),

        Pasta(&'union crate::WirePasta),
    }
}

impl WireExplicitPizzaOrPasta {
    pub fn as_ref(&self) -> crate::explicit_pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked()
            }),

            4 => crate::explicit_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitPizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireExplicitPizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitPizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalExplicitPizzaOrPasta {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitPizzaOrPasta> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitPizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalExplicitPizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitStrictFoo {
    I(i32),

    S(String),
}

impl ::fidl_next::Encodable for ExplicitStrictFoo {
    type Encoded = WireExplicitStrictFoo;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitStrictFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitStrictFoo { raw } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitStrictFoo> {
    type EncodedOption = WireOptionalExplicitStrictFoo;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitStrictFoo>
where
    ___E: ?Sized,
    ExplicitStrictFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitStrictFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExplicitStrictFoo> for ExplicitStrictFoo {
    #[inline]
    fn take_from(from: &WireExplicitStrictFoo) -> Self {
        match from.raw.ordinal() {
            2 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalExplicitStrictFoo> for Option<Box<ExplicitStrictFoo>> {
    #[inline]
    fn take_from(from: &WireOptionalExplicitStrictFoo) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitStrictFoo`].
#[repr(transparent)]
pub struct WireExplicitStrictFoo {
    raw: ::fidl_next::RawWireUnion,
}

pub mod explicit_strict_foo {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::WireI32),

        S(&'union ::fidl_next::WireString),
    }
}

impl WireExplicitStrictFoo {
    pub fn as_ref(&self) -> crate::explicit_strict_foo::Ref<'_> {
        match self.raw.ordinal() {
            2 => crate::explicit_strict_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::explicit_strict_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitStrictFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireExplicitStrictFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitStrictFoo {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalExplicitStrictFoo {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitStrictFoo> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitStrictFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalExplicitStrictFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitUnion {
    Primitive(i32),

    StringNeedsConstructor(String),
}

impl ::fidl_next::Encodable for ExplicitUnion {
    type Encoded = WireExplicitUnion;
}

impl<___E> ::fidl_next::Encode<___E> for ExplicitUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExplicitUnion> {
    type EncodedOption = WireOptionalExplicitUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExplicitUnion>
where
    ___E: ?Sized,
    ExplicitUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExplicitUnion> for ExplicitUnion {
    #[inline]
    fn take_from(from: &WireExplicitUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalExplicitUnion> for Option<Box<ExplicitUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalExplicitUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitUnion`].
#[repr(transparent)]
pub struct WireExplicitUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod explicit_union {
    pub enum Ref<'union> {
        Primitive(&'union ::fidl_next::WireI32),

        StringNeedsConstructor(&'union ::fidl_next::WireString),
    }
}

impl WireExplicitUnion {
    pub fn as_ref(&self) -> crate::explicit_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_union::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::explicit_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireExplicitUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalExplicitUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalExplicitUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FieldCollision {
    FieldCollisionTag(i32),
}

impl ::fidl_next::Encodable for FieldCollision {
    type Encoded = WireFieldCollision;
}

impl<___E> ::fidl_next::Encode<___E> for FieldCollision
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFieldCollision { raw } = slot);

        match self {
            Self::FieldCollisionTag(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FieldCollision> {
    type EncodedOption = WireOptionalFieldCollision;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FieldCollision>
where
    ___E: ?Sized,
    FieldCollision: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFieldCollision { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFieldCollision> for FieldCollision {
    #[inline]
    fn take_from(from: &WireFieldCollision) -> Self {
        match from.raw.ordinal() {
            1 => Self::FieldCollisionTag(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalFieldCollision> for Option<Box<FieldCollision>> {
    #[inline]
    fn take_from(from: &WireOptionalFieldCollision) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FieldCollision`].
#[repr(transparent)]
pub struct WireFieldCollision {
    raw: ::fidl_next::RawWireUnion,
}

pub mod field_collision {
    pub enum Ref<'union> {
        FieldCollisionTag(&'union ::fidl_next::WireI32),
    }
}

impl WireFieldCollision {
    pub fn as_ref(&self) -> crate::field_collision::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::field_collision::Ref::FieldCollisionTag(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireFieldCollision {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFieldCollision
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireFieldCollision {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFieldCollision {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalFieldCollision {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFieldCollision> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalFieldCollision {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalFieldCollision { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireI32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFieldCollision
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalFieldCollision {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexibleFoo {
    S(String),

    I(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for FlexibleFoo {
    type Encoded = WireFlexibleFoo;
}

impl<___E> ::fidl_next::Encode<___E> for FlexibleFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleFoo { raw } = slot);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FlexibleFoo> {
    type EncodedOption = WireOptionalFlexibleFoo;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FlexibleFoo>
where
    ___E: ?Sized,
    FlexibleFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFlexibleFoo> for FlexibleFoo {
    #[inline]
    fn take_from(from: &WireFlexibleFoo) -> Self {
        match from.raw.ordinal() {
            1 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalFlexibleFoo> for Option<Box<FlexibleFoo>> {
    #[inline]
    fn take_from(from: &WireOptionalFlexibleFoo) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexibleFoo`].
#[repr(transparent)]
pub struct WireFlexibleFoo {
    raw: ::fidl_next::RawWireUnion,
}

pub mod flexible_foo {
    pub enum Ref<'union> {
        S(&'union ::fidl_next::WireString),

        I(&'union ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireFlexibleFoo {
    pub fn as_ref(&self) -> crate::flexible_foo::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::flexible_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::flexible_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::flexible_foo::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlexibleFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireFlexibleFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleFoo {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalFlexibleFoo {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleFoo> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFlexibleFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalFlexibleFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexiblePizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for FlexiblePizzaOrPasta {
    type Encoded = WireFlexiblePizzaOrPasta;
}

impl<___E> ::fidl_next::Encode<___E> for FlexiblePizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexiblePizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FlexiblePizzaOrPasta> {
    type EncodedOption = WireOptionalFlexiblePizzaOrPasta;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FlexiblePizzaOrPasta>
where
    ___E: ?Sized,
    FlexiblePizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexiblePizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFlexiblePizzaOrPasta> for FlexiblePizzaOrPasta {
    #[inline]
    fn take_from(from: &WireFlexiblePizzaOrPasta) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalFlexiblePizzaOrPasta> for Option<Box<FlexiblePizzaOrPasta>> {
    #[inline]
    fn take_from(from: &WireOptionalFlexiblePizzaOrPasta) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexiblePizzaOrPasta`].
#[repr(transparent)]
pub struct WireFlexiblePizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

pub mod flexible_pizza_or_pasta {
    pub enum Ref<'union> {
        Pizza(&'union crate::WirePizza),

        Pasta(&'union crate::WirePasta),

        UnknownOrdinal_(u64),
    }
}

impl WireFlexiblePizzaOrPasta {
    pub fn as_ref(&self) -> crate::flexible_pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::flexible_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::flexible_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::flexible_pizza_or_pasta::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlexiblePizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireFlexiblePizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexiblePizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalFlexiblePizzaOrPasta {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexiblePizzaOrPasta> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFlexiblePizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalFlexiblePizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexibleUnion {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for FlexibleUnion {
    type Encoded = WireFlexibleUnion;
}

impl<___E> ::fidl_next::Encode<___E> for FlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<FlexibleUnion> {
    type EncodedOption = WireOptionalFlexibleUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<FlexibleUnion>
where
    ___E: ?Sized,
    FlexibleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireFlexibleUnion> for FlexibleUnion {
    #[inline]
    fn take_from(from: &WireFlexibleUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalFlexibleUnion> for Option<Box<FlexibleUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalFlexibleUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexibleUnion`].
#[repr(transparent)]
pub struct WireFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod flexible_union {
    pub enum Ref<'union> {
        Primitive(&'union ::fidl_next::WireI32),

        StringNeedsConstructor(&'union ::fidl_next::WireString),

        VectorStringAlsoNeedsConstructor(&'union ::fidl_next::WireVector<::fidl_next::WireString>),

        UnknownOrdinal_(u64),
    }
}

impl WireFlexibleUnion {
    pub fn as_ref(&self) -> crate::flexible_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::flexible_union::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::flexible_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => crate::flexible_union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::flexible_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<::fidl_next::WireString>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalFlexibleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum NewerSimpleUnion {
    I(i64),

    S(String),

    V(Vec<String>),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for NewerSimpleUnion {
    type Encoded = WireNewerSimpleUnion;
}

impl<___E> ::fidl_next::Encode<___E> for NewerSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireNewerSimpleUnion { raw } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<NewerSimpleUnion> {
    type EncodedOption = WireOptionalNewerSimpleUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<NewerSimpleUnion>
where
    ___E: ?Sized,
    NewerSimpleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalNewerSimpleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireNewerSimpleUnion> for NewerSimpleUnion {
    #[inline]
    fn take_from(from: &WireNewerSimpleUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::V(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalNewerSimpleUnion> for Option<Box<NewerSimpleUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalNewerSimpleUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`NewerSimpleUnion`].
#[repr(transparent)]
pub struct WireNewerSimpleUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod newer_simple_union {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::WireI64),

        S(&'union ::fidl_next::WireString),

        V(&'union ::fidl_next::WireVector<::fidl_next::WireString>),

        UnknownOrdinal_(u64),
    }
}

impl WireNewerSimpleUnion {
    pub fn as_ref(&self) -> crate::newer_simple_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::newer_simple_union::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::newer_simple_union::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::newer_simple_union::Ref::V(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::newer_simple_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireNewerSimpleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireNewerSimpleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<::fidl_next::WireString>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalNewerSimpleUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalNewerSimpleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireNewerSimpleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalNewerSimpleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalNewerSimpleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct NullableUnionStruct {
    pub the_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for NullableUnionStruct {
    type Encoded = WireNullableUnionStruct;
}

impl<___E> ::fidl_next::Encode<___E> for NullableUnionStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                the_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.the_union, encoder, the_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<NullableUnionStruct> {
    type EncodedOption = ::fidl_next::WireBox<WireNullableUnionStruct>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<NullableUnionStruct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    NullableUnionStruct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireNullableUnionStruct> for NullableUnionStruct {
    #[inline]
    fn take_from(from: &WireNullableUnionStruct) -> Self {
        Self { the_union: ::fidl_next::TakeFrom::take_from(&from.the_union) }
    }
}

/// The wire type corersponding to [`NullableUnionStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireNullableUnionStruct {
    pub the_union: crate::WireOptionalUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireNullableUnionStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut the_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(the_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum OlderSimpleUnion {
    I(i64),

    F(f32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for OlderSimpleUnion {
    type Encoded = WireOlderSimpleUnion;
}

impl<___E> ::fidl_next::Encode<___E> for OlderSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOlderSimpleUnion { raw } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OlderSimpleUnion> {
    type EncodedOption = WireOptionalOlderSimpleUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<OlderSimpleUnion>
where
    ___E: ?Sized,
    OlderSimpleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOlderSimpleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOlderSimpleUnion> for OlderSimpleUnion {
    #[inline]
    fn take_from(from: &WireOlderSimpleUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::F(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalOlderSimpleUnion> for Option<Box<OlderSimpleUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalOlderSimpleUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`OlderSimpleUnion`].
#[repr(transparent)]
pub struct WireOlderSimpleUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod older_simple_union {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::WireI64),

        F(&'union ::fidl_next::WireF32),

        UnknownOrdinal_(u64),
    }
}

impl WireOlderSimpleUnion {
    pub fn as_ref(&self) -> crate::older_simple_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::older_simple_union::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::older_simple_union::Ref::F(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::older_simple_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOlderSimpleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOlderSimpleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireF32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOlderSimpleUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalOlderSimpleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOlderSimpleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalOlderSimpleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalOlderSimpleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum PizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for PizzaOrPasta {
    type Encoded = WirePizzaOrPasta;
}

impl<___E> ::fidl_next::Encode<___E> for PizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WirePizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<PizzaOrPasta> {
    type EncodedOption = WireOptionalPizzaOrPasta;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<PizzaOrPasta>
where
    ___E: ?Sized,
    PizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalPizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePizzaOrPasta> for PizzaOrPasta {
    #[inline]
    fn take_from(from: &WirePizzaOrPasta) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalPizzaOrPasta> for Option<Box<PizzaOrPasta>> {
    #[inline]
    fn take_from(from: &WireOptionalPizzaOrPasta) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`PizzaOrPasta`].
#[repr(transparent)]
pub struct WirePizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

pub mod pizza_or_pasta {
    pub enum Ref<'union> {
        Pizza(&'union crate::WirePizza),

        Pasta(&'union crate::WirePasta),
    }
}

impl WirePizzaOrPasta {
    pub fn as_ref(&self) -> crate::pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::pizza_or_pasta::Ref::Pizza(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::pizza_or_pasta::Ref::Pasta(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WirePizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalPizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalPizzaOrPasta {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WirePizzaOrPasta> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalPizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalPizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ReverseOrdinalUnion {
    First(u32),

    Second(u32),
}

impl ::fidl_next::Encodable for ReverseOrdinalUnion {
    type Encoded = WireReverseOrdinalUnion;
}

impl<___E> ::fidl_next::Encode<___E> for ReverseOrdinalUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireReverseOrdinalUnion { raw } = slot);

        match self {
            Self::First(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::Second(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ReverseOrdinalUnion> {
    type EncodedOption = WireOptionalReverseOrdinalUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ReverseOrdinalUnion>
where
    ___E: ?Sized,
    ReverseOrdinalUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalReverseOrdinalUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireReverseOrdinalUnion> for ReverseOrdinalUnion {
    #[inline]
    fn take_from(from: &WireReverseOrdinalUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::First(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Second(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalReverseOrdinalUnion> for Option<Box<ReverseOrdinalUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalReverseOrdinalUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ReverseOrdinalUnion`].
#[repr(transparent)]
pub struct WireReverseOrdinalUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod reverse_ordinal_union {
    pub enum Ref<'union> {
        First(&'union ::fidl_next::WireU32),

        Second(&'union ::fidl_next::WireU32),
    }
}

impl WireReverseOrdinalUnion {
    pub fn as_ref(&self) -> crate::reverse_ordinal_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::reverse_ordinal_union::Ref::First(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::reverse_ordinal_union::Ref::Second(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireReverseOrdinalUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireReverseOrdinalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireReverseOrdinalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalReverseOrdinalUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalReverseOrdinalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireReverseOrdinalUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalReverseOrdinalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalReverseOrdinalUnion { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalReverseOrdinalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalReverseOrdinalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictBoundedUnion {
    V(Vec<u8>),
}

impl ::fidl_next::Encodable for StrictBoundedUnion {
    type Encoded = WireStrictBoundedUnion;
}

impl<___E> ::fidl_next::Encode<___E> for StrictBoundedUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictBoundedUnion { raw } = slot);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<u8>>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictBoundedUnion> {
    type EncodedOption = WireOptionalStrictBoundedUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictBoundedUnion>
where
    ___E: ?Sized,
    StrictBoundedUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictBoundedUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStrictBoundedUnion> for StrictBoundedUnion {
    #[inline]
    fn take_from(from: &WireStrictBoundedUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::V(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalStrictBoundedUnion> for Option<Box<StrictBoundedUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalStrictBoundedUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictBoundedUnion`].
#[repr(transparent)]
pub struct WireStrictBoundedUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod strict_bounded_union {
    pub enum Ref<'union> {
        V(&'union ::fidl_next::WireVector<u8>),
    }
}

impl WireStrictBoundedUnion {
    pub fn as_ref(&self) -> crate::strict_bounded_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_bounded_union::Ref::V(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictBoundedUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireVector<u8>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireStrictBoundedUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireVector<u8>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictBoundedUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalStrictBoundedUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictBoundedUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictBoundedUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireVector<u8>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalStrictBoundedUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictFoo {
    S(String),

    I(i32),
}

impl ::fidl_next::Encodable for StrictFoo {
    type Encoded = WireStrictFoo;
}

impl<___E> ::fidl_next::Encode<___E> for StrictFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictFoo { raw } = slot);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictFoo> {
    type EncodedOption = WireOptionalStrictFoo;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictFoo>
where
    ___E: ?Sized,
    StrictFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStrictFoo> for StrictFoo {
    #[inline]
    fn take_from(from: &WireStrictFoo) -> Self {
        match from.raw.ordinal() {
            1 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalStrictFoo> for Option<Box<StrictFoo>> {
    #[inline]
    fn take_from(from: &WireOptionalStrictFoo) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictFoo`].
#[repr(transparent)]
pub struct WireStrictFoo {
    raw: ::fidl_next::RawWireUnion,
}

pub mod strict_foo {
    pub enum Ref<'union> {
        S(&'union ::fidl_next::WireString),

        I(&'union ::fidl_next::WireI32),
    }
}

impl WireStrictFoo {
    pub fn as_ref(&self) -> crate::strict_foo::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_foo::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::strict_foo::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireStrictFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictFoo {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalStrictFoo {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictFoo> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictFoo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalStrictFoo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictPizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for StrictPizzaOrPasta {
    type Encoded = WireStrictPizzaOrPasta;
}

impl<___E> ::fidl_next::Encode<___E> for StrictPizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictPizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictPizzaOrPasta> {
    type EncodedOption = WireOptionalStrictPizzaOrPasta;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictPizzaOrPasta>
where
    ___E: ?Sized,
    StrictPizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictPizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStrictPizzaOrPasta> for StrictPizzaOrPasta {
    #[inline]
    fn take_from(from: &WireStrictPizzaOrPasta) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Pasta(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalStrictPizzaOrPasta> for Option<Box<StrictPizzaOrPasta>> {
    #[inline]
    fn take_from(from: &WireOptionalStrictPizzaOrPasta) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictPizzaOrPasta`].
#[repr(transparent)]
pub struct WireStrictPizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

pub mod strict_pizza_or_pasta {
    pub enum Ref<'union> {
        Pizza(&'union crate::WirePizza),

        Pasta(&'union crate::WirePasta),
    }
}

impl WireStrictPizzaOrPasta {
    pub fn as_ref(&self) -> crate::strict_pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::strict_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictPizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireStrictPizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictPizzaOrPasta {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalStrictPizzaOrPasta {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictPizzaOrPasta> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictPizzaOrPasta
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalStrictPizzaOrPasta {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictSimpleUnion {
    I(i32),

    F(f32),

    S(String),
}

impl ::fidl_next::Encodable for StrictSimpleUnion {
    type Encoded = WireStrictSimpleUnion;
}

impl<___E> ::fidl_next::Encode<___E> for StrictSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictSimpleUnion { raw } = slot);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictSimpleUnion> {
    type EncodedOption = WireOptionalStrictSimpleUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictSimpleUnion>
where
    ___E: ?Sized,
    StrictSimpleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictSimpleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStrictSimpleUnion> for StrictSimpleUnion {
    #[inline]
    fn take_from(from: &WireStrictSimpleUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::F(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::S(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalStrictSimpleUnion> for Option<Box<StrictSimpleUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalStrictSimpleUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictSimpleUnion`].
#[repr(transparent)]
pub struct WireStrictSimpleUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod strict_simple_union {
    pub enum Ref<'union> {
        I(&'union ::fidl_next::WireI32),

        F(&'union ::fidl_next::WireF32),

        S(&'union ::fidl_next::WireString),
    }
}

impl WireStrictSimpleUnion {
    pub fn as_ref(&self) -> crate::strict_simple_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_simple_union::Ref::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::strict_simple_union::Ref::F(unsafe { self.raw.get().deref_unchecked() }),

            3 => crate::strict_simple_union::Ref::S(unsafe { self.raw.get().deref_unchecked() }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictSimpleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireStrictSimpleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireF32>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictSimpleUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalStrictSimpleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictSimpleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictSimpleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            3 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalStrictSimpleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictUnion {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),
}

impl ::fidl_next::Encodable for StrictUnion {
    type Encoded = WireStrictUnion;
}

impl<___E> ::fidl_next::Encode<___E> for StrictUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StrictUnion> {
    type EncodedOption = WireOptionalStrictUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StrictUnion>
where
    ___E: ?Sized,
    StrictUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStrictUnion> for StrictUnion {
    #[inline]
    fn take_from(from: &WireStrictUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalStrictUnion> for Option<Box<StrictUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalStrictUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictUnion`].
#[repr(transparent)]
pub struct WireStrictUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod strict_union {
    pub enum Ref<'union> {
        Primitive(&'union ::fidl_next::WireI32),

        StringNeedsConstructor(&'union ::fidl_next::WireString),

        VectorStringAlsoNeedsConstructor(&'union ::fidl_next::WireVector<::fidl_next::WireString>),
    }
}

impl WireStrictUnion {
    pub fn as_ref(&self) -> crate::strict_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_union::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::strict_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => crate::strict_union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireStrictUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<::fidl_next::WireString>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalStrictUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalStrictUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct StructWithNullableUnion {
    pub x1: Option<Box<crate::OlderSimpleUnion>>,
}

impl ::fidl_next::Encodable for StructWithNullableUnion {
    type Encoded = WireStructWithNullableUnion;
}

impl<___E> ::fidl_next::Encode<___E> for StructWithNullableUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                x1,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.x1, encoder, x1)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<StructWithNullableUnion> {
    type EncodedOption = ::fidl_next::WireBox<WireStructWithNullableUnion>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<StructWithNullableUnion>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StructWithNullableUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStructWithNullableUnion> for StructWithNullableUnion {
    #[inline]
    fn take_from(from: &WireStructWithNullableUnion) -> Self {
        Self { x1: ::fidl_next::TakeFrom::take_from(&from.x1) }
    }
}

/// The wire type corersponding to [`StructWithNullableUnion`].
#[derive(Debug)]
#[repr(C)]
pub struct WireStructWithNullableUnion {
    pub x1: crate::WireOptionalOlderSimpleUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStructWithNullableUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut x1,

            } = slot;
        }

        ::fidl_next::Decode::decode(x1.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    pub xu: crate::StrictBoundedUnion,
}

impl ::fidl_next::Encodable for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    type Encoded = WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.xu, encoder, xu)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
{
    #[inline]
    fn take_from(
        from: &WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse,
    ) -> Self {
        Self { xu: ::fidl_next::TakeFrom::take_from(&from.xu) }
    }
}

/// The wire type corersponding to [`TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    pub xu: crate::WireStrictBoundedUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut xu,

            } = slot;
        }

        ::fidl_next::Decode::decode(xu.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    pub xu: crate::OlderSimpleUnion,
}

impl ::fidl_next::Encodable for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    type Encoded = WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.xu, encoder, xu)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
{
    #[inline]
    fn take_from(
        from: &WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse,
    ) -> Self {
        Self { xu: ::fidl_next::TakeFrom::take_from(&from.xu) }
    }
}

/// The wire type corersponding to [`TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    pub xu: crate::WireOlderSimpleUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut xu,

            } = slot;
        }

        ::fidl_next::Decode::decode(xu.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the TestProtocol protocol.
#[derive(Debug)]
pub struct TestProtocol;

pub mod test_protocol {

    pub struct StrictUnionHenceResponseMayBeStackAllocated;

    impl ::fidl_next::Method for StrictUnionHenceResponseMayBeStackAllocated {
        const ORDINAL: u64 = 6628358876445129155;

        type Protocol = crate::TestProtocol;

        type Request = ();

        type Response = crate::WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse;
    }

    pub struct FlexibleUnionHenceResponseMustBeHeapAllocated;

    impl ::fidl_next::Method for FlexibleUnionHenceResponseMustBeHeapAllocated {
        const ORDINAL: u64 = 7588545459451501794;

        type Protocol = crate::TestProtocol;

        type Request = ();

        type Response =
            crate::WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse;
    }
}

/// A helper trait for the `TestProtocol` client sender.
pub trait TestProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_union_hence_response_may_be_stack_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_union_hence_response_must_be_heap_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> TestProtocolClientSender for ::fidl_next::ClientSender<___T, TestProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_union_hence_response_may_be_stack_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6628358876445129155, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_union_hence_response_must_be_heap_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7588545459451501794, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the TestProtocol protocol.
///
/// See [`TestProtocol`] for more details.
pub trait TestProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for TestProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: TestProtocolClientHandler<___T>,

    crate::WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `TestProtocol` server sender.
pub trait TestProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> TestProtocolServerSender for ::fidl_next::ServerSender<___T, TestProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the TestProtocol protocol.
///
/// See [`TestProtocol`] for more details.
pub trait TestProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_union_hence_response_may_be_stack_allocated(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, TestProtocol>,

        responder: ::fidl_next::Responder<
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
    );

    fn flexible_union_hence_response_must_be_heap_allocated(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, TestProtocol>,

        responder: ::fidl_next::Responder<
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for TestProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: TestProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            6628358876445129155 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_union_hence_response_may_be_stack_allocated(sender, responder);
            }

            7588545459451501794 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_union_hence_response_must_be_heap_allocated(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),
}

impl ::fidl_next::Encodable for Union {
    type Encoded = WireUnion;
}

impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Union> {
    type EncodedOption = WireOptionalUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Union>
where
    ___E: ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnion> for Union {
    #[inline]
    fn take_from(from: &WireUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnion> for Option<Box<Union>> {
    #[inline]
    fn take_from(from: &WireOptionalUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod union_ {
    pub enum Ref<'union> {
        Primitive(&'union ::fidl_next::WireI32),

        StringNeedsConstructor(&'union ::fidl_next::WireString),

        VectorStringAlsoNeedsConstructor(&'union ::fidl_next::WireVector<::fidl_next::WireString>),
    }
}

impl WireUnion {
    pub fn as_ref(&self) -> crate::union_::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_::Ref::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => crate::union_::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => crate::union_::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<::fidl_next::WireString>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString>(raw, decoder)?
            }

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<::fidl_next::WireString>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnionContainingEmptyStruct {
    Empty(crate::Empty),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnionContainingEmptyStruct {
    type Encoded = WireUnionContainingEmptyStruct;
}

impl<___E> ::fidl_next::Encode<___E> for UnionContainingEmptyStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionContainingEmptyStruct { raw } = slot);

        match self {
            Self::Empty(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, crate::Empty>(
                    value, 1, encoder, raw,
                )?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionContainingEmptyStruct> {
    type EncodedOption = WireOptionalUnionContainingEmptyStruct;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionContainingEmptyStruct>
where
    ___E: ?Sized,
    UnionContainingEmptyStruct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionContainingEmptyStruct { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnionContainingEmptyStruct> for UnionContainingEmptyStruct {
    #[inline]
    fn take_from(from: &WireUnionContainingEmptyStruct) -> Self {
        match from.raw.ordinal() {
            1 => Self::Empty(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnionContainingEmptyStruct>
    for Option<Box<UnionContainingEmptyStruct>>
{
    #[inline]
    fn take_from(from: &WireOptionalUnionContainingEmptyStruct) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionContainingEmptyStruct`].
#[repr(transparent)]
pub struct WireUnionContainingEmptyStruct {
    raw: ::fidl_next::RawWireUnion,
}

pub mod union_containing_empty_struct {
    pub enum Ref<'union> {
        Empty(&'union crate::WireEmpty),

        UnknownOrdinal_(u64),
    }
}

impl WireUnionContainingEmptyStruct {
    pub fn as_ref(&self) -> crate::union_containing_empty_struct::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_containing_empty_struct::Ref::Empty(unsafe {
                self.raw.get().deref_unchecked()
            }),

            unknown => crate::union_containing_empty_struct::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnionContainingEmptyStruct {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<crate::WireEmpty>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionContainingEmptyStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireEmpty>(raw, decoder)?
            }

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionContainingEmptyStruct {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireEmpty>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionContainingEmptyStruct {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnionContainingEmptyStruct {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionContainingEmptyStruct> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnionContainingEmptyStruct {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnionContainingEmptyStruct {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<crate::WireEmpty>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnionContainingEmptyStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireEmpty>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionContainingEmptyStruct {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnionSandwich {
    pub a: u32,

    pub u: crate::ExplicitFlexibleUnion,

    pub b: u32,
}

impl ::fidl_next::Encodable for UnionSandwich {
    type Encoded = WireUnionSandwich;
}

impl<___E> ::fidl_next::Encode<___E> for UnionSandwich
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                u,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionSandwich> {
    type EncodedOption = ::fidl_next::WireBox<WireUnionSandwich>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionSandwich>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnionSandwich: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnionSandwich> for UnionSandwich {
    #[inline]
    fn take_from(from: &WireUnionSandwich) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            u: ::fidl_next::TakeFrom::take_from(&from.u),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corersponding to [`UnionSandwich`].
#[derive(Debug)]
#[repr(C)]
pub struct WireUnionSandwich {
    pub a: ::fidl_next::WireU32,

    pub u: crate::WireExplicitFlexibleUnion,

    pub b: ::fidl_next::WireU32,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionSandwich
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut u,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnionWithAttributes {
    X(i64),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnionWithAttributes {
    type Encoded = WireUnionWithAttributes;
}

impl<___E> ::fidl_next::Encode<___E> for UnionWithAttributes
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionWithAttributes { raw } = slot);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<UnionWithAttributes> {
    type EncodedOption = WireOptionalUnionWithAttributes;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<UnionWithAttributes>
where
    ___E: ?Sized,
    UnionWithAttributes: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionWithAttributes { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnionWithAttributes> for UnionWithAttributes {
    #[inline]
    fn take_from(from: &WireUnionWithAttributes) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnionWithAttributes> for Option<Box<UnionWithAttributes>> {
    #[inline]
    fn take_from(from: &WireOptionalUnionWithAttributes) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionWithAttributes`].
#[repr(transparent)]
pub struct WireUnionWithAttributes {
    raw: ::fidl_next::RawWireUnion,
}

pub mod union_with_attributes {
    pub enum Ref<'union> {
        X(&'union ::fidl_next::WireI64),

        UnknownOrdinal_(u64),
    }
}

impl WireUnionWithAttributes {
    pub fn as_ref(&self) -> crate::union_with_attributes::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_with_attributes::Ref::X(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::union_with_attributes::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionWithAttributes
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionWithAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionWithAttributes {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnionWithAttributes {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionWithAttributes> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnionWithAttributes
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionWithAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// Commonly-used items that should usually be in scope, such as extension traits.
pub mod prelude {
    pub use super::{TestProtocolClientSender, TestProtocolServerSender};
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `TestProtocol`
    /// protocol.
    pub type TestProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::TestProtocol>;
}
