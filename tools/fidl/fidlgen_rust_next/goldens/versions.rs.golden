// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const ADDED_AT_HEAD: bool = true;

pub const ADDED_AT_NEXT: bool = true;

pub type Alias = String;

/// The wire type corresponding to [`Alias`].
pub type WireAlias = ::fidl_next::WireString;

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const A = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded = WireBits;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBits> for Bits {
    #[inline]
    fn take_from(from: &WireBits) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireBits {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

pub const CONST: u32 = 0;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Enum {
    A = 1,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Enum {
    type Encoded = WireEnum;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::A => 1,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::A,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnum> for Enum {
    #[inline]
    fn take_from(from: &WireEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireEnum {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnum {
    pub const A: WireEnum = WireEnum { value: ::fidl_next::WireU32(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::A => WireEnum::A,

            Enum::UnknownOrdinal_(value) => WireEnum { value: ::fidl_next::WireU32::from(value) },
        }
    }
}

/// The type corresponding to the OtherProtocol protocol.
#[derive(Debug)]
pub struct OtherProtocol;

pub mod other_protocol {
    pub mod prelude {
        pub use crate::{
            other_protocol, OtherProtocol, OtherProtocolClientHandler, OtherProtocolClientSender,
            OtherProtocolServerHandler, OtherProtocolServerSender,
        };
    }
}

/// A helper trait for the `OtherProtocol` client sender.
pub trait OtherProtocolClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OtherProtocolClientSender for ::fidl_next::ClientSender<___T, OtherProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the OtherProtocol protocol.
///
/// See [`OtherProtocol`] for more details.
pub trait OtherProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for OtherProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: OtherProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `OtherProtocol` server sender.
pub trait OtherProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OtherProtocolServerSender for ::fidl_next::ServerSender<___T, OtherProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the OtherProtocol protocol.
///
/// See [`OtherProtocol`] for more details.
pub trait OtherProtocolServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for OtherProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: OtherProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the Protocol protocol.
#[derive(Debug)]
pub struct Protocol;

pub mod protocol {
    pub mod prelude {
        pub use crate::{
            protocol, Protocol, ProtocolClientHandler, ProtocolClientSender, ProtocolServerHandler,
            ProtocolServerSender,
        };
    }

    pub struct Foo;

    impl ::fidl_next::Method for Foo {
        const ORDINAL: u64 = 6231434419097198905;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `Protocol` client sender.
pub trait ProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn foo(&self)
        -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> ProtocolClientSender for ::fidl_next::ClientSender<___T, Protocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn foo(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(6231434419097198905, &mut ())
    }
}

/// A client handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::Transport,
    ___H: ProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// A helper trait for the `Protocol` server sender.
pub trait ProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ProtocolServerSender for ::fidl_next::ServerSender<___T, Protocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn foo(&mut self, sender: &::fidl_next::ServerSender<___T, Protocol>);

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,
        ordinal: u64,
    ) {
        sender.close();
    }
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::Transport,
    ___H: ProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6231434419097198905 => {
                handler.foo(sender);
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => handler.on_unknown_interaction(sender, ordinal),
        }
    }
}

/// The type corresponding to the Service service.
#[derive(Debug)]
pub struct Service;

/// A helper trait for instances of the `Service` service.
pub trait ServiceInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;

    /// Attempts to connect to the `p` member.
    fn p(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>,
        >,
        Self::Error,
    >;
}

impl<___I> ServiceInstance for ::fidl_next::ServiceInstance<___I, Service>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;

    fn p(
        &mut self,
    ) -> Result<
        ::fidl_next::ClientEnd<
            Self::Transport,
            ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>,
        >,
        Self::Error,
    > {
        self.as_untyped_mut().connect("p").map(::fidl_next::ClientEnd::from_untyped)
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct Struct {
    pub x: u32,
}

impl ::fidl_next::Encodable for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                x,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.x, encoder, x)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Struct> {
    type EncodedOption = ::fidl_next::WireBox<WireStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Struct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStruct> for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireStruct) -> Self {
        Self { x: ::fidl_next::TakeFrom::take_from(&from.x) }
    }
}

/// The wire type corresponding to [`Struct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireStruct {
    pub x: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireStruct {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut x,

            } = slot;
        }

        ::fidl_next::Decode::decode(x.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct Table {
    pub x: Option<u32>,
}

impl Table {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for Table {
    type Encoded = WireTable;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(x) = &mut self.x {
                        ::fidl_next::WireEnvelope::encode_value(x, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTable> for Table {
    #[inline]
    fn take_from(from: &WireTable) -> Self {
        Self { x: from.x().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`Table`].
#[repr(C)]
pub struct WireTable {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireTable {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTable
where
    ___D: ::fidl_next::Decoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireU32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireTable {
    pub fn x(&self) -> Option<&::fidl_next::WireU32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("Table").field("x", &self.x()).finish()
    }
}

#[derive(Debug)]
pub enum Union {
    X(u32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Union {
    type Encoded = WireUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw } = out);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Union> {
    type EncodedOption = WireOptionalUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Union>
where
    ___E: ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnion> for Union {
    #[inline]
    fn take_from(from: &WireUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnion> for Option<Box<Union>> {
    #[inline]
    fn take_from(from: &WireOptionalUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union {
    pub enum Ref<'union> {
        X(&'union ::fidl_next::WireU32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnion {
    pub fn as_ref(&self) -> crate::union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union::Ref::X(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            unknown => crate::union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::TakeFrom<crate::WireBits> for ::fidl_test_versions::Bits {
        #[inline]
        fn take_from(from: &crate::WireBits) -> Self {
            Self::from_bits_retain(from.value.into())
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireEnum> for ::fidl_test_versions::Enum {
        #[inline]
        fn take_from(from: &crate::WireEnum) -> Self {
            match crate::Enum::from(*from) {
                crate::Enum::A => Self::A,

                crate::Enum::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `OtherProtocol`
    /// protocol.
    pub type OtherProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::OtherProtocol>;

    impl ::fidl_next::TakeFrom<crate::OtherProtocol> for ::fidl_test_versions::OtherProtocolMarker {
        #[inline]
        fn take_from(from: &crate::OtherProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Protocol`
    /// protocol.
    pub type ProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Protocol>;

    impl ::fidl_next::TakeFrom<crate::Protocol> for ::fidl_test_versions::ProtocolMarker {
        #[inline]
        fn take_from(from: &crate::Protocol) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireStruct> for ::fidl_test_versions::Struct {
        #[inline]
        fn take_from(from: &crate::WireStruct) -> Self {
            Self { x: ::fidl_next::TakeFrom::take_from(&from.x) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireTable> for ::fidl_test_versions::Table {
        #[inline]
        fn take_from(from: &crate::WireTable) -> Self {
            Self {
                x: from.x().map(::fidl_next::TakeFrom::take_from),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnion> for ::fidl_test_versions::Union {
        #[inline]
        fn take_from(from: &crate::WireUnion) -> Self {
            match from.as_ref() {
                crate::union::Ref::X(value) => Self::X(::fidl_next::TakeFrom::take_from(value)),

                crate::union::Ref::UnknownOrdinal_(unknown_ordinal) => {
                    Self::__SourceBreaking { unknown_ordinal }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnion> for Option<Box<::fidl_test_versions::Union>> {
        #[inline]
        fn take_from(from: &crate::WireOptionalUnion) -> Self {
            if let Some(inner) = from.as_ref() {
                Some(::fidl_next::TakeFrom::take_from(inner))
            } else {
                None
            }
        }
    }
}
