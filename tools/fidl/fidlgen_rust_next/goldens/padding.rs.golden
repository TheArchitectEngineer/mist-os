// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct Padding1ByteEnd {
    pub a: u16,

    pub b: u8,
}

impl ::fidl_next::Encodable for Padding1ByteEnd {
    type Encoded = WirePadding1ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding1ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding1ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding1ByteEnd {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding1ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding1ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding1ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding1ByteEnd> for Padding1ByteEnd {
    #[inline]
    fn from_wire(wire: WirePadding1ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding1ByteEnd> for Padding1ByteEnd {
    #[inline]
    fn from_wire_ref(wire: &WirePadding1ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding1ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding1ByteEnd {
    pub a: ::fidl_next::WireU16,

    pub b: u8,
}

unsafe impl ::fidl_next::Wire for WirePadding1ByteEnd {
    type Decoded<'de> = WirePadding1ByteEnd;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(3).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding1ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding1ByteMiddle {
    pub a: u8,

    pub b: u16,
}

impl ::fidl_next::Encodable for Padding1ByteMiddle {
    type Encoded = WirePadding1ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding1ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding1ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding1ByteMiddle {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding1ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding1ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding1ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding1ByteMiddle> for Padding1ByteMiddle {
    #[inline]
    fn from_wire(wire: WirePadding1ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding1ByteMiddle> for Padding1ByteMiddle {
    #[inline]
    fn from_wire_ref(wire: &WirePadding1ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding1ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding1ByteMiddle {
    pub a: u8,

    pub b: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::Wire for WirePadding1ByteMiddle {
    type Decoded<'de> = WirePadding1ByteMiddle;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding1ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding2ByteAlignmentLength6 {
    pub a: u8,

    pub b: u16,

    pub c: u8,
}

impl ::fidl_next::Encodable for Padding2ByteAlignmentLength6 {
    type Encoded = WirePadding2ByteAlignmentLength6;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding2ByteAlignmentLength6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding2ByteAlignmentLength6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding2ByteAlignmentLength6 {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding2ByteAlignmentLength6>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding2ByteAlignmentLength6
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteAlignmentLength6: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding2ByteAlignmentLength6
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteAlignmentLength6: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding2ByteAlignmentLength6> for Padding2ByteAlignmentLength6 {
    #[inline]
    fn from_wire(wire: WirePadding2ByteAlignmentLength6) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),

            c: ::fidl_next::FromWire::from_wire(wire.c),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding2ByteAlignmentLength6> for Padding2ByteAlignmentLength6 {
    #[inline]
    fn from_wire_ref(wire: &WirePadding2ByteAlignmentLength6) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),

            c: ::fidl_next::FromWireRef::from_wire_ref(&wire.c),
        }
    }
}

/// The wire type corresponding to [`Padding2ByteAlignmentLength6`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding2ByteAlignmentLength6 {
    pub a: u8,

    pub b: ::fidl_next::WireU16,

    pub c: u8,
}

unsafe impl ::fidl_next::Wire for WirePadding2ByteAlignmentLength6 {
    type Decoded<'de> = WirePadding2ByteAlignmentLength6;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding2ByteAlignmentLength6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding2ByteEnd {
    pub a: u32,

    pub b: u16,
}

impl ::fidl_next::Encodable for Padding2ByteEnd {
    type Encoded = WirePadding2ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding2ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding2ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding2ByteEnd {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding2ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding2ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding2ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding2ByteEnd> for Padding2ByteEnd {
    #[inline]
    fn from_wire(wire: WirePadding2ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding2ByteEnd> for Padding2ByteEnd {
    #[inline]
    fn from_wire_ref(wire: &WirePadding2ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding2ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding2ByteEnd {
    pub a: ::fidl_next::WireU32,

    pub b: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::Wire for WirePadding2ByteEnd {
    type Decoded<'de> = WirePadding2ByteEnd;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(6).write_bytes(0, 2);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding2ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding2ByteMiddle {
    pub a: u16,

    pub b: u32,
}

impl ::fidl_next::Encodable for Padding2ByteMiddle {
    type Encoded = WirePadding2ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding2ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding2ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding2ByteMiddle {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding2ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding2ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding2ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding2ByteMiddle> for Padding2ByteMiddle {
    #[inline]
    fn from_wire(wire: WirePadding2ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding2ByteMiddle> for Padding2ByteMiddle {
    #[inline]
    fn from_wire_ref(wire: &WirePadding2ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding2ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding2ByteMiddle {
    pub a: ::fidl_next::WireU16,

    pub b: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WirePadding2ByteMiddle {
    type Decoded<'de> = WirePadding2ByteMiddle;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(2).write_bytes(0, 2);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding2ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding3ByteEnd {
    pub a: u32,

    pub b: u8,
}

impl ::fidl_next::Encodable for Padding3ByteEnd {
    type Encoded = WirePadding3ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding3ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding3ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding3ByteEnd {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding3ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding3ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding3ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding3ByteEnd> for Padding3ByteEnd {
    #[inline]
    fn from_wire(wire: WirePadding3ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding3ByteEnd> for Padding3ByteEnd {
    #[inline]
    fn from_wire_ref(wire: &WirePadding3ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding3ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding3ByteEnd {
    pub a: ::fidl_next::WireU32,

    pub b: u8,
}

unsafe impl ::fidl_next::Wire for WirePadding3ByteEnd {
    type Decoded<'de> = WirePadding3ByteEnd;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding3ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding3ByteMiddle {
    pub a: u8,

    pub b: u32,
}

impl ::fidl_next::Encodable for Padding3ByteMiddle {
    type Encoded = WirePadding3ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding3ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding3ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding3ByteMiddle {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding3ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding3ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding3ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding3ByteMiddle> for Padding3ByteMiddle {
    #[inline]
    fn from_wire(wire: WirePadding3ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding3ByteMiddle> for Padding3ByteMiddle {
    #[inline]
    fn from_wire_ref(wire: &WirePadding3ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding3ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding3ByteMiddle {
    pub a: u8,

    pub b: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WirePadding3ByteMiddle {
    type Decoded<'de> = WirePadding3ByteMiddle;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding3ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding4ByteAlignmentLength12 {
    pub a: u32,

    pub b: u8,

    pub c: u16,

    pub d: u16,
}

impl ::fidl_next::Encodable for Padding4ByteAlignmentLength12 {
    type Encoded = WirePadding4ByteAlignmentLength12;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding4ByteAlignmentLength12
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,
                d,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        ::fidl_next::Encode::encode(self.d, encoder, d)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding4ByteAlignmentLength12
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,
                d,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        ::fidl_next::EncodeRef::encode_ref(&self.d, encoder, d)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding4ByteAlignmentLength12 {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding4ByteAlignmentLength12>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding4ByteAlignmentLength12
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteAlignmentLength12: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding4ByteAlignmentLength12
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteAlignmentLength12: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding4ByteAlignmentLength12> for Padding4ByteAlignmentLength12 {
    #[inline]
    fn from_wire(wire: WirePadding4ByteAlignmentLength12) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),

            c: ::fidl_next::FromWire::from_wire(wire.c),

            d: ::fidl_next::FromWire::from_wire(wire.d),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding4ByteAlignmentLength12> for Padding4ByteAlignmentLength12 {
    #[inline]
    fn from_wire_ref(wire: &WirePadding4ByteAlignmentLength12) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),

            c: ::fidl_next::FromWireRef::from_wire_ref(&wire.c),

            d: ::fidl_next::FromWireRef::from_wire_ref(&wire.d),
        }
    }
}

/// The wire type corresponding to [`Padding4ByteAlignmentLength12`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding4ByteAlignmentLength12 {
    pub a: ::fidl_next::WireU32,

    pub b: u8,

    pub c: ::fidl_next::WireU16,

    pub d: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::Wire for WirePadding4ByteAlignmentLength12 {
    type Decoded<'de> = WirePadding4ByteAlignmentLength12;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(10).write_bytes(0, 2);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding4ByteAlignmentLength12
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,
                mut d,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(d.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding4ByteEnd {
    pub a: u64,

    pub b: u32,
}

impl ::fidl_next::Encodable for Padding4ByteEnd {
    type Encoded = WirePadding4ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding4ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding4ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding4ByteEnd {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding4ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding4ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding4ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding4ByteEnd> for Padding4ByteEnd {
    #[inline]
    fn from_wire(wire: WirePadding4ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding4ByteEnd> for Padding4ByteEnd {
    #[inline]
    fn from_wire_ref(wire: &WirePadding4ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding4ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding4ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WirePadding4ByteEnd {
    type Decoded<'de> = WirePadding4ByteEnd;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(12).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding4ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding4ByteMiddle {
    pub a: u32,

    pub b: u64,
}

impl ::fidl_next::Encodable for Padding4ByteMiddle {
    type Encoded = WirePadding4ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding4ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding4ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding4ByteMiddle {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding4ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding4ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding4ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding4ByteMiddle> for Padding4ByteMiddle {
    #[inline]
    fn from_wire(wire: WirePadding4ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding4ByteMiddle> for Padding4ByteMiddle {
    #[inline]
    fn from_wire_ref(wire: &WirePadding4ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding4ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding4ByteMiddle {
    pub a: ::fidl_next::WireU32,

    pub b: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::Wire for WirePadding4ByteMiddle {
    type Decoded<'de> = WirePadding4ByteMiddle;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(4).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding4ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding5ByteEnd {
    pub a: u64,

    pub b: u16,

    pub c: u8,
}

impl ::fidl_next::Encodable for Padding5ByteEnd {
    type Encoded = WirePadding5ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding5ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding5ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding5ByteEnd {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding5ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding5ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding5ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding5ByteEnd> for Padding5ByteEnd {
    #[inline]
    fn from_wire(wire: WirePadding5ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),

            c: ::fidl_next::FromWire::from_wire(wire.c),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding5ByteEnd> for Padding5ByteEnd {
    #[inline]
    fn from_wire_ref(wire: &WirePadding5ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),

            c: ::fidl_next::FromWireRef::from_wire_ref(&wire.c),
        }
    }
}

/// The wire type corresponding to [`Padding5ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding5ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: ::fidl_next::WireU16,

    pub c: u8,
}

unsafe impl ::fidl_next::Wire for WirePadding5ByteEnd {
    type Decoded<'de> = WirePadding5ByteEnd;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(11).write_bytes(0, 5);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding5ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding5ByteMiddle {
    pub a: u16,

    pub b: u8,

    pub c: u64,
}

impl ::fidl_next::Encodable for Padding5ByteMiddle {
    type Encoded = WirePadding5ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding5ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding5ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding5ByteMiddle {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding5ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding5ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding5ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding5ByteMiddle> for Padding5ByteMiddle {
    #[inline]
    fn from_wire(wire: WirePadding5ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),

            c: ::fidl_next::FromWire::from_wire(wire.c),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding5ByteMiddle> for Padding5ByteMiddle {
    #[inline]
    fn from_wire_ref(wire: &WirePadding5ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),

            c: ::fidl_next::FromWireRef::from_wire_ref(&wire.c),
        }
    }
}

/// The wire type corresponding to [`Padding5ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding5ByteMiddle {
    pub a: ::fidl_next::WireU16,

    pub b: u8,

    pub c: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::Wire for WirePadding5ByteMiddle {
    type Decoded<'de> = WirePadding5ByteMiddle;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(3).write_bytes(0, 5);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding5ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding6ByteEnd {
    pub a: u64,

    pub b: u16,
}

impl ::fidl_next::Encodable for Padding6ByteEnd {
    type Encoded = WirePadding6ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding6ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding6ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding6ByteEnd {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding6ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding6ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding6ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding6ByteEnd> for Padding6ByteEnd {
    #[inline]
    fn from_wire(wire: WirePadding6ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding6ByteEnd> for Padding6ByteEnd {
    #[inline]
    fn from_wire_ref(wire: &WirePadding6ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding6ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding6ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::Wire for WirePadding6ByteEnd {
    type Decoded<'de> = WirePadding6ByteEnd;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(10).write_bytes(0, 6);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding6ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding6ByteMiddle {
    pub a: u16,

    pub b: u64,
}

impl ::fidl_next::Encodable for Padding6ByteMiddle {
    type Encoded = WirePadding6ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding6ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding6ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding6ByteMiddle {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding6ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding6ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding6ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding6ByteMiddle> for Padding6ByteMiddle {
    #[inline]
    fn from_wire(wire: WirePadding6ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding6ByteMiddle> for Padding6ByteMiddle {
    #[inline]
    fn from_wire_ref(wire: &WirePadding6ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding6ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding6ByteMiddle {
    pub a: ::fidl_next::WireU16,

    pub b: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::Wire for WirePadding6ByteMiddle {
    type Decoded<'de> = WirePadding6ByteMiddle;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(2).write_bytes(0, 6);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding6ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding7ByteEnd {
    pub a: u64,

    pub b: u8,
}

impl ::fidl_next::Encodable for Padding7ByteEnd {
    type Encoded = WirePadding7ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding7ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding7ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding7ByteEnd {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding7ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding7ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding7ByteEnd
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding7ByteEnd> for Padding7ByteEnd {
    #[inline]
    fn from_wire(wire: WirePadding7ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding7ByteEnd> for Padding7ByteEnd {
    #[inline]
    fn from_wire_ref(wire: &WirePadding7ByteEnd) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding7ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding7ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: u8,
}

unsafe impl ::fidl_next::Wire for WirePadding7ByteEnd {
    type Decoded<'de> = WirePadding7ByteEnd;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(9).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding7ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding7ByteMiddle {
    pub a: u8,

    pub b: u64,
}

impl ::fidl_next::Encodable for Padding7ByteMiddle {
    type Encoded = WirePadding7ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding7ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding7ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Padding7ByteMiddle {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePadding7ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Padding7ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Padding7ByteMiddle
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WirePadding7ByteMiddle> for Padding7ByteMiddle {
    #[inline]
    fn from_wire(wire: WirePadding7ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl ::fidl_next::FromWireRef<WirePadding7ByteMiddle> for Padding7ByteMiddle {
    #[inline]
    fn from_wire_ref(wire: &WirePadding7ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`Padding7ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding7ByteMiddle {
    pub a: u8,

    pub b: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::Wire for WirePadding7ByteMiddle {
    type Decoded<'de> = WirePadding7ByteMiddle;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding7ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {}
