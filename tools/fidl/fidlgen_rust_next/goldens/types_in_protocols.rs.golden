// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],

    pub array_uint16: [u16; 5],

    pub array_uint32: [u32; 5],

    pub array_uint64: [u64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [i16; 5],

    pub array_int32: [i32; 5],

    pub array_int64: [i64; 5],

    pub array_float32: [f32; 5],

    pub array_float64: [f64; 5],

    pub array_string: [String; 5],

    pub array_opt_string: [Option<String>; 5],
}

impl ::fidl_next::Encodable for ArrayBasic {
    type Encoded = WireArrayBasic<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(self.array_uint8, encoder, array_uint8)?;

        ::fidl_next::Encode::encode(self.array_uint16, encoder, array_uint16)?;

        ::fidl_next::Encode::encode(self.array_uint32, encoder, array_uint32)?;

        ::fidl_next::Encode::encode(self.array_uint64, encoder, array_uint64)?;

        ::fidl_next::Encode::encode(self.array_int8, encoder, array_int8)?;

        ::fidl_next::Encode::encode(self.array_int16, encoder, array_int16)?;

        ::fidl_next::Encode::encode(self.array_int32, encoder, array_int32)?;

        ::fidl_next::Encode::encode(self.array_int64, encoder, array_int64)?;

        ::fidl_next::Encode::encode(self.array_float32, encoder, array_float32)?;

        ::fidl_next::Encode::encode(self.array_float64, encoder, array_float64)?;

        ::fidl_next::Encode::encode(self.array_string, encoder, array_string)?;

        ::fidl_next::Encode::encode(self.array_opt_string, encoder, array_opt_string)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ArrayBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint8, encoder, array_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint16, encoder, array_uint16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint32, encoder, array_uint32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint64, encoder, array_uint64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int8, encoder, array_int8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int16, encoder, array_int16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int32, encoder, array_int32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int64, encoder, array_int64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_float32, encoder, array_float32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_float64, encoder, array_float64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_string, encoder, array_string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_opt_string, encoder, array_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ArrayBasic {
    type EncodedOption = ::fidl_next::WireBox<'static, WireArrayBasic<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ArrayBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayBasic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ArrayBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayBasic: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireArrayBasic<'de>> for ArrayBasic {
    #[inline]
    fn from_wire(wire: WireArrayBasic<'de>) -> Self {
        Self {
            array_uint8: ::fidl_next::FromWire::from_wire(wire.array_uint8),

            array_uint16: ::fidl_next::FromWire::from_wire(wire.array_uint16),

            array_uint32: ::fidl_next::FromWire::from_wire(wire.array_uint32),

            array_uint64: ::fidl_next::FromWire::from_wire(wire.array_uint64),

            array_int8: ::fidl_next::FromWire::from_wire(wire.array_int8),

            array_int16: ::fidl_next::FromWire::from_wire(wire.array_int16),

            array_int32: ::fidl_next::FromWire::from_wire(wire.array_int32),

            array_int64: ::fidl_next::FromWire::from_wire(wire.array_int64),

            array_float32: ::fidl_next::FromWire::from_wire(wire.array_float32),

            array_float64: ::fidl_next::FromWire::from_wire(wire.array_float64),

            array_string: ::fidl_next::FromWire::from_wire(wire.array_string),

            array_opt_string: ::fidl_next::FromWire::from_wire(wire.array_opt_string),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireArrayBasic<'de>> for ArrayBasic {
    #[inline]
    fn from_wire_ref(wire: &WireArrayBasic<'de>) -> Self {
        Self {
            array_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint8),

            array_uint16: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint16),

            array_uint32: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint32),

            array_uint64: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint64),

            array_int8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int8),

            array_int16: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int16),

            array_int32: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int32),

            array_int64: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int64),

            array_float32: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_float32),

            array_float64: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_float64),

            array_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_string),

            array_opt_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_opt_string),
        }
    }
}

/// The wire type corresponding to [`ArrayBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayBasic<'de> {
    pub array_uint8: [u8; 5],

    pub array_uint16: [::fidl_next::WireU16; 5],

    pub array_uint32: [::fidl_next::WireU32; 5],

    pub array_uint64: [::fidl_next::WireU64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [::fidl_next::WireI16; 5],

    pub array_int32: [::fidl_next::WireI32; 5],

    pub array_int64: [::fidl_next::WireI64; 5],

    pub array_float32: [::fidl_next::WireF32; 5],

    pub array_float64: [::fidl_next::WireF64; 5],

    pub array_string: [::fidl_next::WireString<'de>; 5],

    pub array_opt_string: [::fidl_next::WireOptionalString<'de>; 5],
}

unsafe impl ::fidl_next::Wire for WireArrayBasic<'static> {
    type Decoded<'de> = WireArrayBasic<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(180).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(116).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(85).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayBasic<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_uint8,
                mut array_uint16,
                mut array_uint32,
                mut array_uint64,
                mut array_int8,
                mut array_int16,
                mut array_int32,
                mut array_int64,
                mut array_float32,
                mut array_float64,
                mut array_string,
                mut array_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const VAL = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded = WireBits;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::FromWire<WireBits> for Bits {
    #[inline]
    fn from_wire(wire: WireBits) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireBits> for Bits {
    #[inline]
    fn from_wire_ref(wire: &WireBits) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireBits {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Enum {
    Val = 1,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Enum {
    type Encoded = WireEnum;
}
impl ::std::convert::From<u32> for Enum {
    fn from(value: u32) -> Self {
        match value {
            1 => Self::Val,

            _ => Self::UnknownOrdinal_(value),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::Val => 1,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::Val,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::FromWire<WireEnum> for Enum {
    #[inline]
    fn from_wire(wire: WireEnum) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireEnum> for Enum {
    #[inline]
    fn from_wire_ref(wire: &WireEnum) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireEnum {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnum {
    pub const VAL: WireEnum = WireEnum { value: ::fidl_next::WireU32(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::Val => WireEnum::VAL,

            Enum::UnknownOrdinal_(value) => WireEnum { value: ::fidl_next::WireU32::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct Struct {}

impl ::fidl_next::Encodable for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireStruct> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Struct {
    type EncodedOption = ::fidl_next::WireBox<'static, WireStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Struct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Struct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireStruct> for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireStruct, Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn from_wire(wire: WireStruct) -> Self {
        Self {}
    }
}

impl ::fidl_next::FromWireRef<WireStruct> for Struct {
    #[inline]
    fn from_wire_ref(wire: &WireStruct) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Struct`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireStruct {}

unsafe impl ::fidl_next::Wire for WireStruct {
    type Decoded<'de> = WireStruct;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct Table {}

impl Table {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for Table {
    type Encoded = WireTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireTable<'de>> for Table {
    #[inline]
    fn from_wire(wire: WireTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

impl<'de> ::fidl_next::FromWireRef<WireTable<'de>> for Table {
    #[inline]
    fn from_wire_ref(wire: &WireTable<'de>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Table`].
#[repr(C)]
pub struct WireTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireTable<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireTable<'static> {
    type Decoded<'de> = WireTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireTable<'de> {}

impl<'de> ::core::fmt::Debug for WireTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("Table").finish()
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Union {
    type Encoded = WireUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Union {
    type EncodedOption = WireOptionalUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Union
where
    ___E: ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Union
where
    ___E: ?Sized,
    Union: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnion> for Union {
    #[inline]
    fn from_wire(wire: WireUnion) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::B(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnion> for Union {
    #[inline]
    fn from_wire_ref(wire: &WireUnion) -> Self {
        match wire.raw.ordinal() {
            1 => Self::B(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnion> for Box<Union> {
    #[inline]
    fn from_wire_option(wire: WireOptionalUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalUnion> for Box<Union> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalUnion) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnion {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<bool>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnion {
    type Decoded<'de> = WireUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union {
    pub enum Ref<'de> {
        B(&'de bool),

        UnknownOrdinal_(u64),
    }
}

impl WireUnion {
    pub fn as_ref(&self) -> crate::union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union::Ref::B(unsafe { self.raw.get().deref_unchecked::<bool>() }),

            unknown => crate::union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnion {
    type Decoded<'de> = WireOptionalUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnion> {
        if self.is_some() {
            Some(WireUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnion {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct ArrayCompound {
    pub array_bits: [crate::Bits; 5],

    pub array_enum: [crate::Enum; 5],

    pub array_struct: [crate::Struct; 5],

    pub array_table: [crate::Table; 5],

    pub array_union: [crate::Union; 5],

    pub array_opt_struct: [Option<Box<crate::Struct>>; 5],

    pub array_opt_union: [Option<Box<crate::Union>>; 5],
}

impl ::fidl_next::Encodable for ArrayCompound {
    type Encoded = WireArrayCompound<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.array_bits, encoder, array_bits)?;

        ::fidl_next::Encode::encode(self.array_enum, encoder, array_enum)?;

        ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(self.array_opt_struct, encoder, array_opt_struct)?;

        ::fidl_next::Encode::encode(self.array_opt_union, encoder, array_opt_union)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ArrayCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.array_bits, encoder, array_bits)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_enum, encoder, array_enum)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_struct, encoder, array_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_table, encoder, array_table)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_union, encoder, array_union)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_opt_struct, encoder, array_opt_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_opt_union, encoder, array_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ArrayCompound {
    type EncodedOption = ::fidl_next::WireBox<'static, WireArrayCompound<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ArrayCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayCompound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ArrayCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayCompound: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireArrayCompound<'de>> for ArrayCompound {
    #[inline]
    fn from_wire(wire: WireArrayCompound<'de>) -> Self {
        Self {
            array_bits: ::fidl_next::FromWire::from_wire(wire.array_bits),

            array_enum: ::fidl_next::FromWire::from_wire(wire.array_enum),

            array_struct: ::fidl_next::FromWire::from_wire(wire.array_struct),

            array_table: ::fidl_next::FromWire::from_wire(wire.array_table),

            array_union: ::fidl_next::FromWire::from_wire(wire.array_union),

            array_opt_struct: ::fidl_next::FromWire::from_wire(wire.array_opt_struct),

            array_opt_union: ::fidl_next::FromWire::from_wire(wire.array_opt_union),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireArrayCompound<'de>> for ArrayCompound {
    #[inline]
    fn from_wire_ref(wire: &WireArrayCompound<'de>) -> Self {
        Self {
            array_bits: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_bits),

            array_enum: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_enum),

            array_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_struct),

            array_table: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_table),

            array_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_union),

            array_opt_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_opt_struct),

            array_opt_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_opt_union),
        }
    }
}

/// The wire type corresponding to [`ArrayCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayCompound<'de> {
    pub array_bits: [crate::WireBits; 5],

    pub array_enum: [crate::WireEnum; 5],

    pub array_struct: [crate::WireStruct; 5],

    pub array_table: [crate::WireTable<'de>; 5],

    pub array_union: [crate::WireUnion; 5],

    pub array_opt_struct: [::fidl_next::WireBox<'de, crate::WireStruct>; 5],

    pub array_opt_union: [crate::WireOptionalUnion; 5],
}

unsafe impl ::fidl_next::Wire for WireArrayCompound<'static> {
    type Decoded<'de> = WireArrayCompound<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(45).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayCompound<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_bits,
                mut array_enum,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut array_opt_struct,
                mut array_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [Vec<u8>; 5],

    pub vector_array_uint8: Vec<[u8; 5]>,

    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl ::fidl_next::Encodable for ArrayVectorNested {
    type Encoded = WireArrayVectorNested<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,

            } = out;
        }

        ::fidl_next::Encode::encode(self.array_array_uint8, encoder, array_array_uint8)?;

        ::fidl_next::Encode::encode(self.array_vector_uint8, encoder, array_vector_uint8)?;

        ::fidl_next::Encode::encode(self.vector_array_uint8, encoder, vector_array_uint8)?;

        ::fidl_next::Encode::encode(self.vector_vector_uint8, encoder, vector_vector_uint8)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.array_array_uint8, encoder, array_array_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_vector_uint8, encoder, array_vector_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_array_uint8, encoder, vector_array_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.vector_vector_uint8,
            encoder,
            vector_vector_uint8,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ArrayVectorNested {
    type EncodedOption = ::fidl_next::WireBox<'static, WireArrayVectorNested<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayVectorNested: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayVectorNested: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireArrayVectorNested<'de>> for ArrayVectorNested {
    #[inline]
    fn from_wire(wire: WireArrayVectorNested<'de>) -> Self {
        Self {
            array_array_uint8: ::fidl_next::FromWire::from_wire(wire.array_array_uint8),

            array_vector_uint8: ::fidl_next::FromWire::from_wire(wire.array_vector_uint8),

            vector_array_uint8: ::fidl_next::FromWire::from_wire(wire.vector_array_uint8),

            vector_vector_uint8: ::fidl_next::FromWire::from_wire(wire.vector_vector_uint8),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireArrayVectorNested<'de>> for ArrayVectorNested {
    #[inline]
    fn from_wire_ref(wire: &WireArrayVectorNested<'de>) -> Self {
        Self {
            array_array_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_array_uint8),

            array_vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_vector_uint8),

            vector_array_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_array_uint8),

            vector_vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_vector_uint8),
        }
    }
}

/// The wire type corresponding to [`ArrayVectorNested`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayVectorNested<'de> {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [::fidl_next::WireVector<'de, u8>; 5],

    pub vector_array_uint8: ::fidl_next::WireVector<'de, [u8; 5]>,

    pub vector_vector_uint8: ::fidl_next::WireVector<'de, ::fidl_next::WireVector<'de, u8>>,
}

unsafe impl ::fidl_next::Wire for WireArrayVectorNested<'static> {
    type Decoded<'de> = WireArrayVectorNested<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(25).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayVectorNested<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_array_uint8,
                mut array_vector_uint8,
                mut vector_array_uint8,
                mut vector_vector_uint8,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vector_uint8.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Basic {
    pub uint8: u8,

    pub uint16: u16,

    pub uint32: u32,

    pub uint64: u64,

    pub int8: i8,

    pub int16: i16,

    pub int32: i32,

    pub int64: i64,

    pub float32: f32,

    pub float64: f64,

    pub string: String,

    pub opt_string: Option<String>,
}

impl ::fidl_next::Encodable for Basic {
    type Encoded = WireBasic<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Basic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(self.uint8, encoder, uint8)?;

        ::fidl_next::Encode::encode(self.uint16, encoder, uint16)?;

        ::fidl_next::Encode::encode(self.uint32, encoder, uint32)?;

        ::fidl_next::Encode::encode(self.uint64, encoder, uint64)?;

        ::fidl_next::Encode::encode(self.int8, encoder, int8)?;

        ::fidl_next::Encode::encode(self.int16, encoder, int16)?;

        ::fidl_next::Encode::encode(self.int32, encoder, int32)?;

        ::fidl_next::Encode::encode(self.int64, encoder, int64)?;

        ::fidl_next::Encode::encode(self.float32, encoder, float32)?;

        ::fidl_next::Encode::encode(self.float64, encoder, float64)?;

        ::fidl_next::Encode::encode(self.string, encoder, string)?;

        ::fidl_next::Encode::encode(self.opt_string, encoder, opt_string)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Basic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.uint8, encoder, uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.uint16, encoder, uint16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.uint32, encoder, uint32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.uint64, encoder, uint64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int8, encoder, int8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int16, encoder, int16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int32, encoder, int32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int64, encoder, int64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.float32, encoder, float32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.float64, encoder, float64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.string, encoder, string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_string, encoder, opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Basic {
    type EncodedOption = ::fidl_next::WireBox<'static, WireBasic<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Basic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Basic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Basic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Basic: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireBasic<'de>> for Basic {
    #[inline]
    fn from_wire(wire: WireBasic<'de>) -> Self {
        Self {
            uint8: ::fidl_next::FromWire::from_wire(wire.uint8),

            uint16: ::fidl_next::FromWire::from_wire(wire.uint16),

            uint32: ::fidl_next::FromWire::from_wire(wire.uint32),

            uint64: ::fidl_next::FromWire::from_wire(wire.uint64),

            int8: ::fidl_next::FromWire::from_wire(wire.int8),

            int16: ::fidl_next::FromWire::from_wire(wire.int16),

            int32: ::fidl_next::FromWire::from_wire(wire.int32),

            int64: ::fidl_next::FromWire::from_wire(wire.int64),

            float32: ::fidl_next::FromWire::from_wire(wire.float32),

            float64: ::fidl_next::FromWire::from_wire(wire.float64),

            string: ::fidl_next::FromWire::from_wire(wire.string),

            opt_string: ::fidl_next::FromWire::from_wire(wire.opt_string),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireBasic<'de>> for Basic {
    #[inline]
    fn from_wire_ref(wire: &WireBasic<'de>) -> Self {
        Self {
            uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint8),

            uint16: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint16),

            uint32: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint32),

            uint64: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint64),

            int8: ::fidl_next::FromWireRef::from_wire_ref(&wire.int8),

            int16: ::fidl_next::FromWireRef::from_wire_ref(&wire.int16),

            int32: ::fidl_next::FromWireRef::from_wire_ref(&wire.int32),

            int64: ::fidl_next::FromWireRef::from_wire_ref(&wire.int64),

            float32: ::fidl_next::FromWireRef::from_wire_ref(&wire.float32),

            float64: ::fidl_next::FromWireRef::from_wire_ref(&wire.float64),

            string: ::fidl_next::FromWireRef::from_wire_ref(&wire.string),

            opt_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_string),
        }
    }
}

/// The wire type corresponding to [`Basic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireBasic<'de> {
    pub uint8: u8,

    pub uint16: ::fidl_next::WireU16,

    pub uint32: ::fidl_next::WireU32,

    pub uint64: ::fidl_next::WireU64,

    pub int8: i8,

    pub int16: ::fidl_next::WireI16,

    pub int32: ::fidl_next::WireI32,

    pub int64: ::fidl_next::WireI64,

    pub float32: ::fidl_next::WireF32,

    pub float64: ::fidl_next::WireF64,

    pub string: ::fidl_next::WireString<'de>,

    pub opt_string: ::fidl_next::WireOptionalString<'de>,
}

unsafe impl ::fidl_next::Wire for WireBasic<'static> {
    type Decoded<'de> = WireBasic<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(17).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBasic<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut uint8,
                mut uint16,
                mut uint32,
                mut uint64,
                mut int8,
                mut int16,
                mut int32,
                mut int64,
                mut float32,
                mut float64,
                mut string,
                mut opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Compound {
    pub bits: crate::Bits,

    pub enum_: crate::Enum,

    pub struct_: crate::Struct,

    pub table: crate::Table,

    pub union: crate::Union,

    pub opt_struct: Option<Box<crate::Struct>>,

    pub opt_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for Compound {
    type Encoded = WireCompound<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Compound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits,
                enum_,
                struct_,
                table,
                union,
                opt_struct,
                opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.bits, encoder, bits)?;

        ::fidl_next::Encode::encode(self.enum_, encoder, enum_)?;

        ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(self.table, encoder, table)?;

        ::fidl_next::Encode::encode(self.union, encoder, union)?;

        ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Compound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits,
                enum_,
                struct_,
                table,
                union,
                opt_struct,
                opt_union,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.bits, encoder, bits)?;

        ::fidl_next::EncodeRef::encode_ref(&self.enum_, encoder, enum_)?;

        ::fidl_next::EncodeRef::encode_ref(&self.struct_, encoder, struct_)?;

        ::fidl_next::EncodeRef::encode_ref(&self.table, encoder, table)?;

        ::fidl_next::EncodeRef::encode_ref(&self.union, encoder, union)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_union, encoder, opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Compound {
    type EncodedOption = ::fidl_next::WireBox<'static, WireCompound<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Compound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Compound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Compound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Compound: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireCompound<'de>> for Compound {
    #[inline]
    fn from_wire(wire: WireCompound<'de>) -> Self {
        Self {
            bits: ::fidl_next::FromWire::from_wire(wire.bits),

            enum_: ::fidl_next::FromWire::from_wire(wire.enum_),

            struct_: ::fidl_next::FromWire::from_wire(wire.struct_),

            table: ::fidl_next::FromWire::from_wire(wire.table),

            union: ::fidl_next::FromWire::from_wire(wire.union),

            opt_struct: ::fidl_next::FromWire::from_wire(wire.opt_struct),

            opt_union: ::fidl_next::FromWire::from_wire(wire.opt_union),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireCompound<'de>> for Compound {
    #[inline]
    fn from_wire_ref(wire: &WireCompound<'de>) -> Self {
        Self {
            bits: ::fidl_next::FromWireRef::from_wire_ref(&wire.bits),

            enum_: ::fidl_next::FromWireRef::from_wire_ref(&wire.enum_),

            struct_: ::fidl_next::FromWireRef::from_wire_ref(&wire.struct_),

            table: ::fidl_next::FromWireRef::from_wire_ref(&wire.table),

            union: ::fidl_next::FromWireRef::from_wire_ref(&wire.union),

            opt_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_struct),

            opt_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_union),
        }
    }
}

/// The wire type corresponding to [`Compound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireCompound<'de> {
    pub bits: crate::WireBits,

    pub enum_: crate::WireEnum,

    pub struct_: crate::WireStruct,

    pub table: crate::WireTable<'de>,

    pub union: crate::WireUnion,

    pub opt_struct: ::fidl_next::WireBox<'de, crate::WireStruct>,

    pub opt_union: crate::WireOptionalUnion,
}

unsafe impl ::fidl_next::Wire for WireCompound<'static> {
    type Decoded<'de> = WireCompound<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(9).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireCompound<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits,
                mut enum_,
                mut struct_,
                mut table,
                mut union,
                mut opt_struct,
                mut opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(enum_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,

    pub vector_uint16: Vec<u16>,

    pub vector_uint32: Vec<u32>,

    pub vector_uint64: Vec<u64>,

    pub vector_int8: Vec<i8>,

    pub vector_int16: Vec<i16>,

    pub vector_int32: Vec<i32>,

    pub vector_int64: Vec<i64>,

    pub vector_float32: Vec<f32>,

    pub vector_float64: Vec<f64>,

    pub vector_string: Vec<String>,

    pub vector_opt_string: Vec<Option<String>>,
}

impl ::fidl_next::Encodable for VectorBasic {
    type Encoded = WireVectorBasic<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(self.vector_uint8, encoder, vector_uint8)?;

        ::fidl_next::Encode::encode(self.vector_uint16, encoder, vector_uint16)?;

        ::fidl_next::Encode::encode(self.vector_uint32, encoder, vector_uint32)?;

        ::fidl_next::Encode::encode(self.vector_uint64, encoder, vector_uint64)?;

        ::fidl_next::Encode::encode(self.vector_int8, encoder, vector_int8)?;

        ::fidl_next::Encode::encode(self.vector_int16, encoder, vector_int16)?;

        ::fidl_next::Encode::encode(self.vector_int32, encoder, vector_int32)?;

        ::fidl_next::Encode::encode(self.vector_int64, encoder, vector_int64)?;

        ::fidl_next::Encode::encode(self.vector_float32, encoder, vector_float32)?;

        ::fidl_next::Encode::encode(self.vector_float64, encoder, vector_float64)?;

        ::fidl_next::Encode::encode(self.vector_string, encoder, vector_string)?;

        ::fidl_next::Encode::encode(self.vector_opt_string, encoder, vector_opt_string)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for VectorBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint8, encoder, vector_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint16, encoder, vector_uint16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint32, encoder, vector_uint32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint64, encoder, vector_uint64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int8, encoder, vector_int8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int16, encoder, vector_int16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int32, encoder, vector_int32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int64, encoder, vector_int64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_float32, encoder, vector_float32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_float64, encoder, vector_float64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_string, encoder, vector_string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_opt_string, encoder, vector_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for VectorBasic {
    type EncodedOption = ::fidl_next::WireBox<'static, WireVectorBasic<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for VectorBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorBasic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for VectorBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorBasic: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireVectorBasic<'de>> for VectorBasic {
    #[inline]
    fn from_wire(wire: WireVectorBasic<'de>) -> Self {
        Self {
            vector_uint8: ::fidl_next::FromWire::from_wire(wire.vector_uint8),

            vector_uint16: ::fidl_next::FromWire::from_wire(wire.vector_uint16),

            vector_uint32: ::fidl_next::FromWire::from_wire(wire.vector_uint32),

            vector_uint64: ::fidl_next::FromWire::from_wire(wire.vector_uint64),

            vector_int8: ::fidl_next::FromWire::from_wire(wire.vector_int8),

            vector_int16: ::fidl_next::FromWire::from_wire(wire.vector_int16),

            vector_int32: ::fidl_next::FromWire::from_wire(wire.vector_int32),

            vector_int64: ::fidl_next::FromWire::from_wire(wire.vector_int64),

            vector_float32: ::fidl_next::FromWire::from_wire(wire.vector_float32),

            vector_float64: ::fidl_next::FromWire::from_wire(wire.vector_float64),

            vector_string: ::fidl_next::FromWire::from_wire(wire.vector_string),

            vector_opt_string: ::fidl_next::FromWire::from_wire(wire.vector_opt_string),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireVectorBasic<'de>> for VectorBasic {
    #[inline]
    fn from_wire_ref(wire: &WireVectorBasic<'de>) -> Self {
        Self {
            vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint8),

            vector_uint16: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint16),

            vector_uint32: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint32),

            vector_uint64: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint64),

            vector_int8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int8),

            vector_int16: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int16),

            vector_int32: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int32),

            vector_int64: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int64),

            vector_float32: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_float32),

            vector_float64: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_float64),

            vector_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_string),

            vector_opt_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_opt_string),
        }
    }
}

/// The wire type corresponding to [`VectorBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorBasic<'de> {
    pub vector_uint8: ::fidl_next::WireVector<'de, u8>,

    pub vector_uint16: ::fidl_next::WireVector<'de, ::fidl_next::WireU16>,

    pub vector_uint32: ::fidl_next::WireVector<'de, ::fidl_next::WireU32>,

    pub vector_uint64: ::fidl_next::WireVector<'de, ::fidl_next::WireU64>,

    pub vector_int8: ::fidl_next::WireVector<'de, i8>,

    pub vector_int16: ::fidl_next::WireVector<'de, ::fidl_next::WireI16>,

    pub vector_int32: ::fidl_next::WireVector<'de, ::fidl_next::WireI32>,

    pub vector_int64: ::fidl_next::WireVector<'de, ::fidl_next::WireI64>,

    pub vector_float32: ::fidl_next::WireVector<'de, ::fidl_next::WireF32>,

    pub vector_float64: ::fidl_next::WireVector<'de, ::fidl_next::WireF64>,

    pub vector_string: ::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>,

    pub vector_opt_string: ::fidl_next::WireVector<'de, ::fidl_next::WireOptionalString<'de>>,
}

unsafe impl ::fidl_next::Wire for WireVectorBasic<'static> {
    type Decoded<'de> = WireVectorBasic<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorBasic<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_uint8,
                mut vector_uint16,
                mut vector_uint32,
                mut vector_uint64,
                mut vector_int8,
                mut vector_int16,
                mut vector_int32,
                mut vector_int64,
                mut vector_float32,
                mut vector_float64,
                mut vector_string,
                mut vector_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorCompound {
    pub vector_bits: Vec<crate::Bits>,

    pub vector_enum: Vec<crate::Enum>,

    pub vector_struct: Vec<crate::Struct>,

    pub vector_table: Vec<crate::Table>,

    pub vector_union: Vec<crate::Union>,

    pub vector_opt_struct: Vec<Option<Box<crate::Struct>>>,

    pub vector_opt_union: Vec<Option<Box<crate::Union>>>,
}

impl ::fidl_next::Encodable for VectorCompound {
    type Encoded = WireVectorCompound<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.vector_bits, encoder, vector_bits)?;

        ::fidl_next::Encode::encode(self.vector_enum, encoder, vector_enum)?;

        ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

        ::fidl_next::Encode::encode(self.vector_opt_struct, encoder, vector_opt_struct)?;

        ::fidl_next::Encode::encode(self.vector_opt_union, encoder, vector_opt_union)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for VectorCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.vector_bits, encoder, vector_bits)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_enum, encoder, vector_enum)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_table, encoder, vector_table)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_union, encoder, vector_union)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_opt_struct, encoder, vector_opt_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_opt_union, encoder, vector_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for VectorCompound {
    type EncodedOption = ::fidl_next::WireBox<'static, WireVectorCompound<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for VectorCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorCompound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for VectorCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorCompound: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireVectorCompound<'de>> for VectorCompound {
    #[inline]
    fn from_wire(wire: WireVectorCompound<'de>) -> Self {
        Self {
            vector_bits: ::fidl_next::FromWire::from_wire(wire.vector_bits),

            vector_enum: ::fidl_next::FromWire::from_wire(wire.vector_enum),

            vector_struct: ::fidl_next::FromWire::from_wire(wire.vector_struct),

            vector_table: ::fidl_next::FromWire::from_wire(wire.vector_table),

            vector_union: ::fidl_next::FromWire::from_wire(wire.vector_union),

            vector_opt_struct: ::fidl_next::FromWire::from_wire(wire.vector_opt_struct),

            vector_opt_union: ::fidl_next::FromWire::from_wire(wire.vector_opt_union),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireVectorCompound<'de>> for VectorCompound {
    #[inline]
    fn from_wire_ref(wire: &WireVectorCompound<'de>) -> Self {
        Self {
            vector_bits: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_bits),

            vector_enum: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_enum),

            vector_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_struct),

            vector_table: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_table),

            vector_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_union),

            vector_opt_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_opt_struct),

            vector_opt_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_opt_union),
        }
    }
}

/// The wire type corresponding to [`VectorCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorCompound<'de> {
    pub vector_bits: ::fidl_next::WireVector<'de, crate::WireBits>,

    pub vector_enum: ::fidl_next::WireVector<'de, crate::WireEnum>,

    pub vector_struct: ::fidl_next::WireVector<'de, crate::WireStruct>,

    pub vector_table: ::fidl_next::WireVector<'de, crate::WireTable<'de>>,

    pub vector_union: ::fidl_next::WireVector<'de, crate::WireUnion>,

    pub vector_opt_struct:
        ::fidl_next::WireVector<'de, ::fidl_next::WireBox<'de, crate::WireStruct>>,

    pub vector_opt_union: ::fidl_next::WireVector<'de, crate::WireOptionalUnion>,
}

unsafe impl ::fidl_next::Wire for WireVectorCompound<'static> {
    type Decoded<'de> = WireVectorCompound<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorCompound<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_bits,
                mut vector_enum,
                mut vector_struct,
                mut vector_table,
                mut vector_union,
                mut vector_opt_struct,
                mut vector_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,

    pub opt_vector_string: Option<Vec<String>>,

    pub opt_vector_struct: Option<Vec<crate::Struct>>,

    pub opt_vector_opt_struct: Option<Vec<Option<Box<crate::Struct>>>>,
}

impl ::fidl_next::Encodable for VectorOptional {
    type Encoded = WireVectorOptional<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorOptional
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,

            } = out;
        }

        ::fidl_next::Encode::encode(self.opt_vector_uint8, encoder, opt_vector_uint8)?;

        ::fidl_next::Encode::encode(self.opt_vector_string, encoder, opt_vector_string)?;

        ::fidl_next::Encode::encode(self.opt_vector_struct, encoder, opt_vector_struct)?;

        ::fidl_next::Encode::encode(self.opt_vector_opt_struct, encoder, opt_vector_opt_struct)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for VectorOptional
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.opt_vector_uint8, encoder, opt_vector_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_vector_string, encoder, opt_vector_string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_vector_struct, encoder, opt_vector_struct)?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.opt_vector_opt_struct,
            encoder,
            opt_vector_opt_struct,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for VectorOptional {
    type EncodedOption = ::fidl_next::WireBox<'static, WireVectorOptional<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for VectorOptional
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorOptional: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for VectorOptional
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorOptional: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireVectorOptional<'de>> for VectorOptional {
    #[inline]
    fn from_wire(wire: WireVectorOptional<'de>) -> Self {
        Self {
            opt_vector_uint8: ::fidl_next::FromWire::from_wire(wire.opt_vector_uint8),

            opt_vector_string: ::fidl_next::FromWire::from_wire(wire.opt_vector_string),

            opt_vector_struct: ::fidl_next::FromWire::from_wire(wire.opt_vector_struct),

            opt_vector_opt_struct: ::fidl_next::FromWire::from_wire(wire.opt_vector_opt_struct),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireVectorOptional<'de>> for VectorOptional {
    #[inline]
    fn from_wire_ref(wire: &WireVectorOptional<'de>) -> Self {
        Self {
            opt_vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_vector_uint8),

            opt_vector_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_vector_string),

            opt_vector_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_vector_struct),

            opt_vector_opt_struct: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.opt_vector_opt_struct,
            ),
        }
    }
}

/// The wire type corresponding to [`VectorOptional`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorOptional<'de> {
    pub opt_vector_uint8: ::fidl_next::WireOptionalVector<'de, u8>,

    pub opt_vector_string: ::fidl_next::WireOptionalVector<'de, ::fidl_next::WireString<'de>>,

    pub opt_vector_struct: ::fidl_next::WireOptionalVector<'de, crate::WireStruct>,

    pub opt_vector_opt_struct:
        ::fidl_next::WireOptionalVector<'de, ::fidl_next::WireBox<'de, crate::WireStruct>>,
}

unsafe impl ::fidl_next::Wire for WireVectorOptional<'static> {
    type Decoded<'de> = WireVectorOptional<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorOptional<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut opt_vector_uint8,
                mut opt_vector_string,
                mut opt_vector_struct,
                mut opt_vector_opt_struct,

            } = slot;
        }

        ::fidl_next::Decode::decode(opt_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_opt_struct.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ResourceStruct {}

impl ::fidl_next::Encodable for ResourceStruct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireResourceStruct> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireResourceStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ResourceStruct {
    type EncodedOption = ::fidl_next::WireBox<'static, WireResourceStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ResourceStruct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ResourceStruct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireResourceStruct> for ResourceStruct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireResourceStruct, Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn from_wire(wire: WireResourceStruct) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ResourceStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResourceStruct {}

unsafe impl ::fidl_next::Wire for WireResourceStruct {
    type Decoded<'de> = WireResourceStruct;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct ResourceTable {}

impl ResourceTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for ResourceTable {
    type Encoded = WireResourceTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceTable
where
    ___E: ::fidl_next::Encoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireResourceTable<'de>> for ResourceTable {
    #[inline]
    fn from_wire(wire: WireResourceTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

/// The wire type corresponding to [`ResourceTable`].
#[repr(C)]
pub struct WireResourceTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireResourceTable<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireResourceTable<'static> {
    type Decoded<'de> = WireResourceTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireResourceTable<'de> {}

impl<'de> ::core::fmt::Debug for WireResourceTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ResourceTable").finish()
    }
}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ResourceUnion {
    type Encoded = WireResourceUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceUnion { raw, _phantom: _ } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ResourceUnion {
    type EncodedOption = WireOptionalResourceUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ResourceUnion
where
    ___E: ?Sized,
    ResourceUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalResourceUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireResourceUnion> for ResourceUnion {
    #[inline]
    fn from_wire(wire: WireResourceUnion) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::B(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalResourceUnion> for Box<ResourceUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalResourceUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ResourceUnion`].
#[repr(transparent)]
pub struct WireResourceUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireResourceUnion {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<bool>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireResourceUnion {
    type Decoded<'de> = WireResourceUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod resource_union {
    pub enum Ref<'de> {
        B(&'de bool),

        UnknownOrdinal_(u64),
    }
}

impl WireResourceUnion {
    pub fn as_ref(&self) -> crate::resource_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::resource_union::Ref::B(unsafe { self.raw.get().deref_unchecked::<bool>() }),

            unknown => crate::resource_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalResourceUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalResourceUnion {
    type Decoded<'de> = WireOptionalResourceUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalResourceUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireResourceUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireResourceUnion> {
        if self.is_some() {
            Some(WireResourceUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct Resource {
    pub handle: ::fidl_next::fuchsia::zx::Handle,

    pub vmo: ::fidl_next::fuchsia::zx::Handle,

    pub client_end: ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>,

    pub server_end: ::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>,

    pub struct_: crate::ResourceStruct,

    pub table: crate::ResourceTable,

    pub union: crate::ResourceUnion,

    pub opt_handle: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_vmo: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_client_end:
        ::fidl_next::ClientEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::ServerEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::Protocol>,

    pub opt_struct: Option<Box<crate::ResourceStruct>>,

    pub opt_union: Option<Box<crate::ResourceUnion>>,

    pub array_handle: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_vmo: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_client_end:
        [::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>; 5],

    pub array_struct: [crate::ResourceStruct; 5],

    pub array_table: [crate::ResourceTable; 5],

    pub array_union: [crate::ResourceUnion; 5],

    pub vector_handle: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_vmo: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_client_end:
        Vec<::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>>,

    pub vector_server_end:
        Vec<::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>>,

    pub vector_struct: Vec<crate::ResourceStruct>,

    pub vector_table: Vec<crate::ResourceTable>,

    pub vector_union: Vec<crate::ResourceUnion>,
}

impl ::fidl_next::Encodable for Resource {
    type Encoded = WireResource<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Resource
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.handle, encoder, handle)?;

        ::fidl_next::Encode::encode(self.vmo, encoder, vmo)?;

        ::fidl_next::Encode::encode(self.client_end, encoder, client_end)?;

        ::fidl_next::Encode::encode(self.server_end, encoder, server_end)?;

        ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(self.table, encoder, table)?;

        ::fidl_next::Encode::encode(self.union, encoder, union)?;

        ::fidl_next::Encode::encode(self.opt_handle, encoder, opt_handle)?;

        ::fidl_next::Encode::encode(self.opt_vmo, encoder, opt_vmo)?;

        ::fidl_next::Encode::encode(self.opt_client_end, encoder, opt_client_end)?;

        ::fidl_next::Encode::encode(self.opt_server_end, encoder, opt_server_end)?;

        ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

        ::fidl_next::Encode::encode(self.array_handle, encoder, array_handle)?;

        ::fidl_next::Encode::encode(self.array_vmo, encoder, array_vmo)?;

        ::fidl_next::Encode::encode(self.array_client_end, encoder, array_client_end)?;

        ::fidl_next::Encode::encode(self.array_server_end, encoder, array_server_end)?;

        ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(self.vector_handle, encoder, vector_handle)?;

        ::fidl_next::Encode::encode(self.vector_vmo, encoder, vector_vmo)?;

        ::fidl_next::Encode::encode(self.vector_client_end, encoder, vector_client_end)?;

        ::fidl_next::Encode::encode(self.vector_server_end, encoder, vector_server_end)?;

        ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Resource {
    type EncodedOption = ::fidl_next::WireBox<'static, WireResource<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Resource
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Resource: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireResource<'de>> for Resource {
    #[inline]
    fn from_wire(wire: WireResource<'de>) -> Self {
        Self {
            handle: ::fidl_next::FromWire::from_wire(wire.handle),

            vmo: ::fidl_next::FromWire::from_wire(wire.vmo),

            client_end: ::fidl_next::FromWire::from_wire(wire.client_end),

            server_end: ::fidl_next::FromWire::from_wire(wire.server_end),

            struct_: ::fidl_next::FromWire::from_wire(wire.struct_),

            table: ::fidl_next::FromWire::from_wire(wire.table),

            union: ::fidl_next::FromWire::from_wire(wire.union),

            opt_handle: ::fidl_next::FromWire::from_wire(wire.opt_handle),

            opt_vmo: ::fidl_next::FromWire::from_wire(wire.opt_vmo),

            opt_client_end: ::fidl_next::FromWire::from_wire(wire.opt_client_end),

            opt_server_end: ::fidl_next::FromWire::from_wire(wire.opt_server_end),

            opt_struct: ::fidl_next::FromWire::from_wire(wire.opt_struct),

            opt_union: ::fidl_next::FromWire::from_wire(wire.opt_union),

            array_handle: ::fidl_next::FromWire::from_wire(wire.array_handle),

            array_vmo: ::fidl_next::FromWire::from_wire(wire.array_vmo),

            array_client_end: ::fidl_next::FromWire::from_wire(wire.array_client_end),

            array_server_end: ::fidl_next::FromWire::from_wire(wire.array_server_end),

            array_struct: ::fidl_next::FromWire::from_wire(wire.array_struct),

            array_table: ::fidl_next::FromWire::from_wire(wire.array_table),

            array_union: ::fidl_next::FromWire::from_wire(wire.array_union),

            vector_handle: ::fidl_next::FromWire::from_wire(wire.vector_handle),

            vector_vmo: ::fidl_next::FromWire::from_wire(wire.vector_vmo),

            vector_client_end: ::fidl_next::FromWire::from_wire(wire.vector_client_end),

            vector_server_end: ::fidl_next::FromWire::from_wire(wire.vector_server_end),

            vector_struct: ::fidl_next::FromWire::from_wire(wire.vector_struct),

            vector_table: ::fidl_next::FromWire::from_wire(wire.vector_table),

            vector_union: ::fidl_next::FromWire::from_wire(wire.vector_union),
        }
    }
}

/// The wire type corresponding to [`Resource`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResource<'de> {
    pub handle: ::fidl_next::fuchsia::WireHandle,

    pub vmo: ::fidl_next::fuchsia::WireHandle,

    pub client_end: ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,

    pub server_end: ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,

    pub struct_: crate::WireResourceStruct,

    pub table: crate::WireResourceTable<'de>,

    pub union: crate::WireResourceUnion,

    pub opt_handle: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_vmo: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_client_end:
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::Protocol>,

    pub opt_struct: ::fidl_next::WireBox<'de, crate::WireResourceStruct>,

    pub opt_union: crate::WireOptionalResourceUnion,

    pub array_handle: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_vmo: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_client_end:
        [::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>; 5],

    pub array_struct: [crate::WireResourceStruct; 5],

    pub array_table: [crate::WireResourceTable<'de>; 5],

    pub array_union: [crate::WireResourceUnion; 5],

    pub vector_handle: ::fidl_next::WireVector<'de, ::fidl_next::fuchsia::WireHandle>,

    pub vector_vmo: ::fidl_next::WireVector<'de, ::fidl_next::fuchsia::WireHandle>,

    pub vector_client_end: ::fidl_next::WireVector<
        'de,
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,
    >,

    pub vector_server_end: ::fidl_next::WireVector<
        'de,
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,
    >,

    pub vector_struct: ::fidl_next::WireVector<'de, crate::WireResourceStruct>,

    pub vector_table: ::fidl_next::WireVector<'de, crate::WireResourceTable<'de>>,

    pub vector_union: ::fidl_next::WireVector<'de, crate::WireResourceUnion>,
}

unsafe impl ::fidl_next::Wire for WireResource<'static> {
    type Decoded<'de> = WireResource<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(181).write_bytes(0, 3);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(17).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResource<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut handle,
                mut vmo,
                mut client_end,
                mut server_end,
                mut struct_,
                mut table,
                mut union,
                mut opt_handle,
                mut opt_vmo,
                mut opt_client_end,
                mut opt_server_end,
                mut opt_struct,
                mut opt_union,
                mut array_handle,
                mut array_vmo,
                mut array_client_end,
                mut array_server_end,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut vector_handle,
                mut vector_vmo,
                mut vector_client_end,
                mut vector_server_end,
                mut vector_struct,
                mut vector_table,
                mut vector_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Protocol protocol.
#[derive(Debug)]
pub struct Protocol;

pub mod protocol {
    pub mod prelude {
        pub use crate::{
            protocol, Protocol, ProtocolClientHandler, ProtocolClientSender, ProtocolServerHandler,
            ProtocolServerSender,
        };

        pub use crate::ArrayBasic;

        pub use crate::ArrayCompound;

        pub use crate::ArrayVectorNested;

        pub use crate::Basic;

        pub use crate::Compound;

        pub use crate::Resource;

        pub use crate::VectorBasic;

        pub use crate::VectorCompound;

        pub use crate::VectorOptional;
    }

    pub struct OneWayBasic;

    impl ::fidl_next::Method for OneWayBasic {
        const ORDINAL: u64 = 8948968077914418681;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayBasic;

    impl ::fidl_next::Method for TwoWayBasic {
        const ORDINAL: u64 = 2331618702752598159;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic<'static>;

        type Response = crate::WireBasic<'static>;
    }

    pub struct ErrorBasic;

    impl ::fidl_next::Method for ErrorBasic {
        const ORDINAL: u64 = 5016634351643393939;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireBasic<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventBasic;

    impl ::fidl_next::Method for EventBasic {
        const ORDINAL: u64 = 5892309624949902400;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireBasic<'static>;
    }

    pub struct OneWayCompound;

    impl ::fidl_next::Method for OneWayCompound {
        const ORDINAL: u64 = 3153289648860022476;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayCompound;

    impl ::fidl_next::Method for TwoWayCompound {
        const ORDINAL: u64 = 8787219719097524529;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound<'static>;

        type Response = crate::WireCompound<'static>;
    }

    pub struct ErrorCompound;

    impl ::fidl_next::Method for ErrorCompound {
        const ORDINAL: u64 = 2990809657626249085;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireCompound<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventCompound;

    impl ::fidl_next::Method for EventCompound {
        const ORDINAL: u64 = 7024581948727571669;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireCompound<'static>;
    }

    pub struct OneWayArrayBasic;

    impl ::fidl_next::Method for OneWayArrayBasic {
        const ORDINAL: u64 = 7125516817014311449;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayBasic;

    impl ::fidl_next::Method for TwoWayArrayBasic {
        const ORDINAL: u64 = 5309034178175279380;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic<'static>;

        type Response = crate::WireArrayBasic<'static>;
    }

    pub struct ErrorArrayBasic;

    impl ::fidl_next::Method for ErrorArrayBasic {
        const ORDINAL: u64 = 1084731895342694265;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireArrayBasic<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventArrayBasic;

    impl ::fidl_next::Method for EventArrayBasic {
        const ORDINAL: u64 = 5888282827283820590;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayBasic<'static>;
    }

    pub struct OneWayArrayCompound;

    impl ::fidl_next::Method for OneWayArrayCompound {
        const ORDINAL: u64 = 5064659223443251357;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayCompound;

    impl ::fidl_next::Method for TwoWayArrayCompound {
        const ORDINAL: u64 = 849744466051983995;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound<'static>;

        type Response = crate::WireArrayCompound<'static>;
    }

    pub struct ErrorArrayCompound;

    impl ::fidl_next::Method for ErrorArrayCompound {
        const ORDINAL: u64 = 5919277476782807556;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireArrayCompound<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventArrayCompound;

    impl ::fidl_next::Method for EventArrayCompound {
        const ORDINAL: u64 = 2189769767733851157;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayCompound<'static>;
    }

    pub struct OneWayVectorBasic;

    impl ::fidl_next::Method for OneWayVectorBasic {
        const ORDINAL: u64 = 5733220720079947351;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorBasic;

    impl ::fidl_next::Method for TwoWayVectorBasic {
        const ORDINAL: u64 = 8674156353091415668;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic<'static>;

        type Response = crate::WireVectorBasic<'static>;
    }

    pub struct ErrorVectorBasic;

    impl ::fidl_next::Method for ErrorVectorBasic {
        const ORDINAL: u64 = 875941614196965234;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireVectorBasic<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventVectorBasic;

    impl ::fidl_next::Method for EventVectorBasic {
        const ORDINAL: u64 = 4583890770109526006;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorBasic<'static>;
    }

    pub struct OneWayVectorCompound;

    impl ::fidl_next::Method for OneWayVectorCompound {
        const ORDINAL: u64 = 1853985797298830992;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorCompound;

    impl ::fidl_next::Method for TwoWayVectorCompound {
        const ORDINAL: u64 = 3968024057912959924;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound<'static>;

        type Response = crate::WireVectorCompound<'static>;
    }

    pub struct ErrorVectorCompound;

    impl ::fidl_next::Method for ErrorVectorCompound {
        const ORDINAL: u64 = 8506780203315865989;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireVectorCompound<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventVectorCompound;

    impl ::fidl_next::Method for EventVectorCompound {
        const ORDINAL: u64 = 6026375226599919603;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorCompound<'static>;
    }

    pub struct OneWayVectorOptional;

    impl ::fidl_next::Method for OneWayVectorOptional {
        const ORDINAL: u64 = 1530215841195476271;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorOptional;

    impl ::fidl_next::Method for TwoWayVectorOptional {
        const ORDINAL: u64 = 1030024737742222323;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional<'static>;

        type Response = crate::WireVectorOptional<'static>;
    }

    pub struct ErrorVectorOptional;

    impl ::fidl_next::Method for ErrorVectorOptional {
        const ORDINAL: u64 = 6406191217027936606;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireVectorOptional<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventVectorOptional;

    impl ::fidl_next::Method for EventVectorOptional {
        const ORDINAL: u64 = 1684763340073130077;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorOptional<'static>;
    }

    pub struct OneWayArrayVectorNested;

    impl ::fidl_next::Method for OneWayArrayVectorNested {
        const ORDINAL: u64 = 5912603762133524183;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayVectorNested;

    impl ::fidl_next::Method for TwoWayArrayVectorNested {
        const ORDINAL: u64 = 5351275678438791132;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested<'static>;

        type Response = crate::WireArrayVectorNested<'static>;
    }

    pub struct ErrorArrayVectorNested;

    impl ::fidl_next::Method for ErrorArrayVectorNested {
        const ORDINAL: u64 = 9085604921605802151;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireArrayVectorNested<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventArrayVectorNested;

    impl ::fidl_next::Method for EventArrayVectorNested {
        const ORDINAL: u64 = 1228201560727880574;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayVectorNested<'static>;
    }

    pub struct OneWayResource;

    impl ::fidl_next::Method for OneWayResource {
        const ORDINAL: u64 = 6553996787849601058;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayResource;

    impl ::fidl_next::Method for TwoWayResource {
        const ORDINAL: u64 = 1802709005492464987;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource<'static>;

        type Response = crate::WireResource<'static>;
    }

    pub struct ErrorResource;

    impl ::fidl_next::Method for ErrorResource {
        const ORDINAL: u64 = 6568609240497354166;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireResource<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventResource;

    impl ::fidl_next::Method for EventResource {
        const ORDINAL: u64 = 5745997765922613643;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireResource<'static>;
    }
}

/// A helper trait for the `Protocol` client sender.
pub trait ProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn one_way_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic<'static>,
        >;

    fn two_way_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic<'static>,
        >;

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound<'static>,
        >;

    fn two_way_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound<'static>,
        >;

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic<'static>,
        >;

    fn two_way_array_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic<'static>,
        >;

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound<'static>,
        >;

    fn two_way_array_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound<'static>,
        >;

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic<'static>,
        >;

    fn two_way_vector_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic<'static>,
        >;

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound<'static>,
        >;

    fn two_way_vector_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound<'static>,
        >;

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_optional<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional<'static>,
        >;

    fn two_way_vector_optional<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional<'static>,
        >;

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_vector_nested<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested<'static>,
        >;

    fn two_way_array_vector_nested<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested<'static>,
        >;

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_resource<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource<'static>,
        >;

    fn two_way_resource<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource<'static>,
        >;

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> ProtocolClientSender for ::fidl_next::ClientSender<___T, Protocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn one_way_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic<'static>,
        >,
    {
        self.as_untyped().send_one_way(8948968077914418681, request)
    }

    fn two_way_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(2331618702752598159, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5016634351643393939, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound<'static>,
        >,
    {
        self.as_untyped().send_one_way(3153289648860022476, request)
    }

    fn two_way_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(8787219719097524529, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2990809657626249085, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_array_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic<'static>,
        >,
    {
        self.as_untyped().send_one_way(7125516817014311449, request)
    }

    fn two_way_array_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(5309034178175279380, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1084731895342694265, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_array_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound<'static>,
        >,
    {
        self.as_untyped().send_one_way(5064659223443251357, request)
    }

    fn two_way_array_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(849744466051983995, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5919277476782807556, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_vector_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic<'static>,
        >,
    {
        self.as_untyped().send_one_way(5733220720079947351, request)
    }

    fn two_way_vector_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(8674156353091415668, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(875941614196965234, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_vector_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound<'static>,
        >,
    {
        self.as_untyped().send_one_way(1853985797298830992, request)
    }

    fn two_way_vector_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(3968024057912959924, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8506780203315865989, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_vector_optional<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional<'static>,
        >,
    {
        self.as_untyped().send_one_way(1530215841195476271, request)
    }

    fn two_way_vector_optional<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(1030024737742222323, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6406191217027936606, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_array_vector_nested<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested<'static>,
        >,
    {
        self.as_untyped().send_one_way(5912603762133524183, request)
    }

    fn two_way_array_vector_nested<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(5351275678438791132, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9085604921605802151, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_resource<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource<'static>,
        >,
    {
        self.as_untyped().send_one_way(6553996787849601058, request)
    }

    fn two_way_resource<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(1802709005492464987, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6568609240497354166, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn event_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventBasic>,
    );

    fn event_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventCompound>,
    );

    fn event_array_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventArrayBasic>,
    );

    fn event_array_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventArrayCompound>,
    );

    fn event_vector_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventVectorBasic>,
    );

    fn event_vector_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventVectorCompound>,
    );

    fn event_vector_optional(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventVectorOptional>,
    );

    fn event_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventArrayVectorNested>,
    );

    fn event_resource(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        event: ::fidl_next::Response<___T, protocol::EventResource>,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::Transport,
    ___H: ProtocolClientHandler<___T>,

    <protocol::TwoWayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5892309624949902400 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_basic(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            7024581948727571669 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_compound(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            5888282827283820590 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_array_basic(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            2189769767733851157 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_array_compound(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            4583890770109526006 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_vector_basic(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            6026375226599919603 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_vector_compound(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            1684763340073130077 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_vector_optional(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            1228201560727880574 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_array_vector_nested(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            5745997765922613643 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_resource(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Protocol` server sender.
pub trait ProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn event_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventBasic as ::fidl_next::Method>::Response,
        >;

    fn event_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventCompound as ::fidl_next::Method>::Response,
        >;

    fn event_array_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayBasic as ::fidl_next::Method>::Response,
        >;

    fn event_array_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayCompound as ::fidl_next::Method>::Response,
        >;

    fn event_vector_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorBasic as ::fidl_next::Method>::Response,
        >;

    fn event_vector_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorCompound as ::fidl_next::Method>::Response,
        >;

    fn event_vector_optional<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorOptional as ::fidl_next::Method>::Response,
        >;

    fn event_array_vector_nested<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayVectorNested as ::fidl_next::Method>::Response,
        >;

    fn event_resource<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventResource as ::fidl_next::Method>::Response,
        >;
}

impl<___T> ProtocolServerSender for ::fidl_next::ServerSender<___T, Protocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn event_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventBasic as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(5892309624949902400, request)
    }

    fn event_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventCompound as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(7024581948727571669, request)
    }

    fn event_array_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayBasic as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(5888282827283820590, request)
    }

    fn event_array_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayCompound as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(2189769767733851157, request)
    }

    fn event_vector_basic<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorBasic as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(4583890770109526006, request)
    }

    fn event_vector_compound<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorCompound as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(6026375226599919603, request)
    }

    fn event_vector_optional<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorOptional as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(1684763340073130077, request)
    }

    fn event_array_vector_nested<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayVectorNested as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(1228201560727880574, request)
    }

    fn event_resource<___R>(
        &self,
        request: ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventResource as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(5745997765922613643, request)
    }
}

/// A server handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn one_way_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayBasic>,
    );

    fn two_way_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayBasic>,

        responder: ::fidl_next::Responder<protocol::TwoWayBasic>,
    );

    fn error_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorBasic>,
    );

    fn one_way_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayCompound>,
    );

    fn two_way_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayCompound>,

        responder: ::fidl_next::Responder<protocol::TwoWayCompound>,
    );

    fn error_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorCompound>,
    );

    fn one_way_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayArrayBasic>,
    );

    fn two_way_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayArrayBasic>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayBasic>,
    );

    fn error_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayBasic>,
    );

    fn one_way_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayArrayCompound>,
    );

    fn two_way_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayArrayCompound>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayCompound>,
    );

    fn error_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayCompound>,
    );

    fn one_way_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayVectorBasic>,
    );

    fn two_way_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayVectorBasic>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorBasic>,
    );

    fn error_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorBasic>,
    );

    fn one_way_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayVectorCompound>,
    );

    fn two_way_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayVectorCompound>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorCompound>,
    );

    fn error_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorCompound>,
    );

    fn one_way_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayVectorOptional>,
    );

    fn two_way_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayVectorOptional>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorOptional>,
    );

    fn error_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorOptional>,
    );

    fn one_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayArrayVectorNested>,
    );

    fn two_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayArrayVectorNested>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayVectorNested>,
    );

    fn error_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayVectorNested>,
    );

    fn one_way_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::OneWayResource>,
    );

    fn two_way_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::Request<___T, protocol::TwoWayResource>,

        responder: ::fidl_next::Responder<protocol::TwoWayResource>,
    );

    fn error_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorResource>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::Transport,
    ___H: ProtocolServerHandler<___T>,

    <protocol::OneWayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayArrayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayArrayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayVectorBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayVectorCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayVectorOptional as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorOptional as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayArrayVectorNested as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayVectorNested as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayResource as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayResource as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            8948968077914418681 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_basic(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            3153289648860022476 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_compound(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            7125516817014311449 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_array_basic(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            5064659223443251357 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_array_compound(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            5733220720079947351 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_vector_basic(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            1853985797298830992 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_vector_compound(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            1530215841195476271 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_vector_optional(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            5912603762133524183 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_array_vector_nested(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            6553996787849601058 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_resource(sender, decoded),
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2331618702752598159 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_basic(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            5016634351643393939 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_basic(sender, responder);
            }

            8787219719097524529 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_compound(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            2990809657626249085 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_compound(sender, responder);
            }

            5309034178175279380 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_array_basic(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            1084731895342694265 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_basic(sender, responder);
            }

            849744466051983995 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_array_compound(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            5919277476782807556 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_compound(sender, responder);
            }

            8674156353091415668 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_vector_basic(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            875941614196965234 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_basic(sender, responder);
            }

            3968024057912959924 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_vector_compound(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            8506780203315865989 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_compound(sender, responder);
            }

            1030024737742222323 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_vector_optional(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            6406191217027936606 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_optional(sender, responder);
            }

            5351275678438791132 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_array_vector_nested(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            9085604921605802151 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_vector_nested(sender, responder);
            }

            1802709005492464987 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_resource(sender, decoded, responder),
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            6568609240497354166 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_resource(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::core::convert::From<crate::Bits> for ::fidl_test_typesinprotocols::Bits {
        #[inline]
        fn from(from: crate::Bits) -> Self {
            Self::from_bits_retain(from.bits())
        }
    }

    impl ::core::convert::From<crate::Enum> for ::fidl_test_typesinprotocols::Enum {
        #[inline]
        fn from(from: crate::Enum) -> Self {
            match crate::Enum::from(from) {
                crate::Enum::Val => Self::Val,

                crate::Enum::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Protocol`
    /// protocol.
    pub type ProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Protocol>;

    impl ::core::convert::From<crate::Protocol> for ::fidl_test_typesinprotocols::ProtocolMarker {
        #[inline]
        fn from(_: crate::Protocol) -> Self {
            Self
        }
    }
}
