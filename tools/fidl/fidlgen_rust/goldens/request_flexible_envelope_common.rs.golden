// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[derive(Clone, Debug, PartialEq)]
pub struct ProtocolRequestFlexibleResponseStrictRequest {
    pub s: FlexibleFoo,
}

impl fidl::Persistable for ProtocolRequestFlexibleResponseStrictRequest {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ProtocolRequestFlexibleResponseStrictResponse {
    pub f: StrictFoo,
}

impl fidl::Persistable for ProtocolRequestFlexibleResponseStrictResponse {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ProtocolRequestStrictResponseFlexibleRequest {
    pub s: StrictFoo,
}

impl fidl::Persistable for ProtocolRequestStrictResponseFlexibleRequest {}

#[derive(Clone, Debug, PartialEq)]
pub struct ProtocolRequestStrictResponseFlexibleResponse {
    pub f: FlexibleFoo,
}

impl fidl::Persistable for ProtocolRequestStrictResponseFlexibleResponse {}

#[derive(Clone, Debug)]
pub enum FlexibleFoo {
    S(String),
    I(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `FlexibleFoo` member.
#[macro_export]
macro_rules! FlexibleFooUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for FlexibleFoo {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::S(x), Self::S(y)) => *x == *y,
            (Self::I(x), Self::I(y)) => *x == *y,
            _ => false,
        }
    }
}

impl FlexibleFoo {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::S(_) => 1,
            Self::I(_) => 2,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for FlexibleFoo {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum StrictFoo {
    S(String),
    I(i32),
}

impl StrictFoo {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::S(_) => 1,
            Self::I(_) => 2,
        }
    }

    #[deprecated = "Strict unions should not use `is_unknown`"]
    #[inline]
    pub fn is_unknown(&self) -> bool {
        false
    }
}

impl fidl::Persistable for StrictFoo {}

mod internal {
    use super::*;

    impl fidl::encoding::ValueTypeMarker for ProtocolRequestFlexibleResponseStrictRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ProtocolRequestFlexibleResponseStrictRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ProtocolRequestFlexibleResponseStrictRequest, D>
        for &ProtocolRequestFlexibleResponseStrictRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestFlexibleResponseStrictRequest>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ProtocolRequestFlexibleResponseStrictRequest, D>::encode(
                (<FlexibleFoo as fidl::encoding::ValueTypeMarker>::borrow(&self.s),),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<FlexibleFoo, D>>
        fidl::encoding::Encode<ProtocolRequestFlexibleResponseStrictRequest, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestFlexibleResponseStrictRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ProtocolRequestFlexibleResponseStrictRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { s: fidl::new_empty!(FlexibleFoo, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(FlexibleFoo, D, &mut self.s, decoder, offset + 0, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ProtocolRequestFlexibleResponseStrictResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ProtocolRequestFlexibleResponseStrictResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ProtocolRequestFlexibleResponseStrictResponse, D>
        for &ProtocolRequestFlexibleResponseStrictResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestFlexibleResponseStrictResponse>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ProtocolRequestFlexibleResponseStrictResponse, D>::encode(
                (<StrictFoo as fidl::encoding::ValueTypeMarker>::borrow(&self.f),),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<StrictFoo, D>>
        fidl::encoding::Encode<ProtocolRequestFlexibleResponseStrictResponse, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestFlexibleResponseStrictResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ProtocolRequestFlexibleResponseStrictResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { f: fidl::new_empty!(StrictFoo, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(StrictFoo, D, &mut self.f, decoder, offset + 0, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ProtocolRequestStrictResponseFlexibleRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ProtocolRequestStrictResponseFlexibleRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ProtocolRequestStrictResponseFlexibleRequest, D>
        for &ProtocolRequestStrictResponseFlexibleRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestStrictResponseFlexibleRequest>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ProtocolRequestStrictResponseFlexibleRequest, D>::encode(
                (<StrictFoo as fidl::encoding::ValueTypeMarker>::borrow(&self.s),),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<StrictFoo, D>>
        fidl::encoding::Encode<ProtocolRequestStrictResponseFlexibleRequest, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestStrictResponseFlexibleRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ProtocolRequestStrictResponseFlexibleRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { s: fidl::new_empty!(StrictFoo, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(StrictFoo, D, &mut self.s, decoder, offset + 0, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ProtocolRequestStrictResponseFlexibleResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ProtocolRequestStrictResponseFlexibleResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ProtocolRequestStrictResponseFlexibleResponse, D>
        for &ProtocolRequestStrictResponseFlexibleResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestStrictResponseFlexibleResponse>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ProtocolRequestStrictResponseFlexibleResponse, D>::encode(
                (<FlexibleFoo as fidl::encoding::ValueTypeMarker>::borrow(&self.f),),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<FlexibleFoo, D>>
        fidl::encoding::Encode<ProtocolRequestStrictResponseFlexibleResponse, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ProtocolRequestStrictResponseFlexibleResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ProtocolRequestStrictResponseFlexibleResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { f: fidl::new_empty!(FlexibleFoo, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(FlexibleFoo, D, &mut self.f, decoder, offset + 0, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for FlexibleFoo {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for FlexibleFoo {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<FlexibleFoo, D>
        for &FlexibleFoo
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<FlexibleFoo>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                FlexibleFoo::S(ref val) => fidl::encoding::encode_in_envelope::<
                    fidl::encoding::UnboundedString,
                    D,
                >(
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(
                        val,
                    ),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                FlexibleFoo::I(ref val) => fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                FlexibleFoo::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for FlexibleFoo {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <fidl::encoding::UnboundedString as fidl::encoding::TypeMarker>::inline_size(
                    decoder.context,
                ),
                2 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let FlexibleFoo::S(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self =
                            FlexibleFoo::S(fidl::new_empty!(fidl::encoding::UnboundedString, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let FlexibleFoo::S(ref mut val) = self {
                        fidl::decode!(
                            fidl::encoding::UnboundedString,
                            D,
                            val,
                            decoder,
                            _inner_offset,
                            depth
                        )?;
                    } else {
                        unreachable!()
                    }
                }
                2 => {
                    #[allow(irrefutable_let_patterns)]
                    if let FlexibleFoo::I(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = FlexibleFoo::I(fidl::new_empty!(i32, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let FlexibleFoo::I(ref mut val) = self {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = FlexibleFoo::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for StrictFoo {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for StrictFoo {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<StrictFoo, D>
        for &StrictFoo
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<StrictFoo>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                StrictFoo::S(ref val) => fidl::encoding::encode_in_envelope::<
                    fidl::encoding::UnboundedString,
                    D,
                >(
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(
                        val,
                    ),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                StrictFoo::I(ref val) => fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for StrictFoo {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::S(fidl::new_empty!(fidl::encoding::UnboundedString, D))
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <fidl::encoding::UnboundedString as fidl::encoding::TypeMarker>::inline_size(
                    decoder.context,
                ),
                2 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                _ => return Err(fidl::Error::UnknownUnionTag),
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let StrictFoo::S(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = StrictFoo::S(fidl::new_empty!(fidl::encoding::UnboundedString, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let StrictFoo::S(ref mut val) = self {
                        fidl::decode!(
                            fidl::encoding::UnboundedString,
                            D,
                            val,
                            decoder,
                            _inner_offset,
                            depth
                        )?;
                    } else {
                        unreachable!()
                    }
                }
                2 => {
                    #[allow(irrefutable_let_patterns)]
                    if let StrictFoo::I(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = StrictFoo::I(fidl::new_empty!(i32, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let StrictFoo::I(ref mut val) = self {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                ordinal => panic!("unexpected ordinal {:?}", ordinal),
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
