// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

bitflags! {
    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Bits: u32 {
        const VAL = 1;
    }
}

impl Bits {
    #[inline(always)]
    pub fn from_bits_allow_unknown(bits: u32) -> Self {
        Self::from_bits_retain(bits)
    }

    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        self.get_unknown_bits() != 0
    }

    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u32 {
        self.bits() & !Self::all().bits()
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum Enum {
    Val,
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u32,
    },
}

/// Pattern that matches an unknown `Enum` member.
#[macro_export]
macro_rules! EnumUnknown {
    () => {
        _
    };
}

impl Enum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Val),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::Val,
            unknown_ordinal => Self::__SourceBreaking { unknown_ordinal },
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0xffffffff }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::Val => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { unknown_ordinal: _ } => true,
            _ => false,
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],
    pub array_uint16: [u16; 5],
    pub array_uint32: [u32; 5],
    pub array_uint64: [u64; 5],
    pub array_int8: [i8; 5],
    pub array_int16: [i16; 5],
    pub array_int32: [i32; 5],
    pub array_int64: [i64; 5],
    pub array_float32: [f32; 5],
    pub array_float64: [f64; 5],
    pub array_string: [String; 5],
    pub array_opt_string: [Option<String>; 5],
}

impl fidl::Persistable for ArrayBasic {}

#[derive(Clone, Debug, PartialEq)]
pub struct ArrayCompound {
    pub array_bits: [Bits; 5],
    pub array_enum: [Enum; 5],
    pub array_struct: [Struct; 5],
    pub array_table: [Table; 5],
    pub array_union: [Union; 5],
    pub array_opt_struct: [Option<Box<Struct>>; 5],
    pub array_opt_union: [Option<Box<Union>>; 5],
}

impl fidl::Persistable for ArrayCompound {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],
    pub array_vector_uint8: [Vec<u8>; 5],
    pub vector_array_uint8: Vec<[u8; 5]>,
    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl fidl::Persistable for ArrayVectorNested {}

#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub struct Basic {
    pub uint8: u8,
    pub uint16: u16,
    pub uint32: u32,
    pub uint64: u64,
    pub int8: i8,
    pub int16: i16,
    pub int32: i32,
    pub int64: i64,
    pub float32: f32,
    pub float64: f64,
    pub string: String,
    pub opt_string: Option<String>,
}

impl fidl::Persistable for Basic {}

#[derive(Clone, Debug, PartialEq)]
pub struct Compound {
    pub bits: Bits,
    pub enum_: Enum,
    pub struct_: Struct,
    pub table: Table,
    pub union: Union,
    pub opt_struct: Option<Box<Struct>>,
    pub opt_union: Option<Box<Union>>,
}

impl fidl::Persistable for Compound {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Struct;

impl fidl::Persistable for Struct {}

#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,
    pub vector_uint16: Vec<u16>,
    pub vector_uint32: Vec<u32>,
    pub vector_uint64: Vec<u64>,
    pub vector_int8: Vec<i8>,
    pub vector_int16: Vec<i16>,
    pub vector_int32: Vec<i32>,
    pub vector_int64: Vec<i64>,
    pub vector_float32: Vec<f32>,
    pub vector_float64: Vec<f64>,
    pub vector_string: Vec<String>,
    pub vector_opt_string: Vec<Option<String>>,
}

impl fidl::Persistable for VectorBasic {}

#[derive(Clone, Debug, PartialEq)]
pub struct VectorCompound {
    pub vector_bits: Vec<Bits>,
    pub vector_enum: Vec<Enum>,
    pub vector_struct: Vec<Struct>,
    pub vector_table: Vec<Table>,
    pub vector_union: Vec<Union>,
    pub vector_opt_struct: Vec<Option<Box<Struct>>>,
    pub vector_opt_union: Vec<Option<Box<Union>>>,
}

impl fidl::Persistable for VectorCompound {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,
    pub opt_vector_string: Option<Vec<String>>,
    pub opt_vector_struct: Option<Vec<Struct>>,
    pub opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
}

impl fidl::Persistable for VectorOptional {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct Table {
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for Table {}

#[derive(Clone, Debug)]
pub enum Union {
    B(bool),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `Union` member.
#[macro_export]
macro_rules! UnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for Union {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::B(x), Self::B(y)) => *x == *y,
            _ => false,
        }
    }
}

impl Union {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::B(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for Union {}

mod internal {
    use super::*;
    unsafe impl fidl::encoding::TypeMarker for Bits {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    impl fidl::encoding::ValueTypeMarker for Bits {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            *value
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Self, D> for Bits {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.bits(), offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Bits {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::empty()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);
            *self = Self::from_bits_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for Enum {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            false
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for Enum {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            *value
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Self, D> for Enum {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Enum {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::unknown()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive_allow_unknown(prim);
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ArrayBasic {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ArrayBasic {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            384
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<ArrayBasic, D>
        for &ArrayBasic
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayBasic>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ArrayBasic, D>::encode(
                (
                    <fidl::encoding::Array<u8, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint8),
                    <fidl::encoding::Array<u16, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint16),
                    <fidl::encoding::Array<u32, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint32),
                    <fidl::encoding::Array<u64, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_uint64),
                    <fidl::encoding::Array<i8, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int8),
                    <fidl::encoding::Array<i16, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int16),
                    <fidl::encoding::Array<i32, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int32),
                    <fidl::encoding::Array<i64, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_int64),
                    <fidl::encoding::Array<f32, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_float32),
                    <fidl::encoding::Array<f64, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_float64),
                    <fidl::encoding::Array<fidl::encoding::UnboundedString, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_string),
                    <fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_opt_string),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::Array<u8, 5>, D>,
            T1: fidl::encoding::Encode<fidl::encoding::Array<u16, 5>, D>,
            T2: fidl::encoding::Encode<fidl::encoding::Array<u32, 5>, D>,
            T3: fidl::encoding::Encode<fidl::encoding::Array<u64, 5>, D>,
            T4: fidl::encoding::Encode<fidl::encoding::Array<i8, 5>, D>,
            T5: fidl::encoding::Encode<fidl::encoding::Array<i16, 5>, D>,
            T6: fidl::encoding::Encode<fidl::encoding::Array<i32, 5>, D>,
            T7: fidl::encoding::Encode<fidl::encoding::Array<i64, 5>, D>,
            T8: fidl::encoding::Encode<fidl::encoding::Array<f32, 5>, D>,
            T9: fidl::encoding::Encode<fidl::encoding::Array<f64, 5>, D>,
            T10: fidl::encoding::Encode<fidl::encoding::Array<fidl::encoding::UnboundedString, 5>, D>,
            T11: fidl::encoding::Encode<
                fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5>,
                D,
            >,
        > fidl::encoding::Encode<ArrayBasic, D>
        for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayBasic>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u64).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                (ptr as *mut u64).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(80);
                (ptr as *mut u64).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(112);
                (ptr as *mut u64).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(176);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 6, depth)?;
            self.2.encode(encoder, offset + 16, depth)?;
            self.3.encode(encoder, offset + 40, depth)?;
            self.4.encode(encoder, offset + 80, depth)?;
            self.5.encode(encoder, offset + 86, depth)?;
            self.6.encode(encoder, offset + 96, depth)?;
            self.7.encode(encoder, offset + 120, depth)?;
            self.8.encode(encoder, offset + 160, depth)?;
            self.9.encode(encoder, offset + 184, depth)?;
            self.10.encode(encoder, offset + 224, depth)?;
            self.11.encode(encoder, offset + 304, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for ArrayBasic {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                array_uint8: fidl::new_empty!(fidl::encoding::Array<u8, 5>, D),
                array_uint16: fidl::new_empty!(fidl::encoding::Array<u16, 5>, D),
                array_uint32: fidl::new_empty!(fidl::encoding::Array<u32, 5>, D),
                array_uint64: fidl::new_empty!(fidl::encoding::Array<u64, 5>, D),
                array_int8: fidl::new_empty!(fidl::encoding::Array<i8, 5>, D),
                array_int16: fidl::new_empty!(fidl::encoding::Array<i16, 5>, D),
                array_int32: fidl::new_empty!(fidl::encoding::Array<i32, 5>, D),
                array_int64: fidl::new_empty!(fidl::encoding::Array<i64, 5>, D),
                array_float32: fidl::new_empty!(fidl::encoding::Array<f32, 5>, D),
                array_float64: fidl::new_empty!(fidl::encoding::Array<f64, 5>, D),
                array_string: fidl::new_empty!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>, D),
                array_opt_string: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                        5,
                    >,
                    D
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xff0000000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffff00000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 32 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(80) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xff0000000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 80 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(112) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffff00000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 112 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(176) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffff00000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 176 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            fidl::decode!(fidl::encoding::Array<u8, 5>, D, &mut self.array_uint8, decoder, offset + 0, _depth)?;
            fidl::decode!(fidl::encoding::Array<u16, 5>, D, &mut self.array_uint16, decoder, offset + 6, _depth)?;
            fidl::decode!(fidl::encoding::Array<u32, 5>, D, &mut self.array_uint32, decoder, offset + 16, _depth)?;
            fidl::decode!(fidl::encoding::Array<u64, 5>, D, &mut self.array_uint64, decoder, offset + 40, _depth)?;
            fidl::decode!(fidl::encoding::Array<i8, 5>, D, &mut self.array_int8, decoder, offset + 80, _depth)?;
            fidl::decode!(fidl::encoding::Array<i16, 5>, D, &mut self.array_int16, decoder, offset + 86, _depth)?;
            fidl::decode!(fidl::encoding::Array<i32, 5>, D, &mut self.array_int32, decoder, offset + 96, _depth)?;
            fidl::decode!(fidl::encoding::Array<i64, 5>, D, &mut self.array_int64, decoder, offset + 120, _depth)?;
            fidl::decode!(fidl::encoding::Array<f32, 5>, D, &mut self.array_float32, decoder, offset + 160, _depth)?;
            fidl::decode!(fidl::encoding::Array<f64, 5>, D, &mut self.array_float64, decoder, offset + 184, _depth)?;
            fidl::decode!(fidl::encoding::Array<fidl::encoding::UnboundedString, 5>, D, &mut self.array_string, decoder, offset + 224, _depth)?;
            fidl::decode!(
                fidl::encoding::Array<fidl::encoding::Optional<fidl::encoding::UnboundedString>, 5>,
                D,
                &mut self.array_opt_string,
                decoder,
                offset + 304,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ArrayCompound {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ArrayCompound {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            328
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<ArrayCompound, D>
        for &ArrayCompound
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayCompound>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ArrayCompound, D>::encode(
                (
                    <fidl::encoding::Array<Bits, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_bits),
                    <fidl::encoding::Array<Enum, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_enum),
                    <fidl::encoding::Array<Struct, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_struct),
                    <fidl::encoding::Array<Table, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_table),
                    <fidl::encoding::Array<Union, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_union),
                    <fidl::encoding::Array<fidl::encoding::Boxed<Struct>, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_opt_struct),
                    <fidl::encoding::Array<fidl::encoding::OptionalUnion<Union>, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_opt_union),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::Array<Bits, 5>, D>,
            T1: fidl::encoding::Encode<fidl::encoding::Array<Enum, 5>, D>,
            T2: fidl::encoding::Encode<fidl::encoding::Array<Struct, 5>, D>,
            T3: fidl::encoding::Encode<fidl::encoding::Array<Table, 5>, D>,
            T4: fidl::encoding::Encode<fidl::encoding::Array<Union, 5>, D>,
            T5: fidl::encoding::Encode<fidl::encoding::Array<fidl::encoding::Boxed<Struct>, 5>, D>,
            T6: fidl::encoding::Encode<
                fidl::encoding::Array<fidl::encoding::OptionalUnion<Union>, 5>,
                D,
            >,
        > fidl::encoding::Encode<ArrayCompound, D> for (T0, T1, T2, T3, T4, T5, T6)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayCompound>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(40);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 20, depth)?;
            self.2.encode(encoder, offset + 40, depth)?;
            self.3.encode(encoder, offset + 48, depth)?;
            self.4.encode(encoder, offset + 128, depth)?;
            self.5.encode(encoder, offset + 208, depth)?;
            self.6.encode(encoder, offset + 248, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for ArrayCompound {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                array_bits: fidl::new_empty!(fidl::encoding::Array<Bits, 5>, D),
                array_enum: fidl::new_empty!(fidl::encoding::Array<Enum, 5>, D),
                array_struct: fidl::new_empty!(fidl::encoding::Array<Struct, 5>, D),
                array_table: fidl::new_empty!(fidl::encoding::Array<Table, 5>, D),
                array_union: fidl::new_empty!(fidl::encoding::Array<Union, 5>, D),
                array_opt_struct: fidl::new_empty!(
                    fidl::encoding::Array<fidl::encoding::Boxed<Struct>, 5>,
                    D
                ),
                array_opt_union: fidl::new_empty!(
                    fidl::encoding::Array<fidl::encoding::OptionalUnion<Union>, 5>,
                    D
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(40) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffff0000000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 40 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            fidl::decode!(fidl::encoding::Array<Bits, 5>, D, &mut self.array_bits, decoder, offset + 0, _depth)?;
            fidl::decode!(fidl::encoding::Array<Enum, 5>, D, &mut self.array_enum, decoder, offset + 20, _depth)?;
            fidl::decode!(fidl::encoding::Array<Struct, 5>, D, &mut self.array_struct, decoder, offset + 40, _depth)?;
            fidl::decode!(fidl::encoding::Array<Table, 5>, D, &mut self.array_table, decoder, offset + 48, _depth)?;
            fidl::decode!(fidl::encoding::Array<Union, 5>, D, &mut self.array_union, decoder, offset + 128, _depth)?;
            fidl::decode!(
                fidl::encoding::Array<fidl::encoding::Boxed<Struct>, 5>,
                D,
                &mut self.array_opt_struct,
                decoder,
                offset + 208,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Array<fidl::encoding::OptionalUnion<Union>, 5>,
                D,
                &mut self.array_opt_union,
                decoder,
                offset + 248,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ArrayVectorNested {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ArrayVectorNested {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            144
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<ArrayVectorNested, D>
        for &ArrayVectorNested
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayVectorNested>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ArrayVectorNested, D>::encode(
                (
                    <fidl::encoding::Array<fidl::encoding::Array<u8, 5>, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_array_uint8),
                    <fidl::encoding::Array<fidl::encoding::UnboundedVector<u8>, 5> as fidl::encoding::ValueTypeMarker>::borrow(&self.array_vector_uint8),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_array_uint8),
                    <fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_vector_uint8),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::Array<fidl::encoding::Array<u8, 5>, 5>, D>,
            T1: fidl::encoding::Encode<
                fidl::encoding::Array<fidl::encoding::UnboundedVector<u8>, 5>,
                D,
            >,
            T2: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>,
                D,
            >,
            T3: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>,
                D,
            >,
        > fidl::encoding::Encode<ArrayVectorNested, D> for (T0, T1, T2, T3)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ArrayVectorNested>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(24);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 32, depth)?;
            self.2.encode(encoder, offset + 112, depth)?;
            self.3.encode(encoder, offset + 128, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for ArrayVectorNested {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                array_array_uint8: fidl::new_empty!(
                    fidl::encoding::Array<fidl::encoding::Array<u8, 5>, 5>,
                    D
                ),
                array_vector_uint8: fidl::new_empty!(
                    fidl::encoding::Array<fidl::encoding::UnboundedVector<u8>, 5>,
                    D
                ),
                vector_array_uint8: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>,
                    D
                ),
                vector_vector_uint8: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>,
                    D
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(24) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffffffff00u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 24 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            fidl::decode!(
                fidl::encoding::Array<fidl::encoding::Array<u8, 5>, 5>,
                D,
                &mut self.array_array_uint8,
                decoder,
                offset + 0,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Array<fidl::encoding::UnboundedVector<u8>, 5>,
                D,
                &mut self.array_vector_uint8,
                decoder,
                offset + 32,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::Array<u8, 5>>,
                D,
                &mut self.vector_array_uint8,
                decoder,
                offset + 112,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedVector<u8>>,
                D,
                &mut self.vector_vector_uint8,
                decoder,
                offset + 128,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Basic {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Basic {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            80
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Basic, D> for &Basic {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Basic>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Basic, D>::encode(
                (
                    <u8 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint8),
                    <u16 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint16),
                    <u32 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint32),
                    <u64 as fidl::encoding::ValueTypeMarker>::borrow(&self.uint64),
                    <i8 as fidl::encoding::ValueTypeMarker>::borrow(&self.int8),
                    <i16 as fidl::encoding::ValueTypeMarker>::borrow(&self.int16),
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(&self.int32),
                    <i64 as fidl::encoding::ValueTypeMarker>::borrow(&self.int64),
                    <f32 as fidl::encoding::ValueTypeMarker>::borrow(&self.float32),
                    <f64 as fidl::encoding::ValueTypeMarker>::borrow(&self.float64),
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(&self.string),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedString> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_string),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u8, D>,
            T1: fidl::encoding::Encode<u16, D>,
            T2: fidl::encoding::Encode<u32, D>,
            T3: fidl::encoding::Encode<u64, D>,
            T4: fidl::encoding::Encode<i8, D>,
            T5: fidl::encoding::Encode<i16, D>,
            T6: fidl::encoding::Encode<i32, D>,
            T7: fidl::encoding::Encode<i64, D>,
            T8: fidl::encoding::Encode<f32, D>,
            T9: fidl::encoding::Encode<f64, D>,
            T10: fidl::encoding::Encode<fidl::encoding::UnboundedString, D>,
            T11: fidl::encoding::Encode<fidl::encoding::Optional<fidl::encoding::UnboundedString>, D>,
        > fidl::encoding::Encode<Basic, D> for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Basic>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u64).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(16);
                (ptr as *mut u64).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(32);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 2, depth)?;
            self.2.encode(encoder, offset + 4, depth)?;
            self.3.encode(encoder, offset + 8, depth)?;
            self.4.encode(encoder, offset + 16, depth)?;
            self.5.encode(encoder, offset + 18, depth)?;
            self.6.encode(encoder, offset + 20, depth)?;
            self.7.encode(encoder, offset + 24, depth)?;
            self.8.encode(encoder, offset + 32, depth)?;
            self.9.encode(encoder, offset + 40, depth)?;
            self.10.encode(encoder, offset + 48, depth)?;
            self.11.encode(encoder, offset + 64, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Basic {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                uint8: fidl::new_empty!(u8, D),
                uint16: fidl::new_empty!(u16, D),
                uint32: fidl::new_empty!(u32, D),
                uint64: fidl::new_empty!(u64, D),
                int8: fidl::new_empty!(i8, D),
                int16: fidl::new_empty!(i16, D),
                int32: fidl::new_empty!(i32, D),
                int64: fidl::new_empty!(i64, D),
                float32: fidl::new_empty!(f32, D),
                float64: fidl::new_empty!(f64, D),
                string: fidl::new_empty!(fidl::encoding::UnboundedString, D),
                opt_string: fidl::new_empty!(
                    fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                    D
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xff00u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(16) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xff00u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 16 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(32) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffff00000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 32 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            fidl::decode!(u8, D, &mut self.uint8, decoder, offset + 0, _depth)?;
            fidl::decode!(u16, D, &mut self.uint16, decoder, offset + 2, _depth)?;
            fidl::decode!(u32, D, &mut self.uint32, decoder, offset + 4, _depth)?;
            fidl::decode!(u64, D, &mut self.uint64, decoder, offset + 8, _depth)?;
            fidl::decode!(i8, D, &mut self.int8, decoder, offset + 16, _depth)?;
            fidl::decode!(i16, D, &mut self.int16, decoder, offset + 18, _depth)?;
            fidl::decode!(i32, D, &mut self.int32, decoder, offset + 20, _depth)?;
            fidl::decode!(i64, D, &mut self.int64, decoder, offset + 24, _depth)?;
            fidl::decode!(f32, D, &mut self.float32, decoder, offset + 32, _depth)?;
            fidl::decode!(f64, D, &mut self.float64, decoder, offset + 40, _depth)?;
            fidl::decode!(
                fidl::encoding::UnboundedString,
                D,
                &mut self.string,
                decoder,
                offset + 48,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                D,
                &mut self.opt_string,
                decoder,
                offset + 64,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Compound {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Compound {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            72
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Compound, D> for &Compound {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Compound>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Compound, D>::encode(
                (
                    <Bits as fidl::encoding::ValueTypeMarker>::borrow(&self.bits),
                    <Enum as fidl::encoding::ValueTypeMarker>::borrow(&self.enum_),
                    <Struct as fidl::encoding::ValueTypeMarker>::borrow(&self.struct_),
                    <Table as fidl::encoding::ValueTypeMarker>::borrow(&self.table),
                    <Union as fidl::encoding::ValueTypeMarker>::borrow(&self.union),
                    <fidl::encoding::Boxed<Struct> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_struct),
                    <fidl::encoding::OptionalUnion<Union> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_union),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<Bits, D>,
            T1: fidl::encoding::Encode<Enum, D>,
            T2: fidl::encoding::Encode<Struct, D>,
            T3: fidl::encoding::Encode<Table, D>,
            T4: fidl::encoding::Encode<Union, D>,
            T5: fidl::encoding::Encode<fidl::encoding::Boxed<Struct>, D>,
            T6: fidl::encoding::Encode<fidl::encoding::OptionalUnion<Union>, D>,
        > fidl::encoding::Encode<Compound, D> for (T0, T1, T2, T3, T4, T5, T6)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Compound>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 4, depth)?;
            self.2.encode(encoder, offset + 8, depth)?;
            self.3.encode(encoder, offset + 16, depth)?;
            self.4.encode(encoder, offset + 32, depth)?;
            self.5.encode(encoder, offset + 48, depth)?;
            self.6.encode(encoder, offset + 56, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Compound {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                bits: fidl::new_empty!(Bits, D),
                enum_: fidl::new_empty!(Enum, D),
                struct_: fidl::new_empty!(Struct, D),
                table: fidl::new_empty!(Table, D),
                union: fidl::new_empty!(Union, D),
                opt_struct: fidl::new_empty!(fidl::encoding::Boxed<Struct>, D),
                opt_union: fidl::new_empty!(fidl::encoding::OptionalUnion<Union>, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(8) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffffffff00u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 8 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            fidl::decode!(Bits, D, &mut self.bits, decoder, offset + 0, _depth)?;
            fidl::decode!(Enum, D, &mut self.enum_, decoder, offset + 4, _depth)?;
            fidl::decode!(Struct, D, &mut self.struct_, decoder, offset + 8, _depth)?;
            fidl::decode!(Table, D, &mut self.table, decoder, offset + 16, _depth)?;
            fidl::decode!(Union, D, &mut self.union, decoder, offset + 32, _depth)?;
            fidl::decode!(
                fidl::encoding::Boxed<Struct>,
                D,
                &mut self.opt_struct,
                decoder,
                offset + 48,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::OptionalUnion<Union>,
                D,
                &mut self.opt_union,
                decoder,
                offset + 56,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Struct {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Struct {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            1
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            1
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Struct, D> for &Struct {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Struct>(offset);
            encoder.write_num(0u8, offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Struct {
        #[inline(always)]
        fn new_empty() -> Self {
            Self
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            match decoder.read_num::<u8>(offset) {
                0 => Ok(()),
                _ => Err(fidl::Error::Invalid),
            }
        }
    }

    impl fidl::encoding::ValueTypeMarker for VectorBasic {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for VectorBasic {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            192
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<VectorBasic, D>
        for &VectorBasic
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorBasic>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<VectorBasic, D>::encode(
                (
                    <fidl::encoding::UnboundedVector<u8> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint8),
                    <fidl::encoding::UnboundedVector<u16> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint16),
                    <fidl::encoding::UnboundedVector<u32> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint32),
                    <fidl::encoding::UnboundedVector<u64> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_uint64),
                    <fidl::encoding::UnboundedVector<i8> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int8),
                    <fidl::encoding::UnboundedVector<i16> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int16),
                    <fidl::encoding::UnboundedVector<i32> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int32),
                    <fidl::encoding::UnboundedVector<i64> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_int64),
                    <fidl::encoding::UnboundedVector<f32> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_float32),
                    <fidl::encoding::UnboundedVector<f64> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_float64),
                    <fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_string),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Optional<fidl::encoding::UnboundedString>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_opt_string),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u8>, D>,
            T1: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u16>, D>,
            T2: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u32>, D>,
            T3: fidl::encoding::Encode<fidl::encoding::UnboundedVector<u64>, D>,
            T4: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i8>, D>,
            T5: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i16>, D>,
            T6: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i32>, D>,
            T7: fidl::encoding::Encode<fidl::encoding::UnboundedVector<i64>, D>,
            T8: fidl::encoding::Encode<fidl::encoding::UnboundedVector<f32>, D>,
            T9: fidl::encoding::Encode<fidl::encoding::UnboundedVector<f64>, D>,
            T10: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                D,
            >,
            T11: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                >,
                D,
            >,
        > fidl::encoding::Encode<VectorBasic, D>
        for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorBasic>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 16, depth)?;
            self.2.encode(encoder, offset + 32, depth)?;
            self.3.encode(encoder, offset + 48, depth)?;
            self.4.encode(encoder, offset + 64, depth)?;
            self.5.encode(encoder, offset + 80, depth)?;
            self.6.encode(encoder, offset + 96, depth)?;
            self.7.encode(encoder, offset + 112, depth)?;
            self.8.encode(encoder, offset + 128, depth)?;
            self.9.encode(encoder, offset + 144, depth)?;
            self.10.encode(encoder, offset + 160, depth)?;
            self.11.encode(encoder, offset + 176, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for VectorBasic {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                vector_uint8: fidl::new_empty!(fidl::encoding::UnboundedVector<u8>, D),
                vector_uint16: fidl::new_empty!(fidl::encoding::UnboundedVector<u16>, D),
                vector_uint32: fidl::new_empty!(fidl::encoding::UnboundedVector<u32>, D),
                vector_uint64: fidl::new_empty!(fidl::encoding::UnboundedVector<u64>, D),
                vector_int8: fidl::new_empty!(fidl::encoding::UnboundedVector<i8>, D),
                vector_int16: fidl::new_empty!(fidl::encoding::UnboundedVector<i16>, D),
                vector_int32: fidl::new_empty!(fidl::encoding::UnboundedVector<i32>, D),
                vector_int64: fidl::new_empty!(fidl::encoding::UnboundedVector<i64>, D),
                vector_float32: fidl::new_empty!(fidl::encoding::UnboundedVector<f32>, D),
                vector_float64: fidl::new_empty!(fidl::encoding::UnboundedVector<f64>, D),
                vector_string: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                    D
                ),
                vector_opt_string: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                    >,
                    D
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedVector<u8>,
                D,
                &mut self.vector_uint8,
                decoder,
                offset + 0,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<u16>,
                D,
                &mut self.vector_uint16,
                decoder,
                offset + 16,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<u32>,
                D,
                &mut self.vector_uint32,
                decoder,
                offset + 32,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<u64>,
                D,
                &mut self.vector_uint64,
                decoder,
                offset + 48,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<i8>,
                D,
                &mut self.vector_int8,
                decoder,
                offset + 64,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<i16>,
                D,
                &mut self.vector_int16,
                decoder,
                offset + 80,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<i32>,
                D,
                &mut self.vector_int32,
                decoder,
                offset + 96,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<i64>,
                D,
                &mut self.vector_int64,
                decoder,
                offset + 112,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<f32>,
                D,
                &mut self.vector_float32,
                decoder,
                offset + 128,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<f64>,
                D,
                &mut self.vector_float64,
                decoder,
                offset + 144,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                D,
                &mut self.vector_string,
                decoder,
                offset + 160,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Optional<fidl::encoding::UnboundedString>,
                >,
                D,
                &mut self.vector_opt_string,
                decoder,
                offset + 176,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for VectorCompound {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for VectorCompound {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            112
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<VectorCompound, D>
        for &VectorCompound
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorCompound>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<VectorCompound, D>::encode(
                (
                    <fidl::encoding::UnboundedVector<Bits> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_bits),
                    <fidl::encoding::UnboundedVector<Enum> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_enum),
                    <fidl::encoding::UnboundedVector<Struct> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_struct),
                    <fidl::encoding::UnboundedVector<Table> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_table),
                    <fidl::encoding::UnboundedVector<Union> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_union),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_opt_struct),
                    <fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>> as fidl::encoding::ValueTypeMarker>::borrow(&self.vector_opt_union),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Bits>, D>,
            T1: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Enum>, D>,
            T2: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Struct>, D>,
            T3: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Table>, D>,
            T4: fidl::encoding::Encode<fidl::encoding::UnboundedVector<Union>, D>,
            T5: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                D,
            >,
            T6: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>,
                D,
            >,
        > fidl::encoding::Encode<VectorCompound, D> for (T0, T1, T2, T3, T4, T5, T6)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorCompound>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 16, depth)?;
            self.2.encode(encoder, offset + 32, depth)?;
            self.3.encode(encoder, offset + 48, depth)?;
            self.4.encode(encoder, offset + 64, depth)?;
            self.5.encode(encoder, offset + 80, depth)?;
            self.6.encode(encoder, offset + 96, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for VectorCompound {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                vector_bits: fidl::new_empty!(fidl::encoding::UnboundedVector<Bits>, D),
                vector_enum: fidl::new_empty!(fidl::encoding::UnboundedVector<Enum>, D),
                vector_struct: fidl::new_empty!(fidl::encoding::UnboundedVector<Struct>, D),
                vector_table: fidl::new_empty!(fidl::encoding::UnboundedVector<Table>, D),
                vector_union: fidl::new_empty!(fidl::encoding::UnboundedVector<Union>, D),
                vector_opt_struct: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                    D
                ),
                vector_opt_union: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>,
                    D
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedVector<Bits>,
                D,
                &mut self.vector_bits,
                decoder,
                offset + 0,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<Enum>,
                D,
                &mut self.vector_enum,
                decoder,
                offset + 16,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<Struct>,
                D,
                &mut self.vector_struct,
                decoder,
                offset + 32,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<Table>,
                D,
                &mut self.vector_table,
                decoder,
                offset + 48,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<Union>,
                D,
                &mut self.vector_union,
                decoder,
                offset + 64,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                D,
                &mut self.vector_opt_struct,
                decoder,
                offset + 80,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<fidl::encoding::OptionalUnion<Union>>,
                D,
                &mut self.vector_opt_union,
                decoder,
                offset + 96,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for VectorOptional {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for VectorOptional {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            64
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<VectorOptional, D>
        for &VectorOptional
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorOptional>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<VectorOptional, D>::encode(
                (
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_uint8),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_string),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_struct),
                    <fidl::encoding::Optional<fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>> as fidl::encoding::ValueTypeMarker>::borrow(&self.opt_vector_opt_struct),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<
                fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>,
                D,
            >,
            T1: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                >,
                D,
            >,
            T2: fidl::encoding::Encode<
                fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>,
                D,
            >,
            T3: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                >,
                D,
            >,
        > fidl::encoding::Encode<VectorOptional, D> for (T0, T1, T2, T3)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<VectorOptional>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 16, depth)?;
            self.2.encode(encoder, offset + 32, depth)?;
            self.3.encode(encoder, offset + 48, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for VectorOptional {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                opt_vector_uint8: fidl::new_empty!(
                    fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>,
                    D
                ),
                opt_vector_string: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                    >,
                    D
                ),
                opt_vector_struct: fidl::new_empty!(
                    fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>,
                    D
                ),
                opt_vector_opt_struct: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                    >,
                    D
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::Optional<fidl::encoding::UnboundedVector<u8>>,
                D,
                &mut self.opt_vector_uint8,
                decoder,
                offset + 0,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::UnboundedString>,
                >,
                D,
                &mut self.opt_vector_string,
                decoder,
                offset + 16,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<fidl::encoding::UnboundedVector<Struct>>,
                D,
                &mut self.opt_vector_struct,
                decoder,
                offset + 32,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::UnboundedVector<fidl::encoding::Boxed<Struct>>,
                >,
                D,
                &mut self.opt_vector_opt_struct,
                decoder,
                offset + 48,
                _depth
            )?;
            Ok(())
        }
    }

    impl Table {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for Table {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Table {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Table, D> for &Table {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Table>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Table {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Union {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Union {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Union, D> for &Union {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Union>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                Union::B(ref val) => fidl::encoding::encode_in_envelope::<bool, D>(
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                Union::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Union {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <bool as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let Union::B(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = Union::B(fidl::new_empty!(bool, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let Union::B(ref mut val) = self {
                        fidl::decode!(bool, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = Union::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
