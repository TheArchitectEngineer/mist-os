// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct AllInstants {
    pub monotonic: fidl::MonotonicInstant,
    pub boot: fidl::BootInstant,
    pub monotonic_ticks: fidl::MonotonicTicks,
    pub boot_ticks: fidl::BootTicks,
}

impl fidl::Persistable for AllInstants {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ComplexInstants {
    pub monotonic: Option<[fidl::MonotonicInstant; 10]>,
    pub boot: Option<Vec<fidl::BootInstant>>,
    pub monotonic_ticks: Option<[fidl::MonotonicTicks; 10]>,
    pub boot_ticks: Option<[fidl::BootTicks; 10]>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for ComplexInstants {}

mod internal {
    use super::*;

    impl fidl::encoding::ValueTypeMarker for AllInstants {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for AllInstants {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            32
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<AllInstants, D>
        for &AllInstants
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<AllInstants>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut AllInstants).write_unaligned((self as *const AllInstants).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::MonotonicInstant, D>,
            T1: fidl::encoding::Encode<fidl::BootInstant, D>,
            T2: fidl::encoding::Encode<fidl::MonotonicTicks, D>,
            T3: fidl::encoding::Encode<fidl::BootTicks, D>,
        > fidl::encoding::Encode<AllInstants, D> for (T0, T1, T2, T3)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<AllInstants>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            self.2.encode(encoder, offset + 16, depth)?;
            self.3.encode(encoder, offset + 24, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for AllInstants {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                monotonic: fidl::new_empty!(fidl::MonotonicInstant, D),
                boot: fidl::new_empty!(fidl::BootInstant, D),
                monotonic_ticks: fidl::new_empty!(fidl::MonotonicTicks, D),
                boot_ticks: fidl::new_empty!(fidl::BootTicks, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 32);
            }
            Ok(())
        }
    }

    impl ComplexInstants {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.boot_ticks {
                return 4;
            }
            if let Some(_) = self.monotonic_ticks {
                return 3;
            }
            if let Some(_) = self.boot {
                return 2;
            }
            if let Some(_) = self.monotonic {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for ComplexInstants {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ComplexInstants {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<ComplexInstants, D>
        for &ComplexInstants
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ComplexInstants>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<fidl::encoding::Array<fidl::MonotonicInstant, 10>, D>(
            self.monotonic.as_ref().map(<fidl::encoding::Array<fidl::MonotonicInstant, 10> as fidl::encoding::ValueTypeMarker>::borrow),
            encoder, offset + cur_offset, depth
        )?;

            _prev_end_offset = cur_offset + envelope_size;
            if 2 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (2 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<fidl::encoding::UnboundedVector<fidl::BootInstant>, D>(
            self.boot.as_ref().map(<fidl::encoding::UnboundedVector<fidl::BootInstant> as fidl::encoding::ValueTypeMarker>::borrow),
            encoder, offset + cur_offset, depth
        )?;

            _prev_end_offset = cur_offset + envelope_size;
            if 3 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (3 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<fidl::encoding::Array<fidl::MonotonicTicks, 10>, D>(
            self.monotonic_ticks.as_ref().map(<fidl::encoding::Array<fidl::MonotonicTicks, 10> as fidl::encoding::ValueTypeMarker>::borrow),
            encoder, offset + cur_offset, depth
        )?;

            _prev_end_offset = cur_offset + envelope_size;
            if 4 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (4 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<fidl::encoding::Array<fidl::BootTicks, 10>, D>(
            self.boot_ticks.as_ref().map(<fidl::encoding::Array<fidl::BootTicks, 10> as fidl::encoding::ValueTypeMarker>::borrow),
            encoder, offset + cur_offset, depth
        )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for ComplexInstants {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size = <fidl::encoding::Array<fidl::MonotonicInstant, 10> as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.monotonic.get_or_insert_with(
                    || fidl::new_empty!(fidl::encoding::Array<fidl::MonotonicInstant, 10>, D),
                );
                fidl::decode!(fidl::encoding::Array<fidl::MonotonicInstant, 10>, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 2 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size = <fidl::encoding::UnboundedVector<fidl::BootInstant> as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.boot.get_or_insert_with(|| {
                    fidl::new_empty!(fidl::encoding::UnboundedVector<fidl::BootInstant>, D)
                });
                fidl::decode!(
                    fidl::encoding::UnboundedVector<fidl::BootInstant>,
                    D,
                    val_ref,
                    decoder,
                    inner_offset,
                    inner_depth
                )?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 3 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size = <fidl::encoding::Array<fidl::MonotonicTicks, 10> as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.monotonic_ticks.get_or_insert_with(
                    || fidl::new_empty!(fidl::encoding::Array<fidl::MonotonicTicks, 10>, D),
                );
                fidl::decode!(fidl::encoding::Array<fidl::MonotonicTicks, 10>, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 4 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size = <fidl::encoding::Array<fidl::BootTicks, 10> as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.boot_ticks.get_or_insert_with(
                    || fidl::new_empty!(fidl::encoding::Array<fidl::BootTicks, 10>, D),
                );
                fidl::decode!(fidl::encoding::Array<fidl::BootTicks, 10>, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }
}
