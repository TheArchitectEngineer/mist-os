// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::client::QueryResponseFut;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use fidl::endpoints::{ControlHandle as _, Responder as _};
pub use fidl_test_driverservice_common::*;
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[cfg(feature = "driver")]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct SomeDriverProtocolMarker;

#[cfg(feature = "driver")]
impl fidl_driver::endpoints::DriverProtocolMarker for SomeDriverProtocolMarker {
    const DEBUG_NAME: &'static str = "(anonymous) SomeDriverProtocol";
}

#[cfg(feature = "driver")]
#[derive(Debug)]
pub enum SomeDriverProtocolRequest {}

#[cfg(feature = "driver")]
impl SomeDriverProtocolRequest {
    #[allow(irrefutable_let_patterns)]
    pub fn read_from(bytes: &[u8], _handles: &mut [zx::HandleInfo]) -> Result<Self, fidl::Error> {
        let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

        match header.ordinal {
            _ => Err(fidl::Error::UnknownOrdinal {
                ordinal: header.ordinal,
                protocol_name: <SomeDriverProtocolMarker as fidl_driver::endpoints::DriverProtocolMarker>::DEBUG_NAME
            }),
        }
    }

    pub fn read_from_message(
        mut message: fdf::Message<[u8]>,
    ) -> Result<(fdf::Arena, Self), fidl::Error> {
        let (arena, Some(body), Some(handles)) = message.take_arena_boxes() else {
            return Err(fidl::Error::Invalid);
        };
        let mut handles = arena.try_insert_from_iter(
            handles
                .into_iter()
                .map(|handle| unsafe { fidl_driver::encoding::mixed_into_handle_info(handle) }),
        );
        let res = match handles {
            Ok(ref mut handles) => Self::read_from(&*body, handles)?,
            Err(_) => return Err(fidl::Error::Invalid),
        };
        std::mem::drop((body, handles));
        Ok((message.take_arena(), res))
    }

    /// Name of the method defined in FIDL
    pub fn method_name(&self) -> &'static str {
        match *self {}
    }
}

/// Like [`SomeDriverProtocolRequest::read_from_message`] except it drops the [`Arena`].
#[cfg(feature = "driver")]
impl std::convert::TryFrom<fdf::Message<[u8]>> for SomeDriverProtocolRequest {
    type Error = fidl::Error;
    fn try_from(msg: fdf::Message<[u8]>) -> Result<SomeDriverProtocolRequest, fidl::Error> {
        Ok(SomeDriverProtocolRequest::read_from_message(msg)?.1)
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct DriverOnlyServiceMarker;

#[cfg(target_os = "fuchsia")]
impl fidl::endpoints::ServiceMarker for DriverOnlyServiceMarker {
    type Proxy = DriverOnlyServiceProxy;
    type Request = DriverOnlyServiceRequest;
    const SERVICE_NAME: &'static str = "test.driverservice.DriverOnlyService";
}

/// A request for one of the member protocols of DriverOnlyService.
///
#[cfg(target_os = "fuchsia")]
pub enum DriverOnlyServiceRequest {}

#[cfg(target_os = "fuchsia")]
impl fidl::endpoints::ServiceRequest for DriverOnlyServiceRequest {
    type Service = DriverOnlyServiceMarker;

    fn dispatch(name: &str, _channel: fidl::AsyncChannel) -> Self {
        match name {
            _ => panic!("no such member protocol name for service DriverOnlyService"),
        }
    }

    fn member_names() -> &'static [&'static str] {
        &[]
    }
}
#[cfg(target_os = "fuchsia")]
pub struct DriverOnlyServiceProxy(#[allow(dead_code)] Box<dyn fidl::endpoints::MemberOpener>);

#[cfg(target_os = "fuchsia")]
impl fidl::endpoints::ServiceProxy for DriverOnlyServiceProxy {
    type Service = DriverOnlyServiceMarker;

    fn from_member_opener(opener: Box<dyn fidl::endpoints::MemberOpener>) -> Self {
        Self(opener)
    }
}

#[cfg(target_os = "fuchsia")]
impl DriverOnlyServiceProxy {
    pub fn instance_name(&self) -> &str {
        self.0.instance_name()
    }
}

mod internal {
    use super::*;
}
