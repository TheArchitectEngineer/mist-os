// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictEventFieldsRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleEventFieldsRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictEventFieldsRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolFlexibleEventTableRequest {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsAjarProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictEventTableRequest {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsClosedProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictEventTableRequest {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleEventTableRequest {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictEventTableRequest {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleTwoWayTableResponse {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictTwoWayTableErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsAjarProtocolFlexibleEventUnionRequest` member.
#[macro_export]
macro_rules! UnknownInteractionsAjarProtocolFlexibleEventUnionRequestUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsAjarProtocolStrictEventUnionRequest` member.
#[macro_export]
macro_rules! UnknownInteractionsAjarProtocolStrictEventUnionRequestUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictEventUnionRequest {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsAjarProtocolStrictTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsClosedProtocolStrictEventUnionRequest` member.
#[macro_export]
macro_rules! UnknownInteractionsClosedProtocolStrictEventUnionRequestUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictEventUnionRequest {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsClosedProtocolStrictTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsDriverProtocolStrictTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleEventUnionRequest {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsProtocolFlexibleEventUnionRequest` member.
#[macro_export]
macro_rules! UnknownInteractionsProtocolFlexibleEventUnionRequestUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsProtocolFlexibleEventUnionRequest {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleEventUnionRequest {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictEventUnionRequest {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsProtocolStrictEventUnionRequest` member.
#[macro_export]
macro_rules! UnknownInteractionsProtocolStrictEventUnionRequestUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsProtocolStrictEventUnionRequest {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsProtocolStrictEventUnionRequest {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictEventUnionRequest {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsProtocolStrictTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsProtocolStrictTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsProtocolFlexibleTwoWayUnionResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsProtocolFlexibleTwoWayUnionResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnknownInteractionsProtocolStrictTwoWayUnionErrResponse` member.
#[macro_export]
macro_rules! UnknownInteractionsProtocolStrictTwoWayUnionErrResponseUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::SomeField(x), Self::SomeField(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::SomeField(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {}

mod internal {
    use super::*;

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, D>
        for &UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse)
                    .write_unaligned(
                    (self
                        as *const UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse)
                        .read(),
                );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<
            UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            D,
        > for &UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse).write_unaligned((self as *const UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<
            UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            D,
        > for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, D>
        for &UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>(
                    offset,
                );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest)
                    .write_unaligned(
                        (self as *const UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictEventFieldsRequest, D>
        for &UnknownInteractionsAjarProtocolStrictEventFieldsRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>(
                offset,
            );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsAjarProtocolStrictEventFieldsRequest)
                    .write_unaligned(
                        (self as *const UnknownInteractionsAjarProtocolStrictEventFieldsRequest)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictEventFieldsRequest, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>(
                offset,
            );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, D>
        for &UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>(
                    offset,
                );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse)
                    .write_unaligned(
                        (self as *const UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, D>
        for &UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>(
                    offset,
                );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse)
                    .write_unaligned(
                        (self
                            as *const UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, D>
        for &UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse).write_unaligned((self as *const UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<
            UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            D,
        > for &UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse).write_unaligned((self as *const UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<
            UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            D,
        > for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictEventFieldsRequest, D>
        for &UnknownInteractionsClosedProtocolStrictEventFieldsRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>(
                    offset,
                );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsClosedProtocolStrictEventFieldsRequest)
                    .write_unaligned(
                        (self as *const UnknownInteractionsClosedProtocolStrictEventFieldsRequest)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictEventFieldsRequest, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, D>
        for &UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>(
                    offset,
                );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse)
                    .write_unaligned(
                        (self
                            as *const UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, D>
        for &UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse)
                    .write_unaligned(
                    (self as *const UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse)
                        .read(),
                );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, D>
        for &UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>(
                    offset,
                );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse)
                    .write_unaligned(
                        (self
                            as *const UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, D>
        for &UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse)
                    .write_unaligned(
                    (self
                        as *const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse)
                        .read(),
                );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, D>
        for &UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse)
                    .write_unaligned(
                    (self as *const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse)
                        .read(),
                );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, D>
        for &UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse)
                    .write_unaligned(
                    (self as *const UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse)
                        .read(),
                );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleEventFieldsRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolFlexibleEventFieldsRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleEventFieldsRequest, D>
        for &UnknownInteractionsProtocolFlexibleEventFieldsRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolFlexibleEventFieldsRequest>(
                offset,
            );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsProtocolFlexibleEventFieldsRequest)
                    .write_unaligned(
                        (self as *const UnknownInteractionsProtocolFlexibleEventFieldsRequest)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleEventFieldsRequest, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolFlexibleEventFieldsRequest>(
                offset,
            );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleEventFieldsRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictEventFieldsRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictEventFieldsRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictEventFieldsRequest, D>
        for &UnknownInteractionsProtocolStrictEventFieldsRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolStrictEventFieldsRequest>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsProtocolStrictEventFieldsRequest)
                    .write_unaligned(
                        (self as *const UnknownInteractionsProtocolStrictEventFieldsRequest).read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictEventFieldsRequest, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolStrictEventFieldsRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictEventFieldsRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayFieldsResponse, D>
        for &UnknownInteractionsProtocolStrictTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayFieldsResponse>(
                offset,
            );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsProtocolStrictTwoWayFieldsResponse)
                    .write_unaligned(
                        (self as *const UnknownInteractionsProtocolStrictTwoWayFieldsResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayFieldsResponse, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayFieldsResponse>(
                offset,
            );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, D>
        for &UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>(
                    offset,
                );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse)
                    .write_unaligned(
                        (self as *const UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, D>
        for &UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>(
                offset,
            );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse)
                    .write_unaligned(
                        (self as *const UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>(
                offset,
            );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, D>
        for &UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>(
                offset,
            );
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse)
                    .write_unaligned(
                        (self as *const UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse)
                            .read(),
                    );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i32, D>>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>(
                offset,
            );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { some_field: fidl::new_empty!(i32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, D>
        for &UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, D>
        for &UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolFlexibleEventTableRequest, D>
        for &UnknownInteractionsAjarProtocolFlexibleEventTableRequest
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolFlexibleEventTableRequest>(
                offset,
            );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsAjarProtocolStrictEventTableRequest {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolStrictEventTableRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsAjarProtocolStrictEventTableRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictEventTableRequest, D>
        for &UnknownInteractionsAjarProtocolStrictEventTableRequest
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolStrictEventTableRequest>(
                offset,
            );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictEventTableRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, D>
        for &UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>(
                offset,
            );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, D>
        for &UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>(
                    offset,
                );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, D>
        for &UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<
            UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse,
            D,
        > for &UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsClosedProtocolStrictEventTableRequest {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsClosedProtocolStrictEventTableRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictEventTableRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictEventTableRequest, D>
        for &UnknownInteractionsClosedProtocolStrictEventTableRequest
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedProtocolStrictEventTableRequest>(
                offset,
            );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictEventTableRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, D>
        for &UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>(
                    offset,
                );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, D>
        for &UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, D>
        for &UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>(
                    offset,
                );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, D>
        for &UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, D>
        for &UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>(
                    offset,
                );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, D>
        for &UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsProtocolFlexibleEventTableRequest {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleEventTableRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolFlexibleEventTableRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleEventTableRequest, D>
        for &UnknownInteractionsProtocolFlexibleEventTableRequest
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolFlexibleEventTableRequest>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleEventTableRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsProtocolStrictEventTableRequest {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictEventTableRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictEventTableRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictEventTableRequest, D>
        for &UnknownInteractionsProtocolStrictEventTableRequest
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolStrictEventTableRequest>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictEventTableRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsProtocolStrictTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictTwoWayTableResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictTwoWayTableResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayTableResponse, D>
        for &UnknownInteractionsProtocolStrictTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayTableResponse>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, D>
        for &UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>(
                    offset,
                );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayTableResponse, D>
        for &UnknownInteractionsProtocolFlexibleTwoWayTableResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayTableResponse>(
                offset,
            );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.some_field {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayTableErrResponse, D>
        for &UnknownInteractionsProtocolStrictTwoWayTableErrResponse
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayTableErrResponse>(
                offset,
            );
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<i32, D>(
                self.some_field.as_ref().map(<i32 as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.some_field.get_or_insert_with(|| fidl::new_empty!(i32, D));
                fidl::decode!(i32, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, D>
        for &UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::SomeField(_) = self {
                    // Do nothing, read the value into the object
                } else {
                    // Initialize `self` to the right variant
                    *self =UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::SomeField(fidl::new_empty!(i32, D));
                }
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::SomeField(ref mut val) = self {
                    fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                } else {
                    unreachable!()
                }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, D>
        for &UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::SomeField(_) = self {
                    // Do nothing, read the value into the object
                } else {
                    // Initialize `self` to the right variant
                    *self =UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::SomeField(fidl::new_empty!(i32, D));
                }
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::SomeField(ref mut val) = self {
                    fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                } else {
                    unreachable!()
                }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, D>
        for &UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>(
                offset,
            );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::SomeField(_) =
                        self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictEventUnionRequest, D>
        for &UnknownInteractionsAjarProtocolStrictEventUnionRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolStrictEventUnionRequest>(
                offset,
            );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsAjarProtocolStrictEventUnionRequest::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsAjarProtocolStrictEventUnionRequest::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictEventUnionRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolStrictEventUnionRequest::SomeField(_) =
                        self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsAjarProtocolStrictEventUnionRequest::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolStrictEventUnionRequest::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self =
                        UnknownInteractionsAjarProtocolStrictEventUnionRequest::__SourceBreaking {
                            unknown_ordinal: ordinal,
                        };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, D>
        for &UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>(
                offset,
            );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::SomeField(_) =
                        self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, D>
        for &UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>(
                    offset,
                );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::SomeField(
                        _,
                    ) = self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self =
                            UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::SomeField(
                                fidl::new_empty!(i32, D),
                            );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, D>
        for &UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::SomeField(_) = self {
                    // Do nothing, read the value into the object
                } else {
                    // Initialize `self` to the right variant
                    *self =UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::SomeField(fidl::new_empty!(i32, D));
                }
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::SomeField(ref mut val) = self {
                    fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                } else {
                    unreachable!()
                }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<
            UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            D,
        > for &UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::SomeField(_) = self {
                    // Do nothing, read the value into the object
                } else {
                    // Initialize `self` to the right variant
                    *self =UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::SomeField(fidl::new_empty!(i32, D));
                }
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::SomeField(ref mut val) = self {
                    fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                } else {
                    unreachable!()
                }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsClosedProtocolStrictEventUnionRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictEventUnionRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictEventUnionRequest, D>
        for &UnknownInteractionsClosedProtocolStrictEventUnionRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedProtocolStrictEventUnionRequest>(
                offset,
            );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsClosedProtocolStrictEventUnionRequest::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsClosedProtocolStrictEventUnionRequest::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictEventUnionRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsClosedProtocolStrictEventUnionRequest::SomeField(_) =
                        self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsClosedProtocolStrictEventUnionRequest::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsClosedProtocolStrictEventUnionRequest::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsClosedProtocolStrictEventUnionRequest::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, D>
        for &UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>(
                    offset,
                );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::SomeField(
                        _,
                    ) = self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self =
                            UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::SomeField(
                                fidl::new_empty!(i32, D),
                            );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, D>
        for &UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::SomeField(_) = self {
                    // Do nothing, read the value into the object
                } else {
                    // Initialize `self` to the right variant
                    *self =UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::SomeField(fidl::new_empty!(i32, D));
                }
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::SomeField(ref mut val) = self {
                    fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                } else {
                    unreachable!()
                }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, D>
        for &UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>(
                    offset,
                );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::SomeField(
                        _,
                    ) = self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self =
                            UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::SomeField(
                                fidl::new_empty!(i32, D),
                            );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, D>
        for &UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::SomeField(_) = self {
                    // Do nothing, read the value into the object
                } else {
                    // Initialize `self` to the right variant
                    *self =UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::SomeField(fidl::new_empty!(i32, D));
                }
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::SomeField(ref mut val) = self {
                    fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                } else {
                    unreachable!()
                }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, D>
        for &UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>(
                    offset,
                );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::SomeField(
                        _,
                    ) = self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self =
                            UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::SomeField(
                                fidl::new_empty!(i32, D),
                            );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, D>
        for &UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
            UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::SomeField(ref val) => {
                fidl::encoding::encode_in_envelope::<i32, D>(
                    <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder, offset + 8, _depth
                )
            }
            UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
        }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::SomeField(_) = self {
                    // Do nothing, read the value into the object
                } else {
                    // Initialize `self` to the right variant
                    *self =UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::SomeField(fidl::new_empty!(i32, D));
                }
                    #[allow(irrefutable_let_patterns)]
                if let UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::SomeField(ref mut val) = self {
                    fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                } else {
                    unreachable!()
                }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleEventUnionRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolFlexibleEventUnionRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleEventUnionRequest, D>
        for &UnknownInteractionsProtocolFlexibleEventUnionRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolFlexibleEventUnionRequest>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsProtocolFlexibleEventUnionRequest::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsProtocolFlexibleEventUnionRequest::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleEventUnionRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolFlexibleEventUnionRequest::SomeField(_) = self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsProtocolFlexibleEventUnionRequest::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolFlexibleEventUnionRequest::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self =
                        UnknownInteractionsProtocolFlexibleEventUnionRequest::__SourceBreaking {
                            unknown_ordinal: ordinal,
                        };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictEventUnionRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictEventUnionRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictEventUnionRequest, D>
        for &UnknownInteractionsProtocolStrictEventUnionRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolStrictEventUnionRequest>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsProtocolStrictEventUnionRequest::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsProtocolStrictEventUnionRequest::__SourceBreaking { .. } => {
                    Err(fidl::Error::UnknownUnionTag)
                }
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictEventUnionRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolStrictEventUnionRequest::SomeField(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsProtocolStrictEventUnionRequest::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolStrictEventUnionRequest::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsProtocolStrictEventUnionRequest::__SourceBreaking {
                        unknown_ordinal: ordinal,
                    };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayUnionResponse, D>
        for &UnknownInteractionsProtocolStrictTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayUnionResponse>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsProtocolStrictTwoWayUnionResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsProtocolStrictTwoWayUnionResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolStrictTwoWayUnionResponse::SomeField(_) = self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsProtocolStrictTwoWayUnionResponse::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolStrictTwoWayUnionResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self =
                        UnknownInteractionsProtocolStrictTwoWayUnionResponse::__SourceBreaking {
                            unknown_ordinal: ordinal,
                        };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, D>
        for &UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>(
                    offset,
                );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::SomeField(_) =
                        self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self =
                            UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::SomeField(
                                fidl::new_empty!(i32, D),
                            );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, D>
        for &UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>(
                offset,
            );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::SomeField(_) =
                        self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self =
                        UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::__SourceBreaking {
                            unknown_ordinal: ordinal,
                        };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, D>
        for &UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>(
                offset,
            );
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::SomeField(ref val) => {
                    fidl::encoding::encode_in_envelope::<i32, D>(
                        <i32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::__SourceBreaking {
                    ..
                } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <i32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::SomeField(_) =
                        self
                    {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::SomeField(
                            fidl::new_empty!(i32, D),
                        );
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::SomeField(
                        ref mut val,
                    ) = self
                    {
                        fidl::decode!(i32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self =
                        UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::__SourceBreaking {
                            unknown_ordinal: ordinal,
                        };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
