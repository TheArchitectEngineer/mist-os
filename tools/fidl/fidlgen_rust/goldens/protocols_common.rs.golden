// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(u32)]
pub enum ErrorEnum {
    ErrFoo = 1,
    ErrBar = 2,
}

impl ErrorEnum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::ErrFoo),
            2 => Some(Self::ErrBar),
            _ => None,
        }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        self as u32
    }

    #[deprecated = "Strict enums should not use `is_unknown`"]
    #[inline]
    pub fn is_unknown(&self) -> bool {
        false
    }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ChannelProtocolEventARequest {
    pub a: i64,
    pub b: i64,
}

impl fidl::Persistable for ChannelProtocolEventARequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ChannelProtocolMethodARequest {
    pub a: i64,
    pub b: i64,
}

impl fidl::Persistable for ChannelProtocolMethodARequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ChannelProtocolMethodBRequest {
    pub a: i64,
    pub b: i64,
}

impl fidl::Persistable for ChannelProtocolMethodBRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ChannelProtocolMethodBResponse {
    pub result: i64,
}

impl fidl::Persistable for ChannelProtocolMethodBResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ManyParametersFifteenRequest {
    pub p1: bool,
    pub p2: bool,
    pub p3: bool,
    pub p4: bool,
    pub p5: bool,
    pub p6: bool,
    pub p7: bool,
    pub p8: bool,
    pub p9: bool,
    pub p10: bool,
    pub p11: bool,
    pub p12: bool,
    pub p13: bool,
    pub p14: bool,
    pub p15: bool,
}

impl fidl::Persistable for ManyParametersFifteenRequest {}

#[derive(Clone, Debug, PartialEq)]
pub struct MethodWithUnionUnionMethodRequest {
    pub u: TheUnion,
}

impl fidl::Persistable for MethodWithUnionUnionMethodRequest {}

#[derive(Clone, Debug, PartialEq)]
pub struct MethodWithUnionUnionMethodResponse {
    pub u: Option<Box<TheUnion>>,
}

impl fidl::Persistable for MethodWithUnionUnionMethodResponse {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: String,
}

impl fidl::Persistable for WithAndWithoutRequestResponseNoRequestWithResponseResponse {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: String,
}

impl fidl::Persistable for WithAndWithoutRequestResponseOnWithResponseRequest {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: String,
}

impl fidl::Persistable for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: String,
}

impl fidl::Persistable for WithAndWithoutRequestResponseWithRequestNoResponseRequest {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: String,
}

impl fidl::Persistable for WithAndWithoutRequestResponseWithRequestWithResponseRequest {}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: String,
}

impl fidl::Persistable for WithAndWithoutRequestResponseWithRequestWithResponseResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct WithErrorSyntaxResponseAsStructResponse {
    pub a: i64,
    pub b: i64,
    pub c: i64,
}

impl fidl::Persistable for WithErrorSyntaxResponseAsStructResponse {}

#[derive(Clone, Debug)]
pub enum TheUnion {
    V(u32),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `TheUnion` member.
#[macro_export]
macro_rules! TheUnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for TheUnion {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::V(x), Self::V(y)) => *x == *y,
            _ => false,
        }
    }
}

impl TheUnion {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::V(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for TheUnion {}

mod internal {
    use super::*;
    unsafe impl fidl::encoding::TypeMarker for ErrorEnum {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for ErrorEnum {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            *value
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Self, D> for ErrorEnum {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for ErrorEnum {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::ErrFoo
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive(prim).ok_or(fidl::Error::InvalidEnumValue)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ChannelProtocolEventARequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ChannelProtocolEventARequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ChannelProtocolEventARequest, D> for &ChannelProtocolEventARequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolEventARequest>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut ChannelProtocolEventARequest)
                    .write_unaligned((self as *const ChannelProtocolEventARequest).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<i64, D>,
            T1: fidl::encoding::Encode<i64, D>,
        > fidl::encoding::Encode<ChannelProtocolEventARequest, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolEventARequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ChannelProtocolEventARequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(i64, D), b: fidl::new_empty!(i64, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ChannelProtocolMethodARequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ChannelProtocolMethodARequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ChannelProtocolMethodARequest, D>
        for &ChannelProtocolMethodARequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolMethodARequest>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut ChannelProtocolMethodARequest)
                    .write_unaligned((self as *const ChannelProtocolMethodARequest).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<i64, D>,
            T1: fidl::encoding::Encode<i64, D>,
        > fidl::encoding::Encode<ChannelProtocolMethodARequest, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolMethodARequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ChannelProtocolMethodARequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(i64, D), b: fidl::new_empty!(i64, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ChannelProtocolMethodBRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ChannelProtocolMethodBRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ChannelProtocolMethodBRequest, D>
        for &ChannelProtocolMethodBRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolMethodBRequest>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut ChannelProtocolMethodBRequest)
                    .write_unaligned((self as *const ChannelProtocolMethodBRequest).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<i64, D>,
            T1: fidl::encoding::Encode<i64, D>,
        > fidl::encoding::Encode<ChannelProtocolMethodBRequest, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolMethodBRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ChannelProtocolMethodBRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(i64, D), b: fidl::new_empty!(i64, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ChannelProtocolMethodBResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ChannelProtocolMethodBResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            8
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ChannelProtocolMethodBResponse, D>
        for &ChannelProtocolMethodBResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolMethodBResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut ChannelProtocolMethodBResponse)
                    .write_unaligned((self as *const ChannelProtocolMethodBResponse).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<i64, D>>
        fidl::encoding::Encode<ChannelProtocolMethodBResponse, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ChannelProtocolMethodBResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ChannelProtocolMethodBResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { result: fidl::new_empty!(i64, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for ManyParametersFifteenRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ManyParametersFifteenRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            1
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            15
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<ManyParametersFifteenRequest, D> for &ManyParametersFifteenRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ManyParametersFifteenRequest>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<ManyParametersFifteenRequest, D>::encode(
                (
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p1),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p2),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p3),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p4),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p5),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p6),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p7),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p8),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p9),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p10),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p11),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p12),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p13),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p14),
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(&self.p15),
                ),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<bool, D>,
            T1: fidl::encoding::Encode<bool, D>,
            T2: fidl::encoding::Encode<bool, D>,
            T3: fidl::encoding::Encode<bool, D>,
            T4: fidl::encoding::Encode<bool, D>,
            T5: fidl::encoding::Encode<bool, D>,
            T6: fidl::encoding::Encode<bool, D>,
            T7: fidl::encoding::Encode<bool, D>,
            T8: fidl::encoding::Encode<bool, D>,
            T9: fidl::encoding::Encode<bool, D>,
            T10: fidl::encoding::Encode<bool, D>,
            T11: fidl::encoding::Encode<bool, D>,
            T12: fidl::encoding::Encode<bool, D>,
            T13: fidl::encoding::Encode<bool, D>,
            T14: fidl::encoding::Encode<bool, D>,
        > fidl::encoding::Encode<ManyParametersFifteenRequest, D>
        for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ManyParametersFifteenRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 1, depth)?;
            self.2.encode(encoder, offset + 2, depth)?;
            self.3.encode(encoder, offset + 3, depth)?;
            self.4.encode(encoder, offset + 4, depth)?;
            self.5.encode(encoder, offset + 5, depth)?;
            self.6.encode(encoder, offset + 6, depth)?;
            self.7.encode(encoder, offset + 7, depth)?;
            self.8.encode(encoder, offset + 8, depth)?;
            self.9.encode(encoder, offset + 9, depth)?;
            self.10.encode(encoder, offset + 10, depth)?;
            self.11.encode(encoder, offset + 11, depth)?;
            self.12.encode(encoder, offset + 12, depth)?;
            self.13.encode(encoder, offset + 13, depth)?;
            self.14.encode(encoder, offset + 14, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for ManyParametersFifteenRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                p1: fidl::new_empty!(bool, D),
                p2: fidl::new_empty!(bool, D),
                p3: fidl::new_empty!(bool, D),
                p4: fidl::new_empty!(bool, D),
                p5: fidl::new_empty!(bool, D),
                p6: fidl::new_empty!(bool, D),
                p7: fidl::new_empty!(bool, D),
                p8: fidl::new_empty!(bool, D),
                p9: fidl::new_empty!(bool, D),
                p10: fidl::new_empty!(bool, D),
                p11: fidl::new_empty!(bool, D),
                p12: fidl::new_empty!(bool, D),
                p13: fidl::new_empty!(bool, D),
                p14: fidl::new_empty!(bool, D),
                p15: fidl::new_empty!(bool, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(bool, D, &mut self.p1, decoder, offset + 0, _depth)?;
            fidl::decode!(bool, D, &mut self.p2, decoder, offset + 1, _depth)?;
            fidl::decode!(bool, D, &mut self.p3, decoder, offset + 2, _depth)?;
            fidl::decode!(bool, D, &mut self.p4, decoder, offset + 3, _depth)?;
            fidl::decode!(bool, D, &mut self.p5, decoder, offset + 4, _depth)?;
            fidl::decode!(bool, D, &mut self.p6, decoder, offset + 5, _depth)?;
            fidl::decode!(bool, D, &mut self.p7, decoder, offset + 6, _depth)?;
            fidl::decode!(bool, D, &mut self.p8, decoder, offset + 7, _depth)?;
            fidl::decode!(bool, D, &mut self.p9, decoder, offset + 8, _depth)?;
            fidl::decode!(bool, D, &mut self.p10, decoder, offset + 9, _depth)?;
            fidl::decode!(bool, D, &mut self.p11, decoder, offset + 10, _depth)?;
            fidl::decode!(bool, D, &mut self.p12, decoder, offset + 11, _depth)?;
            fidl::decode!(bool, D, &mut self.p13, decoder, offset + 12, _depth)?;
            fidl::decode!(bool, D, &mut self.p14, decoder, offset + 13, _depth)?;
            fidl::decode!(bool, D, &mut self.p15, decoder, offset + 14, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for MethodWithUnionUnionMethodRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for MethodWithUnionUnionMethodRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<MethodWithUnionUnionMethodRequest, D>
        for &MethodWithUnionUnionMethodRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<MethodWithUnionUnionMethodRequest>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<MethodWithUnionUnionMethodRequest, D>::encode(
                (<TheUnion as fidl::encoding::ValueTypeMarker>::borrow(&self.u),),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<TheUnion, D>>
        fidl::encoding::Encode<MethodWithUnionUnionMethodRequest, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<MethodWithUnionUnionMethodRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for MethodWithUnionUnionMethodRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { u: fidl::new_empty!(TheUnion, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(TheUnion, D, &mut self.u, decoder, offset + 0, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for MethodWithUnionUnionMethodResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for MethodWithUnionUnionMethodResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<MethodWithUnionUnionMethodResponse, D>
        for &MethodWithUnionUnionMethodResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<MethodWithUnionUnionMethodResponse>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<MethodWithUnionUnionMethodResponse, D>::encode(
                (
                    <fidl::encoding::OptionalUnion<TheUnion> as fidl::encoding::ValueTypeMarker>::borrow(&self.u),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::OptionalUnion<TheUnion>, D>,
        > fidl::encoding::Encode<MethodWithUnionUnionMethodResponse, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<MethodWithUnionUnionMethodResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for MethodWithUnionUnionMethodResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { u: fidl::new_empty!(fidl::encoding::OptionalUnion<TheUnion>, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::OptionalUnion<TheUnion>,
                D,
                &mut self.u,
                decoder,
                offset + 0,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for WithAndWithoutRequestResponseNoRequestWithResponseResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for WithAndWithoutRequestResponseNoRequestWithResponseResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<WithAndWithoutRequestResponseNoRequestWithResponseResponse, D>
        for &WithAndWithoutRequestResponseNoRequestWithResponseResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseNoRequestWithResponseResponse>(
                    offset,
                );
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<WithAndWithoutRequestResponseNoRequestWithResponseResponse, D>::encode(
                (
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(&self.ret),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedString, D>,
        > fidl::encoding::Encode<WithAndWithoutRequestResponseNoRequestWithResponseResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseNoRequestWithResponseResponse>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for WithAndWithoutRequestResponseNoRequestWithResponseResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { ret: fidl::new_empty!(fidl::encoding::UnboundedString, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedString,
                D,
                &mut self.ret,
                decoder,
                offset + 0,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for WithAndWithoutRequestResponseOnWithResponseRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for WithAndWithoutRequestResponseOnWithResponseRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<WithAndWithoutRequestResponseOnWithResponseRequest, D>
        for &WithAndWithoutRequestResponseOnWithResponseRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseOnWithResponseRequest>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<WithAndWithoutRequestResponseOnWithResponseRequest, D>::encode(
                (<fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(
                    &self.ret,
                ),),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedString, D>,
        > fidl::encoding::Encode<WithAndWithoutRequestResponseOnWithResponseRequest, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseOnWithResponseRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for WithAndWithoutRequestResponseOnWithResponseRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { ret: fidl::new_empty!(fidl::encoding::UnboundedString, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedString,
                D,
                &mut self.ret,
                decoder,
                offset + 0,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, D>
        for &WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>(
                    offset,
                );
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, D>::encode(
                (
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(&self.arg),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedString, D>,
        >
        fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { arg: fidl::new_empty!(fidl::encoding::UnboundedString, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedString,
                D,
                &mut self.arg,
                decoder,
                offset + 0,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for WithAndWithoutRequestResponseWithRequestNoResponseRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestNoResponseRequest, D>
        for &WithAndWithoutRequestResponseWithRequestNoResponseRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestNoResponseRequest>(
                    offset,
                );
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<WithAndWithoutRequestResponseWithRequestNoResponseRequest, D>::encode(
                (
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(&self.arg),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedString, D>,
        > fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestNoResponseRequest, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestNoResponseRequest>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for WithAndWithoutRequestResponseWithRequestNoResponseRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { arg: fidl::new_empty!(fidl::encoding::UnboundedString, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedString,
                D,
                &mut self.arg,
                decoder,
                offset + 0,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for WithAndWithoutRequestResponseWithRequestWithResponseRequest
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for WithAndWithoutRequestResponseWithRequestWithResponseRequest
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestWithResponseRequest, D>
        for &WithAndWithoutRequestResponseWithRequestWithResponseRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestWithResponseRequest>(
                    offset,
                );
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<WithAndWithoutRequestResponseWithRequestWithResponseRequest, D>::encode(
                (
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(&self.arg),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedString, D>,
        > fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestWithResponseRequest, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestWithResponseRequest>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for WithAndWithoutRequestResponseWithRequestWithResponseRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { arg: fidl::new_empty!(fidl::encoding::UnboundedString, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedString,
                D,
                &mut self.arg,
                decoder,
                offset + 0,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker
        for WithAndWithoutRequestResponseWithRequestWithResponseResponse
    {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker
        for WithAndWithoutRequestResponseWithRequestWithResponseResponse
    {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestWithResponseResponse, D>
        for &WithAndWithoutRequestResponseWithRequestWithResponseResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestWithResponseResponse>(
                    offset,
                );
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<WithAndWithoutRequestResponseWithRequestWithResponseResponse, D>::encode(
                (
                    <fidl::encoding::UnboundedString as fidl::encoding::ValueTypeMarker>::borrow(&self.ret),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<fidl::encoding::UnboundedString, D>,
        >
        fidl::encoding::Encode<WithAndWithoutRequestResponseWithRequestWithResponseResponse, D>
        for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder
                .debug_check_bounds::<WithAndWithoutRequestResponseWithRequestWithResponseResponse>(
                    offset,
                );
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for WithAndWithoutRequestResponseWithRequestWithResponseResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { ret: fidl::new_empty!(fidl::encoding::UnboundedString, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(
                fidl::encoding::UnboundedString,
                D,
                &mut self.ret,
                decoder,
                offset + 0,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for WithErrorSyntaxResponseAsStructResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for WithErrorSyntaxResponseAsStructResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            24
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<WithErrorSyntaxResponseAsStructResponse, D>
        for &WithErrorSyntaxResponseAsStructResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<WithErrorSyntaxResponseAsStructResponse>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut WithErrorSyntaxResponseAsStructResponse).write_unaligned(
                    (self as *const WithErrorSyntaxResponseAsStructResponse).read(),
                );
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<i64, D>,
            T1: fidl::encoding::Encode<i64, D>,
            T2: fidl::encoding::Encode<i64, D>,
        > fidl::encoding::Encode<WithErrorSyntaxResponseAsStructResponse, D> for (T0, T1, T2)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<WithErrorSyntaxResponseAsStructResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            self.2.encode(encoder, offset + 16, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for WithErrorSyntaxResponseAsStructResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                a: fidl::new_empty!(i64, D),
                b: fidl::new_empty!(i64, D),
                c: fidl::new_empty!(i64, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 24);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for TheUnion {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for TheUnion {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<TheUnion, D> for &TheUnion {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TheUnion>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                TheUnion::V(ref val) => fidl::encoding::encode_in_envelope::<u32, D>(
                    <u32 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                TheUnion::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for TheUnion {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <u32 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let TheUnion::V(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = TheUnion::V(fidl::new_empty!(u32, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let TheUnion::V(ref mut val) = self {
                        fidl::decode!(u32, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = TheUnion::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
