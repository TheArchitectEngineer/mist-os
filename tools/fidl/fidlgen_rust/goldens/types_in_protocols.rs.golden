// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::client::QueryResponseFut;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use fidl::endpoints::{ControlHandle as _, Responder as _};
pub use fidl_test_typesinprotocols_common::*;
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[derive(Debug, PartialEq)]
pub struct Resource {
    pub handle: fidl::Handle,
    pub vmo: fidl::Vmo,
    pub client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
    pub server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
    pub struct_: ResourceStruct,
    pub table: ResourceTable,
    pub union: ResourceUnion,
    pub opt_handle: Option<fidl::Handle>,
    pub opt_vmo: Option<fidl::Vmo>,
    pub opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
    pub opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
    pub opt_struct: Option<Box<ResourceStruct>>,
    pub opt_union: Option<Box<ResourceUnion>>,
    pub array_handle: [fidl::Handle; 5],
    pub array_vmo: [fidl::Vmo; 5],
    pub array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
    pub array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
    pub array_struct: [ResourceStruct; 5],
    pub array_table: [ResourceTable; 5],
    pub array_union: [ResourceUnion; 5],
    pub vector_handle: Vec<fidl::Handle>,
    pub vector_vmo: Vec<fidl::Vmo>,
    pub vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
    pub vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
    pub vector_struct: Vec<ResourceStruct>,
    pub vector_table: Vec<ResourceTable>,
    pub vector_union: Vec<ResourceUnion>,
}

impl fidl::Standalone<fidl::encoding::DefaultFuchsiaResourceDialect> for Resource {}

#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResourceStruct;

impl fidl::Standalone<fidl::encoding::DefaultFuchsiaResourceDialect> for ResourceStruct {}

#[derive(Debug, Default, PartialEq)]
pub struct ResourceTable {
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Standalone<fidl::encoding::DefaultFuchsiaResourceDialect> for ResourceTable {}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `ResourceUnion` member.
#[macro_export]
macro_rules! ResourceUnionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for ResourceUnion {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::B(x), Self::B(y)) => *x == *y,
            _ => false,
        }
    }
}

impl ResourceUnion {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::B(_) => 1,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Standalone<fidl::encoding::DefaultFuchsiaResourceDialect> for ResourceUnion {}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct ProtocolMarker;

impl fidl::endpoints::ProtocolMarker for ProtocolMarker {
    type Proxy = ProtocolProxy;
    type RequestStream = ProtocolRequestStream;
    #[cfg(target_os = "fuchsia")]
    type SynchronousProxy = ProtocolSynchronousProxy;

    const DEBUG_NAME: &'static str = "(anonymous) Protocol";
}
pub type ProtocolErrorBasicResult =
    Result<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>), u32>;
pub type ProtocolErrorCompoundResult =
    Result<(Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>), u32>;
pub type ProtocolErrorArrayBasicResult = Result<
    (
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    ),
    u32,
>;
pub type ProtocolErrorArrayCompoundResult = Result<
    (
        [Bits; 5],
        [Enum; 5],
        [Struct; 5],
        [Table; 5],
        [Union; 5],
        [Option<Box<Struct>>; 5],
        [Option<Box<Union>>; 5],
    ),
    u32,
>;
pub type ProtocolErrorVectorBasicResult = Result<
    (
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    ),
    u32,
>;
pub type ProtocolErrorVectorCompoundResult = Result<
    (
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    ),
    u32,
>;
pub type ProtocolErrorVectorOptionalResult = Result<
    (Option<Vec<u8>>, Option<Vec<String>>, Option<Vec<Struct>>, Option<Vec<Option<Box<Struct>>>>),
    u32,
>;
pub type ProtocolErrorArrayVectorNestedResult =
    Result<([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>), u32>;
pub type ProtocolErrorResourceResult = Result<
    (
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    ),
    u32,
>;

pub trait ProtocolProxyInterface: Send + Sync {
    fn r#one_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Result<(), fidl::Error>;
    type TwoWayBasicResponseFut: std::future::Future<
            Output = Result<
                (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_basic(
        &self,
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: &str,
        opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut;
    type ErrorBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorBasicResult, fidl::Error>>
        + Send;
    fn r#error_basic(&self) -> Self::ErrorBasicResponseFut;
    fn r#one_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &Struct,
        table: &Table,
        union: &Union,
        opt_struct: Option<&Struct>,
        opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error>;
    type TwoWayCompoundResponseFut: std::future::Future<
            Output = Result<
                (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_compound(
        &self,
        bits: Bits,
        enum_: Enum,
        struct_: &Struct,
        table: &Table,
        union: &Union,
        opt_struct: Option<&Struct>,
        opt_union: Option<&Union>,
    ) -> Self::TwoWayCompoundResponseFut;
    type ErrorCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorCompoundResult, fidl::Error>>
        + Send;
    fn r#error_compound(&self) -> Self::ErrorCompoundResponseFut;
    fn r#one_way_array_basic(
        &self,
        array_uint8: &[u8; 5],
        array_uint16: &[u16; 5],
        array_uint32: &[u32; 5],
        array_uint64: &[u64; 5],
        array_int8: &[i8; 5],
        array_int16: &[i16; 5],
        array_int32: &[i32; 5],
        array_int64: &[i64; 5],
        array_float32: &[f32; 5],
        array_float64: &[f64; 5],
        array_string: &[String; 5],
        array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    [u8; 5],
                    [u16; 5],
                    [u32; 5],
                    [u64; 5],
                    [i8; 5],
                    [i16; 5],
                    [i32; 5],
                    [i64; 5],
                    [f32; 5],
                    [f64; 5],
                    [String; 5],
                    [Option<String>; 5],
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_basic(
        &self,
        array_uint8: &[u8; 5],
        array_uint16: &[u16; 5],
        array_uint32: &[u32; 5],
        array_uint64: &[u64; 5],
        array_int8: &[i8; 5],
        array_int16: &[i16; 5],
        array_int32: &[i32; 5],
        array_int64: &[i64; 5],
        array_float32: &[f32; 5],
        array_float64: &[f64; 5],
        array_string: &[String; 5],
        array_opt_string: &[Option<String>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut;
    type ErrorArrayBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayBasicResult, fidl::Error>>
        + Send;
    fn r#error_array_basic(&self) -> Self::ErrorArrayBasicResponseFut;
    fn r#one_way_array_compound(
        &self,
        array_bits: &[Bits; 5],
        array_enum: &[Enum; 5],
        array_struct: &[Struct; 5],
        array_table: &[Table; 5],
        array_union: &[Union; 5],
        array_opt_struct: &[Option<Box<Struct>>; 5],
        array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayCompoundResponseFut: std::future::Future<
            Output = Result<
                (
                    [Bits; 5],
                    [Enum; 5],
                    [Struct; 5],
                    [Table; 5],
                    [Union; 5],
                    [Option<Box<Struct>>; 5],
                    [Option<Box<Union>>; 5],
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_array_compound(
        &self,
        array_bits: &[Bits; 5],
        array_enum: &[Enum; 5],
        array_struct: &[Struct; 5],
        array_table: &[Table; 5],
        array_union: &[Union; 5],
        array_opt_struct: &[Option<Box<Struct>>; 5],
        array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut;
    type ErrorArrayCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayCompoundResult, fidl::Error>>
        + Send;
    fn r#error_array_compound(&self) -> Self::ErrorArrayCompoundResponseFut;
    fn r#one_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &[String],
        vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorBasicResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<u8>,
                    Vec<u16>,
                    Vec<u32>,
                    Vec<u64>,
                    Vec<i8>,
                    Vec<i16>,
                    Vec<i32>,
                    Vec<i64>,
                    Vec<f32>,
                    Vec<f64>,
                    Vec<String>,
                    Vec<Option<String>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_basic(
        &self,
        vector_uint8: &[u8],
        vector_uint16: &[u16],
        vector_uint32: &[u32],
        vector_uint64: &[u64],
        vector_int8: &[i8],
        vector_int16: &[i16],
        vector_int32: &[i32],
        vector_int64: &[i64],
        vector_float32: &[f32],
        vector_float64: &[f64],
        vector_string: &[String],
        vector_opt_string: &[Option<String>],
    ) -> Self::TwoWayVectorBasicResponseFut;
    type ErrorVectorBasicResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorBasicResult, fidl::Error>>
        + Send;
    fn r#error_vector_basic(&self) -> Self::ErrorVectorBasicResponseFut;
    fn r#one_way_vector_compound(
        &self,
        vector_bits: &[Bits],
        vector_enum: &[Enum],
        vector_struct: &[Struct],
        vector_table: &[Table],
        vector_union: &[Union],
        vector_opt_struct: &[Option<Box<Struct>>],
        vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorCompoundResponseFut: std::future::Future<
            Output = Result<
                (
                    Vec<Bits>,
                    Vec<Enum>,
                    Vec<Struct>,
                    Vec<Table>,
                    Vec<Union>,
                    Vec<Option<Box<Struct>>>,
                    Vec<Option<Box<Union>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_compound(
        &self,
        vector_bits: &[Bits],
        vector_enum: &[Enum],
        vector_struct: &[Struct],
        vector_table: &[Table],
        vector_union: &[Union],
        vector_opt_struct: &[Option<Box<Struct>>],
        vector_opt_union: &[Option<Box<Union>>],
    ) -> Self::TwoWayVectorCompoundResponseFut;
    type ErrorVectorCompoundResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorCompoundResult, fidl::Error>>
        + Send;
    fn r#error_vector_compound(&self) -> Self::ErrorVectorCompoundResponseFut;
    fn r#one_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&[String]>,
        opt_vector_struct: Option<&[Struct]>,
        opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error>;
    type TwoWayVectorOptionalResponseFut: std::future::Future<
            Output = Result<
                (
                    Option<Vec<u8>>,
                    Option<Vec<String>>,
                    Option<Vec<Struct>>,
                    Option<Vec<Option<Box<Struct>>>>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_vector_optional(
        &self,
        opt_vector_uint8: Option<&[u8]>,
        opt_vector_string: Option<&[String]>,
        opt_vector_struct: Option<&[Struct]>,
        opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Self::TwoWayVectorOptionalResponseFut;
    type ErrorVectorOptionalResponseFut: std::future::Future<Output = Result<ProtocolErrorVectorOptionalResult, fidl::Error>>
        + Send;
    fn r#error_vector_optional(&self) -> Self::ErrorVectorOptionalResponseFut;
    fn r#one_way_array_vector_nested(
        &self,
        array_array_uint8: &[[u8; 5]; 5],
        array_vector_uint8: &[Vec<u8>; 5],
        vector_array_uint8: &[[u8; 5]],
        vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error>;
    type TwoWayArrayVectorNestedResponseFut: std::future::Future<
            Output = Result<([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error>,
        > + Send;
    fn r#two_way_array_vector_nested(
        &self,
        array_array_uint8: &[[u8; 5]; 5],
        array_vector_uint8: &[Vec<u8>; 5],
        vector_array_uint8: &[[u8; 5]],
        vector_vector_uint8: &[Vec<u8>],
    ) -> Self::TwoWayArrayVectorNestedResponseFut;
    type ErrorArrayVectorNestedResponseFut: std::future::Future<Output = Result<ProtocolErrorArrayVectorNestedResult, fidl::Error>>
        + Send;
    fn r#error_array_vector_nested(&self) -> Self::ErrorArrayVectorNestedResponseFut;
    fn r#one_way_resource(
        &self,
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<ResourceStruct>,
        opt_union: Option<ResourceUnion>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error>;
    type TwoWayResourceResponseFut: std::future::Future<
            Output = Result<
                (
                    fidl::Handle,
                    fidl::Vmo,
                    fidl::endpoints::ClientEnd<ProtocolMarker>,
                    fidl::endpoints::ServerEnd<ProtocolMarker>,
                    ResourceStruct,
                    ResourceTable,
                    ResourceUnion,
                    Option<fidl::Handle>,
                    Option<fidl::Vmo>,
                    Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    Option<Box<ResourceStruct>>,
                    Option<Box<ResourceUnion>>,
                    [fidl::Handle; 5],
                    [fidl::Vmo; 5],
                    [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                    [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                    [ResourceStruct; 5],
                    [ResourceTable; 5],
                    [ResourceUnion; 5],
                    Vec<fidl::Handle>,
                    Vec<fidl::Vmo>,
                    Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    Vec<ResourceStruct>,
                    Vec<ResourceTable>,
                    Vec<ResourceUnion>,
                ),
                fidl::Error,
            >,
        > + Send;
    fn r#two_way_resource(
        &self,
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<ResourceStruct>,
        opt_union: Option<ResourceUnion>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    ) -> Self::TwoWayResourceResponseFut;
    type ErrorResourceResponseFut: std::future::Future<Output = Result<ProtocolErrorResourceResult, fidl::Error>>
        + Send;
    fn r#error_resource(&self) -> Self::ErrorResourceResponseFut;
}
#[derive(Debug)]
#[cfg(target_os = "fuchsia")]
pub struct ProtocolSynchronousProxy {
    client: fidl::client::sync::Client,
}

#[cfg(target_os = "fuchsia")]
impl fidl::endpoints::SynchronousProxy for ProtocolSynchronousProxy {
    type Proxy = ProtocolProxy;
    type Protocol = ProtocolMarker;

    fn from_channel(inner: fidl::Channel) -> Self {
        Self::new(inner)
    }

    fn into_channel(self) -> fidl::Channel {
        self.client.into_channel()
    }

    fn as_channel(&self) -> &fidl::Channel {
        self.client.as_channel()
    }
}

#[cfg(target_os = "fuchsia")]
impl ProtocolSynchronousProxy {
    pub fn new(channel: fidl::Channel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::sync::Client::new(channel, protocol_name) }
    }

    pub fn into_channel(self) -> fidl::Channel {
        self.client.into_channel()
    }

    /// Waits until an event arrives and returns it. It is safe for other
    /// threads to make concurrent requests while waiting for an event.
    pub fn wait_for_event(
        &self,
        deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolEvent, fidl::Error> {
        ProtocolEvent::decode(self.client.wait_for_event(deadline)?)
    }

    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>), fidl::Error>
    {
        let _response = self.client.send_query::<Basic, Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.uint8,
            _response.uint16,
            _response.uint32,
            _response.uint64,
            _response.int8,
            _response.int16,
            _response.int32,
            _response.int64,
            _response.float32,
            _response.float64,
            _response.string,
            _response.opt_string,
        ))
    }

    pub fn r#error_basic(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorBasicResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Basic, u32>>(
                (),
                0x459eaa5d11b9ff93,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response.map(|x| {
            (
                x.uint8,
                x.uint16,
                x.uint32,
                x.uint64,
                x.int8,
                x.int16,
                x.int32,
                x.int64,
                x.float32,
                x.float64,
                x.string,
                x.opt_string,
            )
        }))
    }

    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<
        (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        fidl::Error,
    > {
        let _response = self.client.send_query::<Compound, Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.bits,
            _response.enum_,
            _response.struct_,
            _response.table,
            _response.union,
            _response.opt_struct,
            _response.opt_union,
        ))
    }

    pub fn r#error_compound(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorCompoundResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Compound, u32>>(
                (),
                0x29817d89a19ec77d,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response
            .map(|x| (x.bits, x.enum_, x.struct_, x.table, x.union, x.opt_struct, x.opt_union)))
    }

    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
        ___deadline: zx::MonotonicInstant,
    ) -> Result<
        (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<ArrayBasic, ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_uint8,
            _response.array_uint16,
            _response.array_uint32,
            _response.array_uint64,
            _response.array_int8,
            _response.array_int16,
            _response.array_int32,
            _response.array_int64,
            _response.array_float32,
            _response.array_float64,
            _response.array_string,
            _response.array_opt_string,
        ))
    }

    pub fn r#error_array_basic(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorArrayBasicResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<ArrayBasic, u32>,
        >(
            (),
            0xf0dbde9626fff79,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (
                x.array_uint8,
                x.array_uint16,
                x.array_uint32,
                x.array_uint64,
                x.array_int8,
                x.array_int16,
                x.array_int32,
                x.array_int64,
                x.array_float32,
                x.array_float64,
                x.array_string,
                x.array_opt_string,
            )
        }))
    }

    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound>(
            (
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
            ),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
        ___deadline: zx::MonotonicInstant,
    ) -> Result<
        (
            [Bits; 5],
            [Enum; 5],
            [Struct; 5],
            [Table; 5],
            [Union; 5],
            [Option<Box<Struct>>; 5],
            [Option<Box<Union>>; 5],
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<ArrayCompound, ArrayCompound>(
            (
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
            ),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_bits,
            _response.array_enum,
            _response.array_struct,
            _response.array_table,
            _response.array_union,
            _response.array_opt_struct,
            _response.array_opt_union,
        ))
    }

    pub fn r#error_array_compound(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorArrayCompoundResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<ArrayCompound, u32>,
        >(
            (),
            0x52257f80e29c1a04,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (
                x.array_bits,
                x.array_enum,
                x.array_struct,
                x.array_table,
                x.array_union,
                x.array_opt_struct,
                x.array_opt_union,
            )
        }))
    }

    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
        ___deadline: zx::MonotonicInstant,
    ) -> Result<
        (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorBasic, VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_uint8,
            _response.vector_uint16,
            _response.vector_uint32,
            _response.vector_uint64,
            _response.vector_int8,
            _response.vector_int16,
            _response.vector_int32,
            _response.vector_int64,
            _response.vector_float32,
            _response.vector_float64,
            _response.vector_string,
            _response.vector_opt_string,
        ))
    }

    pub fn r#error_vector_basic(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorVectorBasicResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<VectorBasic, u32>,
        >(
            (),
            0xc27f841d6313f72,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (
                x.vector_uint8,
                x.vector_uint16,
                x.vector_uint32,
                x.vector_uint64,
                x.vector_int8,
                x.vector_int16,
                x.vector_int32,
                x.vector_int64,
                x.vector_float32,
                x.vector_float64,
                x.vector_string,
                x.vector_opt_string,
            )
        }))
    }

    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
        ___deadline: zx::MonotonicInstant,
    ) -> Result<
        (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorCompound, VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.vector_bits,
            _response.vector_enum,
            _response.vector_struct,
            _response.vector_table,
            _response.vector_union,
            _response.vector_opt_struct,
            _response.vector_opt_union,
        ))
    }

    pub fn r#error_vector_compound(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorVectorCompoundResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<VectorCompound, u32>,
        >(
            (),
            0x760e278628f7a985,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (
                x.vector_bits,
                x.vector_enum,
                x.vector_struct,
                x.vector_table,
                x.vector_union,
                x.vector_opt_struct,
                x.vector_opt_union,
            )
        }))
    }

    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<
        (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<VectorOptional, VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.opt_vector_uint8,
            _response.opt_vector_string,
            _response.opt_vector_struct,
            _response.opt_vector_opt_struct,
        ))
    }

    pub fn r#error_vector_optional(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorVectorOptionalResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<VectorOptional, u32>,
        >(
            (),
            0x58e75cf86e2d715e,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (x.opt_vector_uint8, x.opt_vector_string, x.opt_vector_struct, x.opt_vector_opt_struct)
        }))
    }

    pub fn r#one_way_array_vector_nested(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested>(
            (array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_array_vector_nested(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
        ___deadline: zx::MonotonicInstant,
    ) -> Result<([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
        let _response = self.client.send_query::<ArrayVectorNested, ArrayVectorNested>(
            (array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8),
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.array_array_uint8,
            _response.array_vector_uint8,
            _response.vector_array_uint8,
            _response.vector_vector_uint8,
        ))
    }

    pub fn r#error_array_vector_nested(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorArrayVectorNestedResult, fidl::Error> {
        let _response = self.client.send_query::<
            fidl::encoding::EmptyPayload,
            fidl::encoding::ResultType<ArrayVectorNested, u32>,
        >(
            (),
            0x7e168d89e1dac8a7,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok(_response.map(|x| {
            (x.array_array_uint8, x.array_vector_uint8, x.vector_array_uint8, x.vector_vector_uint8)
        }))
    }

    pub fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x5af4795a9ed3a022,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<
        (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        ),
        fidl::Error,
    > {
        let _response = self.client.send_query::<Resource, Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x1904824a11c6ad5b,
            fidl::encoding::DynamicFlags::empty(),
            ___deadline,
        )?;
        Ok((
            _response.handle,
            _response.vmo,
            _response.client_end,
            _response.server_end,
            _response.struct_,
            _response.table,
            _response.union,
            _response.opt_handle,
            _response.opt_vmo,
            _response.opt_client_end,
            _response.opt_server_end,
            _response.opt_struct,
            _response.opt_union,
            _response.array_handle,
            _response.array_vmo,
            _response.array_client_end,
            _response.array_server_end,
            _response.array_struct,
            _response.array_table,
            _response.array_union,
            _response.vector_handle,
            _response.vector_vmo,
            _response.vector_client_end,
            _response.vector_server_end,
            _response.vector_struct,
            _response.vector_table,
            _response.vector_union,
        ))
    }

    pub fn r#error_resource(
        &self,
        ___deadline: zx::MonotonicInstant,
    ) -> Result<ProtocolErrorResourceResult, fidl::Error> {
        let _response = self
            .client
            .send_query::<fidl::encoding::EmptyPayload, fidl::encoding::ResultType<Resource, u32>>(
                (),
                0x5b28634d603175b6,
                fidl::encoding::DynamicFlags::empty(),
                ___deadline,
            )?;
        Ok(_response.map(|x| {
            (
                x.handle,
                x.vmo,
                x.client_end,
                x.server_end,
                x.struct_,
                x.table,
                x.union,
                x.opt_handle,
                x.opt_vmo,
                x.opt_client_end,
                x.opt_server_end,
                x.opt_struct,
                x.opt_union,
                x.array_handle,
                x.array_vmo,
                x.array_client_end,
                x.array_server_end,
                x.array_struct,
                x.array_table,
                x.array_union,
                x.vector_handle,
                x.vector_vmo,
                x.vector_client_end,
                x.vector_server_end,
                x.vector_struct,
                x.vector_table,
                x.vector_union,
            )
        }))
    }
}

#[cfg(target_os = "fuchsia")]
impl From<ProtocolSynchronousProxy> for zx::Handle {
    fn from(value: ProtocolSynchronousProxy) -> Self {
        value.into_channel().into()
    }
}

#[cfg(target_os = "fuchsia")]
impl From<fidl::Channel> for ProtocolSynchronousProxy {
    fn from(value: fidl::Channel) -> Self {
        Self::new(value)
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolProxy {
    client: fidl::client::Client<fidl::encoding::DefaultFuchsiaResourceDialect>,
}

impl fidl::endpoints::Proxy for ProtocolProxy {
    type Protocol = ProtocolMarker;

    fn from_channel(inner: ::fidl::AsyncChannel) -> Self {
        Self::new(inner)
    }

    fn into_channel(self) -> Result<::fidl::AsyncChannel, Self> {
        self.client.into_channel().map_err(|client| Self { client })
    }

    fn as_channel(&self) -> &::fidl::AsyncChannel {
        self.client.as_channel()
    }
}

impl ProtocolProxy {
    /// Create a new Proxy for test.typesinprotocols/Protocol.
    pub fn new(channel: ::fidl::AsyncChannel) -> Self {
        let protocol_name = <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME;
        Self { client: fidl::client::Client::new(channel, protocol_name) }
    }

    /// Get a Stream of events from the remote end of the protocol.
    ///
    /// # Panics
    ///
    /// Panics if the event stream was already taken.
    pub fn take_event_stream(&self) -> ProtocolEventStream {
        ProtocolEventStream { event_receiver: self.client.take_event_receiver() }
    }

    pub fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }

    pub fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> fidl::client::QueryResponseFut<
        (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_basic(
            self, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64,
            string, opt_string,
        )
    }

    pub fn r#error_basic(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorBasicResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_basic(self)
    }

    pub fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }

    pub fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> fidl::client::QueryResponseFut<
        (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_compound(
            self, bits, enum_, struct_, table, union, opt_struct, opt_union,
        )
    }

    pub fn r#error_compound(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorCompoundResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_compound(self)
    }

    pub fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }

    pub fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> fidl::client::QueryResponseFut<
        (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_array_basic(
            self,
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        )
    }

    pub fn r#error_array_basic(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorArrayBasicResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_array_basic(self)
    }

    pub fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            array_opt_struct,
            array_opt_union,
        )
    }

    pub fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> fidl::client::QueryResponseFut<
        (
            [Bits; 5],
            [Enum; 5],
            [Struct; 5],
            [Table; 5],
            [Union; 5],
            [Option<Box<Struct>>; 5],
            [Option<Box<Union>>; 5],
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_array_compound(
            self,
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            array_opt_struct,
            array_opt_union,
        )
    }

    pub fn r#error_array_compound(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorArrayCompoundResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_array_compound(self)
    }

    pub fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }

    pub fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> fidl::client::QueryResponseFut<
        (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_vector_basic(
            self,
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        )
    }

    pub fn r#error_vector_basic(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorVectorBasicResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_vector_basic(self)
    }

    pub fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }

    pub fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> fidl::client::QueryResponseFut<
        (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_vector_compound(
            self,
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        )
    }

    pub fn r#error_vector_compound(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorVectorCompoundResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_vector_compound(self)
    }

    pub fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }

    pub fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> fidl::client::QueryResponseFut<
        (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_vector_optional(
            self,
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        )
    }

    pub fn r#error_vector_optional(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorVectorOptionalResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_vector_optional(self)
    }

    pub fn r#one_way_array_vector_nested(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_array_vector_nested(
            self,
            array_array_uint8,
            array_vector_uint8,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }

    pub fn r#two_way_array_vector_nested(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> fidl::client::QueryResponseFut<
        ([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_array_vector_nested(
            self,
            array_array_uint8,
            array_vector_uint8,
            vector_array_uint8,
            vector_vector_uint8,
        )
    }

    pub fn r#error_array_vector_nested(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorArrayVectorNestedResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_array_vector_nested(self)
    }

    pub fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        ProtocolProxyInterface::r#one_way_resource(
            self,
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        )
    }

    pub fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> fidl::client::QueryResponseFut<
        (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#two_way_resource(
            self,
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        )
    }

    pub fn r#error_resource(
        &self,
    ) -> fidl::client::QueryResponseFut<
        ProtocolErrorResourceResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    > {
        ProtocolProxyInterface::r#error_resource(self)
    }
}

impl ProtocolProxyInterface for ProtocolProxy {
    fn r#one_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0x7c311f0d9e662df9,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayBasicResponseFut = fidl::client::QueryResponseFut<
        (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Self::TwoWayBasicResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                Basic,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x205b92db5139c88f,
            >(_buf?)?;
            Ok((
                _response.uint8,
                _response.uint16,
                _response.uint32,
                _response.uint64,
                _response.int8,
                _response.int16,
                _response.int32,
                _response.int64,
                _response.float32,
                _response.float64,
                _response.string,
                _response.opt_string,
            ))
        }
        self.client.send_query_and_decode::<
            Basic,
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>),
        >(
            (uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string,),
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorBasicResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorBasicResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_basic(&self) -> Self::ErrorBasicResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Basic, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x459eaa5d11b9ff93,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.uint8,
                    x.uint16,
                    x.uint32,
                    x.uint64,
                    x.int8,
                    x.int16,
                    x.int32,
                    x.int64,
                    x.float32,
                    x.float64,
                    x.string,
                    x.opt_string,
                )
            }))
        }
        self.client.send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorBasicResult>(
            (),
            0x459eaa5d11b9ff93,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0x2bc2bc3a9237c6cc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayCompoundResponseFut = fidl::client::QueryResponseFut<
        (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Self::TwoWayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                Compound,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x79f279c7201da131,
            >(_buf?)?;
            Ok((
                _response.bits,
                _response.enum_,
                _response.struct_,
                _response.table,
                _response.union,
                _response.opt_struct,
                _response.opt_union,
            ))
        }
        self.client.send_query_and_decode::<
            Compound,
            (Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>),
        >(
            (bits, enum_, struct_, table, union, opt_struct, opt_union,),
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorCompoundResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorCompoundResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_compound(&self) -> Self::ErrorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Compound, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x29817d89a19ec77d,
            >(_buf?)?;
            Ok(_response
                .map(|x| (x.bits, x.enum_, x.struct_, x.table, x.union, x.opt_struct, x.opt_union)))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorCompoundResult>(
                (),
                0x29817d89a19ec77d,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }

    fn r#one_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x62e2ebcadf35ca19,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayArrayBasicResponseFut = fidl::client::QueryResponseFut<
        (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Self::TwoWayArrayBasicResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                [u8; 5],
                [u16; 5],
                [u32; 5],
                [u64; 5],
                [i8; 5],
                [i16; 5],
                [i32; 5],
                [i64; 5],
                [f32; 5],
                [f64; 5],
                [String; 5],
                [Option<String>; 5],
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                ArrayBasic,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x49ad7a74e28ba114,
            >(_buf?)?;
            Ok((
                _response.array_uint8,
                _response.array_uint16,
                _response.array_uint32,
                _response.array_uint64,
                _response.array_int8,
                _response.array_int16,
                _response.array_int32,
                _response.array_int64,
                _response.array_float32,
                _response.array_float64,
                _response.array_string,
                _response.array_opt_string,
            ))
        }
        self.client.send_query_and_decode::<ArrayBasic, (
            [u8; 5],
            [u16; 5],
            [u32; 5],
            [u64; 5],
            [i8; 5],
            [i16; 5],
            [i32; 5],
            [i64; 5],
            [f32; 5],
            [f64; 5],
            [String; 5],
            [Option<String>; 5],
        )>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorArrayBasicResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorArrayBasicResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_array_basic(&self) -> Self::ErrorArrayBasicResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayBasic, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0xf0dbde9626fff79,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.array_uint8,
                    x.array_uint16,
                    x.array_uint32,
                    x.array_uint64,
                    x.array_int8,
                    x.array_int16,
                    x.array_int32,
                    x.array_int64,
                    x.array_float32,
                    x.array_float64,
                    x.array_string,
                    x.array_opt_string,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorArrayBasicResult>(
                (),
                0xf0dbde9626fff79,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }

    fn r#one_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayCompound>(
            (
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
            ),
            0x464948bae1bda09d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayArrayCompoundResponseFut = fidl::client::QueryResponseFut<
        (
            [Bits; 5],
            [Enum; 5],
            [Struct; 5],
            [Table; 5],
            [Union; 5],
            [Option<Box<Struct>>; 5],
            [Option<Box<Union>>; 5],
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Self::TwoWayArrayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                [Bits; 5],
                [Enum; 5],
                [Struct; 5],
                [Table; 5],
                [Union; 5],
                [Option<Box<Struct>>; 5],
                [Option<Box<Union>>; 5],
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                ArrayCompound,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0xbcae616f8e1ea7b,
            >(_buf?)?;
            Ok((
                _response.array_bits,
                _response.array_enum,
                _response.array_struct,
                _response.array_table,
                _response.array_union,
                _response.array_opt_struct,
                _response.array_opt_union,
            ))
        }
        self.client.send_query_and_decode::<ArrayCompound, (
            [Bits; 5],
            [Enum; 5],
            [Struct; 5],
            [Table; 5],
            [Union; 5],
            [Option<Box<Struct>>; 5],
            [Option<Box<Union>>; 5],
        )>(
            (
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
            ),
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorArrayCompoundResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorArrayCompoundResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_array_compound(&self) -> Self::ErrorArrayCompoundResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayCompound, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x52257f80e29c1a04,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.array_bits,
                    x.array_enum,
                    x.array_struct,
                    x.array_table,
                    x.array_union,
                    x.array_opt_struct,
                    x.array_opt_union,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorArrayCompoundResult,
        >(
            (),
            0x52257f80e29c1a04,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x4f907dde77464657,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayVectorBasicResponseFut = fidl::client::QueryResponseFut<
        (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Self::TwoWayVectorBasicResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<u8>,
                Vec<u16>,
                Vec<u32>,
                Vec<u64>,
                Vec<i8>,
                Vec<i16>,
                Vec<i32>,
                Vec<i64>,
                Vec<f32>,
                Vec<f64>,
                Vec<String>,
                Vec<Option<String>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                VectorBasic,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x7860cb3ed8362e74,
            >(_buf?)?;
            Ok((
                _response.vector_uint8,
                _response.vector_uint16,
                _response.vector_uint32,
                _response.vector_uint64,
                _response.vector_int8,
                _response.vector_int16,
                _response.vector_int32,
                _response.vector_int64,
                _response.vector_float32,
                _response.vector_float64,
                _response.vector_string,
                _response.vector_opt_string,
            ))
        }
        self.client.send_query_and_decode::<VectorBasic, (
            Vec<u8>,
            Vec<u16>,
            Vec<u32>,
            Vec<u64>,
            Vec<i8>,
            Vec<i16>,
            Vec<i32>,
            Vec<i64>,
            Vec<f32>,
            Vec<f64>,
            Vec<String>,
            Vec<Option<String>>,
        )>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorVectorBasicResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorVectorBasicResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_vector_basic(&self) -> Self::ErrorVectorBasicResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorBasicResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorBasic, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0xc27f841d6313f72,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.vector_uint8,
                    x.vector_uint16,
                    x.vector_uint32,
                    x.vector_uint64,
                    x.vector_int8,
                    x.vector_int16,
                    x.vector_int32,
                    x.vector_int64,
                    x.vector_float32,
                    x.vector_float64,
                    x.vector_string,
                    x.vector_opt_string,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorVectorBasicResult>(
                (),
                0xc27f841d6313f72,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }

    fn r#one_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x19baae42829dbe90,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayVectorCompoundResponseFut = fidl::client::QueryResponseFut<
        (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Self::TwoWayVectorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Vec<Bits>,
                Vec<Enum>,
                Vec<Struct>,
                Vec<Table>,
                Vec<Union>,
                Vec<Option<Box<Struct>>>,
                Vec<Option<Box<Union>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                VectorCompound,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x371140db701b23b4,
            >(_buf?)?;
            Ok((
                _response.vector_bits,
                _response.vector_enum,
                _response.vector_struct,
                _response.vector_table,
                _response.vector_union,
                _response.vector_opt_struct,
                _response.vector_opt_union,
            ))
        }
        self.client.send_query_and_decode::<VectorCompound, (
            Vec<Bits>,
            Vec<Enum>,
            Vec<Struct>,
            Vec<Table>,
            Vec<Union>,
            Vec<Option<Box<Struct>>>,
            Vec<Option<Box<Union>>>,
        )>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorVectorCompoundResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorVectorCompoundResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_vector_compound(&self) -> Self::ErrorVectorCompoundResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorCompoundResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorCompound, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x760e278628f7a985,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.vector_bits,
                    x.vector_enum,
                    x.vector_struct,
                    x.vector_table,
                    x.vector_union,
                    x.vector_opt_struct,
                    x.vector_opt_union,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorVectorCompoundResult,
        >(
            (),
            0x760e278628f7a985,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0x153c6b333c21c52f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayVectorOptionalResponseFut = fidl::client::QueryResponseFut<
        (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Self::TwoWayVectorOptionalResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                Option<Vec<u8>>,
                Option<Vec<String>>,
                Option<Vec<Struct>>,
                Option<Vec<Option<Box<Struct>>>>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                VectorOptional,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0xe4b620aaafd73f3,
            >(_buf?)?;
            Ok((
                _response.opt_vector_uint8,
                _response.opt_vector_string,
                _response.opt_vector_struct,
                _response.opt_vector_opt_struct,
            ))
        }
        self.client.send_query_and_decode::<VectorOptional, (
            Option<Vec<u8>>,
            Option<Vec<String>>,
            Option<Vec<Struct>>,
            Option<Vec<Option<Box<Struct>>>>,
        )>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorVectorOptionalResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorVectorOptionalResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_vector_optional(&self) -> Self::ErrorVectorOptionalResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorVectorOptionalResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<VectorOptional, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x58e75cf86e2d715e,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.opt_vector_uint8,
                    x.opt_vector_string,
                    x.opt_vector_struct,
                    x.opt_vector_opt_struct,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorVectorOptionalResult,
        >(
            (),
            0x58e75cf86e2d715e,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_array_vector_nested(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.client.send::<ArrayVectorNested>(
            (array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8),
            0x520dc9cb9b9b5ed7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayArrayVectorNestedResponseFut = fidl::client::QueryResponseFut<
        ([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_array_vector_nested(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Self::TwoWayArrayVectorNestedResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>), fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                ArrayVectorNested,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x4a438ce0948817dc,
            >(_buf?)?;
            Ok((
                _response.array_array_uint8,
                _response.array_vector_uint8,
                _response.vector_array_uint8,
                _response.vector_vector_uint8,
            ))
        }
        self.client.send_query_and_decode::<
            ArrayVectorNested,
            ([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>),
        >(
            (array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8,),
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorArrayVectorNestedResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorArrayVectorNestedResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_array_vector_nested(&self) -> Self::ErrorArrayVectorNestedResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorArrayVectorNestedResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<ArrayVectorNested, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x7e168d89e1dac8a7,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.array_array_uint8,
                    x.array_vector_uint8,
                    x.vector_array_uint8,
                    x.vector_vector_uint8,
                )
            }))
        }
        self.client.send_query_and_decode::<
            fidl::encoding::EmptyPayload,
            ProtocolErrorArrayVectorNestedResult,
        >(
            (),
            0x7e168d89e1dac8a7,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    fn r#one_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.client.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x5af4795a9ed3a022,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    type TwoWayResourceResponseFut = fidl::client::QueryResponseFut<
        (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        ),
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#two_way_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Self::TwoWayResourceResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<Box<ResourceStruct>>,
                Option<Box<ResourceUnion>>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            fidl::Error,
        > {
            let _response = fidl::client::decode_transaction_body::<
                Resource,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x1904824a11c6ad5b,
            >(_buf?)?;
            Ok((
                _response.handle,
                _response.vmo,
                _response.client_end,
                _response.server_end,
                _response.struct_,
                _response.table,
                _response.union,
                _response.opt_handle,
                _response.opt_vmo,
                _response.opt_client_end,
                _response.opt_server_end,
                _response.opt_struct,
                _response.opt_union,
                _response.array_handle,
                _response.array_vmo,
                _response.array_client_end,
                _response.array_server_end,
                _response.array_struct,
                _response.array_table,
                _response.array_union,
                _response.vector_handle,
                _response.vector_vmo,
                _response.vector_client_end,
                _response.vector_server_end,
                _response.vector_struct,
                _response.vector_table,
                _response.vector_union,
            ))
        }
        self.client.send_query_and_decode::<Resource, (
            fidl::Handle,
            fidl::Vmo,
            fidl::endpoints::ClientEnd<ProtocolMarker>,
            fidl::endpoints::ServerEnd<ProtocolMarker>,
            ResourceStruct,
            ResourceTable,
            ResourceUnion,
            Option<fidl::Handle>,
            Option<fidl::Vmo>,
            Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Option<Box<ResourceStruct>>,
            Option<Box<ResourceUnion>>,
            [fidl::Handle; 5],
            [fidl::Vmo; 5],
            [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
            [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
            [ResourceStruct; 5],
            [ResourceTable; 5],
            [ResourceUnion; 5],
            Vec<fidl::Handle>,
            Vec<fidl::Vmo>,
            Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
            Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
            Vec<ResourceStruct>,
            Vec<ResourceTable>,
            Vec<ResourceUnion>,
        )>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0x1904824a11c6ad5b,
            fidl::encoding::DynamicFlags::empty(),
            _decode,
        )
    }

    type ErrorResourceResponseFut = fidl::client::QueryResponseFut<
        ProtocolErrorResourceResult,
        fidl::encoding::DefaultFuchsiaResourceDialect,
    >;
    fn r#error_resource(&self) -> Self::ErrorResourceResponseFut {
        fn _decode(
            mut _buf: Result<<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc, fidl::Error>,
        ) -> Result<ProtocolErrorResourceResult, fidl::Error> {
            let _response = fidl::client::decode_transaction_body::<
                fidl::encoding::ResultType<Resource, u32>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                0x5b28634d603175b6,
            >(_buf?)?;
            Ok(_response.map(|x| {
                (
                    x.handle,
                    x.vmo,
                    x.client_end,
                    x.server_end,
                    x.struct_,
                    x.table,
                    x.union,
                    x.opt_handle,
                    x.opt_vmo,
                    x.opt_client_end,
                    x.opt_server_end,
                    x.opt_struct,
                    x.opt_union,
                    x.array_handle,
                    x.array_vmo,
                    x.array_client_end,
                    x.array_server_end,
                    x.array_struct,
                    x.array_table,
                    x.array_union,
                    x.vector_handle,
                    x.vector_vmo,
                    x.vector_client_end,
                    x.vector_server_end,
                    x.vector_struct,
                    x.vector_table,
                    x.vector_union,
                )
            }))
        }
        self.client
            .send_query_and_decode::<fidl::encoding::EmptyPayload, ProtocolErrorResourceResult>(
                (),
                0x5b28634d603175b6,
                fidl::encoding::DynamicFlags::empty(),
                _decode,
            )
    }
}

pub struct ProtocolEventStream {
    event_receiver: fidl::client::EventReceiver<fidl::encoding::DefaultFuchsiaResourceDialect>,
}

impl std::marker::Unpin for ProtocolEventStream {}

impl futures::stream::FusedStream for ProtocolEventStream {
    fn is_terminated(&self) -> bool {
        self.event_receiver.is_terminated()
    }
}

impl futures::Stream for ProtocolEventStream {
    type Item = Result<ProtocolEvent, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        match futures::ready!(futures::stream::StreamExt::poll_next_unpin(
            &mut self.event_receiver,
            cx
        )?) {
            Some(buf) => std::task::Poll::Ready(Some(ProtocolEvent::decode(buf))),
            None => std::task::Poll::Ready(None),
        }
    }
}

#[derive(Debug)]
pub enum ProtocolEvent {
    EventBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
    },
    EventCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
    },
    EventArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
    },
    EventArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        array_opt_struct: [Option<Box<Struct>>; 5],
        array_opt_union: [Option<Box<Union>>; 5],
    },
    EventVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
    },
    EventVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
    },
    EventVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
    },
    EventArrayVectorNested {
        array_array_uint8: [[u8; 5]; 5],
        array_vector_uint8: [Vec<u8>; 5],
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
    },
    EventResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
    },
}

impl ProtocolEvent {
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_basic(
        self,
    ) -> Option<(u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, String, Option<String>)> {
        if let ProtocolEvent::EventBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_compound(
        self,
    ) -> Option<(Bits, Enum, Struct, Table, Union, Option<Box<Struct>>, Option<Box<Union>>)> {
        if let ProtocolEvent::EventCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
    )> {
        if let ProtocolEvent::EventArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_compound(
        self,
    ) -> Option<(
        [Bits; 5],
        [Enum; 5],
        [Struct; 5],
        [Table; 5],
        [Union; 5],
        [Option<Box<Struct>>; 5],
        [Option<Box<Union>>; 5],
    )> {
        if let ProtocolEvent::EventArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            array_opt_struct,
            array_opt_union,
        } = self
        {
            Some((
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
    )> {
        if let ProtocolEvent::EventVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
    )> {
        if let ProtocolEvent::EventVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
    )> {
        if let ProtocolEvent::EventVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        } = self
        {
            Some((opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_array_vector_nested(
        self,
    ) -> Option<([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>)> {
        if let ProtocolEvent::EventArrayVectorNested {
            array_array_uint8,
            array_vector_uint8,
            vector_array_uint8,
            vector_vector_uint8,
        } = self
        {
            Some((array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8))
        } else {
            None
        }
    }
    #[allow(irrefutable_let_patterns)]
    pub fn into_event_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
    )> {
        if let ProtocolEvent::EventResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
            ))
        } else {
            None
        }
    }

    /// Decodes a message buffer as a [`ProtocolEvent`].
    fn decode(
        mut buf: <fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::MessageBufEtc,
    ) -> Result<ProtocolEvent, fidl::Error> {
        let (bytes, _handles) = buf.split_mut();
        let (tx_header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;
        debug_assert_eq!(tx_header.tx_id, 0);
        match tx_header.ordinal {
            0x51c5b06295c10c40 => {
                let mut out =
                    fidl::new_empty!(Basic, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Basic>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventBasic {
                    uint8: out.uint8,
                    uint16: out.uint16,
                    uint32: out.uint32,
                    uint64: out.uint64,
                    int8: out.int8,
                    int16: out.int16,
                    int32: out.int32,
                    int64: out.int64,
                    float32: out.float32,
                    float64: out.float64,
                    string: out.string,
                    opt_string: out.opt_string,
                }))
            }
            0x617c5410858734d5 => {
                let mut out =
                    fidl::new_empty!(Compound, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Compound>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventCompound {
                    bits: out.bits,
                    enum_: out.enum_,
                    struct_: out.struct_,
                    table: out.table,
                    union: out.union,
                    opt_struct: out.opt_struct,
                    opt_union: out.opt_union,
                }))
            }
            0x51b76208b148f02e => {
                let mut out =
                    fidl::new_empty!(ArrayBasic, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayBasic>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventArrayBasic {
                    array_uint8: out.array_uint8,
                    array_uint16: out.array_uint16,
                    array_uint32: out.array_uint32,
                    array_uint64: out.array_uint64,
                    array_int8: out.array_int8,
                    array_int16: out.array_int16,
                    array_int32: out.array_int32,
                    array_int64: out.array_int64,
                    array_float32: out.array_float32,
                    array_float64: out.array_float64,
                    array_string: out.array_string,
                    array_opt_string: out.array_opt_string,
                }))
            }
            0x1e63a00079aa7415 => {
                let mut out =
                    fidl::new_empty!(ArrayCompound, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayCompound>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventArrayCompound {
                    array_bits: out.array_bits,
                    array_enum: out.array_enum,
                    array_struct: out.array_struct,
                    array_table: out.array_table,
                    array_union: out.array_union,
                    array_opt_struct: out.array_opt_struct,
                    array_opt_union: out.array_opt_union,
                }))
            }
            0x3f9d405e7191eff6 => {
                let mut out =
                    fidl::new_empty!(VectorBasic, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorBasic>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventVectorBasic {
                    vector_uint8: out.vector_uint8,
                    vector_uint16: out.vector_uint16,
                    vector_uint32: out.vector_uint32,
                    vector_uint64: out.vector_uint64,
                    vector_int8: out.vector_int8,
                    vector_int16: out.vector_int16,
                    vector_int32: out.vector_int32,
                    vector_int64: out.vector_int64,
                    vector_float32: out.vector_float32,
                    vector_float64: out.vector_float64,
                    vector_string: out.vector_string,
                    vector_opt_string: out.vector_opt_string,
                }))
            }
            0x53a1fc56e8b3cff3 => {
                let mut out =
                    fidl::new_empty!(VectorCompound, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorCompound>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventVectorCompound {
                    vector_bits: out.vector_bits,
                    vector_enum: out.vector_enum,
                    vector_struct: out.vector_struct,
                    vector_table: out.vector_table,
                    vector_union: out.vector_union,
                    vector_opt_struct: out.vector_opt_struct,
                    vector_opt_union: out.vector_opt_union,
                }))
            }
            0x17617b54dfa8d85d => {
                let mut out =
                    fidl::new_empty!(VectorOptional, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorOptional>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventVectorOptional {
                    opt_vector_uint8: out.opt_vector_uint8,
                    opt_vector_string: out.opt_vector_string,
                    opt_vector_struct: out.opt_vector_struct,
                    opt_vector_opt_struct: out.opt_vector_opt_struct,
                }))
            }
            0x110b72cfebc4037e => {
                let mut out = fidl::new_empty!(
                    ArrayVectorNested,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                );
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayVectorNested>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventArrayVectorNested {
                    array_array_uint8: out.array_array_uint8,
                    array_vector_uint8: out.array_vector_uint8,
                    vector_array_uint8: out.vector_array_uint8,
                    vector_vector_uint8: out.vector_vector_uint8,
                }))
            }
            0x4fbde2864601698b => {
                let mut out =
                    fidl::new_empty!(Resource, fidl::encoding::DefaultFuchsiaResourceDialect);
                fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Resource>(&tx_header, _body_bytes, _handles, &mut out)?;
                Ok((ProtocolEvent::EventResource {
                    handle: out.handle,
                    vmo: out.vmo,
                    client_end: out.client_end,
                    server_end: out.server_end,
                    struct_: out.struct_,
                    table: out.table,
                    union: out.union,
                    opt_handle: out.opt_handle,
                    opt_vmo: out.opt_vmo,
                    opt_client_end: out.opt_client_end,
                    opt_server_end: out.opt_server_end,
                    opt_struct: out.opt_struct,
                    opt_union: out.opt_union,
                    array_handle: out.array_handle,
                    array_vmo: out.array_vmo,
                    array_client_end: out.array_client_end,
                    array_server_end: out.array_server_end,
                    array_struct: out.array_struct,
                    array_table: out.array_table,
                    array_union: out.array_union,
                    vector_handle: out.vector_handle,
                    vector_vmo: out.vector_vmo,
                    vector_client_end: out.vector_client_end,
                    vector_server_end: out.vector_server_end,
                    vector_struct: out.vector_struct,
                    vector_table: out.vector_table,
                    vector_union: out.vector_union,
                }))
            }
            _ => Err(fidl::Error::UnknownOrdinal {
                ordinal: tx_header.ordinal,
                protocol_name: <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
            }),
        }
    }
}

/// A Stream of incoming requests for test.typesinprotocols/Protocol.
pub struct ProtocolRequestStream {
    inner: std::sync::Arc<fidl::ServeInner<fidl::encoding::DefaultFuchsiaResourceDialect>>,
    is_terminated: bool,
}

impl std::marker::Unpin for ProtocolRequestStream {}

impl futures::stream::FusedStream for ProtocolRequestStream {
    fn is_terminated(&self) -> bool {
        self.is_terminated
    }
}

impl fidl::endpoints::RequestStream for ProtocolRequestStream {
    type Protocol = ProtocolMarker;
    type ControlHandle = ProtocolControlHandle;

    fn from_channel(channel: ::fidl::AsyncChannel) -> Self {
        Self { inner: std::sync::Arc::new(fidl::ServeInner::new(channel)), is_terminated: false }
    }

    fn control_handle(&self) -> Self::ControlHandle {
        ProtocolControlHandle { inner: self.inner.clone() }
    }

    fn into_inner(
        self,
    ) -> (::std::sync::Arc<fidl::ServeInner<fidl::encoding::DefaultFuchsiaResourceDialect>>, bool)
    {
        (self.inner, self.is_terminated)
    }

    fn from_inner(
        inner: std::sync::Arc<fidl::ServeInner<fidl::encoding::DefaultFuchsiaResourceDialect>>,
        is_terminated: bool,
    ) -> Self {
        Self { inner, is_terminated }
    }
}

impl futures::Stream for ProtocolRequestStream {
    type Item = Result<ProtocolRequest, fidl::Error>;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        let this = &mut *self;
        if this.inner.check_shutdown(cx) {
            this.is_terminated = true;
            return std::task::Poll::Ready(None);
        }
        if this.is_terminated {
            panic!("polled ProtocolRequestStream after completion");
        }
        fidl::encoding::with_tls_decode_buf::<_, fidl::encoding::DefaultFuchsiaResourceDialect>(
            |bytes, handles| {
                match this.inner.channel().read_etc(cx, bytes, handles) {
                    std::task::Poll::Ready(Ok(())) => {}
                    std::task::Poll::Pending => return std::task::Poll::Pending,
                    std::task::Poll::Ready(Err(zx_status::Status::PEER_CLOSED)) => {
                        this.is_terminated = true;
                        return std::task::Poll::Ready(None);
                    }
                    std::task::Poll::Ready(Err(e)) => {
                        return std::task::Poll::Ready(Some(Err(fidl::Error::ServerRequestRead(
                            e.into(),
                        ))))
                    }
                }

                // A message has been received from the channel
                let (header, _body_bytes) = fidl::encoding::decode_transaction_header(bytes)?;

                std::task::Poll::Ready(Some(match header.ordinal {
                    0x7c311f0d9e662df9 => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req =
                            fidl::new_empty!(Basic, fidl::encoding::DefaultFuchsiaResourceDialect);
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Basic>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayBasic {
                            uint8: req.uint8,
                            uint16: req.uint16,
                            uint32: req.uint32,
                            uint64: req.uint64,
                            int8: req.int8,
                            int16: req.int16,
                            int32: req.int32,
                            int64: req.int64,
                            float32: req.float32,
                            float64: req.float64,
                            string: req.string,
                            opt_string: req.opt_string,

                            control_handle,
                        })
                    }
                    0x205b92db5139c88f => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req =
                            fidl::new_empty!(Basic, fidl::encoding::DefaultFuchsiaResourceDialect);
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Basic>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayBasic {
                            uint8: req.uint8,
                            uint16: req.uint16,
                            uint32: req.uint32,
                            uint64: req.uint64,
                            int8: req.int8,
                            int16: req.int16,
                            int32: req.int32,
                            int64: req.int64,
                            float32: req.float32,
                            float64: req.float64,
                            string: req.string,
                            opt_string: req.opt_string,

                            responder: ProtocolTwoWayBasicResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x459eaa5d11b9ff93 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorBasic {
                            responder: ProtocolErrorBasicResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x2bc2bc3a9237c6cc => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            Compound,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Compound>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayCompound {
                            bits: req.bits,
                            enum_: req.enum_,
                            struct_: req.struct_,
                            table: req.table,
                            union: req.union,
                            opt_struct: req.opt_struct,
                            opt_union: req.opt_union,

                            control_handle,
                        })
                    }
                    0x79f279c7201da131 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            Compound,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Compound>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayCompound {
                            bits: req.bits,
                            enum_: req.enum_,
                            struct_: req.struct_,
                            table: req.table,
                            union: req.union,
                            opt_struct: req.opt_struct,
                            opt_union: req.opt_union,

                            responder: ProtocolTwoWayCompoundResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x29817d89a19ec77d => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorCompound {
                            responder: ProtocolErrorCompoundResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x62e2ebcadf35ca19 => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            ArrayBasic,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayBasic>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayArrayBasic {
                            array_uint8: req.array_uint8,
                            array_uint16: req.array_uint16,
                            array_uint32: req.array_uint32,
                            array_uint64: req.array_uint64,
                            array_int8: req.array_int8,
                            array_int16: req.array_int16,
                            array_int32: req.array_int32,
                            array_int64: req.array_int64,
                            array_float32: req.array_float32,
                            array_float64: req.array_float64,
                            array_string: req.array_string,
                            array_opt_string: req.array_opt_string,

                            control_handle,
                        })
                    }
                    0x49ad7a74e28ba114 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            ArrayBasic,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayBasic>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayArrayBasic {
                            array_uint8: req.array_uint8,
                            array_uint16: req.array_uint16,
                            array_uint32: req.array_uint32,
                            array_uint64: req.array_uint64,
                            array_int8: req.array_int8,
                            array_int16: req.array_int16,
                            array_int32: req.array_int32,
                            array_int64: req.array_int64,
                            array_float32: req.array_float32,
                            array_float64: req.array_float64,
                            array_string: req.array_string,
                            array_opt_string: req.array_opt_string,

                            responder: ProtocolTwoWayArrayBasicResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0xf0dbde9626fff79 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorArrayBasic {
                            responder: ProtocolErrorArrayBasicResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x464948bae1bda09d => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            ArrayCompound,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayCompound>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayArrayCompound {
                            array_bits: req.array_bits,
                            array_enum: req.array_enum,
                            array_struct: req.array_struct,
                            array_table: req.array_table,
                            array_union: req.array_union,
                            array_opt_struct: req.array_opt_struct,
                            array_opt_union: req.array_opt_union,

                            control_handle,
                        })
                    }
                    0xbcae616f8e1ea7b => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            ArrayCompound,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayCompound>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayArrayCompound {
                            array_bits: req.array_bits,
                            array_enum: req.array_enum,
                            array_struct: req.array_struct,
                            array_table: req.array_table,
                            array_union: req.array_union,
                            array_opt_struct: req.array_opt_struct,
                            array_opt_union: req.array_opt_union,

                            responder: ProtocolTwoWayArrayCompoundResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x52257f80e29c1a04 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorArrayCompound {
                            responder: ProtocolErrorArrayCompoundResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x4f907dde77464657 => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            VectorBasic,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorBasic>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayVectorBasic {
                            vector_uint8: req.vector_uint8,
                            vector_uint16: req.vector_uint16,
                            vector_uint32: req.vector_uint32,
                            vector_uint64: req.vector_uint64,
                            vector_int8: req.vector_int8,
                            vector_int16: req.vector_int16,
                            vector_int32: req.vector_int32,
                            vector_int64: req.vector_int64,
                            vector_float32: req.vector_float32,
                            vector_float64: req.vector_float64,
                            vector_string: req.vector_string,
                            vector_opt_string: req.vector_opt_string,

                            control_handle,
                        })
                    }
                    0x7860cb3ed8362e74 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            VectorBasic,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorBasic>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayVectorBasic {
                            vector_uint8: req.vector_uint8,
                            vector_uint16: req.vector_uint16,
                            vector_uint32: req.vector_uint32,
                            vector_uint64: req.vector_uint64,
                            vector_int8: req.vector_int8,
                            vector_int16: req.vector_int16,
                            vector_int32: req.vector_int32,
                            vector_int64: req.vector_int64,
                            vector_float32: req.vector_float32,
                            vector_float64: req.vector_float64,
                            vector_string: req.vector_string,
                            vector_opt_string: req.vector_opt_string,

                            responder: ProtocolTwoWayVectorBasicResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0xc27f841d6313f72 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorVectorBasic {
                            responder: ProtocolErrorVectorBasicResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x19baae42829dbe90 => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            VectorCompound,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorCompound>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayVectorCompound {
                            vector_bits: req.vector_bits,
                            vector_enum: req.vector_enum,
                            vector_struct: req.vector_struct,
                            vector_table: req.vector_table,
                            vector_union: req.vector_union,
                            vector_opt_struct: req.vector_opt_struct,
                            vector_opt_union: req.vector_opt_union,

                            control_handle,
                        })
                    }
                    0x371140db701b23b4 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            VectorCompound,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorCompound>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayVectorCompound {
                            vector_bits: req.vector_bits,
                            vector_enum: req.vector_enum,
                            vector_struct: req.vector_struct,
                            vector_table: req.vector_table,
                            vector_union: req.vector_union,
                            vector_opt_struct: req.vector_opt_struct,
                            vector_opt_union: req.vector_opt_union,

                            responder: ProtocolTwoWayVectorCompoundResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x760e278628f7a985 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorVectorCompound {
                            responder: ProtocolErrorVectorCompoundResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x153c6b333c21c52f => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            VectorOptional,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorOptional>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayVectorOptional {
                            opt_vector_uint8: req.opt_vector_uint8,
                            opt_vector_string: req.opt_vector_string,
                            opt_vector_struct: req.opt_vector_struct,
                            opt_vector_opt_struct: req.opt_vector_opt_struct,

                            control_handle,
                        })
                    }
                    0xe4b620aaafd73f3 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            VectorOptional,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<VectorOptional>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayVectorOptional {
                            opt_vector_uint8: req.opt_vector_uint8,
                            opt_vector_string: req.opt_vector_string,
                            opt_vector_struct: req.opt_vector_struct,
                            opt_vector_opt_struct: req.opt_vector_opt_struct,

                            responder: ProtocolTwoWayVectorOptionalResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x58e75cf86e2d715e => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorVectorOptional {
                            responder: ProtocolErrorVectorOptionalResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x520dc9cb9b9b5ed7 => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            ArrayVectorNested,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayVectorNested>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayArrayVectorNested {
                            array_array_uint8: req.array_array_uint8,
                            array_vector_uint8: req.array_vector_uint8,
                            vector_array_uint8: req.vector_array_uint8,
                            vector_vector_uint8: req.vector_vector_uint8,

                            control_handle,
                        })
                    }
                    0x4a438ce0948817dc => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            ArrayVectorNested,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<ArrayVectorNested>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayArrayVectorNested {
                            array_array_uint8: req.array_array_uint8,
                            array_vector_uint8: req.array_vector_uint8,
                            vector_array_uint8: req.vector_array_uint8,
                            vector_vector_uint8: req.vector_vector_uint8,

                            responder: ProtocolTwoWayArrayVectorNestedResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x7e168d89e1dac8a7 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorArrayVectorNested {
                            responder: ProtocolErrorArrayVectorNestedResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x5af4795a9ed3a022 => {
                        header.validate_request_tx_id(fidl::MethodType::OneWay)?;
                        let mut req = fidl::new_empty!(
                            Resource,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Resource>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::OneWayResource {
                            handle: req.handle,
                            vmo: req.vmo,
                            client_end: req.client_end,
                            server_end: req.server_end,
                            struct_: req.struct_,
                            table: req.table,
                            union: req.union,
                            opt_handle: req.opt_handle,
                            opt_vmo: req.opt_vmo,
                            opt_client_end: req.opt_client_end,
                            opt_server_end: req.opt_server_end,
                            opt_struct: req.opt_struct,
                            opt_union: req.opt_union,
                            array_handle: req.array_handle,
                            array_vmo: req.array_vmo,
                            array_client_end: req.array_client_end,
                            array_server_end: req.array_server_end,
                            array_struct: req.array_struct,
                            array_table: req.array_table,
                            array_union: req.array_union,
                            vector_handle: req.vector_handle,
                            vector_vmo: req.vector_vmo,
                            vector_client_end: req.vector_client_end,
                            vector_server_end: req.vector_server_end,
                            vector_struct: req.vector_struct,
                            vector_table: req.vector_table,
                            vector_union: req.vector_union,

                            control_handle,
                        })
                    }
                    0x1904824a11c6ad5b => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            Resource,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<Resource>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::TwoWayResource {
                            handle: req.handle,
                            vmo: req.vmo,
                            client_end: req.client_end,
                            server_end: req.server_end,
                            struct_: req.struct_,
                            table: req.table,
                            union: req.union,
                            opt_handle: req.opt_handle,
                            opt_vmo: req.opt_vmo,
                            opt_client_end: req.opt_client_end,
                            opt_server_end: req.opt_server_end,
                            opt_struct: req.opt_struct,
                            opt_union: req.opt_union,
                            array_handle: req.array_handle,
                            array_vmo: req.array_vmo,
                            array_client_end: req.array_client_end,
                            array_server_end: req.array_server_end,
                            array_struct: req.array_struct,
                            array_table: req.array_table,
                            array_union: req.array_union,
                            vector_handle: req.vector_handle,
                            vector_vmo: req.vector_vmo,
                            vector_client_end: req.vector_client_end,
                            vector_server_end: req.vector_server_end,
                            vector_struct: req.vector_struct,
                            vector_table: req.vector_table,
                            vector_union: req.vector_union,

                            responder: ProtocolTwoWayResourceResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    0x5b28634d603175b6 => {
                        header.validate_request_tx_id(fidl::MethodType::TwoWay)?;
                        let mut req = fidl::new_empty!(
                            fidl::encoding::EmptyPayload,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        );
                        fidl::encoding::Decoder::<fidl::encoding::DefaultFuchsiaResourceDialect>::decode_into::<fidl::encoding::EmptyPayload>(&header, _body_bytes, handles, &mut req)?;
                        let control_handle = ProtocolControlHandle { inner: this.inner.clone() };
                        Ok(ProtocolRequest::ErrorResource {
                            responder: ProtocolErrorResourceResponder {
                                control_handle: std::mem::ManuallyDrop::new(control_handle),
                                tx_id: header.tx_id,
                            },
                        })
                    }
                    _ => Err(fidl::Error::UnknownOrdinal {
                        ordinal: header.ordinal,
                        protocol_name:
                            <ProtocolMarker as fidl::endpoints::ProtocolMarker>::DEBUG_NAME,
                    }),
                }))
            },
        )
    }
}

#[derive(Debug)]
pub enum ProtocolRequest {
    OneWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayBasic {
        uint8: u8,
        uint16: u16,
        uint32: u32,
        uint64: u64,
        int8: i8,
        int16: i16,
        int32: i32,
        int64: i64,
        float32: f32,
        float64: f64,
        string: String,
        opt_string: Option<String>,
        responder: ProtocolTwoWayBasicResponder,
    },
    ErrorBasic {
        responder: ProtocolErrorBasicResponder,
    },
    OneWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayCompound {
        bits: Bits,
        enum_: Enum,
        struct_: Struct,
        table: Table,
        union: Union,
        opt_struct: Option<Box<Struct>>,
        opt_union: Option<Box<Union>>,
        responder: ProtocolTwoWayCompoundResponder,
    },
    ErrorCompound {
        responder: ProtocolErrorCompoundResponder,
    },
    OneWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayBasic {
        array_uint8: [u8; 5],
        array_uint16: [u16; 5],
        array_uint32: [u32; 5],
        array_uint64: [u64; 5],
        array_int8: [i8; 5],
        array_int16: [i16; 5],
        array_int32: [i32; 5],
        array_int64: [i64; 5],
        array_float32: [f32; 5],
        array_float64: [f64; 5],
        array_string: [String; 5],
        array_opt_string: [Option<String>; 5],
        responder: ProtocolTwoWayArrayBasicResponder,
    },
    ErrorArrayBasic {
        responder: ProtocolErrorArrayBasicResponder,
    },
    OneWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        array_opt_struct: [Option<Box<Struct>>; 5],
        array_opt_union: [Option<Box<Union>>; 5],
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayCompound {
        array_bits: [Bits; 5],
        array_enum: [Enum; 5],
        array_struct: [Struct; 5],
        array_table: [Table; 5],
        array_union: [Union; 5],
        array_opt_struct: [Option<Box<Struct>>; 5],
        array_opt_union: [Option<Box<Union>>; 5],
        responder: ProtocolTwoWayArrayCompoundResponder,
    },
    ErrorArrayCompound {
        responder: ProtocolErrorArrayCompoundResponder,
    },
    OneWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorBasic {
        vector_uint8: Vec<u8>,
        vector_uint16: Vec<u16>,
        vector_uint32: Vec<u32>,
        vector_uint64: Vec<u64>,
        vector_int8: Vec<i8>,
        vector_int16: Vec<i16>,
        vector_int32: Vec<i32>,
        vector_int64: Vec<i64>,
        vector_float32: Vec<f32>,
        vector_float64: Vec<f64>,
        vector_string: Vec<String>,
        vector_opt_string: Vec<Option<String>>,
        responder: ProtocolTwoWayVectorBasicResponder,
    },
    ErrorVectorBasic {
        responder: ProtocolErrorVectorBasicResponder,
    },
    OneWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorCompound {
        vector_bits: Vec<Bits>,
        vector_enum: Vec<Enum>,
        vector_struct: Vec<Struct>,
        vector_table: Vec<Table>,
        vector_union: Vec<Union>,
        vector_opt_struct: Vec<Option<Box<Struct>>>,
        vector_opt_union: Vec<Option<Box<Union>>>,
        responder: ProtocolTwoWayVectorCompoundResponder,
    },
    ErrorVectorCompound {
        responder: ProtocolErrorVectorCompoundResponder,
    },
    OneWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayVectorOptional {
        opt_vector_uint8: Option<Vec<u8>>,
        opt_vector_string: Option<Vec<String>>,
        opt_vector_struct: Option<Vec<Struct>>,
        opt_vector_opt_struct: Option<Vec<Option<Box<Struct>>>>,
        responder: ProtocolTwoWayVectorOptionalResponder,
    },
    ErrorVectorOptional {
        responder: ProtocolErrorVectorOptionalResponder,
    },
    OneWayArrayVectorNested {
        array_array_uint8: [[u8; 5]; 5],
        array_vector_uint8: [Vec<u8>; 5],
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayArrayVectorNested {
        array_array_uint8: [[u8; 5]; 5],
        array_vector_uint8: [Vec<u8>; 5],
        vector_array_uint8: Vec<[u8; 5]>,
        vector_vector_uint8: Vec<Vec<u8>>,
        responder: ProtocolTwoWayArrayVectorNestedResponder,
    },
    ErrorArrayVectorNested {
        responder: ProtocolErrorArrayVectorNestedResponder,
    },
    OneWayResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
        control_handle: ProtocolControlHandle,
    },
    TwoWayResource {
        handle: fidl::Handle,
        vmo: fidl::Vmo,
        client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        struct_: ResourceStruct,
        table: ResourceTable,
        union: ResourceUnion,
        opt_handle: Option<fidl::Handle>,
        opt_vmo: Option<fidl::Vmo>,
        opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        opt_struct: Option<Box<ResourceStruct>>,
        opt_union: Option<Box<ResourceUnion>>,
        array_handle: [fidl::Handle; 5],
        array_vmo: [fidl::Vmo; 5],
        array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        array_struct: [ResourceStruct; 5],
        array_table: [ResourceTable; 5],
        array_union: [ResourceUnion; 5],
        vector_handle: Vec<fidl::Handle>,
        vector_vmo: Vec<fidl::Vmo>,
        vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        vector_struct: Vec<ResourceStruct>,
        vector_table: Vec<ResourceTable>,
        vector_union: Vec<ResourceUnion>,
        responder: ProtocolTwoWayResourceResponder,
    },
    ErrorResource {
        responder: ProtocolErrorResourceResponder,
    },
}

impl ProtocolRequest {
    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            control_handle,
        } = self
        {
            Some((
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_basic(
        self,
    ) -> Option<(
        u8,
        u16,
        u32,
        u64,
        i8,
        i16,
        i32,
        i64,
        f32,
        f64,
        String,
        Option<String>,
        ProtocolTwoWayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayBasic {
            uint8,
            uint16,
            uint32,
            uint64,
            int8,
            int16,
            int32,
            int64,
            float32,
            float64,
            string,
            opt_string,
            responder,
        } = self
        {
            Some((
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string, responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_basic(self) -> Option<(ProtocolErrorBasicResponder)> {
        if let ProtocolRequest::ErrorBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            control_handle,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, control_handle))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_compound(
        self,
    ) -> Option<(
        Bits,
        Enum,
        Struct,
        Table,
        Union,
        Option<Box<Struct>>,
        Option<Box<Union>>,
        ProtocolTwoWayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayCompound {
            bits,
            enum_,
            struct_,
            table,
            union,
            opt_struct,
            opt_union,
            responder,
        } = self
        {
            Some((bits, enum_, struct_, table, union, opt_struct, opt_union, responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_compound(self) -> Option<(ProtocolErrorCompoundResponder)> {
        if let ProtocolRequest::ErrorCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            control_handle,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_basic(
        self,
    ) -> Option<(
        [u8; 5],
        [u16; 5],
        [u32; 5],
        [u64; 5],
        [i8; 5],
        [i16; 5],
        [i32; 5],
        [i64; 5],
        [f32; 5],
        [f64; 5],
        [String; 5],
        [Option<String>; 5],
        ProtocolTwoWayArrayBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayBasic {
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
            responder,
        } = self
        {
            Some((
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_basic(self) -> Option<(ProtocolErrorArrayBasicResponder)> {
        if let ProtocolRequest::ErrorArrayBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_compound(
        self,
    ) -> Option<(
        [Bits; 5],
        [Enum; 5],
        [Struct; 5],
        [Table; 5],
        [Union; 5],
        [Option<Box<Struct>>; 5],
        [Option<Box<Union>>; 5],
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            array_opt_struct,
            array_opt_union,
            control_handle,
        } = self
        {
            Some((
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_compound(
        self,
    ) -> Option<(
        [Bits; 5],
        [Enum; 5],
        [Struct; 5],
        [Table; 5],
        [Union; 5],
        [Option<Box<Struct>>; 5],
        [Option<Box<Union>>; 5],
        ProtocolTwoWayArrayCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayCompound {
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            array_opt_struct,
            array_opt_union,
            responder,
        } = self
        {
            Some((
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_compound(self) -> Option<(ProtocolErrorArrayCompoundResponder)> {
        if let ProtocolRequest::ErrorArrayCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            control_handle,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_basic(
        self,
    ) -> Option<(
        Vec<u8>,
        Vec<u16>,
        Vec<u32>,
        Vec<u64>,
        Vec<i8>,
        Vec<i16>,
        Vec<i32>,
        Vec<i64>,
        Vec<f32>,
        Vec<f64>,
        Vec<String>,
        Vec<Option<String>>,
        ProtocolTwoWayVectorBasicResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorBasic {
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
            responder,
        } = self
        {
            Some((
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_basic(self) -> Option<(ProtocolErrorVectorBasicResponder)> {
        if let ProtocolRequest::ErrorVectorBasic { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            control_handle,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_compound(
        self,
    ) -> Option<(
        Vec<Bits>,
        Vec<Enum>,
        Vec<Struct>,
        Vec<Table>,
        Vec<Union>,
        Vec<Option<Box<Struct>>>,
        Vec<Option<Box<Union>>>,
        ProtocolTwoWayVectorCompoundResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorCompound {
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
            responder,
        } = self
        {
            Some((
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_compound(self) -> Option<(ProtocolErrorVectorCompoundResponder)> {
        if let ProtocolRequest::ErrorVectorCompound { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            control_handle,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_vector_optional(
        self,
    ) -> Option<(
        Option<Vec<u8>>,
        Option<Vec<String>>,
        Option<Vec<Struct>>,
        Option<Vec<Option<Box<Struct>>>>,
        ProtocolTwoWayVectorOptionalResponder,
    )> {
        if let ProtocolRequest::TwoWayVectorOptional {
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
            responder,
        } = self
        {
            Some((
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_vector_optional(self) -> Option<(ProtocolErrorVectorOptionalResponder)> {
        if let ProtocolRequest::ErrorVectorOptional { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_array_vector_nested(
        self,
    ) -> Option<([[u8; 5]; 5], [Vec<u8>; 5], Vec<[u8; 5]>, Vec<Vec<u8>>, ProtocolControlHandle)>
    {
        if let ProtocolRequest::OneWayArrayVectorNested {
            array_array_uint8,
            array_vector_uint8,
            vector_array_uint8,
            vector_vector_uint8,
            control_handle,
        } = self
        {
            Some((
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_array_vector_nested(
        self,
    ) -> Option<(
        [[u8; 5]; 5],
        [Vec<u8>; 5],
        Vec<[u8; 5]>,
        Vec<Vec<u8>>,
        ProtocolTwoWayArrayVectorNestedResponder,
    )> {
        if let ProtocolRequest::TwoWayArrayVectorNested {
            array_array_uint8,
            array_vector_uint8,
            vector_array_uint8,
            vector_vector_uint8,
            responder,
        } = self
        {
            Some((
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_array_vector_nested(
        self,
    ) -> Option<(ProtocolErrorArrayVectorNestedResponder)> {
        if let ProtocolRequest::ErrorArrayVectorNested { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_one_way_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
        ProtocolControlHandle,
    )> {
        if let ProtocolRequest::OneWayResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
            control_handle,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
                control_handle,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_two_way_resource(
        self,
    ) -> Option<(
        fidl::Handle,
        fidl::Vmo,
        fidl::endpoints::ClientEnd<ProtocolMarker>,
        fidl::endpoints::ServerEnd<ProtocolMarker>,
        ResourceStruct,
        ResourceTable,
        ResourceUnion,
        Option<fidl::Handle>,
        Option<fidl::Vmo>,
        Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Option<Box<ResourceStruct>>,
        Option<Box<ResourceUnion>>,
        [fidl::Handle; 5],
        [fidl::Vmo; 5],
        [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        [ResourceStruct; 5],
        [ResourceTable; 5],
        [ResourceUnion; 5],
        Vec<fidl::Handle>,
        Vec<fidl::Vmo>,
        Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        Vec<ResourceStruct>,
        Vec<ResourceTable>,
        Vec<ResourceUnion>,
        ProtocolTwoWayResourceResponder,
    )> {
        if let ProtocolRequest::TwoWayResource {
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
            responder,
        } = self
        {
            Some((
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,
                responder,
            ))
        } else {
            None
        }
    }

    #[allow(irrefutable_let_patterns)]
    pub fn into_error_resource(self) -> Option<(ProtocolErrorResourceResponder)> {
        if let ProtocolRequest::ErrorResource { responder } = self {
            Some((responder))
        } else {
            None
        }
    }

    /// Name of the method defined in FIDL
    pub fn method_name(&self) -> &'static str {
        match *self {
            ProtocolRequest::OneWayBasic { .. } => "one_way_basic",
            ProtocolRequest::TwoWayBasic { .. } => "two_way_basic",
            ProtocolRequest::ErrorBasic { .. } => "error_basic",
            ProtocolRequest::OneWayCompound { .. } => "one_way_compound",
            ProtocolRequest::TwoWayCompound { .. } => "two_way_compound",
            ProtocolRequest::ErrorCompound { .. } => "error_compound",
            ProtocolRequest::OneWayArrayBasic { .. } => "one_way_array_basic",
            ProtocolRequest::TwoWayArrayBasic { .. } => "two_way_array_basic",
            ProtocolRequest::ErrorArrayBasic { .. } => "error_array_basic",
            ProtocolRequest::OneWayArrayCompound { .. } => "one_way_array_compound",
            ProtocolRequest::TwoWayArrayCompound { .. } => "two_way_array_compound",
            ProtocolRequest::ErrorArrayCompound { .. } => "error_array_compound",
            ProtocolRequest::OneWayVectorBasic { .. } => "one_way_vector_basic",
            ProtocolRequest::TwoWayVectorBasic { .. } => "two_way_vector_basic",
            ProtocolRequest::ErrorVectorBasic { .. } => "error_vector_basic",
            ProtocolRequest::OneWayVectorCompound { .. } => "one_way_vector_compound",
            ProtocolRequest::TwoWayVectorCompound { .. } => "two_way_vector_compound",
            ProtocolRequest::ErrorVectorCompound { .. } => "error_vector_compound",
            ProtocolRequest::OneWayVectorOptional { .. } => "one_way_vector_optional",
            ProtocolRequest::TwoWayVectorOptional { .. } => "two_way_vector_optional",
            ProtocolRequest::ErrorVectorOptional { .. } => "error_vector_optional",
            ProtocolRequest::OneWayArrayVectorNested { .. } => "one_way_array_vector_nested",
            ProtocolRequest::TwoWayArrayVectorNested { .. } => "two_way_array_vector_nested",
            ProtocolRequest::ErrorArrayVectorNested { .. } => "error_array_vector_nested",
            ProtocolRequest::OneWayResource { .. } => "one_way_resource",
            ProtocolRequest::TwoWayResource { .. } => "two_way_resource",
            ProtocolRequest::ErrorResource { .. } => "error_resource",
        }
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolControlHandle {
    inner: std::sync::Arc<fidl::ServeInner<fidl::encoding::DefaultFuchsiaResourceDialect>>,
}

impl fidl::endpoints::ControlHandle for ProtocolControlHandle {
    fn shutdown(&self) {
        self.inner.shutdown()
    }
    fn shutdown_with_epitaph(&self, status: zx_status::Status) {
        self.inner.shutdown_with_epitaph(status)
    }

    fn is_closed(&self) -> bool {
        self.inner.channel().is_closed()
    }
    fn on_closed(&self) -> fidl::OnSignalsRef<'_> {
        self.inner.channel().on_closed()
    }

    #[cfg(target_os = "fuchsia")]
    fn signal_peer(
        &self,
        clear_mask: zx::Signals,
        set_mask: zx::Signals,
    ) -> Result<(), zx_status::Status> {
        use fidl::Peered;
        self.inner.channel().signal_peer(clear_mask, set_mask)
    }
}

impl ProtocolControlHandle {
    pub fn send_event_basic(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            0,
            0x51c5b06295c10c40,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_compound(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            0,
            0x617c5410858734d5,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_array_basic(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            0,
            0x51b76208b148f02e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_array_compound(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayCompound>(
            (
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
            ),
            0,
            0x1e63a00079aa7415,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_vector_basic(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            0,
            0x3f9d405e7191eff6,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_vector_compound(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            0,
            0x53a1fc56e8b3cff3,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_vector_optional(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            0,
            0x17617b54dfa8d85d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_array_vector_nested(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.inner.send::<ArrayVectorNested>(
            (array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8),
            0,
            0x110b72cfebc4037e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }

    pub fn send_event_resource(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.inner.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            0,
            0x4fbde2864601698b,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
            opt_string,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut uint8: u8,
        mut uint16: u16,
        mut uint32: u32,
        mut uint64: u64,
        mut int8: i8,
        mut int16: i16,
        mut int32: i32,
        mut int64: i64,
        mut float32: f32,
        mut float64: f64,
        mut string: &str,
        mut opt_string: Option<&str>,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<Basic>(
            (
                uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string,
                opt_string,
            ),
            self.tx_id,
            0x205b92db5139c88f,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (u8, u16, u32, u64, i8, i16, i32, i64, f32, f64, &str, Option<&str>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<Basic, u32>>(
            result,
            self.tx_id,
            0x459eaa5d11b9ff93,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(bits, enum_, struct_, table, union, opt_struct, opt_union);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut bits: Bits,
        mut enum_: Enum,
        mut struct_: &Struct,
        mut table: &Table,
        mut union: &Union,
        mut opt_struct: Option<&Struct>,
        mut opt_union: Option<&Union>,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<Compound>(
            (bits, enum_, struct_, table, union, opt_struct, opt_union),
            self.tx_id,
            0x79f279c7201da131,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (Bits, Enum, &Struct, &Table, &Union, Option<&Struct>, Option<&Union>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<Compound, u32>>(
            result,
            self.tx_id,
            0x29817d89a19ec77d,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            array_uint8,
            array_uint16,
            array_uint32,
            array_uint64,
            array_int8,
            array_int16,
            array_int32,
            array_int64,
            array_float32,
            array_float64,
            array_string,
            array_opt_string,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut array_uint8: &[u8; 5],
        mut array_uint16: &[u16; 5],
        mut array_uint32: &[u32; 5],
        mut array_uint64: &[u64; 5],
        mut array_int8: &[i8; 5],
        mut array_int16: &[i16; 5],
        mut array_int32: &[i32; 5],
        mut array_int64: &[i64; 5],
        mut array_float32: &[f32; 5],
        mut array_float64: &[f64; 5],
        mut array_string: &[String; 5],
        mut array_opt_string: &[Option<String>; 5],
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<ArrayBasic>(
            (
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,
            ),
            self.tx_id,
            0x49ad7a74e28ba114,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[u8; 5],
                &[u16; 5],
                &[u32; 5],
                &[u64; 5],
                &[i8; 5],
                &[i16; 5],
                &[i32; 5],
                &[i64; 5],
                &[f32; 5],
                &[f64; 5],
                &[String; 5],
                &[Option<String>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<ArrayBasic, u32>>(
            result,
            self.tx_id,
            0xf0dbde9626fff79,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            array_opt_struct,
            array_opt_union,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            array_bits,
            array_enum,
            array_struct,
            array_table,
            array_union,
            array_opt_struct,
            array_opt_union,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut array_bits: &[Bits; 5],
        mut array_enum: &[Enum; 5],
        mut array_struct: &[Struct; 5],
        mut array_table: &[Table; 5],
        mut array_union: &[Union; 5],
        mut array_opt_struct: &[Option<Box<Struct>>; 5],
        mut array_opt_union: &[Option<Box<Union>>; 5],
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<ArrayCompound>(
            (
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,
            ),
            self.tx_id,
            0xbcae616f8e1ea7b,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[Bits; 5],
                &[Enum; 5],
                &[Struct; 5],
                &[Table; 5],
                &[Union; 5],
                &[Option<Box<Struct>>; 5],
                &[Option<Box<Union>>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[Bits; 5],
                &[Enum; 5],
                &[Struct; 5],
                &[Table; 5],
                &[Union; 5],
                &[Option<Box<Struct>>; 5],
                &[Option<Box<Union>>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[Bits; 5],
                &[Enum; 5],
                &[Struct; 5],
                &[Table; 5],
                &[Union; 5],
                &[Option<Box<Struct>>; 5],
                &[Option<Box<Union>>; 5],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<ArrayCompound, u32>>(
            result,
            self.tx_id,
            0x52257f80e29c1a04,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            vector_uint8,
            vector_uint16,
            vector_uint32,
            vector_uint64,
            vector_int8,
            vector_int16,
            vector_int32,
            vector_int64,
            vector_float32,
            vector_float64,
            vector_string,
            vector_opt_string,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut vector_uint8: &[u8],
        mut vector_uint16: &[u16],
        mut vector_uint32: &[u32],
        mut vector_uint64: &[u64],
        mut vector_int8: &[i8],
        mut vector_int16: &[i16],
        mut vector_int32: &[i32],
        mut vector_int64: &[i64],
        mut vector_float32: &[f32],
        mut vector_float64: &[f64],
        mut vector_string: &[String],
        mut vector_opt_string: &[Option<String>],
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<VectorBasic>(
            (
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,
            ),
            self.tx_id,
            0x7860cb3ed8362e74,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorBasicResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorBasicResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorBasicResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorBasicResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[u8],
                &[u16],
                &[u32],
                &[u64],
                &[i8],
                &[i16],
                &[i32],
                &[i64],
                &[f32],
                &[f64],
                &[String],
                &[Option<String>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<VectorBasic, u32>>(
            result,
            self.tx_id,
            0xc27f841d6313f72,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            vector_bits,
            vector_enum,
            vector_struct,
            vector_table,
            vector_union,
            vector_opt_struct,
            vector_opt_union,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut vector_bits: &[Bits],
        mut vector_enum: &[Enum],
        mut vector_struct: &[Struct],
        mut vector_table: &[Table],
        mut vector_union: &[Union],
        mut vector_opt_struct: &[Option<Box<Struct>>],
        mut vector_opt_union: &[Option<Box<Union>>],
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<VectorCompound>(
            (
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,
            ),
            self.tx_id,
            0x371140db701b23b4,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorCompoundResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorCompoundResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorCompoundResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorCompoundResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                &[Bits],
                &[Enum],
                &[Struct],
                &[Table],
                &[Union],
                &[Option<Box<Struct>>],
                &[Option<Box<Union>>],
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<VectorCompound, u32>>(
            result,
            self.tx_id,
            0x760e278628f7a985,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayVectorOptionalResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayVectorOptionalResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayVectorOptionalResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayVectorOptionalResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            opt_vector_uint8,
            opt_vector_string,
            opt_vector_struct,
            opt_vector_opt_struct,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut opt_vector_uint8: Option<&[u8]>,
        mut opt_vector_string: Option<&[String]>,
        mut opt_vector_struct: Option<&[Struct]>,
        mut opt_vector_opt_struct: Option<&[Option<Box<Struct>>]>,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<VectorOptional>(
            (opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct),
            self.tx_id,
            0xe4b620aaafd73f3,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorVectorOptionalResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorVectorOptionalResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorVectorOptionalResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorVectorOptionalResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (Option<&[u8]>, Option<&[String]>, Option<&[Struct]>, Option<&[Option<Box<Struct>>]>),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<VectorOptional, u32>>(
            result,
            self.tx_id,
            0x58e75cf86e2d715e,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayArrayVectorNestedResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayArrayVectorNestedResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayArrayVectorNestedResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayArrayVectorNestedResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            array_array_uint8,
            array_vector_uint8,
            vector_array_uint8,
            vector_vector_uint8,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            array_array_uint8,
            array_vector_uint8,
            vector_array_uint8,
            vector_vector_uint8,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut array_array_uint8: &[[u8; 5]; 5],
        mut array_vector_uint8: &[Vec<u8>; 5],
        mut vector_array_uint8: &[[u8; 5]],
        mut vector_vector_uint8: &[Vec<u8>],
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<ArrayVectorNested>(
            (array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8),
            self.tx_id,
            0x4a438ce0948817dc,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorArrayVectorNestedResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorArrayVectorNestedResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorArrayVectorNestedResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorArrayVectorNestedResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<(&[[u8; 5]; 5], &[Vec<u8>; 5], &[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<(&[[u8; 5]; 5], &[Vec<u8>; 5], &[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<(&[[u8; 5]; 5], &[Vec<u8>; 5], &[[u8; 5]], &[Vec<u8>]), u32>,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<ArrayVectorNested, u32>>(
            result,
            self.tx_id,
            0x7e168d89e1dac8a7,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolTwoWayResourceResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolTwoWayResourceResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolTwoWayResourceResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolTwoWayResourceResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        );
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(
            handle,
            vmo,
            client_end,
            server_end,
            struct_,
            table,
            union,
            opt_handle,
            opt_vmo,
            opt_client_end,
            opt_server_end,
            opt_struct,
            opt_union,
            array_handle,
            array_vmo,
            array_client_end,
            array_server_end,
            array_struct,
            array_table,
            array_union,
            vector_handle,
            vector_vmo,
            vector_client_end,
            vector_server_end,
            vector_struct,
            vector_table,
            vector_union,
        );
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut handle: fidl::Handle,
        mut vmo: fidl::Vmo,
        mut client_end: fidl::endpoints::ClientEnd<ProtocolMarker>,
        mut server_end: fidl::endpoints::ServerEnd<ProtocolMarker>,
        mut struct_: ResourceStruct,
        mut table: ResourceTable,
        mut union: ResourceUnion,
        mut opt_handle: Option<fidl::Handle>,
        mut opt_vmo: Option<fidl::Vmo>,
        mut opt_client_end: Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut opt_server_end: Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut opt_struct: Option<ResourceStruct>,
        mut opt_union: Option<ResourceUnion>,
        mut array_handle: [fidl::Handle; 5],
        mut array_vmo: [fidl::Vmo; 5],
        mut array_client_end: [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
        mut array_server_end: [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
        mut array_struct: [ResourceStruct; 5],
        mut array_table: [ResourceTable; 5],
        mut array_union: [ResourceUnion; 5],
        mut vector_handle: Vec<fidl::Handle>,
        mut vector_vmo: Vec<fidl::Vmo>,
        mut vector_client_end: Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
        mut vector_server_end: Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
        mut vector_struct: Vec<ResourceStruct>,
        mut vector_table: Vec<ResourceTable>,
        mut vector_union: Vec<ResourceUnion>,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<Resource>(
            (
                handle,
                vmo,
                client_end,
                server_end,
                &mut struct_,
                &mut table,
                &mut union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct.as_mut(),
                opt_union.as_mut(),
                &mut array_handle,
                &mut array_vmo,
                &mut array_client_end,
                &mut array_server_end,
                &mut array_struct,
                &mut array_table,
                &mut array_union,
                vector_handle.as_mut(),
                vector_vmo.as_mut(),
                vector_client_end.as_mut(),
                vector_server_end.as_mut(),
                vector_struct.as_mut(),
                vector_table.as_mut(),
                vector_union.as_mut(),
            ),
            self.tx_id,
            0x1904824a11c6ad5b,
            fidl::encoding::DynamicFlags::empty(),
        )
    }
}

#[must_use = "FIDL methods require a response to be sent"]
#[derive(Debug)]
pub struct ProtocolErrorResourceResponder {
    control_handle: std::mem::ManuallyDrop<ProtocolControlHandle>,
    tx_id: u32,
}

/// Set the the channel to be shutdown (see [`ProtocolControlHandle::shutdown`])
/// if the responder is dropped without sending a response, so that the client
/// doesn't hang. To prevent this behavior, call `drop_without_shutdown`.
impl std::ops::Drop for ProtocolErrorResourceResponder {
    fn drop(&mut self) {
        self.control_handle.shutdown();
        // Safety: drops once, never accessed again
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
    }
}

impl fidl::endpoints::Responder for ProtocolErrorResourceResponder {
    type ControlHandle = ProtocolControlHandle;

    fn control_handle(&self) -> &ProtocolControlHandle {
        &self.control_handle
    }

    fn drop_without_shutdown(mut self) {
        // Safety: drops once, never accessed again due to mem::forget
        unsafe { std::mem::ManuallyDrop::drop(&mut self.control_handle) };
        // Prevent Drop from running (which would shut down the channel)
        std::mem::forget(self);
    }
}

impl ProtocolErrorResourceResponder {
    /// Sends a response to the FIDL transaction.
    ///
    /// Sets the channel to shutdown if an error occurs.
    pub fn send(
        self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        if _result.is_err() {
            self.control_handle.shutdown();
        }
        self.drop_without_shutdown();
        _result
    }

    /// Similar to "send" but does not shutdown the channel if an error occurs.
    pub fn send_no_shutdown_on_err(
        self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        let _result = self.send_raw(result);
        self.drop_without_shutdown();
        _result
    }

    fn send_raw(
        &self,
        mut result: Result<
            (
                fidl::Handle,
                fidl::Vmo,
                fidl::endpoints::ClientEnd<ProtocolMarker>,
                fidl::endpoints::ServerEnd<ProtocolMarker>,
                ResourceStruct,
                ResourceTable,
                ResourceUnion,
                Option<fidl::Handle>,
                Option<fidl::Vmo>,
                Option<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Option<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Option<ResourceStruct>,
                Option<ResourceUnion>,
                [fidl::Handle; 5],
                [fidl::Vmo; 5],
                [fidl::endpoints::ClientEnd<ProtocolMarker>; 5],
                [fidl::endpoints::ServerEnd<ProtocolMarker>; 5],
                [ResourceStruct; 5],
                [ResourceTable; 5],
                [ResourceUnion; 5],
                Vec<fidl::Handle>,
                Vec<fidl::Vmo>,
                Vec<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                Vec<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                Vec<ResourceStruct>,
                Vec<ResourceTable>,
                Vec<ResourceUnion>,
            ),
            u32,
        >,
    ) -> Result<(), fidl::Error> {
        self.control_handle.inner.send::<fidl::encoding::ResultType<Resource, u32>>(
            result.as_mut().map_err(|e| *e).map(|(handle, vmo, client_end, server_end, struct_, table, union, opt_handle, opt_vmo, opt_client_end, opt_server_end, opt_struct, opt_union, array_handle, array_vmo, array_client_end, array_server_end, array_struct, array_table, array_union, vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union)| (std::mem::replace(handle, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into()), std::mem::replace(vmo, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into()), std::mem::replace(client_end, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into()), std::mem::replace(server_end, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into()), struct_, table, union, opt_handle.as_mut().map(|x| std::mem::replace(x, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into())), opt_vmo.as_mut().map(|x| std::mem::replace(x, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into())), opt_client_end.as_mut().map(|x| std::mem::replace(x, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into())), opt_server_end.as_mut().map(|x| std::mem::replace(x, <<fidl::encoding::DefaultFuchsiaResourceDialect as fidl::encoding::ResourceDialect>::Handle as fidl::encoding::HandleFor<fidl::encoding::DefaultFuchsiaResourceDialect>>::invalid().into())), opt_struct.as_mut(), opt_union.as_mut(), array_handle, array_vmo, array_client_end, array_server_end, array_struct, array_table, array_union, vector_handle.as_mut_slice(), vector_vmo.as_mut_slice(), vector_client_end.as_mut_slice(), vector_server_end.as_mut_slice(), vector_struct.as_mut_slice(), vector_table.as_mut_slice(), vector_union.as_mut_slice(),)),
            self.tx_id,
            0x5b28634d603175b6,
            fidl::encoding::DynamicFlags::empty()
        )
    }
}

mod internal {
    use super::*;

    impl fidl::encoding::ResourceTypeMarker for Resource {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Resource {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            456
        }
    }

    unsafe impl fidl::encoding::Encode<Resource, fidl::encoding::DefaultFuchsiaResourceDialect>
        for &mut Resource
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Resource>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<Resource, fidl::encoding::DefaultFuchsiaResourceDialect>::encode(
                (
                    <fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.handle),
                    <fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vmo),
                    <fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.client_end),
                    <fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.server_end),
                    <ResourceStruct as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.struct_),
                    <ResourceTable as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.table),
                    <ResourceUnion as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.union),
                    <fidl::encoding::Optional<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_handle),
                    <fidl::encoding::Optional<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_vmo),
                    <fidl::encoding::Optional<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_client_end),
                    <fidl::encoding::Optional<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_server_end),
                    <fidl::encoding::Boxed<ResourceStruct> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_struct),
                    <fidl::encoding::OptionalUnion<ResourceUnion> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.opt_union),
                    <fidl::encoding::Array<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_handle),
                    <fidl::encoding::Array<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_vmo),
                    <fidl::encoding::Array<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_client_end),
                    <fidl::encoding::Array<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_server_end),
                    <fidl::encoding::Array<ResourceStruct, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_struct),
                    <fidl::encoding::Array<ResourceTable, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_table),
                    <fidl::encoding::Array<ResourceUnion, 5> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.array_union),
                    <fidl::encoding::UnboundedVector<fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_handle),
                    <fidl::encoding::UnboundedVector<fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_vmo),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_client_end),
                    <fidl::encoding::UnboundedVector<fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_server_end),
                    <fidl::encoding::UnboundedVector<ResourceStruct> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_struct),
                    <fidl::encoding::UnboundedVector<ResourceTable> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_table),
                    <fidl::encoding::UnboundedVector<ResourceUnion> as fidl::encoding::ResourceTypeMarker>::take_or_borrow(&mut self.vector_union),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            T0: fidl::encoding::Encode<
                fidl::encoding::HandleType<
                    fidl::Handle,
                    { fidl::ObjectType::NONE.into_raw() },
                    2147483648,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T1: fidl::encoding::Encode<
                fidl::encoding::HandleType<
                    fidl::Vmo,
                    { fidl::ObjectType::VMO.into_raw() },
                    2147483648,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T2: fidl::encoding::Encode<
                fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T3: fidl::encoding::Encode<
                fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T4: fidl::encoding::Encode<ResourceStruct, fidl::encoding::DefaultFuchsiaResourceDialect>,
            T5: fidl::encoding::Encode<ResourceTable, fidl::encoding::DefaultFuchsiaResourceDialect>,
            T6: fidl::encoding::Encode<ResourceUnion, fidl::encoding::DefaultFuchsiaResourceDialect>,
            T7: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T8: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T9: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T10: fidl::encoding::Encode<
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T11: fidl::encoding::Encode<
                fidl::encoding::Boxed<ResourceStruct>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T12: fidl::encoding::Encode<
                fidl::encoding::OptionalUnion<ResourceUnion>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T13: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T14: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T15: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T16: fidl::encoding::Encode<
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T17: fidl::encoding::Encode<
                fidl::encoding::Array<ResourceStruct, 5>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T18: fidl::encoding::Encode<
                fidl::encoding::Array<ResourceTable, 5>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T19: fidl::encoding::Encode<
                fidl::encoding::Array<ResourceUnion, 5>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T20: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T21: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T22: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T23: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T24: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<ResourceStruct>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T25: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<ResourceTable>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            T26: fidl::encoding::Encode<
                fidl::encoding::UnboundedVector<ResourceUnion>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
        > fidl::encoding::Encode<Resource, fidl::encoding::DefaultFuchsiaResourceDialect>
        for (
            T0,
            T1,
            T2,
            T3,
            T4,
            T5,
            T6,
            T7,
            T8,
            T9,
            T10,
            T11,
            T12,
            T13,
            T14,
            T15,
            T16,
            T17,
            T18,
            T19,
            T20,
            T21,
            T22,
            T23,
            T24,
            T25,
            T26,
        )
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Resource>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(16);
                (ptr as *mut u64).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(176);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 4, depth)?;
            self.2.encode(encoder, offset + 8, depth)?;
            self.3.encode(encoder, offset + 12, depth)?;
            self.4.encode(encoder, offset + 16, depth)?;
            self.5.encode(encoder, offset + 24, depth)?;
            self.6.encode(encoder, offset + 40, depth)?;
            self.7.encode(encoder, offset + 56, depth)?;
            self.8.encode(encoder, offset + 60, depth)?;
            self.9.encode(encoder, offset + 64, depth)?;
            self.10.encode(encoder, offset + 68, depth)?;
            self.11.encode(encoder, offset + 72, depth)?;
            self.12.encode(encoder, offset + 80, depth)?;
            self.13.encode(encoder, offset + 96, depth)?;
            self.14.encode(encoder, offset + 116, depth)?;
            self.15.encode(encoder, offset + 136, depth)?;
            self.16.encode(encoder, offset + 156, depth)?;
            self.17.encode(encoder, offset + 176, depth)?;
            self.18.encode(encoder, offset + 184, depth)?;
            self.19.encode(encoder, offset + 264, depth)?;
            self.20.encode(encoder, offset + 344, depth)?;
            self.21.encode(encoder, offset + 360, depth)?;
            self.22.encode(encoder, offset + 376, depth)?;
            self.23.encode(encoder, offset + 392, depth)?;
            self.24.encode(encoder, offset + 408, depth)?;
            self.25.encode(encoder, offset + 424, depth)?;
            self.26.encode(encoder, offset + 440, depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self, fidl::encoding::DefaultFuchsiaResourceDialect> for Resource {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                handle: fidl::new_empty!(fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>, fidl::encoding::DefaultFuchsiaResourceDialect),
                vmo: fidl::new_empty!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, fidl::encoding::DefaultFuchsiaResourceDialect),
                client_end: fidl::new_empty!(
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                server_end: fidl::new_empty!(
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                struct_: fidl::new_empty!(
                    ResourceStruct,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                table: fidl::new_empty!(
                    ResourceTable,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                union: fidl::new_empty!(
                    ResourceUnion,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                opt_handle: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::HandleType<
                            fidl::Handle,
                            { fidl::ObjectType::NONE.into_raw() },
                            2147483648,
                        >,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                opt_vmo: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                opt_client_end: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                opt_server_end: fidl::new_empty!(
                    fidl::encoding::Optional<
                        fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                opt_struct: fidl::new_empty!(
                    fidl::encoding::Boxed<ResourceStruct>,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                opt_union: fidl::new_empty!(
                    fidl::encoding::OptionalUnion<ResourceUnion>,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                array_handle: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Handle,
                            { fidl::ObjectType::NONE.into_raw() },
                            2147483648,
                        >,
                        5,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                array_vmo: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                        5,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                array_client_end: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                        5,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                array_server_end: fidl::new_empty!(
                    fidl::encoding::Array<
                        fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                        5,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                array_struct: fidl::new_empty!(fidl::encoding::Array<ResourceStruct, 5>, fidl::encoding::DefaultFuchsiaResourceDialect),
                array_table: fidl::new_empty!(fidl::encoding::Array<ResourceTable, 5>, fidl::encoding::DefaultFuchsiaResourceDialect),
                array_union: fidl::new_empty!(fidl::encoding::Array<ResourceUnion, 5>, fidl::encoding::DefaultFuchsiaResourceDialect),
                vector_handle: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::HandleType<
                            fidl::Handle,
                            { fidl::ObjectType::NONE.into_raw() },
                            2147483648,
                        >,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                vector_vmo: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::HandleType<
                            fidl::Vmo,
                            { fidl::ObjectType::VMO.into_raw() },
                            2147483648,
                        >,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                vector_client_end: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                vector_server_end: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<
                        fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    >,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                vector_struct: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<ResourceStruct>,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                vector_table: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<ResourceTable>,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
                vector_union: fidl::new_empty!(
                    fidl::encoding::UnboundedVector<ResourceUnion>,
                    fidl::encoding::DefaultFuchsiaResourceDialect
                ),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(16) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffffffff00u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 16 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(176) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffff0000000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 176 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            fidl::decode!(fidl::encoding::HandleType<fidl::Handle, { fidl::ObjectType::NONE.into_raw() }, 2147483648>, fidl::encoding::DefaultFuchsiaResourceDialect, &mut self.handle, decoder, offset + 0, _depth)?;
            fidl::decode!(fidl::encoding::HandleType<fidl::Vmo, { fidl::ObjectType::VMO.into_raw() }, 2147483648>, fidl::encoding::DefaultFuchsiaResourceDialect, &mut self.vmo, decoder, offset + 4, _depth)?;
            fidl::decode!(
                fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.client_end,
                decoder,
                offset + 8,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.server_end,
                decoder,
                offset + 12,
                _depth
            )?;
            fidl::decode!(
                ResourceStruct,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.struct_,
                decoder,
                offset + 16,
                _depth
            )?;
            fidl::decode!(
                ResourceTable,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.table,
                decoder,
                offset + 24,
                _depth
            )?;
            fidl::decode!(
                ResourceUnion,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.union,
                decoder,
                offset + 40,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.opt_handle,
                decoder,
                offset + 56,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.opt_vmo,
                decoder,
                offset + 60,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.opt_client_end,
                decoder,
                offset + 64,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Optional<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.opt_server_end,
                decoder,
                offset + 68,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Boxed<ResourceStruct>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.opt_struct,
                decoder,
                offset + 72,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::OptionalUnion<ResourceUnion>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.opt_union,
                decoder,
                offset + 80,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.array_handle,
                decoder,
                offset + 96,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.array_vmo,
                decoder,
                offset + 116,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.array_client_end,
                decoder,
                offset + 136,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::Array<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                    5,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.array_server_end,
                decoder,
                offset + 156,
                _depth
            )?;
            fidl::decode!(fidl::encoding::Array<ResourceStruct, 5>, fidl::encoding::DefaultFuchsiaResourceDialect, &mut self.array_struct, decoder, offset + 176, _depth)?;
            fidl::decode!(fidl::encoding::Array<ResourceTable, 5>, fidl::encoding::DefaultFuchsiaResourceDialect, &mut self.array_table, decoder, offset + 184, _depth)?;
            fidl::decode!(fidl::encoding::Array<ResourceUnion, 5>, fidl::encoding::DefaultFuchsiaResourceDialect, &mut self.array_union, decoder, offset + 264, _depth)?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Handle,
                        { fidl::ObjectType::NONE.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.vector_handle,
                decoder,
                offset + 344,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::HandleType<
                        fidl::Vmo,
                        { fidl::ObjectType::VMO.into_raw() },
                        2147483648,
                    >,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.vector_vmo,
                decoder,
                offset + 360,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ClientEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.vector_client_end,
                decoder,
                offset + 376,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<
                    fidl::encoding::Endpoint<fidl::endpoints::ServerEnd<ProtocolMarker>>,
                >,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.vector_server_end,
                decoder,
                offset + 392,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<ResourceStruct>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.vector_struct,
                decoder,
                offset + 408,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<ResourceTable>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.vector_table,
                decoder,
                offset + 424,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::UnboundedVector<ResourceUnion>,
                fidl::encoding::DefaultFuchsiaResourceDialect,
                &mut self.vector_union,
                decoder,
                offset + 440,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ResourceTypeMarker for ResourceStruct {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ResourceStruct {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            1
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            1
        }
    }

    unsafe impl
        fidl::encoding::Encode<ResourceStruct, fidl::encoding::DefaultFuchsiaResourceDialect>
        for &mut ResourceStruct
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ResourceStruct>(offset);
            encoder.write_num(0u8, offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self, fidl::encoding::DefaultFuchsiaResourceDialect>
        for ResourceStruct
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            match decoder.read_num::<u8>(offset) {
                0 => Ok(()),
                _ => Err(fidl::Error::Invalid),
            }
        }
    }

    impl ResourceTable {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            0
        }
    }

    impl fidl::encoding::ResourceTypeMarker for ResourceTable {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ResourceTable {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl fidl::encoding::Encode<ResourceTable, fidl::encoding::DefaultFuchsiaResourceDialect>
        for &mut ResourceTable
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ResourceTable>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;

            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self, fidl::encoding::DefaultFuchsiaResourceDialect> for ResourceTable {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl fidl::encoding::ResourceTypeMarker for ResourceUnion {
        type Borrowed<'a> = &'a mut Self;
        fn take_or_borrow<'a>(
            value: &'a mut <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for ResourceUnion {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl fidl::encoding::Encode<ResourceUnion, fidl::encoding::DefaultFuchsiaResourceDialect>
        for &mut ResourceUnion
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<ResourceUnion>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                ResourceUnion::B(ref val) => fidl::encoding::encode_in_envelope::<
                    bool,
                    fidl::encoding::DefaultFuchsiaResourceDialect,
                >(
                    <bool as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                ResourceUnion::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl fidl::encoding::Decode<Self, fidl::encoding::DefaultFuchsiaResourceDialect> for ResourceUnion {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<
                '_,
                fidl::encoding::DefaultFuchsiaResourceDialect,
            >,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <bool as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let ResourceUnion::B(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = ResourceUnion::B(fidl::new_empty!(
                            bool,
                            fidl::encoding::DefaultFuchsiaResourceDialect
                        ));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let ResourceUnion::B(ref mut val) = self {
                        fidl::decode!(
                            bool,
                            fidl::encoding::DefaultFuchsiaResourceDialect,
                            val,
                            decoder,
                            _inner_offset,
                            depth
                        )?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = ResourceUnion::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
