// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

bitflags! {
    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct BitsMember: u32 {
        const BIT_ONE = 1;
        const BIT_TWO = 2;
    }
}

impl BitsMember {
    #[inline(always)]
    pub fn from_bits_allow_unknown(bits: u32) -> Self {
        Self::from_bits_retain(bits)
    }

    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        self.get_unknown_bits() != 0
    }

    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u32 {
        self.bits() & !Self::all().bits()
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Flags: u16 {
        const INLINE = 1;
    }
}

impl Flags {
    #[inline(always)]
    pub fn from_bits_allow_unknown(bits: u16) -> Self {
        Self::from_bits_retain(bits)
    }

    #[inline(always)]
    pub fn has_unknown_bits(&self) -> bool {
        self.get_unknown_bits() != 0
    }

    #[inline(always)]
    pub fn get_unknown_bits(&self) -> u16 {
        self.bits() & !Self::all().bits()
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum Op {
    Add,
    Mul,
    Div,
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u32,
    },
}

/// Pattern that matches an unknown `Op` member.
#[macro_export]
macro_rules! OpUnknown {
    () => {
        _
    };
}

impl Op {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Add),
            2 => Some(Self::Mul),
            3 => Some(Self::Div),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::Add,
            2 => Self::Mul,
            3 => Self::Div,
            unknown_ordinal => Self::__SourceBreaking { unknown_ordinal },
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0xffffffff }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::Add => 1,
            Self::Mul => 2,
            Self::Div => 3,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { unknown_ordinal: _ } => true,
            _ => false,
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum SomeProtocolSomeMethodError {
    ErrorOne,
    ErrorTwo,
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u32,
    },
}

/// Pattern that matches an unknown `SomeProtocolSomeMethodError` member.
#[macro_export]
macro_rules! SomeProtocolSomeMethodErrorUnknown {
    () => {
        _
    };
}

impl SomeProtocolSomeMethodError {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::ErrorOne),
            2 => Some(Self::ErrorTwo),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::ErrorOne,
            2 => Self::ErrorTwo,
            unknown_ordinal => Self::__SourceBreaking { unknown_ordinal },
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0xffffffff }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::ErrorOne => 1,
            Self::ErrorTwo => 2,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { unknown_ordinal: _ } => true,
            _ => false,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct OverrideTest {
    pub op: Op,
    pub left: Option<Box<Expression>>,
    pub right: Option<Box<Expression>>,
}

impl fidl::Persistable for OverrideTest {}

#[derive(Clone, Debug, PartialEq)]
pub struct SomeProtocolSomeMethodRequest {
    pub union_member: UnionMember,
    pub table_member: TableMember,
}

impl fidl::Persistable for SomeProtocolSomeMethodRequest {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SomeProtocolSomeMethodResponse {
    pub bits_member: BitsMember,
}

impl fidl::Persistable for SomeProtocolSomeMethodResponse {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct TableData {
    pub data: u8,
}

impl fidl::Persistable for TableData {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct FunctionApplication {
    pub func: Option<String>,
    pub args: Option<Vec<Option<Box<Expression>>>>,
    pub flags: Option<Flags>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for FunctionApplication {}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct TableMember {
    pub table_data: Option<Vec<TableData>>,
    #[doc(hidden)]
    pub __source_breaking: fidl::marker::SourceBreaking,
}

impl fidl::Persistable for TableMember {}

#[derive(Clone, Debug)]
pub enum Expression {
    Value(u64),
    BinOp(OverrideTest),
    FunctionApplication(FunctionApplication),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `Expression` member.
#[macro_export]
macro_rules! ExpressionUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for Expression {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Value(x), Self::Value(y)) => *x == *y,
            (Self::BinOp(x), Self::BinOp(y)) => *x == *y,
            (Self::FunctionApplication(x), Self::FunctionApplication(y)) => *x == *y,
            _ => false,
        }
    }
}

impl Expression {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::Value(_) => 1,
            Self::BinOp(_) => 2,
            Self::FunctionApplication(_) => 3,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for Expression {}

#[derive(Clone, Debug)]
pub enum UnionMember {
    UnionData(u8),
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u64,
    },
}

/// Pattern that matches an unknown `UnionMember` member.
#[macro_export]
macro_rules! UnionMemberUnknown {
    () => {
        _
    };
}

// Custom PartialEq so that unknown variants are not equal to themselves.
impl PartialEq for UnionMember {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::UnionData(x), Self::UnionData(y)) => *x == *y,
            _ => false,
        }
    }
}

impl UnionMember {
    #[inline]
    pub fn ordinal(&self) -> u64 {
        match *self {
            Self::UnionData(_) => 2,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn unknown_variant_for_testing() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0 }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { .. } => true,
            _ => false,
        }
    }
}

impl fidl::Persistable for UnionMember {}

mod internal {
    use super::*;
    unsafe impl fidl::encoding::TypeMarker for BitsMember {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    impl fidl::encoding::ValueTypeMarker for BitsMember {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            *value
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Self, D> for BitsMember {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.bits(), offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for BitsMember {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::empty()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);
            *self = Self::from_bits_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for Flags {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            2
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            2
        }
    }

    impl fidl::encoding::ValueTypeMarker for Flags {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            *value
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Self, D> for Flags {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.bits(), offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Flags {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::empty()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u16>(offset);
            *self = Self::from_bits_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for Op {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            false
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for Op {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            *value
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Self, D> for Op {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Op {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::unknown()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for SomeProtocolSomeMethodError {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            false
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for SomeProtocolSomeMethodError {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            *value
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Self, D>
        for SomeProtocolSomeMethodError
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for SomeProtocolSomeMethodError
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::unknown()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive_allow_unknown(prim);
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for OverrideTest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for OverrideTest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            40
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<OverrideTest, D>
        for &OverrideTest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<OverrideTest>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<OverrideTest, D>::encode(
                (
                    <Op as fidl::encoding::ValueTypeMarker>::borrow(&self.op),
                    <fidl::encoding::OptionalUnion<Expression> as fidl::encoding::ValueTypeMarker>::borrow(&self.left),
                    <fidl::encoding::OptionalUnion<Expression> as fidl::encoding::ValueTypeMarker>::borrow(&self.right),
                ),
                encoder, offset, _depth
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<Op, D>,
            T1: fidl::encoding::Encode<fidl::encoding::OptionalUnion<Expression>, D>,
            T2: fidl::encoding::Encode<fidl::encoding::OptionalUnion<Expression>, D>,
        > fidl::encoding::Encode<OverrideTest, D> for (T0, T1, T2)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<OverrideTest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            self.2.encode(encoder, offset + 24, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for OverrideTest {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                op: fidl::new_empty!(Op, D),
                left: fidl::new_empty!(fidl::encoding::OptionalUnion<Expression>, D),
                right: fidl::new_empty!(fidl::encoding::OptionalUnion<Expression>, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            let ptr = unsafe { decoder.buf.as_ptr().add(offset).offset(0) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffff00000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            fidl::decode!(Op, D, &mut self.op, decoder, offset + 0, _depth)?;
            fidl::decode!(
                fidl::encoding::OptionalUnion<Expression>,
                D,
                &mut self.left,
                decoder,
                offset + 8,
                _depth
            )?;
            fidl::decode!(
                fidl::encoding::OptionalUnion<Expression>,
                D,
                &mut self.right,
                decoder,
                offset + 24,
                _depth
            )?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for SomeProtocolSomeMethodRequest {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for SomeProtocolSomeMethodRequest {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            32
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<SomeProtocolSomeMethodRequest, D>
        for &SomeProtocolSomeMethodRequest
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<SomeProtocolSomeMethodRequest>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<SomeProtocolSomeMethodRequest, D>::encode(
                (
                    <UnionMember as fidl::encoding::ValueTypeMarker>::borrow(&self.union_member),
                    <TableMember as fidl::encoding::ValueTypeMarker>::borrow(&self.table_member),
                ),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<UnionMember, D>,
            T1: fidl::encoding::Encode<TableMember, D>,
        > fidl::encoding::Encode<SomeProtocolSomeMethodRequest, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<SomeProtocolSomeMethodRequest>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 16, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for SomeProtocolSomeMethodRequest
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                union_member: fidl::new_empty!(UnionMember, D),
                table_member: fidl::new_empty!(TableMember, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(UnionMember, D, &mut self.union_member, decoder, offset + 0, _depth)?;
            fidl::decode!(TableMember, D, &mut self.table_member, decoder, offset + 16, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for SomeProtocolSomeMethodResponse {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for SomeProtocolSomeMethodResponse {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<SomeProtocolSomeMethodResponse, D>
        for &SomeProtocolSomeMethodResponse
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<SomeProtocolSomeMethodResponse>(offset);
            // Delegate to tuple encoding.
            fidl::encoding::Encode::<SomeProtocolSomeMethodResponse, D>::encode(
                (<BitsMember as fidl::encoding::ValueTypeMarker>::borrow(&self.bits_member),),
                encoder,
                offset,
                _depth,
            )
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<BitsMember, D>>
        fidl::encoding::Encode<SomeProtocolSomeMethodResponse, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<SomeProtocolSomeMethodResponse>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for SomeProtocolSomeMethodResponse
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { bits_member: fidl::new_empty!(BitsMember, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            // Verify that padding bytes are zero.
            fidl::decode!(BitsMember, D, &mut self.bits_member, decoder, offset + 0, _depth)?;
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for TableData {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for TableData {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            1
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            1
        }
        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            true
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<TableData, D>
        for &TableData
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TableData>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut TableData).write_unaligned((self as *const TableData).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
            }
            Ok(())
        }
    }
    unsafe impl<D: fidl::encoding::ResourceDialect, T0: fidl::encoding::Encode<u8, D>>
        fidl::encoding::Encode<TableData, D> for (T0,)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TableData>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for TableData {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { data: fidl::new_empty!(u8, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 1);
            }
            Ok(())
        }
    }

    impl FunctionApplication {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.flags {
                return 4;
            }
            if let Some(_) = self.args {
                return 3;
            }
            if let Some(_) = self.func {
                return 1;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for FunctionApplication {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for FunctionApplication {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<FunctionApplication, D>
        for &FunctionApplication
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<FunctionApplication>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 1 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (1 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<fidl::encoding::BoundedString<100>, D>(
                self.func.as_ref().map(
                    <fidl::encoding::BoundedString<100> as fidl::encoding::ValueTypeMarker>::borrow,
                ),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;
            if 3 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (3 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<fidl::encoding::Vector<fidl::encoding::OptionalUnion<Expression>, 5>, D>(
            self.args.as_ref().map(<fidl::encoding::Vector<fidl::encoding::OptionalUnion<Expression>, 5> as fidl::encoding::ValueTypeMarker>::borrow),
            encoder, offset + cur_offset, depth
        )?;

            _prev_end_offset = cur_offset + envelope_size;
            if 4 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (4 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<Flags, D>(
                self.flags.as_ref().map(<Flags as fidl::encoding::ValueTypeMarker>::borrow),
                encoder,
                offset + cur_offset,
                depth,
            )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for FunctionApplication {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 1 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <fidl::encoding::BoundedString<100> as fidl::encoding::TypeMarker>::inline_size(
                        decoder.context,
                    );
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self
                    .func
                    .get_or_insert_with(|| fidl::new_empty!(fidl::encoding::BoundedString<100>, D));
                fidl::decode!(
                    fidl::encoding::BoundedString<100>,
                    D,
                    val_ref,
                    decoder,
                    inner_offset,
                    inner_depth
                )?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 3 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size = <fidl::encoding::Vector<
                    fidl::encoding::OptionalUnion<Expression>,
                    5,
                > as fidl::encoding::TypeMarker>::inline_size(
                    decoder.context
                );
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.args.get_or_insert_with(|| {
                    fidl::new_empty!(
                        fidl::encoding::Vector<fidl::encoding::OptionalUnion<Expression>, 5>,
                        D
                    )
                });
                fidl::decode!(
                    fidl::encoding::Vector<fidl::encoding::OptionalUnion<Expression>, 5>,
                    D,
                    val_ref,
                    decoder,
                    inner_offset,
                    inner_depth
                )?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 4 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size =
                    <Flags as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.flags.get_or_insert_with(|| fidl::new_empty!(Flags, D));
                fidl::decode!(Flags, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl TableMember {
        #[inline(always)]
        fn max_ordinal_present(&self) -> u64 {
            if let Some(_) = self.table_data {
                return 2;
            }
            0
        }
    }

    impl fidl::encoding::ValueTypeMarker for TableMember {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for TableMember {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<TableMember, D>
        for &TableMember
    {
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<TableMember>(offset);
            // Vector header
            let max_ordinal: u64 = self.max_ordinal_present();
            encoder.write_num(max_ordinal, offset);
            encoder.write_num(fidl::encoding::ALLOC_PRESENT_U64, offset + 8);
            // Calling encoder.out_of_line_offset(0) is not allowed.
            if max_ordinal == 0 {
                return Ok(());
            }
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = max_ordinal as usize * envelope_size;
            #[allow(unused_variables)]
            let offset = encoder.out_of_line_offset(bytes_len);
            let mut _prev_end_offset: usize = 0;
            if 2 > max_ordinal {
                return Ok(());
            }

            // Write at offset+(ordinal-1)*envelope_size, since ordinals are one-based and envelopes
            // are envelope_size bytes.
            let cur_offset: usize = (2 - 1) * envelope_size;

            // Zero reserved fields.
            encoder.padding(offset + _prev_end_offset, cur_offset - _prev_end_offset);

            // Safety:
            // - bytes_len is calculated to fit envelope_size*max(member.ordinal).
            // - Since cur_offset is envelope_size*(member.ordinal - 1) and the envelope takes
            //   envelope_size bytes, there is always sufficient room.
            fidl::encoding::encode_in_envelope_optional::<fidl::encoding::Vector<TableData, 10>, D>(
            self.table_data.as_ref().map(<fidl::encoding::Vector<TableData, 10> as fidl::encoding::ValueTypeMarker>::borrow),
            encoder, offset + cur_offset, depth
        )?;

            _prev_end_offset = cur_offset + envelope_size;

            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for TableMember {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::default()
        }

        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let len = match fidl::encoding::decode_vector_header(decoder, offset)? {
                None => return Err(fidl::Error::NotNullable),
                Some(len) => len,
            };
            // Calling decoder.out_of_line_offset(0) is not allowed.
            if len == 0 {
                return Ok(());
            };
            depth.increment()?;
            let envelope_size = 8;
            let bytes_len = len * envelope_size;
            let offset = decoder.out_of_line_offset(bytes_len)?;
            // Decode the envelope for each type.
            let mut _next_ordinal_to_read = 0;
            let mut next_offset = offset;
            let end_offset = offset + bytes_len;
            _next_ordinal_to_read += 1;
            if next_offset >= end_offset {
                return Ok(());
            }

            // Decode unknown envelopes for gaps in ordinals.
            while _next_ordinal_to_read < 2 {
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                _next_ordinal_to_read += 1;
                next_offset += envelope_size;
            }

            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            if let Some((inlined, num_bytes, num_handles)) =
                fidl::encoding::decode_envelope_header(decoder, next_offset)?
            {
                let member_inline_size = <fidl::encoding::Vector<TableData, 10> as fidl::encoding::TypeMarker>::inline_size(decoder.context);
                if inlined != (member_inline_size <= 4) {
                    return Err(fidl::Error::InvalidInlineBitInEnvelope);
                }
                let inner_offset;
                let mut inner_depth = depth.clone();
                if inlined {
                    decoder.check_inline_envelope_padding(next_offset, member_inline_size)?;
                    inner_offset = next_offset;
                } else {
                    inner_offset = decoder.out_of_line_offset(member_inline_size)?;
                    inner_depth.increment()?;
                }
                let val_ref = self.table_data.get_or_insert_with(
                    || fidl::new_empty!(fidl::encoding::Vector<TableData, 10>, D),
                );
                fidl::decode!(fidl::encoding::Vector<TableData, 10>, D, val_ref, decoder, inner_offset, inner_depth)?;
                if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize)
                {
                    return Err(fidl::Error::InvalidNumBytesInEnvelope);
                }
                if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                    return Err(fidl::Error::InvalidNumHandlesInEnvelope);
                }
            }

            next_offset += envelope_size;

            // Decode the remaining unknown envelopes.
            while next_offset < end_offset {
                _next_ordinal_to_read += 1;
                fidl::encoding::decode_unknown_envelope(decoder, next_offset, depth)?;
                next_offset += envelope_size;
            }

            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Expression {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Expression {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Expression, D>
        for &Expression
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Expression>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                Expression::Value(ref val) => fidl::encoding::encode_in_envelope::<u64, D>(
                    <u64 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                Expression::BinOp(ref val) => {
                    fidl::encoding::encode_in_envelope::<OverrideTest, D>(
                        <OverrideTest as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                Expression::FunctionApplication(ref val) => {
                    fidl::encoding::encode_in_envelope::<FunctionApplication, D>(
                        <FunctionApplication as fidl::encoding::ValueTypeMarker>::borrow(val),
                        encoder,
                        offset + 8,
                        _depth,
                    )
                }
                Expression::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Expression {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                1 => <u64 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                2 => <OverrideTest as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                3 => <FunctionApplication as fidl::encoding::TypeMarker>::inline_size(
                    decoder.context,
                ),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                1 => {
                    #[allow(irrefutable_let_patterns)]
                    if let Expression::Value(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = Expression::Value(fidl::new_empty!(u64, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let Expression::Value(ref mut val) = self {
                        fidl::decode!(u64, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                2 => {
                    #[allow(irrefutable_let_patterns)]
                    if let Expression::BinOp(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = Expression::BinOp(fidl::new_empty!(OverrideTest, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let Expression::BinOp(ref mut val) = self {
                        fidl::decode!(OverrideTest, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                3 => {
                    #[allow(irrefutable_let_patterns)]
                    if let Expression::FunctionApplication(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = Expression::FunctionApplication(fidl::new_empty!(
                            FunctionApplication,
                            D
                        ));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let Expression::FunctionApplication(ref mut val) = self {
                        fidl::decode!(FunctionApplication, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = Expression::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for UnionMember {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for UnionMember {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<UnionMember, D>
        for &UnionMember
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<UnionMember>(offset);
            encoder.write_num::<u64>(self.ordinal(), offset);
            match self {
                UnionMember::UnionData(ref val) => fidl::encoding::encode_in_envelope::<u8, D>(
                    <u8 as fidl::encoding::ValueTypeMarker>::borrow(val),
                    encoder,
                    offset + 8,
                    _depth,
                ),
                UnionMember::__SourceBreaking { .. } => Err(fidl::Error::UnknownUnionTag),
            }
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for UnionMember {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::__SourceBreaking { unknown_ordinal: 0 }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            mut depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            #[allow(unused_variables)]
            let next_out_of_line = decoder.next_out_of_line();
            let handles_before = decoder.remaining_handles();
            let (ordinal, inlined, num_bytes, num_handles) =
                fidl::encoding::decode_union_inline_portion(decoder, offset)?;

            let member_inline_size = match ordinal {
                2 => <u8 as fidl::encoding::TypeMarker>::inline_size(decoder.context),
                0 => return Err(fidl::Error::UnknownUnionTag),
                _ => num_bytes as usize,
            };

            if inlined != (member_inline_size <= 4) {
                return Err(fidl::Error::InvalidInlineBitInEnvelope);
            }
            let _inner_offset;
            if inlined {
                decoder.check_inline_envelope_padding(offset + 8, member_inline_size)?;
                _inner_offset = offset + 8;
            } else {
                depth.increment()?;
                _inner_offset = decoder.out_of_line_offset(member_inline_size)?;
            }
            match ordinal {
                2 => {
                    #[allow(irrefutable_let_patterns)]
                    if let UnionMember::UnionData(_) = self {
                        // Do nothing, read the value into the object
                    } else {
                        // Initialize `self` to the right variant
                        *self = UnionMember::UnionData(fidl::new_empty!(u8, D));
                    }
                    #[allow(irrefutable_let_patterns)]
                    if let UnionMember::UnionData(ref mut val) = self {
                        fidl::decode!(u8, D, val, decoder, _inner_offset, depth)?;
                    } else {
                        unreachable!()
                    }
                }
                #[allow(deprecated)]
                ordinal => {
                    for _ in 0..num_handles {
                        decoder.drop_next_handle()?;
                    }
                    *self = UnionMember::__SourceBreaking { unknown_ordinal: ordinal };
                }
            }
            if !inlined && decoder.next_out_of_line() != next_out_of_line + (num_bytes as usize) {
                return Err(fidl::Error::InvalidNumBytesInEnvelope);
            }
            if handles_before != decoder.remaining_handles() + (num_handles as usize) {
                return Err(fidl::Error::InvalidNumHandlesInEnvelope);
            }
            Ok(())
        }
    }
}
