// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use bitflags::bitflags;
use fidl::encoding::{MessageBufFor, ProxyChannelBox, ResourceDialect};
use futures::future::{self, MaybeDone, TryFutureExt};
use zx_status;

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding1ByteEnd {
    pub a: u16,
    pub b: u8,
}

impl fidl::Persistable for Padding1ByteEnd {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding1ByteMiddle {
    pub a: u8,
    pub b: u16,
}

impl fidl::Persistable for Padding1ByteMiddle {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding2ByteAlignmentLength6 {
    pub a: u8,
    pub b: u16,
    pub c: u8,
}

impl fidl::Persistable for Padding2ByteAlignmentLength6 {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding2ByteEnd {
    pub a: u32,
    pub b: u16,
}

impl fidl::Persistable for Padding2ByteEnd {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding2ByteMiddle {
    pub a: u16,
    pub b: u32,
}

impl fidl::Persistable for Padding2ByteMiddle {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding3ByteEnd {
    pub a: u32,
    pub b: u8,
}

impl fidl::Persistable for Padding3ByteEnd {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding3ByteMiddle {
    pub a: u8,
    pub b: u32,
}

impl fidl::Persistable for Padding3ByteMiddle {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding4ByteAlignmentLength12 {
    pub a: u32,
    pub b: u8,
    pub c: u16,
    pub d: u16,
}

impl fidl::Persistable for Padding4ByteAlignmentLength12 {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding4ByteEnd {
    pub a: u64,
    pub b: u32,
}

impl fidl::Persistable for Padding4ByteEnd {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding4ByteMiddle {
    pub a: u32,
    pub b: u64,
}

impl fidl::Persistable for Padding4ByteMiddle {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding5ByteEnd {
    pub a: u64,
    pub b: u16,
    pub c: u8,
}

impl fidl::Persistable for Padding5ByteEnd {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding5ByteMiddle {
    pub a: u16,
    pub b: u8,
    pub c: u64,
}

impl fidl::Persistable for Padding5ByteMiddle {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding6ByteEnd {
    pub a: u64,
    pub b: u16,
}

impl fidl::Persistable for Padding6ByteEnd {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding6ByteMiddle {
    pub a: u16,
    pub b: u64,
}

impl fidl::Persistable for Padding6ByteMiddle {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding7ByteEnd {
    pub a: u64,
    pub b: u8,
}

impl fidl::Persistable for Padding7ByteEnd {}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Padding7ByteMiddle {
    pub a: u8,
    pub b: u64,
}

impl fidl::Persistable for Padding7ByteMiddle {}

mod internal {
    use super::*;

    impl fidl::encoding::ValueTypeMarker for Padding1ByteEnd {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding1ByteEnd {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            2
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding1ByteEnd, D>
        for &Padding1ByteEnd
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding1ByteEnd>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding1ByteEnd)
                    .write_unaligned((self as *const Padding1ByteEnd).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(2) as *mut u16;
                let padding_mask = 0xff00u16;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u16, D>,
            T1: fidl::encoding::Encode<u8, D>,
        > fidl::encoding::Encode<Padding1ByteEnd, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding1ByteEnd>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(2);
                (ptr as *mut u16).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 2, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding1ByteEnd {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u16, D), b: fidl::new_empty!(u8, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(2) };
            let padval = unsafe { (ptr as *const u16).read_unaligned() };
            let mask = 0xff00u16;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 2 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding1ByteMiddle {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding1ByteMiddle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            2
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            4
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding1ByteMiddle, D>
        for &Padding1ByteMiddle
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding1ByteMiddle>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding1ByteMiddle)
                    .write_unaligned((self as *const Padding1ByteMiddle).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u16;
                let padding_mask = 0xff00u16;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u8, D>,
            T1: fidl::encoding::Encode<u16, D>,
        > fidl::encoding::Encode<Padding1ByteMiddle, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding1ByteMiddle>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u16).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 2, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding1ByteMiddle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u8, D), b: fidl::new_empty!(u16, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u16).read_unaligned() };
            let mask = 0xff00u16;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 4);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding2ByteAlignmentLength6 {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding2ByteAlignmentLength6 {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            2
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            6
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<Padding2ByteAlignmentLength6, D> for &Padding2ByteAlignmentLength6
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding2ByteAlignmentLength6>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding2ByteAlignmentLength6)
                    .write_unaligned((self as *const Padding2ByteAlignmentLength6).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u16;
                let padding_mask = 0xff00u16;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
                let padding_ptr = buf_ptr.offset(4) as *mut u16;
                let padding_mask = 0xff00u16;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u8, D>,
            T1: fidl::encoding::Encode<u16, D>,
            T2: fidl::encoding::Encode<u8, D>,
        > fidl::encoding::Encode<Padding2ByteAlignmentLength6, D> for (T0, T1, T2)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding2ByteAlignmentLength6>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u16).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(4);
                (ptr as *mut u16).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 2, depth)?;
            self.2.encode(encoder, offset + 4, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for Padding2ByteAlignmentLength6
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                a: fidl::new_empty!(u8, D),
                b: fidl::new_empty!(u16, D),
                c: fidl::new_empty!(u8, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u16).read_unaligned() };
            let mask = 0xff00u16;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { buf_ptr.offset(4) };
            let padval = unsafe { (ptr as *const u16).read_unaligned() };
            let mask = 0xff00u16;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 4 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 6);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding2ByteEnd {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding2ByteEnd {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            8
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding2ByteEnd, D>
        for &Padding2ByteEnd
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding2ByteEnd>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding2ByteEnd)
                    .write_unaligned((self as *const Padding2ByteEnd).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(4) as *mut u32;
                let padding_mask = 0xffff0000u32;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u32, D>,
            T1: fidl::encoding::Encode<u16, D>,
        > fidl::encoding::Encode<Padding2ByteEnd, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding2ByteEnd>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(4);
                (ptr as *mut u32).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 4, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding2ByteEnd {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u32, D), b: fidl::new_empty!(u16, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(4) };
            let padval = unsafe { (ptr as *const u32).read_unaligned() };
            let mask = 0xffff0000u32;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 4 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding2ByteMiddle {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding2ByteMiddle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            8
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding2ByteMiddle, D>
        for &Padding2ByteMiddle
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding2ByteMiddle>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding2ByteMiddle)
                    .write_unaligned((self as *const Padding2ByteMiddle).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u32;
                let padding_mask = 0xffff0000u32;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u16, D>,
            T1: fidl::encoding::Encode<u32, D>,
        > fidl::encoding::Encode<Padding2ByteMiddle, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding2ByteMiddle>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u32).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 4, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding2ByteMiddle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u16, D), b: fidl::new_empty!(u32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u32).read_unaligned() };
            let mask = 0xffff0000u32;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding3ByteEnd {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding3ByteEnd {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            8
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding3ByteEnd, D>
        for &Padding3ByteEnd
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding3ByteEnd>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding3ByteEnd)
                    .write_unaligned((self as *const Padding3ByteEnd).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(4) as *mut u32;
                let padding_mask = 0xffffff00u32;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u32, D>,
            T1: fidl::encoding::Encode<u8, D>,
        > fidl::encoding::Encode<Padding3ByteEnd, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding3ByteEnd>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(4);
                (ptr as *mut u32).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 4, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding3ByteEnd {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u32, D), b: fidl::new_empty!(u8, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(4) };
            let padval = unsafe { (ptr as *const u32).read_unaligned() };
            let mask = 0xffffff00u32;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 4 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding3ByteMiddle {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding3ByteMiddle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            8
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding3ByteMiddle, D>
        for &Padding3ByteMiddle
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding3ByteMiddle>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding3ByteMiddle)
                    .write_unaligned((self as *const Padding3ByteMiddle).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u32;
                let padding_mask = 0xffffff00u32;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u8, D>,
            T1: fidl::encoding::Encode<u32, D>,
        > fidl::encoding::Encode<Padding3ByteMiddle, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding3ByteMiddle>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u32).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 4, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding3ByteMiddle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u8, D), b: fidl::new_empty!(u32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u32).read_unaligned() };
            let mask = 0xffffff00u32;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 8);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding4ByteAlignmentLength12 {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding4ByteAlignmentLength12 {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            4
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            12
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect>
        fidl::encoding::Encode<Padding4ByteAlignmentLength12, D>
        for &Padding4ByteAlignmentLength12
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding4ByteAlignmentLength12>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding4ByteAlignmentLength12)
                    .write_unaligned((self as *const Padding4ByteAlignmentLength12).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(4) as *mut u32;
                let padding_mask = 0xff00u32;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
                let padding_ptr = buf_ptr.offset(8) as *mut u32;
                let padding_mask = 0xffff0000u32;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u32, D>,
            T1: fidl::encoding::Encode<u8, D>,
            T2: fidl::encoding::Encode<u16, D>,
            T3: fidl::encoding::Encode<u16, D>,
        > fidl::encoding::Encode<Padding4ByteAlignmentLength12, D> for (T0, T1, T2, T3)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding4ByteAlignmentLength12>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(4);
                (ptr as *mut u32).write_unaligned(0);
            }
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                (ptr as *mut u32).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 4, depth)?;
            self.2.encode(encoder, offset + 6, depth)?;
            self.3.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D>
        for Padding4ByteAlignmentLength12
    {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                a: fidl::new_empty!(u32, D),
                b: fidl::new_empty!(u8, D),
                c: fidl::new_empty!(u16, D),
                d: fidl::new_empty!(u16, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(4) };
            let padval = unsafe { (ptr as *const u32).read_unaligned() };
            let mask = 0xff00u32;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 4 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            let ptr = unsafe { buf_ptr.offset(8) };
            let padval = unsafe { (ptr as *const u32).read_unaligned() };
            let mask = 0xffff0000u32;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 8 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 12);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding4ByteEnd {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding4ByteEnd {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding4ByteEnd, D>
        for &Padding4ByteEnd
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding4ByteEnd>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding4ByteEnd)
                    .write_unaligned((self as *const Padding4ByteEnd).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(8) as *mut u64;
                let padding_mask = 0xffffffff00000000u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u64, D>,
            T1: fidl::encoding::Encode<u32, D>,
        > fidl::encoding::Encode<Padding4ByteEnd, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding4ByteEnd>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding4ByteEnd {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u64, D), b: fidl::new_empty!(u32, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(8) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffff00000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 8 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding4ByteMiddle {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding4ByteMiddle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding4ByteMiddle, D>
        for &Padding4ByteMiddle
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding4ByteMiddle>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding4ByteMiddle)
                    .write_unaligned((self as *const Padding4ByteMiddle).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u64;
                let padding_mask = 0xffffffff00000000u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u32, D>,
            T1: fidl::encoding::Encode<u64, D>,
        > fidl::encoding::Encode<Padding4ByteMiddle, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding4ByteMiddle>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding4ByteMiddle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u32, D), b: fidl::new_empty!(u64, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffff00000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding5ByteEnd {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding5ByteEnd {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding5ByteEnd, D>
        for &Padding5ByteEnd
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding5ByteEnd>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding5ByteEnd)
                    .write_unaligned((self as *const Padding5ByteEnd).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(8) as *mut u64;
                let padding_mask = 0xffffffffff000000u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u64, D>,
            T1: fidl::encoding::Encode<u16, D>,
            T2: fidl::encoding::Encode<u8, D>,
        > fidl::encoding::Encode<Padding5ByteEnd, D> for (T0, T1, T2)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding5ByteEnd>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            self.2.encode(encoder, offset + 10, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding5ByteEnd {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                a: fidl::new_empty!(u64, D),
                b: fidl::new_empty!(u16, D),
                c: fidl::new_empty!(u8, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(8) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffff000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 8 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding5ByteMiddle {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding5ByteMiddle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding5ByteMiddle, D>
        for &Padding5ByteMiddle
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding5ByteMiddle>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding5ByteMiddle)
                    .write_unaligned((self as *const Padding5ByteMiddle).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u64;
                let padding_mask = 0xffffffffff000000u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u16, D>,
            T1: fidl::encoding::Encode<u8, D>,
            T2: fidl::encoding::Encode<u64, D>,
        > fidl::encoding::Encode<Padding5ByteMiddle, D> for (T0, T1, T2)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding5ByteMiddle>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 2, depth)?;
            self.2.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding5ByteMiddle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self {
                a: fidl::new_empty!(u16, D),
                b: fidl::new_empty!(u8, D),
                c: fidl::new_empty!(u64, D),
            }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffff000000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding6ByteEnd {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding6ByteEnd {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding6ByteEnd, D>
        for &Padding6ByteEnd
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding6ByteEnd>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding6ByteEnd)
                    .write_unaligned((self as *const Padding6ByteEnd).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(8) as *mut u64;
                let padding_mask = 0xffffffffffff0000u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u64, D>,
            T1: fidl::encoding::Encode<u16, D>,
        > fidl::encoding::Encode<Padding6ByteEnd, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding6ByteEnd>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding6ByteEnd {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u64, D), b: fidl::new_empty!(u16, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(8) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffffff0000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 8 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding6ByteMiddle {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding6ByteMiddle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding6ByteMiddle, D>
        for &Padding6ByteMiddle
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding6ByteMiddle>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding6ByteMiddle)
                    .write_unaligned((self as *const Padding6ByteMiddle).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u64;
                let padding_mask = 0xffffffffffff0000u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u16, D>,
            T1: fidl::encoding::Encode<u64, D>,
        > fidl::encoding::Encode<Padding6ByteMiddle, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding6ByteMiddle>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding6ByteMiddle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u16, D), b: fidl::new_empty!(u64, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffffff0000u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding7ByteEnd {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding7ByteEnd {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding7ByteEnd, D>
        for &Padding7ByteEnd
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding7ByteEnd>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding7ByteEnd)
                    .write_unaligned((self as *const Padding7ByteEnd).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(8) as *mut u64;
                let padding_mask = 0xffffffffffffff00u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u64, D>,
            T1: fidl::encoding::Encode<u8, D>,
        > fidl::encoding::Encode<Padding7ByteEnd, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding7ByteEnd>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(8);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding7ByteEnd {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u64, D), b: fidl::new_empty!(u8, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(8) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffffffff00u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 8 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }

    impl fidl::encoding::ValueTypeMarker for Padding7ByteMiddle {
        type Borrowed<'a> = &'a Self;
        fn borrow(value: &<Self as fidl::encoding::TypeMarker>::Owned) -> Self::Borrowed<'_> {
            value
        }
    }

    unsafe impl fidl::encoding::TypeMarker for Padding7ByteMiddle {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            8
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            16
        }
    }

    unsafe impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Encode<Padding7ByteMiddle, D>
        for &Padding7ByteMiddle
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding7ByteMiddle>(offset);
            unsafe {
                // Copy the object into the buffer.
                let buf_ptr = encoder.buf.as_mut_ptr().add(offset);
                (buf_ptr as *mut Padding7ByteMiddle)
                    .write_unaligned((self as *const Padding7ByteMiddle).read());
                // Zero out padding regions. Unlike `fidl_struct_impl_noncopy!`, this must be
                // done second because the memcpy will write garbage to these bytes.
                let padding_ptr = buf_ptr.offset(0) as *mut u64;
                let padding_mask = 0xffffffffffffff00u64;
                padding_ptr.write_unaligned(padding_ptr.read_unaligned() & !padding_mask);
            }
            Ok(())
        }
    }
    unsafe impl<
            D: fidl::encoding::ResourceDialect,
            T0: fidl::encoding::Encode<u8, D>,
            T1: fidl::encoding::Encode<u64, D>,
        > fidl::encoding::Encode<Padding7ByteMiddle, D> for (T0, T1)
    {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_, D>,
            offset: usize,
            depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Padding7ByteMiddle>(offset);
            // Zero out padding regions. There's no need to apply masks
            // because the unmasked parts will be overwritten by fields.
            unsafe {
                let ptr = encoder.buf.as_mut_ptr().add(offset).offset(0);
                (ptr as *mut u64).write_unaligned(0);
            }
            // Write the fields.
            self.0.encode(encoder, offset + 0, depth)?;
            self.1.encode(encoder, offset + 8, depth)?;
            Ok(())
        }
    }

    impl<D: fidl::encoding::ResourceDialect> fidl::encoding::Decode<Self, D> for Padding7ByteMiddle {
        #[inline(always)]
        fn new_empty() -> Self {
            Self { a: fidl::new_empty!(u8, D), b: fidl::new_empty!(u64, D) }
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_, D>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let buf_ptr = unsafe { decoder.buf.as_ptr().add(offset) };
            // Verify that padding bytes are zero.
            let ptr = unsafe { buf_ptr.offset(0) };
            let padval = unsafe { (ptr as *const u64).read_unaligned() };
            let mask = 0xffffffffffffff00u64;
            let maskedval = padval & mask;
            if maskedval != 0 {
                return Err(fidl::Error::NonZeroPadding {
                    padding_start: offset + 0 + ((mask as u64).trailing_zeros() / 8) as usize,
                });
            }
            // Copy from the buffer into the object.
            unsafe {
                std::ptr::copy_nonoverlapping(buf_ptr, self as *mut Self as *mut u8, 16);
            }
            Ok(())
        }
    }
}
